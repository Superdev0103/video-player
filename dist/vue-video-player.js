(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.VueVideoPlayer = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
 /**
 *
 * Vue-Video-Player
 * Adapted from Videojs (https://github.com/videojs/video.js)
 *
 */

window.videojs = require('video.js')
videojs = videojs.default || videojs
var playerComponent = require('./src/player.vue')
playerComponent = playerComponent.default || playerComponent

var videoPlayer = {
  videojs: videojs,
  videoPlayer: playerComponent,
  install: function(Vue) {
    Vue.component(playerComponent.name, playerComponent)
  }
}

module.exports = videoPlayer

},{"./src/player.vue":55,"video.js":48}],2:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":4}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;

},{"../../modules/_core":9,"../../modules/es6.object.assign":39}],5:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],6:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":22}],7:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":32,"./_to-iobject":34,"./_to-length":35}],8:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],9:[function(require,module,exports){
var core = module.exports = { version: '2.5.0' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],10:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":5}],11:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],12:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":16}],13:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":17,"./_is-object":22}],14:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],15:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":9,"./_ctx":10,"./_global":17,"./_hide":19}],16:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],17:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],18:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],19:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":12,"./_object-dp":24,"./_property-desc":29}],20:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":12,"./_dom-create":13,"./_fails":16}],21:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":8}],22:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],23:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":16,"./_iobject":21,"./_object-gops":25,"./_object-keys":27,"./_object-pie":28,"./_to-object":36}],24:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":6,"./_descriptors":12,"./_ie8-dom-define":20,"./_to-primitive":37}],25:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],26:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":7,"./_has":18,"./_shared-key":30,"./_to-iobject":34}],27:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":14,"./_object-keys-internal":26}],28:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],29:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],30:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":31,"./_uid":38}],31:[function(require,module,exports){
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};

},{"./_global":17}],32:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":33}],33:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],34:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":11,"./_iobject":21}],35:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":33}],36:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":11}],37:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":22}],38:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],39:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":15,"./_object-assign":23}],40:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":43}],41:[function(require,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = require('min-document');

var doccy;

if (typeof document !== 'undefined') {
    doccy = document;
} else {
    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }
}

module.exports = doccy;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"min-document":3}],42:[function(require,module,exports){
(function (global){
var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],43:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],44:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":40,"trim":46}],45:[function(require,module,exports){
module.exports = SafeParseTuple

function SafeParseTuple(obj, reviver) {
    var json
    var error = null

    try {
        json = JSON.parse(obj, reviver)
    } catch (err) {
        error = err
    }

    return [error, json]
}

},{}],46:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],47:[function(require,module,exports){
function clean (s) {
  return s.replace(/\n\r?\s*/g, '')
}


module.exports = function tsml (sa) {
  var s = ''
    , i = 0

  for (; i < arguments.length; i++)
    s += clean(sa[i]) + (arguments[i + 1] || '')

  return s
}
},{}],48:[function(require,module,exports){
/**
 * @license
 * Video.js 6.2.4 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/master/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>
 */

'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var window = _interopDefault(require('global/window'));
var document = _interopDefault(require('global/document'));
var tsml = _interopDefault(require('tsml'));
var safeParseTuple = _interopDefault(require('safe-json-parse/tuple'));
var xhr = _interopDefault(require('xhr'));
var vtt = _interopDefault(require('videojs-vtt.js'));

var version = "6.2.4";

/**
 * @file browser.js
 * @module browser
 */
var USER_AGENT = window.navigator && window.navigator.userAgent || '';
var webkitVersionMap = /AppleWebKit\/([\d.]+)/i.exec(USER_AGENT);
var appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;

/*
 * Device is an iPhone
 *
 * @type {Boolean}
 * @constant
 * @private
 */
var IS_IPAD = /iPad/i.test(USER_AGENT);

// The Facebook app's UIWebView identifies as both an iPhone and iPad, so
// to identify iPhones, we need to exclude iPads.
// http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/
var IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
var IS_IPOD = /iPod/i.test(USER_AGENT);
var IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;

var IOS_VERSION = function () {
  var match = USER_AGENT.match(/OS (\d+)_/i);

  if (match && match[1]) {
    return match[1];
  }
  return null;
}();

var IS_ANDROID = /Android/i.test(USER_AGENT);
var ANDROID_VERSION = function () {
  // This matches Android Major.Minor.Patch versions
  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
  var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);

  if (!match) {
    return null;
  }

  var major = match[1] && parseFloat(match[1]);
  var minor = match[2] && parseFloat(match[2]);

  if (major && minor) {
    return parseFloat(match[1] + '.' + match[2]);
  } else if (major) {
    return major;
  }
  return null;
}();

// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser
var IS_OLD_ANDROID = IS_ANDROID && /webkit/i.test(USER_AGENT) && ANDROID_VERSION < 2.3;
var IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;

var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
var IS_EDGE = /Edge/i.test(USER_AGENT);
var IS_CHROME = !IS_EDGE && /Chrome/i.test(USER_AGENT);
var CHROME_VERSION = function () {
  var match = USER_AGENT.match(/Chrome\/(\d+)/);

  if (match && match[1]) {
    return parseFloat(match[1]);
  }
  return null;
}();
var IS_IE8 = /MSIE\s8\.0/.test(USER_AGENT);
var IE_VERSION = function () {
  var result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
  var version = result && parseFloat(result[1]);

  if (!version && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
    // IE 11 has a different user agent string than other IE versions
    version = 11.0;
  }

  return version;
}();

var IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
var IS_ANY_SAFARI = IS_SAFARI || IS_IOS;

var TOUCH_ENABLED = isReal() && ('ontouchstart' in window || window.DocumentTouch && window.document instanceof window.DocumentTouch);

var BACKGROUND_SIZE_SUPPORTED = isReal() && 'backgroundSize' in window.document.createElement('video').style;

var browser = (Object.freeze || Object)({
	IS_IPAD: IS_IPAD,
	IS_IPHONE: IS_IPHONE,
	IS_IPOD: IS_IPOD,
	IS_IOS: IS_IOS,
	IOS_VERSION: IOS_VERSION,
	IS_ANDROID: IS_ANDROID,
	ANDROID_VERSION: ANDROID_VERSION,
	IS_OLD_ANDROID: IS_OLD_ANDROID,
	IS_NATIVE_ANDROID: IS_NATIVE_ANDROID,
	IS_FIREFOX: IS_FIREFOX,
	IS_EDGE: IS_EDGE,
	IS_CHROME: IS_CHROME,
	CHROME_VERSION: CHROME_VERSION,
	IS_IE8: IS_IE8,
	IE_VERSION: IE_VERSION,
	IS_SAFARI: IS_SAFARI,
	IS_ANY_SAFARI: IS_ANY_SAFARI,
	TOUCH_ENABLED: TOUCH_ENABLED,
	BACKGROUND_SIZE_SUPPORTED: BACKGROUND_SIZE_SUPPORTED
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};











var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};











var taggedTemplateLiteralLoose = function (strings, raw) {
  strings.raw = raw;
  return strings;
};

/**
 * @file obj.js
 * @module obj
 */

/**
 * @callback obj:EachCallback
 *
 * @param {Mixed} value
 *        The current key for the object that is being iterated over.
 *
 * @param {string} key
 *        The current key-value for object that is being iterated over
 */

/**
 * @callback obj:ReduceCallback
 *
 * @param {Mixed} accum
 *        The value that is accumulating over the reduce loop.
 *
 * @param {Mixed} value
 *        The current key for the object that is being iterated over.
 *
 * @param {string} key
 *        The current key-value for object that is being iterated over
 *
 * @return {Mixed}
 *         The new accumulated value.
 */
var toString = Object.prototype.toString;

/**
 * Get the keys of an Object
 *
 * @param {Object}
 *        The Object to get the keys from
 *
 * @return {string[]}
 *         An array of the keys from the object. Returns an empty array if the
 *         object passed in was invalid or had no keys.
 *
 * @private
 */
var keys = function keys(object) {
  return isObject(object) ? Object.keys(object) : [];
};

/**
 * Array-like iteration for objects.
 *
 * @param {Object} object
 *        The object to iterate over
 *
 * @param {obj:EachCallback} fn
 *        The callback function which is called for each key in the object.
 */
function each(object, fn) {
  keys(object).forEach(function (key) {
    return fn(object[key], key);
  });
}

/**
 * Array-like reduce for objects.
 *
 * @param {Object} object
 *        The Object that you want to reduce.
 *
 * @param {Function} fn
 *         A callback function which is called for each key in the object. It
 *         receives the accumulated value and the per-iteration value and key
 *         as arguments.
 *
 * @param {Mixed} [initial = 0]
 *        Starting value
 *
 * @return {Mixed}
 *         The final accumulated value.
 */
function reduce(object, fn) {
  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  return keys(object).reduce(function (accum, key) {
    return fn(accum, object[key], key);
  }, initial);
}

/**
 * Object.assign-style object shallow merge/extend.
 *
 * @param  {Object} target
 * @param  {Object} ...sources
 * @return {Object}
 */
function assign(target) {
  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  if (Object.assign) {
    return Object.assign.apply(Object, [target].concat(sources));
  }

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    each(source, function (value, key) {
      target[key] = value;
    });
  });

  return target;
}

/**
 * Returns whether a value is an object of any kind - including DOM nodes,
 * arrays, regular expressions, etc. Not functions, though.
 *
 * This avoids the gotcha where using `typeof` on a `null` value
 * results in `'object'`.
 *
 * @param  {Object} value
 * @return {Boolean}
 */
function isObject(value) {
  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
}

/**
 * Returns whether an object appears to be a "plain" object - that is, a
 * direct instance of `Object`.
 *
 * @param  {Object} value
 * @return {Boolean}
 */
function isPlain(value) {
  return isObject(value) && toString.call(value) === '[object Object]' && value.constructor === Object;
}

/**
 * @file log.js
 * @module log
 */
var log = void 0;

// This is the private tracking variable for logging level.
var level = 'all';

// This is the private tracking variable for the logging history.
var history = [];

/**
 * Log messages to the console and history based on the type of message
 *
 * @private
 * @param  {string} type
 *         The name of the console method to use.
 *
 * @param  {Array} args
 *         The arguments to be passed to the matching console method.
 *
 * @param  {boolean} [stringify]
 *         By default, only old IEs should get console argument stringification,
 *         but this is exposed as a parameter to facilitate testing.
 */
var logByType = function logByType(type, args) {
  var stringify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !!IE_VERSION && IE_VERSION < 11;

  var lvl = log.levels[level];
  var lvlRegExp = new RegExp('^(' + lvl + ')$');

  if (type !== 'log') {

    // Add the type to the front of the message when it's not "log".
    args.unshift(type.toUpperCase() + ':');
  }

  // Add a clone of the args at this point to history.
  if (history) {
    history.push([].concat(args));
  }

  // Add console prefix after adding to history.
  args.unshift('VIDEOJS:');

  // If there's no console then don't try to output messages, but they will
  // still be stored in history.
  //
  // Was setting these once outside of this function, but containing them
  // in the function makes it easier to test cases where console doesn't exist
  // when the module is executed.
  var fn = window.console && window.console[type];

  // Bail out if there's no console or if this type is not allowed by the
  // current logging level.
  if (!fn || !lvl || !lvlRegExp.test(type)) {
    return;
  }

  // IEs previous to 11 log objects uselessly as "[object Object]"; so, JSONify
  // objects and arrays for those less-capable browsers.
  if (stringify) {
    args = args.map(function (a) {
      if (isObject(a) || Array.isArray(a)) {
        try {
          return JSON.stringify(a);
        } catch (x) {
          return String(a);
        }
      }

      // Cast to string before joining, so we get null and undefined explicitly
      // included in output (as we would in a modern console).
      return String(a);
    }).join(' ');
  }

  // Old IE versions do not allow .apply() for console methods (they are
  // reported as objects rather than functions).
  if (!fn.apply) {
    fn(args);
  } else {
    fn[Array.isArray(args) ? 'apply' : 'call'](window.console, args);
  }
};

/**
 * Logs plain debug messages. Similar to `console.log`.
 *
 * @class
 * @param    {Mixed[]} args
 *           One or more messages or objects that should be logged.
 */
log = function log() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  logByType('log', args);
};

/**
 * Enumeration of available logging levels, where the keys are the level names
 * and the values are `|`-separated strings containing logging methods allowed
 * in that logging level. These strings are used to create a regular expression
 * matching the function name being called.
 *
 * Levels provided by video.js are:
 *
 * - `off`: Matches no calls. Any value that can be cast to `false` will have
 *   this effect. The most restrictive.
 * - `all` (default): Matches only Video.js-provided functions (`log`,
 *   `log.warn`, and `log.error`).
 * - `warn`: Matches `log.warn` and `log.error` calls.
 * - `error`: Matches only `log.error` calls.
 *
 * @type {Object}
 */
log.levels = {
  all: 'log|warn|error',
  error: 'error',
  off: '',
  warn: 'warn|error',
  DEFAULT: level
};

/**
 * Get or set the current logging level. If a string matching a key from
 * {@link log.levels} is provided, acts as a setter. Regardless of argument,
 * returns the current logging level.
 *
 * @param  {string} [lvl]
 *         Pass to set a new logging level.
 *
 * @return {string}
 *         The current logging level.
 */
log.level = function (lvl) {
  if (typeof lvl === 'string') {
    if (!log.levels.hasOwnProperty(lvl)) {
      throw new Error('"' + lvl + '" in not a valid log level');
    }
    level = lvl;
  }
  return level;
};

/**
 * Returns an array containing everything that has been logged to the history.
 *
 * This array is a shallow clone of the internal history record. However, its
 * contents are _not_ cloned; so, mutating objects inside this array will
 * mutate them in history.
 *
 * @return {Array}
 */
log.history = function () {
  return history ? [].concat(history) : [];
};

/**
 * Clears the internal history tracking, but does not prevent further history
 * tracking.
 */
log.history.clear = function () {
  if (history) {
    history.length = 0;
  }
};

/**
 * Disable history tracking if it is currently enabled.
 */
log.history.disable = function () {
  if (history !== null) {
    history.length = 0;
    history = null;
  }
};

/**
 * Enable history tracking if it is currently disabled.
 */
log.history.enable = function () {
  if (history === null) {
    history = [];
  }
};

/**
 * Logs error messages. Similar to `console.error`.
 *
 * @param {Mixed[]} args
 *        One or more messages or objects that should be logged as an error
 */
log.error = function () {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return logByType('error', args);
};

/**
 * Logs warning messages. Similar to `console.warn`.
 *
 * @param {Mixed[]} args
 *        One or more messages or objects that should be logged as a warning.
 */
log.warn = function () {
  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  return logByType('warn', args);
};

var log$1 = log;

/**
 * @file computed-style.js
 * @module computed-style
 */
/**
 * A safe getComputedStyle with an IE8 fallback.
 *
 * This is needed because in Firefox, if the player is loaded in an iframe with
 * `display:none`, then `getComputedStyle` returns `null`, so, we do a null-check to
 * make sure  that the player doesn't break in these cases.
 *
 * @param {Element} el
 *        The element you want the computed style of
 *
 * @param {string} prop
 *        The property name you want
 *
 * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397
 *
 * @static
 * @const
 */
function computedStyle(el, prop) {
  if (!el || !prop) {
    return '';
  }

  if (typeof window.getComputedStyle === 'function') {
    var cs = window.getComputedStyle(el);

    return cs ? cs[prop] : '';
  }

  return el.currentStyle[prop] || '';
}

var _templateObject = taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\n                has been deprecated. Use the third argument instead.\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.'], ['Setting attributes in the second argument of createEl()\n                has been deprecated. Use the third argument instead.\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.']);

/**
 * @file dom.js
 * @module dom
 */
/**
 * Detect if a value is a string with any non-whitespace characters.
 *
 * @param {string} str
 *        The string to check
 *
 * @return {boolean}
 *         - True if the string is non-blank
 *         - False otherwise
 *
 */
function isNonBlankString(str) {
  return typeof str === 'string' && /\S/.test(str);
}

/**
 * Throws an error if the passed string has whitespace. This is used by
 * class methods to be relatively consistent with the classList API.
 *
 * @param {string} str
 *         The string to check for whitespace.
 *
 * @throws {Error}
 *         Throws an error if there is whitespace in the string.
 *
 */
function throwIfWhitespace(str) {
  if (/\s/.test(str)) {
    throw new Error('class has illegal whitespace characters');
  }
}

/**
 * Produce a regular expression for matching a className within an elements className.
 *
 * @param {string} className
 *         The className to generate the RegExp for.
 *
 * @return {RegExp}
 *         The RegExp that will check for a specific `className` in an elements
 *         className.
 */
function classRegExp(className) {
  return new RegExp('(^|\\s)' + className + '($|\\s)');
}

/**
 * Whether the current DOM interface appears to be real.
 *
 * @return {Boolean}
 */
function isReal() {
  return (

    // Both document and window will never be undefined thanks to `global`.
    document === window.document &&

    // In IE < 9, DOM methods return "object" as their type, so all we can
    // confidently check is that it exists.
    typeof document.createElement !== 'undefined'
  );
}

/**
 * Determines, via duck typing, whether or not a value is a DOM element.
 *
 * @param {Mixed} value
 *        The thing to check
 *
 * @return {boolean}
 *         - True if it is a DOM element
 *         - False otherwise
 */
function isEl(value) {
  return isObject(value) && value.nodeType === 1;
}

/**
 * Creates functions to query the DOM using a given method.
 *
 * @param {string} method
 *         The method to create the query with.
 *
 * @return {Function}
 *         The query method
 */
function createQuerier(method) {
  return function (selector, context) {
    if (!isNonBlankString(selector)) {
      return document[method](null);
    }
    if (isNonBlankString(context)) {
      context = document.querySelector(context);
    }

    var ctx = isEl(context) ? context : document;

    return ctx[method] && ctx[method](selector);
  };
}

/**
 * Creates an element and applies properties.
 *
 * @param {string} [tagName='div']
 *         Name of tag to be created.
 *
 * @param {Object} [properties={}]
 *         Element properties to be applied.
 *
 * @param {Object} [attributes={}]
 *         Element attributes to be applied.
 *
 * @param {String|Element|TextNode|Array|Function} [content]
 *         Contents for the element (see: {@link dom:normalizeContent})
 *
 * @return {Element}
 *         The element that was created.
 */
function createEl() {
  var tagName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';
  var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var content = arguments[3];

  var el = document.createElement(tagName);

  Object.getOwnPropertyNames(properties).forEach(function (propName) {
    var val = properties[propName];

    // See #2176
    // We originally were accepting both properties and attributes in the
    // same object, but that doesn't work so well.
    if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {
      log$1.warn(tsml(_templateObject, propName, val));
      el.setAttribute(propName, val);

      // Handle textContent since it's not supported everywhere and we have a
      // method for it.
    } else if (propName === 'textContent') {
      textContent(el, val);
    } else {
      el[propName] = val;
    }
  });

  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
    el.setAttribute(attrName, attributes[attrName]);
  });

  if (content) {
    appendContent(el, content);
  }

  return el;
}

/**
 * Injects text into an element, replacing any existing contents entirely.
 *
 * @param {Element} el
 *        The element to add text content into
 *
 * @param {string} text
 *        The text content to add.
 *
 * @return {Element}
 *         The element with added text content.
 */
function textContent(el, text) {
  if (typeof el.textContent === 'undefined') {
    el.innerText = text;
  } else {
    el.textContent = text;
  }
  return el;
}

/**
 * Insert an element as the first child node of another
 *
 * @param {Element} child
 *        Element to insert
 *
 * @param {Element} parent
 *        Element to insert child into
 */
function prependTo(child, parent) {
  if (parent.firstChild) {
    parent.insertBefore(child, parent.firstChild);
  } else {
    parent.appendChild(child);
  }
}

/**
 * Check if an element has a CSS class
 *
 * @param {Element} element
 *        Element to check
 *
 * @param {string} classToCheck
 *        Class name to check for
 *
 * @return {boolean}
 *         - True if the element had the class
 *         - False otherwise.
 *
 * @throws {Error}
 *         Throws an error if `classToCheck` has white space.
 */
function hasClass(element, classToCheck) {
  throwIfWhitespace(classToCheck);
  if (element.classList) {
    return element.classList.contains(classToCheck);
  }
  return classRegExp(classToCheck).test(element.className);
}

/**
 * Add a CSS class name to an element
 *
 * @param {Element} element
 *        Element to add class name to.
 *
 * @param {string} classToAdd
 *        Class name to add.
 *
 * @return {Element}
 *         The dom element with the added class name.
 */
function addClass(element, classToAdd) {
  if (element.classList) {
    element.classList.add(classToAdd);

    // Don't need to `throwIfWhitespace` here because `hasElClass` will do it
    // in the case of classList not being supported.
  } else if (!hasClass(element, classToAdd)) {
    element.className = (element.className + ' ' + classToAdd).trim();
  }

  return element;
}

/**
 * Remove a CSS class name from an element
 *
 * @param {Element} element
 *        Element to remove a class name from.
 *
 * @param {string} classToRemove
 *        Class name to remove
 *
 * @return {Element}
 *         The dom element with class name removed.
 */
function removeClass(element, classToRemove) {
  if (element.classList) {
    element.classList.remove(classToRemove);
  } else {
    throwIfWhitespace(classToRemove);
    element.className = element.className.split(/\s+/).filter(function (c) {
      return c !== classToRemove;
    }).join(' ');
  }

  return element;
}

/**
 * The callback definition for toggleElClass.
 *
 * @callback Dom~PredicateCallback
 * @param {Element} element
 *        The DOM element of the Component.
 *
 * @param {string} classToToggle
 *        The `className` that wants to be toggled
 *
 * @return {boolean|undefined}
 *         - If true the `classToToggle` will get added to `element`.
 *         - If false the `classToToggle` will get removed from `element`.
 *         - If undefined this callback will be ignored
 */

/**
 * Adds or removes a CSS class name on an element depending on an optional
 * condition or the presence/absence of the class name.
 *
 * @param {Element} element
 *        The element to toggle a class name on.
 *
 * @param {string} classToToggle
 *        The class that should be toggled
 *
 * @param {boolean|PredicateCallback} [predicate]
 *        See the return value for {@link Dom~PredicateCallback}
 *
 * @return {Element}
 *         The element with a class that has been toggled.
 */
function toggleClass(element, classToToggle, predicate) {

  // This CANNOT use `classList` internally because IE does not support the
  // second parameter to the `classList.toggle()` method! Which is fine because
  // `classList` will be used by the add/remove functions.
  var has = hasClass(element, classToToggle);

  if (typeof predicate === 'function') {
    predicate = predicate(element, classToToggle);
  }

  if (typeof predicate !== 'boolean') {
    predicate = !has;
  }

  // If the necessary class operation matches the current state of the
  // element, no action is required.
  if (predicate === has) {
    return;
  }

  if (predicate) {
    addClass(element, classToToggle);
  } else {
    removeClass(element, classToToggle);
  }

  return element;
}

/**
 * Apply attributes to an HTML element.
 *
 * @param {Element} el
 *        Element to add attributes to.
 *
 * @param {Object} [attributes]
 *        Attributes to be applied.
 */
function setAttributes(el, attributes) {
  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
    var attrValue = attributes[attrName];

    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
      el.removeAttribute(attrName);
    } else {
      el.setAttribute(attrName, attrValue === true ? '' : attrValue);
    }
  });
}

/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributes are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 *
 * @param {Element} tag
 *        Element from which to get tag attributes.
 *
 * @return {Object}
 *         All attributes of the element.
 */
function getAttributes(tag) {
  var obj = {};

  // known boolean attributes
  // we can check for matching boolean properties, but older browsers
  // won't know about HTML5 boolean attributes that we still read from
  var knownBooleans = ',' + 'autoplay,controls,loop,muted,default' + ',';

  if (tag && tag.attributes && tag.attributes.length > 0) {
    var attrs = tag.attributes;

    for (var i = attrs.length - 1; i >= 0; i--) {
      var attrName = attrs[i].name;
      var attrVal = attrs[i].value;

      // check for known booleans
      // the matching element property will return a value for typeof
      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {
        // the value of an included boolean attribute is typically an empty
        // string ('') which would equal false if we just check for a false value.
        // we also don't want support bad code like autoplay='false'
        attrVal = attrVal !== null ? true : false;
      }

      obj[attrName] = attrVal;
    }
  }

  return obj;
}

/**
 * Get the value of an element's attribute
 *
 * @param {Element} el
 *        A DOM element
 *
 * @param {string} attribute
 *        Attribute to get the value of
 *
 * @return {string}
 *         value of the attribute
 */
function getAttribute(el, attribute) {
  return el.getAttribute(attribute);
}

/**
 * Set the value of an element's attribute
 *
 * @param {Element} el
 *        A DOM element
 *
 * @param {string} attribute
 *        Attribute to set
 *
 * @param {string} value
 *        Value to set the attribute to
 */
function setAttribute(el, attribute, value) {
  el.setAttribute(attribute, value);
}

/**
 * Remove an element's attribute
 *
 * @param {Element} el
 *        A DOM element
 *
 * @param {string} attribute
 *        Attribute to remove
 */
function removeAttribute(el, attribute) {
  el.removeAttribute(attribute);
}

/**
 * Attempt to block the ability to select text while dragging controls
 */
function blockTextSelection() {
  document.body.focus();
  document.onselectstart = function () {
    return false;
  };
}

/**
 * Turn off text selection blocking
 */
function unblockTextSelection() {
  document.onselectstart = function () {
    return true;
  };
}

/**
 * Identical to the native `getBoundingClientRect` function, but ensures that
 * the method is supported at all (it is in all browsers we claim to support)
 * and that the element is in the DOM before continuing.
 *
 * This wrapper function also shims properties which are not provided by some
 * older browsers (namely, IE8).
 *
 * Additionally, some browsers do not support adding properties to a
 * `ClientRect`/`DOMRect` object; so, we shallow-copy it with the standard
 * properties (except `x` and `y` which are not widely supported). This helps
 * avoid implementations where keys are non-enumerable.
 *
 * @param  {Element} el
 *         Element whose `ClientRect` we want to calculate.
 *
 * @return {Object|undefined}
 *         Always returns a plain
 */
function getBoundingClientRect(el) {
  if (el && el.getBoundingClientRect && el.parentNode) {
    var rect = el.getBoundingClientRect();
    var result = {};

    ['bottom', 'height', 'left', 'right', 'top', 'width'].forEach(function (k) {
      if (rect[k] !== undefined) {
        result[k] = rect[k];
      }
    });

    if (!result.height) {
      result.height = parseFloat(computedStyle(el, 'height'));
    }

    if (!result.width) {
      result.width = parseFloat(computedStyle(el, 'width'));
    }

    return result;
  }
}

/**
 * The postion of a DOM element on the page.
 *
 * @typedef {Object} module:dom~Position
 *
 * @property {number} left
 *           Pixels to the left
 *
 * @property {number} top
 *           Pixels on top
 */

/**
 * Offset Left.
 * getBoundingClientRect technique from
 * John Resig
 *
 * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/
 *
 * @param {Element} el
 *        Element from which to get offset
 *
 * @return {module:dom~Position}
 *         The position of the element that was passed in.
 */
function findPosition(el) {
  var box = void 0;

  if (el.getBoundingClientRect && el.parentNode) {
    box = el.getBoundingClientRect();
  }

  if (!box) {
    return {
      left: 0,
      top: 0
    };
  }

  var docEl = document.documentElement;
  var body = document.body;

  var clientLeft = docEl.clientLeft || body.clientLeft || 0;
  var scrollLeft = window.pageXOffset || body.scrollLeft;
  var left = box.left + scrollLeft - clientLeft;

  var clientTop = docEl.clientTop || body.clientTop || 0;
  var scrollTop = window.pageYOffset || body.scrollTop;
  var top = box.top + scrollTop - clientTop;

  // Android sometimes returns slightly off decimal values, so need to round
  return {
    left: Math.round(left),
    top: Math.round(top)
  };
}

/**
 * x and y coordinates for a dom element or mouse pointer
 *
 * @typedef {Object} Dom~Coordinates
 *
 * @property {number} x
 *           x coordinate in pixels
 *
 * @property {number} y
 *           y coordinate in pixels
 */

/**
 * Get pointer position in element
 * Returns an object with x and y coordinates.
 * The base on the coordinates are the bottom left of the element.
 *
 * @param {Element} el
 *        Element on which to get the pointer position on
 *
 * @param {EventTarget~Event} event
 *        Event object
 *
 * @return {Dom~Coordinates}
 *         A Coordinates object corresponding to the mouse position.
 *
 */
function getPointerPosition(el, event) {
  var position = {};
  var box = findPosition(el);
  var boxW = el.offsetWidth;
  var boxH = el.offsetHeight;

  var boxY = box.top;
  var boxX = box.left;
  var pageY = event.pageY;
  var pageX = event.pageX;

  if (event.changedTouches) {
    pageX = event.changedTouches[0].pageX;
    pageY = event.changedTouches[0].pageY;
  }

  position.y = Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));
  position.x = Math.max(0, Math.min(1, (pageX - boxX) / boxW));

  return position;
}

/**
 * Determines, via duck typing, whether or not a value is a text node.
 *
 * @param {Mixed} value
 *        Check if this value is a text node.
 *
 * @return {boolean}
 *         - True if it is a text node
 *         - False otherwise
 */
function isTextNode(value) {
  return isObject(value) && value.nodeType === 3;
}

/**
 * Empties the contents of an element.
 *
 * @param {Element} el
 *        The element to empty children from
 *
 * @return {Element}
 *         The element with no children
 */
function emptyEl(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
  return el;
}

/**
 * Normalizes content for eventual insertion into the DOM.
 *
 * This allows a wide range of content definition methods, but protects
 * from falling into the trap of simply writing to `innerHTML`, which is
 * an XSS concern.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * @param {String|Element|TextNode|Array|Function} content
 *        - String: Normalized into a text node.
 *        - Element/TextNode: Passed through.
 *        - Array: A one-dimensional array of strings, elements, nodes, or functions
 *          (which return single strings, elements, or nodes).
 *        - Function: If the sole argument, is expected to produce a string, element,
 *          node, or array as defined above.
 *
 * @return {Array}
 *         All of the content that was passed in normalized.
 */
function normalizeContent(content) {

  // First, invoke content if it is a function. If it produces an array,
  // that needs to happen before normalization.
  if (typeof content === 'function') {
    content = content();
  }

  // Next up, normalize to an array, so one or many items can be normalized,
  // filtered, and returned.
  return (Array.isArray(content) ? content : [content]).map(function (value) {

    // First, invoke value if it is a function to produce a new value,
    // which will be subsequently normalized to a Node of some kind.
    if (typeof value === 'function') {
      value = value();
    }

    if (isEl(value) || isTextNode(value)) {
      return value;
    }

    if (typeof value === 'string' && /\S/.test(value)) {
      return document.createTextNode(value);
    }
  }).filter(function (value) {
    return value;
  });
}

/**
 * Normalizes and appends content to an element.
 *
 * @param {Element} el
 *        Element to append normalized content to.
 *
 *
 * @param {String|Element|TextNode|Array|Function} content
 *        See the `content` argument of {@link dom:normalizeContent}
 *
 * @return {Element}
 *         The element with appended normalized content.
 */
function appendContent(el, content) {
  normalizeContent(content).forEach(function (node) {
    return el.appendChild(node);
  });
  return el;
}

/**
 * Normalizes and inserts content into an element; this is identical to
 * `appendContent()`, except it empties the element first.
 *
 * @param {Element} el
 *        Element to insert normalized content into.
 *
 * @param {String|Element|TextNode|Array|Function} content
 *        See the `content` argument of {@link dom:normalizeContent}
 *
 * @return {Element}
 *         The element with inserted normalized content.
 *
 */
function insertContent(el, content) {
  return appendContent(emptyEl(el), content);
}

/**
 * Finds a single DOM element matching `selector` within the optional
 * `context` of another DOM element (defaulting to `document`).
 *
 * @param {string} selector
 *        A valid CSS selector, which will be passed to `querySelector`.
 *
 * @param {Element|String} [context=document]
 *        A DOM element within which to query. Can also be a selector
 *        string in which case the first matching element will be used
 *        as context. If missing (or no element matches selector), falls
 *        back to `document`.
 *
 * @return {Element|null}
 *         The element that was found or null.
 */
var $ = createQuerier('querySelector');

/**
 * Finds a all DOM elements matching `selector` within the optional
 * `context` of another DOM element (defaulting to `document`).
 *
 * @param {string} selector
 *           A valid CSS selector, which will be passed to `querySelectorAll`.
 *
 * @param {Element|String} [context=document]
 *           A DOM element within which to query. Can also be a selector
 *           string in which case the first matching element will be used
 *           as context. If missing (or no element matches selector), falls
 *           back to `document`.
 *
 * @return {NodeList}
 *         A element list of elements that were found. Will be empty if none were found.
 *
 */
var $$ = createQuerier('querySelectorAll');



var Dom = (Object.freeze || Object)({
	isReal: isReal,
	isEl: isEl,
	createEl: createEl,
	textContent: textContent,
	prependTo: prependTo,
	hasClass: hasClass,
	addClass: addClass,
	removeClass: removeClass,
	toggleClass: toggleClass,
	setAttributes: setAttributes,
	getAttributes: getAttributes,
	getAttribute: getAttribute,
	setAttribute: setAttribute,
	removeAttribute: removeAttribute,
	blockTextSelection: blockTextSelection,
	unblockTextSelection: unblockTextSelection,
	getBoundingClientRect: getBoundingClientRect,
	findPosition: findPosition,
	getPointerPosition: getPointerPosition,
	isTextNode: isTextNode,
	emptyEl: emptyEl,
	normalizeContent: normalizeContent,
	appendContent: appendContent,
	insertContent: insertContent,
	$: $,
	$$: $$
});

/**
 * @file guid.js
 * @module guid
 */

/**
 * Unique ID for an element or function
 * @type {Number}
 */
var _guid = 1;

/**
 * Get a unique auto-incrementing ID by number that has not been returned before.
 *
 * @return {number}
 *         A new unique ID.
 */
function newGUID() {
  return _guid++;
}

/**
 * @file dom-data.js
 * @module dom-data
 */
/**
 * Element Data Store.
 *
 * Allows for binding data to an element without putting it directly on the
 * element. Ex. Event listeners are stored here.
 * (also from jsninja.com, slightly modified and updated for closure compiler)
 *
 * @type {Object}
 * @private
 */
var elData = {};

/*
 * Unique attribute name to store an element's guid in
 *
 * @type {String}
 * @constant
 * @private
 */
var elIdAttr = 'vdata' + new Date().getTime();

/**
 * Returns the cache object where data for an element is stored
 *
 * @param {Element} el
 *        Element to store data for.
 *
 * @return {Object}
 *         The cache object for that el that was passed in.
 */
function getData(el) {
  var id = el[elIdAttr];

  if (!id) {
    id = el[elIdAttr] = newGUID();
  }

  if (!elData[id]) {
    elData[id] = {};
  }

  return elData[id];
}

/**
 * Returns whether or not an element has cached data
 *
 * @param {Element} el
 *        Check if this element has cached data.
 *
 * @return {boolean}
 *         - True if the DOM element has cached data.
 *         - False otherwise.
 */
function hasData(el) {
  var id = el[elIdAttr];

  if (!id) {
    return false;
  }

  return !!Object.getOwnPropertyNames(elData[id]).length;
}

/**
 * Delete data for the element from the cache and the guid attr from getElementById
 *
 * @param {Element} el
 *        Remove cached data for this element.
 */
function removeData(el) {
  var id = el[elIdAttr];

  if (!id) {
    return;
  }

  // Remove all stored data
  delete elData[id];

  // Remove the elIdAttr property from the DOM node
  try {
    delete el[elIdAttr];
  } catch (e) {
    if (el.removeAttribute) {
      el.removeAttribute(elIdAttr);
    } else {
      // IE doesn't appear to support removeAttribute on the document element
      el[elIdAttr] = null;
    }
  }
}

/**
 * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)
 * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)
 * This should work very similarly to jQuery's events, however it's based off the book version which isn't as
 * robust as jquery's, so there's probably some differences.
 *
 * @module events
 */

/**
 * Clean up the listener cache and dispatchers
 *
 * @param {Element|Object} elem
 *        Element to clean up
 *
 * @param {string} type
 *        Type of event to clean up
 */
function _cleanUpEvents(elem, type) {
  var data = getData(elem);

  // Remove the events of a particular type if there are none left
  if (data.handlers[type].length === 0) {
    delete data.handlers[type];
    // data.handlers[type] = null;
    // Setting to null was causing an error with data.handlers

    // Remove the meta-handler from the element
    if (elem.removeEventListener) {
      elem.removeEventListener(type, data.dispatcher, false);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + type, data.dispatcher);
    }
  }

  // Remove the events object if there are no types left
  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
    delete data.handlers;
    delete data.dispatcher;
    delete data.disabled;
  }

  // Finally remove the element data if there is no data left
  if (Object.getOwnPropertyNames(data).length === 0) {
    removeData(elem);
  }
}

/**
 * Loops through an array of event types and calls the requested method for each type.
 *
 * @param {Function} fn
 *        The event method we want to use.
 *
 * @param {Element|Object} elem
 *        Element or object to bind listeners to
 *
 * @param {string} type
 *        Type of event to bind to.
 *
 * @param {EventTarget~EventListener} callback
 *        Event listener.
 */
function _handleMultipleEvents(fn, elem, types, callback) {
  types.forEach(function (type) {
    // Call the event method for each one of the types
    fn(elem, type, callback);
  });
}

/**
 * Fix a native event to have standard property values
 *
 * @param {Object} event
 *        Event object to fix.
 *
 * @return {Object}
 *         Fixed event object.
 */
function fixEvent(event) {

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  }

  // Test if fixing up is needed
  // Used to check if !event.stopPropagation instead of isPropagationStopped
  // But native events return true for stopPropagation, but don't have
  // other expected methods like isPropagationStopped. Seems to be a problem
  // with the Javascript Ninja code. So we're just overriding all events now.
  if (!event || !event.isPropagationStopped) {
    var old = event || window.event;

    event = {};
    // Clone the old object so that we can modify the values event = {};
    // IE8 Doesn't like when you mess with native event properties
    // Firefox returns false for event.hasOwnProperty('type') and other props
    //  which makes copying more difficult.
    // TODO: Probably best to create a whitelist of event props
    for (var key in old) {
      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y
      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation
      // and webkitMovementX/Y
      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {
        // Chrome 32+ warns if you try to copy deprecated returnValue, but
        // we still want to if preventDefault isn't supported (IE8).
        if (!(key === 'returnValue' && old.preventDefault)) {
          event[key] = old[key];
        }
      }
    }

    // The event occurred on this element
    if (!event.target) {
      event.target = event.srcElement || document;
    }

    // Handle which other element the event is related to
    if (!event.relatedTarget) {
      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
    }

    // Stop the default browser action
    event.preventDefault = function () {
      if (old.preventDefault) {
        old.preventDefault();
      }
      event.returnValue = false;
      old.returnValue = false;
      event.defaultPrevented = true;
    };

    event.defaultPrevented = false;

    // Stop the event from bubbling
    event.stopPropagation = function () {
      if (old.stopPropagation) {
        old.stopPropagation();
      }
      event.cancelBubble = true;
      old.cancelBubble = true;
      event.isPropagationStopped = returnTrue;
    };

    event.isPropagationStopped = returnFalse;

    // Stop the event from bubbling and executing other handlers
    event.stopImmediatePropagation = function () {
      if (old.stopImmediatePropagation) {
        old.stopImmediatePropagation();
      }
      event.isImmediatePropagationStopped = returnTrue;
      event.stopPropagation();
    };

    event.isImmediatePropagationStopped = returnFalse;

    // Handle mouse position
    if (event.clientX !== null && event.clientX !== undefined) {
      var doc = document.documentElement;
      var body = document.body;

      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }

    // Handle key presses
    event.which = event.charCode || event.keyCode;

    // Fix button for mouse clicks:
    // 0 == left; 1 == middle; 2 == right
    if (event.button !== null && event.button !== undefined) {

      // The following is disabled because it does not pass videojs-standard
      // and... yikes.
      /* eslint-disable */
      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
      /* eslint-enable */
    }
  }

  // Returns fixed-up instance
  return event;
}

/**
 * Whether passive event listeners are supported
 */
var _supportsPassive = false;

(function () {
  try {
    var opts = Object.defineProperty({}, 'passive', {
      get: function get() {
        _supportsPassive = true;
      }
    });

    window.addEventListener('test', null, opts);
  } catch (e) {
    // disregard
  }
})();

/**
 * Touch events Chrome expects to be passive
 */
var passiveEvents = ['touchstart', 'touchmove'];

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 *
 * @param {Element|Object} elem
 *        Element or object to bind listeners to
 *
 * @param {string|string[]} type
 *        Type of event to bind to.
 *
 * @param {EventTarget~EventListener} fn
 *        Event listener.
 */
function on(elem, type, fn) {
  if (Array.isArray(type)) {
    return _handleMultipleEvents(on, elem, type, fn);
  }

  var data = getData(elem);

  // We need a place to store all our handler data
  if (!data.handlers) {
    data.handlers = {};
  }

  if (!data.handlers[type]) {
    data.handlers[type] = [];
  }

  if (!fn.guid) {
    fn.guid = newGUID();
  }

  data.handlers[type].push(fn);

  if (!data.dispatcher) {
    data.disabled = false;

    data.dispatcher = function (event, hash) {

      if (data.disabled) {
        return;
      }

      event = fixEvent(event);

      var handlers = data.handlers[event.type];

      if (handlers) {
        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.
        var handlersCopy = handlers.slice(0);

        for (var m = 0, n = handlersCopy.length; m < n; m++) {
          if (event.isImmediatePropagationStopped()) {
            break;
          } else {
            try {
              handlersCopy[m].call(elem, event, hash);
            } catch (e) {
              log$1.error(e);
            }
          }
        }
      }
    };
  }

  if (data.handlers[type].length === 1) {
    if (elem.addEventListener) {
      var options = false;

      if (_supportsPassive && passiveEvents.indexOf(type) > -1) {
        options = { passive: true };
      }
      elem.addEventListener(type, data.dispatcher, options);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + type, data.dispatcher);
    }
  }
}

/**
 * Removes event listeners from an element
 *
 * @param {Element|Object} elem
 *        Object to remove listeners from.
 *
 * @param {string|string[]} [type]
 *        Type of listener to remove. Don't include to remove all events from element.
 *
 * @param {EventTarget~EventListener} [fn]
 *        Specific listener to remove. Don't include to remove listeners for an event
 *        type.
 */
function off(elem, type, fn) {
  // Don't want to add a cache object through getElData if not needed
  if (!hasData(elem)) {
    return;
  }

  var data = getData(elem);

  // If no events exist, nothing to unbind
  if (!data.handlers) {
    return;
  }

  if (Array.isArray(type)) {
    return _handleMultipleEvents(off, elem, type, fn);
  }

  // Utility function
  var removeType = function removeType(t) {
    data.handlers[t] = [];
    _cleanUpEvents(elem, t);
  };

  // Are we removing all bound events?
  if (!type) {
    for (var t in data.handlers) {
      removeType(t);
    }
    return;
  }

  var handlers = data.handlers[type];

  // If no handlers exist, nothing to unbind
  if (!handlers) {
    return;
  }

  // If no listener was provided, remove all listeners for type
  if (!fn) {
    removeType(type);
    return;
  }

  // We're only removing a single handler
  if (fn.guid) {
    for (var n = 0; n < handlers.length; n++) {
      if (handlers[n].guid === fn.guid) {
        handlers.splice(n--, 1);
      }
    }
  }

  _cleanUpEvents(elem, type);
}

/**
 * Trigger an event for an element
 *
 * @param {Element|Object} elem
 *        Element to trigger an event on
 *
 * @param {EventTarget~Event|string} event
 *        A string (the type) or an event object with a type attribute
 *
 * @param {Object} [hash]
 *        data hash to pass along with the event
 *
 * @return {boolean|undefined}
 *         - Returns the opposite of `defaultPrevented` if default was prevented
 *         - Otherwise returns undefined
 */
function trigger(elem, event, hash) {
  // Fetches element data and a reference to the parent (for bubbling).
  // Don't want to add a data object to cache for every parent,
  // so checking hasElData first.
  var elemData = hasData(elem) ? getData(elem) : {};
  var parent = elem.parentNode || elem.ownerDocument;
  // type = event.type || event,
  // handler;

  // If an event name was passed as a string, creates an event out of it
  if (typeof event === 'string') {
    event = { type: event, target: elem };
  }
  // Normalizes the event properties.
  event = fixEvent(event);

  // If the passed element has a dispatcher, executes the established handlers.
  if (elemData.dispatcher) {
    elemData.dispatcher.call(elem, event, hash);
  }

  // Unless explicitly stopped or the event does not bubble (e.g. media events)
  // recursively calls this function to bubble the event up the DOM.
  if (parent && !event.isPropagationStopped() && event.bubbles === true) {
    trigger.call(null, parent, event, hash);

    // If at the top of the DOM, triggers the default action unless disabled.
  } else if (!parent && !event.defaultPrevented) {
    var targetData = getData(event.target);

    // Checks if the target has a default action for this event.
    if (event.target[event.type]) {
      // Temporarily disables event dispatching on the target as we have already executed the handler.
      targetData.disabled = true;
      // Executes the default action.
      if (typeof event.target[event.type] === 'function') {
        event.target[event.type]();
      }
      // Re-enables event dispatching.
      targetData.disabled = false;
    }
  }

  // Inform the triggerer if the default was prevented by returning false
  return !event.defaultPrevented;
}

/**
 * Trigger a listener only once for an event
 *
 * @param {Element|Object} elem
 *        Element or object to bind to.
 *
 * @param {string|string[]} type
 *        Name/type of event
 *
 * @param {Event~EventListener} fn
 *        Event Listener function
 */
function one(elem, type, fn) {
  if (Array.isArray(type)) {
    return _handleMultipleEvents(one, elem, type, fn);
  }
  var func = function func() {
    off(elem, type, func);
    fn.apply(this, arguments);
  };

  // copy the guid to the new function so it can removed using the original function's ID
  func.guid = fn.guid = fn.guid || newGUID();
  on(elem, type, func);
}

var Events = (Object.freeze || Object)({
	fixEvent: fixEvent,
	on: on,
	off: off,
	trigger: trigger,
	one: one
});

/**
 * @file setup.js - Functions for setting up a player without
 * user interaction based on the data-setup `attribute` of the video tag.
 *
 * @module setup
 */
var _windowLoaded = false;
var videojs$2 = void 0;

/**
 * Set up any tags that have a data-setup `attribute` when the player is started.
 */
var autoSetup = function autoSetup() {

  // Protect against breakage in non-browser environments.
  if (!isReal()) {
    return;
  }

  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*
  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));
  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));
  // var mediaEls = vids.concat(audios);

  // Because IE8 doesn't support calling slice on a node list, we need to loop
  // through each list of elements to build up a new, combined list of elements.
  var vids = document.getElementsByTagName('video');
  var audios = document.getElementsByTagName('audio');
  var mediaEls = [];

  if (vids && vids.length > 0) {
    for (var i = 0, e = vids.length; i < e; i++) {
      mediaEls.push(vids[i]);
    }
  }

  if (audios && audios.length > 0) {
    for (var _i = 0, _e = audios.length; _i < _e; _i++) {
      mediaEls.push(audios[_i]);
    }
  }

  // Check if any media elements exist
  if (mediaEls && mediaEls.length > 0) {

    for (var _i2 = 0, _e2 = mediaEls.length; _i2 < _e2; _i2++) {
      var mediaEl = mediaEls[_i2];

      // Check if element exists, has getAttribute func.
      // IE seems to consider typeof el.getAttribute == 'object' instead of
      // 'function' like expected, at least when loading the player immediately.
      if (mediaEl && mediaEl.getAttribute) {

        // Make sure this player hasn't already been set up.
        if (mediaEl.player === undefined) {
          var options = mediaEl.getAttribute('data-setup');

          // Check if data-setup attr exists.
          // We only auto-setup if they've added the data-setup attr.
          if (options !== null) {
            // Create new video.js instance.
            videojs$2(mediaEl);
          }
        }

        // If getAttribute isn't defined, we need to wait for the DOM.
      } else {
        autoSetupTimeout(1);
        break;
      }
    }

    // No videos were found, so keep looping unless page is finished loading.
  } else if (!_windowLoaded) {
    autoSetupTimeout(1);
  }
};

/**
 * Wait until the page is loaded before running autoSetup. This will be called in
 * autoSetup if `hasLoaded` returns false.
 *
 * @param {number} wait
 *        How long to wait in ms
 *
 * @param {module:videojs} [vjs]
 *        The videojs library function
 */
function autoSetupTimeout(wait, vjs) {
  if (vjs) {
    videojs$2 = vjs;
  }

  window.setTimeout(autoSetup, wait);
}

if (isReal() && document.readyState === 'complete') {
  _windowLoaded = true;
} else {
  /**
   * Listen for the load event on window, and set _windowLoaded to true.
   *
   * @listens load
   */
  one(window, 'load', function () {
    _windowLoaded = true;
  });
}

/**
 * @file stylesheet.js
 * @module stylesheet
 */
/**
 * Create a DOM syle element given a className for it.
 *
 * @param {string} className
 *        The className to add to the created style element.
 *
 * @return {Element}
 *         The element that was created.
 */
var createStyleElement = function createStyleElement(className) {
  var style = document.createElement('style');

  style.className = className;

  return style;
};

/**
 * Add text to a DOM element.
 *
 * @param {Element} el
 *        The Element to add text content to.
 *
 * @param {string} content
 *        The text to add to the element.
 */
var setTextContent = function setTextContent(el, content) {
  if (el.styleSheet) {
    el.styleSheet.cssText = content;
  } else {
    el.textContent = content;
  }
};

/**
 * @file fn.js
 * @module fn
 */
/**
 * Bind (a.k.a proxy or Context). A simple method for changing the context of a function
 * It also stores a unique id on the function so it can be easily removed from events.
 *
 * @param {Mixed} context
 *        The object to bind as scope.
 *
 * @param {Function} fn
 *        The function to be bound to a scope.
 *
 * @param {number} [uid]
 *        An optional unique ID for the function to be set
 *
 * @return {Function}
 *         The new function that will be bound into the context given
 */
var bind = function bind(context, fn, uid) {
  // Make sure the function has a unique ID
  if (!fn.guid) {
    fn.guid = newGUID();
  }

  // Create the new function that changes the context
  var bound = function bound() {
    return fn.apply(context, arguments);
  };

  // Allow for the ability to individualize this function
  // Needed in the case where multiple objects might share the same prototype
  // IF both items add an event listener with the same function, then you try to remove just one
  // it will remove both because they both have the same guid.
  // when using this, you need to use the bind method when you remove the listener as well.
  // currently used in text tracks
  bound.guid = uid ? uid + '_' + fn.guid : fn.guid;

  return bound;
};

/**
 * Wraps the given function, `fn`, with a new function that only invokes `fn`
 * at most once per every `wait` milliseconds.
 *
 * @param  {Function} fn
 *         The function to be throttled.
 *
 * @param  {Number}   wait
 *         The number of milliseconds by which to throttle.
 *
 * @return {Function}
 */
var throttle = function throttle(fn, wait) {
  var last = Date.now();

  var throttled = function throttled() {
    var now = Date.now();

    if (now - last >= wait) {
      fn.apply(undefined, arguments);
      last = now;
    }
  };

  return throttled;
};

/**
 * @file src/js/event-target.js
 */
/**
 * `EventTarget` is a class that can have the same API as the DOM `EventTarget`. It
 * adds shorthand functions that wrap around lengthy functions. For example:
 * the `on` function is a wrapper around `addEventListener`.
 *
 * @see [EventTarget Spec]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}
 * @class EventTarget
 */
var EventTarget = function EventTarget() {};

/**
 * A Custom DOM event.
 *
 * @typedef {Object} EventTarget~Event
 * @see [Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}
 */

/**
 * All event listeners should follow the following format.
 *
 * @callback EventTarget~EventListener
 * @this {EventTarget}
 *
 * @param {EventTarget~Event} event
 *        the event that triggered this function
 *
 * @param {Object} [hash]
 *        hash of data sent during the event
 */

/**
 * An object containing event names as keys and booleans as values.
 *
 * > NOTE: If an event name is set to a true value here {@link EventTarget#trigger}
 *         will have extra functionality. See that function for more information.
 *
 * @property EventTarget.prototype.allowedEvents_
 * @private
 */
EventTarget.prototype.allowedEvents_ = {};

/**
 * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a
 * function that will get called when an event with a certain name gets triggered.
 *
 * @param {string|string[]} type
 *        An event name or an array of event names.
 *
 * @param {EventTarget~EventListener} fn
 *        The function to call with `EventTarget`s
 */
EventTarget.prototype.on = function (type, fn) {
  // Remove the addEventListener alias before calling Events.on
  // so we don't get into an infinite type loop
  var ael = this.addEventListener;

  this.addEventListener = function () {};
  on(this, type, fn);
  this.addEventListener = ael;
};

/**
 * An alias of {@link EventTarget#on}. Allows `EventTarget` to mimic
 * the standard DOM API.
 *
 * @function
 * @see {@link EventTarget#on}
 */
EventTarget.prototype.addEventListener = EventTarget.prototype.on;

/**
 * Removes an `event listener` for a specific event from an instance of `EventTarget`.
 * This makes it so that the `event listener` will no longer get called when the
 * named event happens.
 *
 * @param {string|string[]} type
 *        An event name or an array of event names.
 *
 * @param {EventTarget~EventListener} fn
 *        The function to remove.
 */
EventTarget.prototype.off = function (type, fn) {
  off(this, type, fn);
};

/**
 * An alias of {@link EventTarget#off}. Allows `EventTarget` to mimic
 * the standard DOM API.
 *
 * @function
 * @see {@link EventTarget#off}
 */
EventTarget.prototype.removeEventListener = EventTarget.prototype.off;

/**
 * This function will add an `event listener` that gets triggered only once. After the
 * first trigger it will get removed. This is like adding an `event listener`
 * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.
 *
 * @param {string|string[]} type
 *        An event name or an array of event names.
 *
 * @param {EventTarget~EventListener} fn
 *        The function to be called once for each event name.
 */
EventTarget.prototype.one = function (type, fn) {
  // Remove the addEventListener alialing Events.on
  // so we don't get into an infinite type loop
  var ael = this.addEventListener;

  this.addEventListener = function () {};
  one(this, type, fn);
  this.addEventListener = ael;
};

/**
 * This function causes an event to happen. This will then cause any `event listeners`
 * that are waiting for that event, to get called. If there are no `event listeners`
 * for an event then nothing will happen.
 *
 * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.
 * Trigger will also call the `on` + `uppercaseEventName` function.
 *
 * Example:
 * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call
 * `onClick` if it exists.
 *
 * @param {string|EventTarget~Event|Object} event
 *        The name of the event, an `Event`, or an object with a key of type set to
 *        an event name.
 */
EventTarget.prototype.trigger = function (event) {
  var type = event.type || event;

  if (typeof event === 'string') {
    event = { type: type };
  }
  event = fixEvent(event);

  if (this.allowedEvents_[type] && this['on' + type]) {
    this['on' + type](event);
  }

  trigger(this, event);
};

/**
 * An alias of {@link EventTarget#trigger}. Allows `EventTarget` to mimic
 * the standard DOM API.
 *
 * @function
 * @see {@link EventTarget#trigger}
 */
EventTarget.prototype.dispatchEvent = EventTarget.prototype.trigger;

/**
 * @file mixins/evented.js
 * @module evented
 */
/**
 * Returns whether or not an object has had the evented mixin applied.
 *
 * @param  {Object} object
 *         An object to test.
 *
 * @return {boolean}
 *         Whether or not the object appears to be evented.
 */
var isEvented = function isEvented(object) {
  return object instanceof EventTarget || !!object.eventBusEl_ && ['on', 'one', 'off', 'trigger'].every(function (k) {
    return typeof object[k] === 'function';
  });
};

/**
 * Whether a value is a valid event type - non-empty string or array.
 *
 * @private
 * @param  {string|Array} type
 *         The type value to test.
 *
 * @return {boolean}
 *         Whether or not the type is a valid event type.
 */
var isValidEventType = function isValidEventType(type) {
  return (
    // The regex here verifies that the `type` contains at least one non-
    // whitespace character.
    typeof type === 'string' && /\S/.test(type) || Array.isArray(type) && !!type.length
  );
};

/**
 * Validates a value to determine if it is a valid event target. Throws if not.
 *
 * @private
 * @throws {Error}
 *         If the target does not appear to be a valid event target.
 *
 * @param  {Object} target
 *         The object to test.
 */
var validateTarget = function validateTarget(target) {
  if (!target.nodeName && !isEvented(target)) {
    throw new Error('Invalid target; must be a DOM node or evented object.');
  }
};

/**
 * Validates a value to determine if it is a valid event target. Throws if not.
 *
 * @private
 * @throws {Error}
 *         If the type does not appear to be a valid event type.
 *
 * @param  {string|Array} type
 *         The type to test.
 */
var validateEventType = function validateEventType(type) {
  if (!isValidEventType(type)) {
    throw new Error('Invalid event type; must be a non-empty string or array.');
  }
};

/**
 * Validates a value to determine if it is a valid listener. Throws if not.
 *
 * @private
 * @throws {Error}
 *         If the listener is not a function.
 *
 * @param  {Function} listener
 *         The listener to test.
 */
var validateListener = function validateListener(listener) {
  if (typeof listener !== 'function') {
    throw new Error('Invalid listener; must be a function.');
  }
};

/**
 * Takes an array of arguments given to `on()` or `one()`, validates them, and
 * normalizes them into an object.
 *
 * @private
 * @param  {Object} self
 *         The evented object on which `on()` or `one()` was called. This
 *         object will be bound as the `this` value for the listener.
 *
 * @param  {Array} args
 *         An array of arguments passed to `on()` or `one()`.
 *
 * @return {Object}
 *         An object containing useful values for `on()` or `one()` calls.
 */
var normalizeListenArgs = function normalizeListenArgs(self, args) {

  // If the number of arguments is less than 3, the target is always the
  // evented object itself.
  var isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;
  var target = void 0;
  var type = void 0;
  var listener = void 0;

  if (isTargetingSelf) {
    target = self.eventBusEl_;

    // Deal with cases where we got 3 arguments, but we are still listening to
    // the evented object itself.
    if (args.length >= 3) {
      args.shift();
    }

    type = args[0];
    listener = args[1];
  } else {
    target = args[0];
    type = args[1];
    listener = args[2];
  }

  validateTarget(target);
  validateEventType(type);
  validateListener(listener);

  listener = bind(self, listener);

  return { isTargetingSelf: isTargetingSelf, target: target, type: type, listener: listener };
};

/**
 * Adds the listener to the event type(s) on the target, normalizing for
 * the type of target.
 *
 * @private
 * @param  {Element|Object} target
 *         A DOM node or evented object.
 *
 * @param  {string} method
 *         The event binding method to use ("on" or "one").
 *
 * @param  {string|Array} type
 *         One or more event type(s).
 *
 * @param  {Function} listener
 *         A listener function.
 */
var listen = function listen(target, method, type, listener) {
  validateTarget(target);

  if (target.nodeName) {
    Events[method](target, type, listener);
  } else {
    target[method](type, listener);
  }
};

/**
 * Contains methods that provide event capabilites to an object which is passed
 * to {@link module:evented|evented}.
 *
 * @mixin EventedMixin
 */
var EventedMixin = {

  /**
   * Add a listener to an event (or events) on this object or another evented
   * object.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  on: function on$$1() {
    var _this = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _normalizeListenArgs = normalizeListenArgs(this, args),
        isTargetingSelf = _normalizeListenArgs.isTargetingSelf,
        target = _normalizeListenArgs.target,
        type = _normalizeListenArgs.type,
        listener = _normalizeListenArgs.listener;

    listen(target, 'on', type, listener);

    // If this object is listening to another evented object.
    if (!isTargetingSelf) {

      // If this object is disposed, remove the listener.
      var removeListenerOnDispose = function removeListenerOnDispose() {
        return _this.off(target, type, listener);
      };

      // Use the same function ID as the listener so we can remove it later it
      // using the ID of the original listener.
      removeListenerOnDispose.guid = listener.guid;

      // Add a listener to the target's dispose event as well. This ensures
      // that if the target is disposed BEFORE this object, we remove the
      // removal listener that was just added. Otherwise, we create a memory leak.
      var removeRemoverOnTargetDispose = function removeRemoverOnTargetDispose() {
        return _this.off('dispose', removeListenerOnDispose);
      };

      // Use the same function ID as the listener so we can remove it later
      // it using the ID of the original listener.
      removeRemoverOnTargetDispose.guid = listener.guid;

      listen(this, 'on', 'dispose', removeListenerOnDispose);
      listen(target, 'on', 'dispose', removeRemoverOnTargetDispose);
    }
  },


  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will only be called once and then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  one: function one$$1() {
    var _this2 = this;

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var _normalizeListenArgs2 = normalizeListenArgs(this, args),
        isTargetingSelf = _normalizeListenArgs2.isTargetingSelf,
        target = _normalizeListenArgs2.target,
        type = _normalizeListenArgs2.type,
        listener = _normalizeListenArgs2.listener;

    // Targeting this evented object.


    if (isTargetingSelf) {
      listen(target, 'one', type, listener);

      // Targeting another evented object.
    } else {
      var wrapper = function wrapper() {
        for (var _len3 = arguments.length, largs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          largs[_key3] = arguments[_key3];
        }

        _this2.off(target, type, wrapper);
        listener.apply(null, largs);
      };

      // Use the same function ID as the listener so we can remove it later
      // it using the ID of the original listener.
      wrapper.guid = listener.guid;
      listen(target, 'one', type, wrapper);
    }
  },


  /**
   * Removes listener(s) from event(s) on an evented object.
   *
   * @param  {string|Array|Element|Object} [targetOrType]
   *         If this is a string or array, it represents the event type(s).
   *
   *         Another evented object can be passed here instead, in which case
   *         ALL 3 arguments are _required_.
   *
   * @param  {string|Array|Function} [typeOrListener]
   *         If the first argument was a string or array, this may be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function; otherwise, _all_ listeners bound to the
   *         event type(s) will be removed.
   */
  off: function off$$1(targetOrType, typeOrListener, listener) {

    // Targeting this evented object.
    if (!targetOrType || isValidEventType(targetOrType)) {
      off(this.eventBusEl_, targetOrType, typeOrListener);

      // Targeting another evented object.
    } else {
      var target = targetOrType;
      var type = typeOrListener;

      // Fail fast and in a meaningful way!
      validateTarget(target);
      validateEventType(type);
      validateListener(listener);

      // Ensure there's at least a guid, even if the function hasn't been used
      listener = bind(this, listener);

      // Remove the dispose listener on this evented object, which was given
      // the same guid as the event listener in on().
      this.off('dispose', listener);

      if (target.nodeName) {
        off(target, type, listener);
        off(target, 'dispose', listener);
      } else if (isEvented(target)) {
        target.off(type, listener);
        target.off('dispose', listener);
      }
    }
  },


  /**
   * Fire an event on this evented object, causing its listeners to be called.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash]
   *          An additional object to pass along to listeners.
   *
   * @returns {boolean}
   *          Whether or not the default behavior was prevented.
   */
  trigger: function trigger$$1(event, hash) {
    return trigger(this.eventBusEl_, event, hash);
  }
};

/**
 * Applies {@link module:evented~EventedMixin|EventedMixin} to a target object.
 *
 * @param  {Object} target
 *         The object to which to add event methods.
 *
 * @param  {Object} [options={}]
 *         Options for customizing the mixin behavior.
 *
 * @param  {String} [options.eventBusKey]
 *         By default, adds a `eventBusEl_` DOM element to the target object,
 *         which is used as an event bus. If the target object already has a
 *         DOM element that should be used, pass its key here.
 *
 * @return {Object}
 *         The target object.
 */
function evented(target) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var eventBusKey = options.eventBusKey;

  // Set or create the eventBusEl_.

  if (eventBusKey) {
    if (!target[eventBusKey].nodeName) {
      throw new Error('The eventBusKey "' + eventBusKey + '" does not refer to an element.');
    }
    target.eventBusEl_ = target[eventBusKey];
  } else {
    target.eventBusEl_ = createEl('span', { className: 'vjs-event-bus' });
  }

  assign(target, EventedMixin);

  // When any evented object is disposed, it removes all its listeners.
  target.on('dispose', function () {
    return target.off();
  });

  return target;
}

/**
 * @file mixins/stateful.js
 * @module stateful
 */
/**
 * Contains methods that provide statefulness to an object which is passed
 * to {@link module:stateful}.
 *
 * @mixin StatefulMixin
 */
var StatefulMixin = {

  /**
   * A hash containing arbitrary keys and values representing the state of
   * the object.
   *
   * @type {Object}
   */
  state: {},

  /**
   * Set the state of an object by mutating its
   * {@link module:stateful~StatefulMixin.state|state} object in place.
   *
   * @fires   module:stateful~StatefulMixin#statechanged
   * @param   {Object|Function} stateUpdates
   *          A new set of properties to shallow-merge into the plugin state.
   *          Can be a plain object or a function returning a plain object.
   *
   * @returns {Object|undefined}
   *          An object containing changes that occurred. If no changes
   *          occurred, returns `undefined`.
   */
  setState: function setState(stateUpdates) {
    var _this = this;

    // Support providing the `stateUpdates` state as a function.
    if (typeof stateUpdates === 'function') {
      stateUpdates = stateUpdates();
    }

    var changes = void 0;

    each(stateUpdates, function (value, key) {

      // Record the change if the value is different from what's in the
      // current state.
      if (_this.state[key] !== value) {
        changes = changes || {};
        changes[key] = {
          from: _this.state[key],
          to: value
        };
      }

      _this.state[key] = value;
    });

    // Only trigger "statechange" if there were changes AND we have a trigger
    // function. This allows us to not require that the target object be an
    // evented object.
    if (changes && isEvented(this)) {

      /**
       * An event triggered on an object that is both
       * {@link module:stateful|stateful} and {@link module:evented|evented}
       * indicating that its state has changed.
       *
       * @event    module:stateful~StatefulMixin#statechanged
       * @type     {Object}
       * @property {Object} changes
       *           A hash containing the properties that were changed and
       *           the values they were changed `from` and `to`.
       */
      this.trigger({
        changes: changes,
        type: 'statechanged'
      });
    }

    return changes;
  }
};

/**
 * Applies {@link module:stateful~StatefulMixin|StatefulMixin} to a target
 * object.
 *
 * If the target object is {@link module:evented|evented} and has a
 * `handleStateChanged` method, that method will be automatically bound to the
 * `statechanged` event on itself.
 *
 * @param   {Object} target
 *          The object to be made stateful.
 *
 * @param   {Object} [defaultState]
 *          A default set of properties to populate the newly-stateful object's
 *          `state` property.
 *
 * @returns {Object}
 *          Returns the `target`.
 */
function stateful(target, defaultState) {
  assign(target, StatefulMixin);

  // This happens after the mixing-in because we need to replace the `state`
  // added in that step.
  target.state = assign({}, target.state, defaultState);

  // Auto-bind the `handleStateChanged` method of the target object if it exists.
  if (typeof target.handleStateChanged === 'function' && isEvented(target)) {
    target.on('statechanged', target.handleStateChanged);
  }

  return target;
}

/**
 * @file to-title-case.js
 * @module to-title-case
 */

/**
 * Uppercase the first letter of a string.
 *
 * @param {string} string
 *        String to be uppercased
 *
 * @return {string}
 *         The string with an uppercased first letter
 */
function toTitleCase(string) {
  if (typeof string !== 'string') {
    return string;
  }

  return string.charAt(0).toUpperCase() + string.slice(1);
}

/**
 * Compares the TitleCase versions of the two strings for equality.
 *
 * @param {string} str1
 *        The first string to compare
 *
 * @param {string} str2
 *        The second string to compare
 *
 * @return {boolean}
 *         Whether the TitleCase versions of the strings are equal
 */
function titleCaseEquals(str1, str2) {
  return toTitleCase(str1) === toTitleCase(str2);
}

/**
 * @file merge-options.js
 * @module merge-options
 */
/**
 * Deep-merge one or more options objects, recursively merging **only** plain
 * object properties.
 *
 * @param   {Object[]} sources
 *          One or more objects to merge into a new object.
 *
 * @returns {Object}
 *          A new object that is the merged result of all sources.
 */
function mergeOptions() {
  var result = {};

  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    each(source, function (value, key) {
      if (!isPlain(value)) {
        result[key] = value;
        return;
      }

      if (!isPlain(result[key])) {
        result[key] = {};
      }

      result[key] = mergeOptions(result[key], value);
    });
  });

  return result;
}

/**
 * Player Component - Base class for all UI objects
 *
 * @file component.js
 */
/**
 * Base class for all UI Components.
 * Components are UI objects which represent both a javascript object and an element
 * in the DOM. They can be children of other components, and can have
 * children themselves.
 *
 * Components can also use methods from {@link EventTarget}
 */

var Component = function () {

  /**
   * A callback that is called when a component is ready. Does not have any
   * paramters and any callback value will be ignored.
   *
   * @callback Component~ReadyCallback
   * @this Component
   */

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Object[]} [options.children]
   *        An array of children objects to intialize this component with. Children objects have
   *        a name property that will be used if more than one component of the same type needs to be
   *        added.
   *
   * @param {Component~ReadyCallback} [ready]
   *        Function that gets called when the `Component` is ready.
   */
  function Component(player, options, ready) {
    classCallCheck(this, Component);


    // The component might be the player itself and we can't pass `this` to super
    if (!player && this.play) {
      this.player_ = player = this; // eslint-disable-line
    } else {
      this.player_ = player;
    }

    // Make a copy of prototype.options_ to protect against overriding defaults
    this.options_ = mergeOptions({}, this.options_);

    // Updated options with supplied options
    options = this.options_ = mergeOptions(this.options_, options);

    // Get ID from options or options element if one is supplied
    this.id_ = options.id || options.el && options.el.id;

    // If there was no ID from the options, generate one
    if (!this.id_) {
      // Don't require the player ID function in the case of mock players
      var id = player && player.id && player.id() || 'no_player';

      this.id_ = id + '_component_' + newGUID();
    }

    this.name_ = options.name || null;

    // Create element if one wasn't provided in options
    if (options.el) {
      this.el_ = options.el;
    } else if (options.createEl !== false) {
      this.el_ = this.createEl();
    }

    // Make this an evented object and use `el_`, if available, as its event bus
    evented(this, { eventBusKey: this.el_ ? 'el_' : null });
    stateful(this, this.constructor.defaultState);

    this.children_ = [];
    this.childIndex_ = {};
    this.childNameIndex_ = {};

    // Add any child components in options
    if (options.initChildren !== false) {
      this.initChildren();
    }

    this.ready(ready);
    // Don't want to trigger ready here or it will before init is actually
    // finished for all children that run this constructor

    if (options.reportTouchActivity !== false) {
      this.enableTouchActivity();
    }
  }

  /**
   * Dispose of the `Component` and all child components.
   *
   * @fires Component#dispose
   */


  Component.prototype.dispose = function dispose() {

    /**
     * Triggered when a `Component` is disposed.
     *
     * @event Component#dispose
     * @type {EventTarget~Event}
     *
     * @property {boolean} [bubbles=false]
     *           set to false so that the close event does not
     *           bubble up
     */
    this.trigger({ type: 'dispose', bubbles: false });

    // Dispose all children.
    if (this.children_) {
      for (var i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i].dispose) {
          this.children_[i].dispose();
        }
      }
    }

    // Delete child references
    this.children_ = null;
    this.childIndex_ = null;
    this.childNameIndex_ = null;

    if (this.el_) {
      // Remove element from DOM
      if (this.el_.parentNode) {
        this.el_.parentNode.removeChild(this.el_);
      }

      removeData(this.el_);
      this.el_ = null;
    }
  };

  /**
   * Return the {@link Player} that the `Component` has attached to.
   *
   * @return {Player}
   *         The player that this `Component` has attached to.
   */


  Component.prototype.player = function player() {
    return this.player_;
  };

  /**
   * Deep merge of options objects with new options.
   * > Note: When both `obj` and `options` contain properties whose values are objects.
   *         The two properties get merged using {@link module:mergeOptions}
   *
   * @param {Object} obj
   *        The object that contains new options.
   *
   * @return {Object}
   *         A new object of `this.options_` and `obj` merged together.
   *
   * @deprecated since version 5
   */


  Component.prototype.options = function options(obj) {
    log$1.warn('this.options() has been deprecated and will be moved to the constructor in 6.0');

    if (!obj) {
      return this.options_;
    }

    this.options_ = mergeOptions(this.options_, obj);
    return this.options_;
  };

  /**
   * Get the `Component`s DOM element
   *
   * @return {Element}
   *         The DOM element for this `Component`.
   */


  Component.prototype.el = function el() {
    return this.el_;
  };

  /**
   * Create the `Component`s DOM element.
   *
   * @param {string} [tagName]
   *        Element's DOM node type. e.g. 'div'
   *
   * @param {Object} [properties]
   *        An object of properties that should be set.
   *
   * @param {Object} [attributes]
   *        An object of attributes that should be set.
   *
   * @return {Element}
   *         The element that gets created.
   */


  Component.prototype.createEl = function createEl$$1(tagName, properties, attributes) {
    return createEl(tagName, properties, attributes);
  };

  /**
   * Localize a string given the string in english.
   *
   * If tokens are provided, it'll try and run a simple token replacement on the provided string.
   * The tokens it loooks for look like `{1}` with the index being 1-indexed into the tokens array.
   *
   * If a `defaultValue` is provided, it'll use that over `string`,
   * if a value isn't found in provided language files.
   * This is useful if you want to have a descriptive key for token replacement
   * but have a succinct localized string and not require `en.json` to be included.
   *
   * Currently, it is used for the progress bar timing.
   * ```js
   * {
   *   "progress bar timing: currentTime={1} duration={2}": "{1} of {2}"
   * }
   * ```
   * It is then used like so:
   * ```js
   * this.localize('progress bar timing: currentTime={1} duration{2}',
   *               [this.player_.currentTime(), this.player_.duration()],
   *               '{1} of {2}');
   * ```
   *
   * Which outputs something like: `01:23 of 24:56`.
   *
   *
   * @param {string} string
   *        The string to localize and the key to lookup in the language files.
   * @param {string[]} [tokens]
   *        If the current item has token replacements, provide the tokens here.
   * @param {string} [defaultValue]
   *        Defaults to `string`. Can be a default value to use for token replacement
   *        if the lookup key is needed to be separate.
   *
   * @return {string}
   *         The localized string or if no localization exists the english string.
   */


  Component.prototype.localize = function localize(string, tokens) {
    var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : string;

    var code = this.player_.language && this.player_.language();
    var languages = this.player_.languages && this.player_.languages();
    var language = languages && languages[code];
    var primaryCode = code && code.split('-')[0];
    var primaryLang = languages && languages[primaryCode];

    var localizedString = defaultValue;

    if (language && language[string]) {
      localizedString = language[string];
    } else if (primaryLang && primaryLang[string]) {
      localizedString = primaryLang[string];
    }

    if (tokens) {
      localizedString = localizedString.replace(/\{(\d+)\}/g, function (match, index) {
        var value = tokens[index - 1];
        var ret = value;

        if (typeof value === 'undefined') {
          ret = match;
        }

        return ret;
      });
    }

    return localizedString;
  };

  /**
   * Return the `Component`s DOM element. This is where children get inserted.
   * This will usually be the the same as the element returned in {@link Component#el}.
   *
   * @return {Element}
   *         The content element for this `Component`.
   */


  Component.prototype.contentEl = function contentEl() {
    return this.contentEl_ || this.el_;
  };

  /**
   * Get this `Component`s ID
   *
   * @return {string}
   *         The id of this `Component`
   */


  Component.prototype.id = function id() {
    return this.id_;
  };

  /**
   * Get the `Component`s name. The name gets used to reference the `Component`
   * and is set during registration.
   *
   * @return {string}
   *         The name of this `Component`.
   */


  Component.prototype.name = function name() {
    return this.name_;
  };

  /**
   * Get an array of all child components
   *
   * @return {Array}
   *         The children
   */


  Component.prototype.children = function children() {
    return this.children_;
  };

  /**
   * Returns the child `Component` with the given `id`.
   *
   * @param {string} id
   *        The id of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The child `Component` with the given `id` or undefined.
   */


  Component.prototype.getChildById = function getChildById(id) {
    return this.childIndex_[id];
  };

  /**
   * Returns the child `Component` with the given `name`.
   *
   * @param {string} name
   *        The name of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The child `Component` with the given `name` or undefined.
   */


  Component.prototype.getChild = function getChild(name) {
    if (!name) {
      return;
    }

    name = toTitleCase(name);

    return this.childNameIndex_[name];
  };

  /**
   * Add a child `Component` inside the current `Component`.
   *
   *
   * @param {string|Component} child
   *        The name or instance of a child to add.
   *
   * @param {Object} [options={}]
   *        The key/value store of options that will get passed to children of
   *        the child.
   *
   * @param {number} [index=this.children_.length]
   *        The index to attempt to add a child into.
   *
   * @return {Component}
   *         The `Component` that gets added as a child. When using a string the
   *         `Component` will get created by this process.
   */


  Component.prototype.addChild = function addChild(child) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.children_.length;

    var component = void 0;
    var componentName = void 0;

    // If child is a string, create component with options
    if (typeof child === 'string') {
      componentName = toTitleCase(child);

      var componentClassName = options.componentClass || componentName;

      // Set name through options
      options.name = componentName;

      // Create a new object & element for this controls set
      // If there's no .player_, this is a player
      var ComponentClass = Component.getComponent(componentClassName);

      if (!ComponentClass) {
        throw new Error('Component ' + componentClassName + ' does not exist');
      }

      // data stored directly on the videojs object may be
      // misidentified as a component to retain
      // backwards-compatibility with 4.x. check to make sure the
      // component class can be instantiated.
      if (typeof ComponentClass !== 'function') {
        return null;
      }

      component = new ComponentClass(this.player_ || this, options);

      // child is a component instance
    } else {
      component = child;
    }

    this.children_.splice(index, 0, component);

    if (typeof component.id === 'function') {
      this.childIndex_[component.id()] = component;
    }

    // If a name wasn't used to create the component, check if we can use the
    // name function of the component
    componentName = componentName || component.name && toTitleCase(component.name());

    if (componentName) {
      this.childNameIndex_[componentName] = component;
    }

    // Add the UI object's element to the container div (box)
    // Having an element is not required
    if (typeof component.el === 'function' && component.el()) {
      var childNodes = this.contentEl().children;
      var refNode = childNodes[index] || null;

      this.contentEl().insertBefore(component.el(), refNode);
    }

    // Return so it can stored on parent object if desired.
    return component;
  };

  /**
   * Remove a child `Component` from this `Component`s list of children. Also removes
   * the child `Component`s element from this `Component`s element.
   *
   * @param {Component} component
   *        The child `Component` to remove.
   */


  Component.prototype.removeChild = function removeChild(component) {
    if (typeof component === 'string') {
      component = this.getChild(component);
    }

    if (!component || !this.children_) {
      return;
    }

    var childFound = false;

    for (var i = this.children_.length - 1; i >= 0; i--) {
      if (this.children_[i] === component) {
        childFound = true;
        this.children_.splice(i, 1);
        break;
      }
    }

    if (!childFound) {
      return;
    }

    this.childIndex_[component.id()] = null;
    this.childNameIndex_[component.name()] = null;

    var compEl = component.el();

    if (compEl && compEl.parentNode === this.contentEl()) {
      this.contentEl().removeChild(component.el());
    }
  };

  /**
   * Add and initialize default child `Component`s based upon options.
   */


  Component.prototype.initChildren = function initChildren() {
    var _this = this;

    var children = this.options_.children;

    if (children) {
      // `this` is `parent`
      var parentOptions = this.options_;

      var handleAdd = function handleAdd(child) {
        var name = child.name;
        var opts = child.opts;

        // Allow options for children to be set at the parent options
        // e.g. videojs(id, { controlBar: false });
        // instead of videojs(id, { children: { controlBar: false });
        if (parentOptions[name] !== undefined) {
          opts = parentOptions[name];
        }

        // Allow for disabling default components
        // e.g. options['children']['posterImage'] = false
        if (opts === false) {
          return;
        }

        // Allow options to be passed as a simple boolean if no configuration
        // is necessary.
        if (opts === true) {
          opts = {};
        }

        // We also want to pass the original player options
        // to each component as well so they don't need to
        // reach back into the player for options later.
        opts.playerOptions = _this.options_.playerOptions;

        // Create and add the child component.
        // Add a direct reference to the child by name on the parent instance.
        // If two of the same component are used, different names should be supplied
        // for each
        var newChild = _this.addChild(name, opts);

        if (newChild) {
          _this[name] = newChild;
        }
      };

      // Allow for an array of children details to passed in the options
      var workingChildren = void 0;
      var Tech = Component.getComponent('Tech');

      if (Array.isArray(children)) {
        workingChildren = children;
      } else {
        workingChildren = Object.keys(children);
      }

      workingChildren
      // children that are in this.options_ but also in workingChildren  would
      // give us extra children we do not want. So, we want to filter them out.
      .concat(Object.keys(this.options_).filter(function (child) {
        return !workingChildren.some(function (wchild) {
          if (typeof wchild === 'string') {
            return child === wchild;
          }
          return child === wchild.name;
        });
      })).map(function (child) {
        var name = void 0;
        var opts = void 0;

        if (typeof child === 'string') {
          name = child;
          opts = children[name] || _this.options_[name] || {};
        } else {
          name = child.name;
          opts = child;
        }

        return { name: name, opts: opts };
      }).filter(function (child) {
        // we have to make sure that child.name isn't in the techOrder since
        // techs are registerd as Components but can't aren't compatible
        // See https://github.com/videojs/video.js/issues/2772
        var c = Component.getComponent(child.opts.componentClass || toTitleCase(child.name));

        return c && !Tech.isTech(c);
      }).forEach(handleAdd);
    }
  };

  /**
   * Builds the default DOM class name. Should be overriden by sub-components.
   *
   * @return {string}
   *         The DOM class name for this object.
   *
   * @abstract
   */


  Component.prototype.buildCSSClass = function buildCSSClass() {
    // Child classes can include a function that does:
    // return 'CLASS NAME' + this._super();
    return '';
  };

  /**
   * Bind a listener to the component's ready state.
   * Different from event listeners in that if the ready event has already happened
   * it will trigger the function immediately.
   *
   * @return {Component}
   *         Returns itself; method can be chained.
   */


  Component.prototype.ready = function ready(fn) {
    var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (fn) {
      if (this.isReady_) {
        if (sync) {
          fn.call(this);
        } else {
          // Call the function asynchronously by default for consistency
          this.setTimeout(fn, 1);
        }
      } else {
        this.readyQueue_ = this.readyQueue_ || [];
        this.readyQueue_.push(fn);
      }
    }
  };

  /**
   * Trigger all the ready listeners for this `Component`.
   *
   * @fires Component#ready
   */


  Component.prototype.triggerReady = function triggerReady() {
    this.isReady_ = true;

    // Ensure ready is triggerd asynchronously
    this.setTimeout(function () {
      var readyQueue = this.readyQueue_;

      // Reset Ready Queue
      this.readyQueue_ = [];

      if (readyQueue && readyQueue.length > 0) {
        readyQueue.forEach(function (fn) {
          fn.call(this);
        }, this);
      }

      // Allow for using event listeners also
      /**
       * Triggered when a `Component` is ready.
       *
       * @event Component#ready
       * @type {EventTarget~Event}
       */
      this.trigger('ready');
    }, 1);
  };

  /**
   * Find a single DOM element matching a `selector`. This can be within the `Component`s
   * `contentEl()` or another custom context.
   *
   * @param {string} selector
   *        A valid CSS selector, which will be passed to `querySelector`.
   *
   * @param {Element|string} [context=this.contentEl()]
   *        A DOM element within which to query. Can also be a selector string in
   *        which case the first matching element will get used as context. If
   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
   *        nothing it falls back to `document`.
   *
   * @return {Element|null}
   *         the dom element that was found, or null
   *
   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
   */


  Component.prototype.$ = function $$$1(selector, context) {
    return $(selector, context || this.contentEl());
  };

  /**
   * Finds all DOM element matching a `selector`. This can be within the `Component`s
   * `contentEl()` or another custom context.
   *
   * @param {string} selector
   *        A valid CSS selector, which will be passed to `querySelectorAll`.
   *
   * @param {Element|string} [context=this.contentEl()]
   *        A DOM element within which to query. Can also be a selector string in
   *        which case the first matching element will get used as context. If
   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
   *        nothing it falls back to `document`.
   *
   * @return {NodeList}
   *         a list of dom elements that were found
   *
   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
   */


  Component.prototype.$$ = function $$$$1(selector, context) {
    return $$(selector, context || this.contentEl());
  };

  /**
   * Check if a component's element has a CSS class name.
   *
   * @param {string} classToCheck
   *        CSS class name to check.
   *
   * @return {boolean}
   *         - True if the `Component` has the class.
   *         - False if the `Component` does not have the class`
   */


  Component.prototype.hasClass = function hasClass$$1(classToCheck) {
    return hasClass(this.el_, classToCheck);
  };

  /**
   * Add a CSS class name to the `Component`s element.
   *
   * @param {string} classToAdd
   *        CSS class name to add
   */


  Component.prototype.addClass = function addClass$$1(classToAdd) {
    addClass(this.el_, classToAdd);
  };

  /**
   * Remove a CSS class name from the `Component`s element.
   *
   * @param {string} classToRemove
   *        CSS class name to remove
   */


  Component.prototype.removeClass = function removeClass$$1(classToRemove) {
    removeClass(this.el_, classToRemove);
  };

  /**
   * Add or remove a CSS class name from the component's element.
   * - `classToToggle` gets added when {@link Component#hasClass} would return false.
   * - `classToToggle` gets removed when {@link Component#hasClass} would return true.
   *
   * @param  {string} classToToggle
   *         The class to add or remove based on (@link Component#hasClass}
   *
   * @param  {boolean|Dom~predicate} [predicate]
   *         An {@link Dom~predicate} function or a boolean
   */


  Component.prototype.toggleClass = function toggleClass$$1(classToToggle, predicate) {
    toggleClass(this.el_, classToToggle, predicate);
  };

  /**
   * Show the `Component`s element if it is hidden by removing the
   * 'vjs-hidden' class name from it.
   */


  Component.prototype.show = function show() {
    this.removeClass('vjs-hidden');
  };

  /**
   * Hide the `Component`s element if it is currently showing by adding the
   * 'vjs-hidden` class name to it.
   */


  Component.prototype.hide = function hide() {
    this.addClass('vjs-hidden');
  };

  /**
   * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'
   * class name to it. Used during fadeIn/fadeOut.
   *
   * @private
   */


  Component.prototype.lockShowing = function lockShowing() {
    this.addClass('vjs-lock-showing');
  };

  /**
   * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'
   * class name from it. Used during fadeIn/fadeOut.
   *
   * @private
   */


  Component.prototype.unlockShowing = function unlockShowing() {
    this.removeClass('vjs-lock-showing');
  };

  /**
   * Get the value of an attribute on the `Component`s element.
   *
   * @param {string} attribute
   *        Name of the attribute to get the value from.
   *
   * @return {string|null}
   *         - The value of the attribute that was asked for.
   *         - Can be an empty string on some browsers if the attribute does not exist
   *           or has no value
   *         - Most browsers will return null if the attibute does not exist or has
   *           no value.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}
   */


  Component.prototype.getAttribute = function getAttribute$$1(attribute) {
    return getAttribute(this.el_, attribute);
  };

  /**
   * Set the value of an attribute on the `Component`'s element
   *
   * @param {string} attribute
   *        Name of the attribute to set.
   *
   * @param {string} value
   *        Value to set the attribute to.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}
   */


  Component.prototype.setAttribute = function setAttribute$$1(attribute, value) {
    setAttribute(this.el_, attribute, value);
  };

  /**
   * Remove an attribute from the `Component`s element.
   *
   * @param {string} attribute
   *        Name of the attribute to remove.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}
   */


  Component.prototype.removeAttribute = function removeAttribute$$1(attribute) {
    removeAttribute(this.el_, attribute);
  };

  /**
   * Get or set the width of the component based upon the CSS styles.
   * See {@link Component#dimension} for more detailed information.
   *
   * @param {number|string} [num]
   *        The width that you want to set postfixed with '%', 'px' or nothing.
   *
   * @param {boolean} [skipListeners]
   *        Skip the componentresize event trigger
   *
   * @return {number|string}
   *         The width when getting, zero if there is no width. Can be a string
   *           postpixed with '%' or 'px'.
   */


  Component.prototype.width = function width(num, skipListeners) {
    return this.dimension('width', num, skipListeners);
  };

  /**
   * Get or set the height of the component based upon the CSS styles.
   * See {@link Component#dimension} for more detailed information.
   *
   * @param {number|string} [num]
   *        The height that you want to set postfixed with '%', 'px' or nothing.
   *
   * @param {boolean} [skipListeners]
   *        Skip the componentresize event trigger
   *
   * @return {number|string}
   *         The width when getting, zero if there is no width. Can be a string
   *         postpixed with '%' or 'px'.
   */


  Component.prototype.height = function height(num, skipListeners) {
    return this.dimension('height', num, skipListeners);
  };

  /**
   * Set both the width and height of the `Component` element at the same time.
   *
   * @param  {number|string} width
   *         Width to set the `Component`s element to.
   *
   * @param  {number|string} height
   *         Height to set the `Component`s element to.
   */


  Component.prototype.dimensions = function dimensions(width, height) {
    // Skip componentresize listeners on width for optimization
    this.width(width, true);
    this.height(height);
  };

  /**
   * Get or set width or height of the `Component` element. This is the shared code
   * for the {@link Component#width} and {@link Component#height}.
   *
   * Things to know:
   * - If the width or height in an number this will return the number postfixed with 'px'.
   * - If the width/height is a percent this will return the percent postfixed with '%'
   * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function
   *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.
   *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}
   *   for more information
   * - If you want the computed style of the component, use {@link Component#currentWidth}
   *   and {@link {Component#currentHeight}
   *
   * @fires Component#componentresize
   *
   * @param {string} widthOrHeight
   8        'width' or 'height'
   *
   * @param  {number|string} [num]
   8         New dimension
   *
   * @param  {boolean} [skipListeners]
   *         Skip componentresize event trigger
   *
   * @return {number}
   *         The dimension when getting or 0 if unset
   */


  Component.prototype.dimension = function dimension(widthOrHeight, num, skipListeners) {
    if (num !== undefined) {
      // Set to zero if null or literally NaN (NaN !== NaN)
      if (num === null || num !== num) {
        num = 0;
      }

      // Check if using css width/height (% or px) and adjust
      if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {
        this.el_.style[widthOrHeight] = num;
      } else if (num === 'auto') {
        this.el_.style[widthOrHeight] = '';
      } else {
        this.el_.style[widthOrHeight] = num + 'px';
      }

      // skipListeners allows us to avoid triggering the resize event when setting both width and height
      if (!skipListeners) {
        /**
         * Triggered when a component is resized.
         *
         * @event Component#componentresize
         * @type {EventTarget~Event}
         */
        this.trigger('componentresize');
      }

      return;
    }

    // Not setting a value, so getting it
    // Make sure element exists
    if (!this.el_) {
      return 0;
    }

    // Get dimension value from style
    var val = this.el_.style[widthOrHeight];
    var pxIndex = val.indexOf('px');

    if (pxIndex !== -1) {
      // Return the pixel value with no 'px'
      return parseInt(val.slice(0, pxIndex), 10);
    }

    // No px so using % or no style was set, so falling back to offsetWidth/height
    // If component has display:none, offset will return 0
    // TODO: handle display:none and no dimension style using px
    return parseInt(this.el_['offset' + toTitleCase(widthOrHeight)], 10);
  };

  /**
   * Get the width or the height of the `Component` elements computed style. Uses
   * `window.getComputedStyle`.
   *
   * @param {string} widthOrHeight
   *        A string containing 'width' or 'height'. Whichever one you want to get.
   *
   * @return {number}
   *         The dimension that gets asked for or 0 if nothing was set
   *         for that dimension.
   */


  Component.prototype.currentDimension = function currentDimension(widthOrHeight) {
    var computedWidthOrHeight = 0;

    if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {
      throw new Error('currentDimension only accepts width or height value');
    }

    if (typeof window.getComputedStyle === 'function') {
      var computedStyle = window.getComputedStyle(this.el_);

      computedWidthOrHeight = computedStyle.getPropertyValue(widthOrHeight) || computedStyle[widthOrHeight];
    }

    // remove 'px' from variable and parse as integer
    computedWidthOrHeight = parseFloat(computedWidthOrHeight);

    // if the computed value is still 0, it's possible that the browser is lying
    // and we want to check the offset values.
    // This code also runs on IE8 and wherever getComputedStyle doesn't exist.
    if (computedWidthOrHeight === 0) {
      var rule = 'offset' + toTitleCase(widthOrHeight);

      computedWidthOrHeight = this.el_[rule];
    }

    return computedWidthOrHeight;
  };

  /**
   * An object that contains width and height values of the `Component`s
   * computed style. Uses `window.getComputedStyle`.
   *
   * @typedef {Object} Component~DimensionObject
   *
   * @property {number} width
   *           The width of the `Component`s computed style.
   *
   * @property {number} height
   *           The height of the `Component`s computed style.
   */

  /**
   * Get an object that contains width and height values of the `Component`s
   * computed style.
   *
   * @return {Component~DimensionObject}
   *         The dimensions of the components element
   */


  Component.prototype.currentDimensions = function currentDimensions() {
    return {
      width: this.currentDimension('width'),
      height: this.currentDimension('height')
    };
  };

  /**
   * Get the width of the `Component`s computed style. Uses `window.getComputedStyle`.
   *
   * @return {number} width
   *           The width of the `Component`s computed style.
   */


  Component.prototype.currentWidth = function currentWidth() {
    return this.currentDimension('width');
  };

  /**
   * Get the height of the `Component`s computed style. Uses `window.getComputedStyle`.
   *
   * @return {number} height
   *           The height of the `Component`s computed style.
   */


  Component.prototype.currentHeight = function currentHeight() {
    return this.currentDimension('height');
  };

  /**
   * Set the focus to this component
   */


  Component.prototype.focus = function focus() {
    this.el_.focus();
  };

  /**
   * Remove the focus from this component
   */


  Component.prototype.blur = function blur() {
    this.el_.blur();
  };

  /**
   * Emit a 'tap' events when touch event support gets detected. This gets used to
   * support toggling the controls through a tap on the video. They get enabled
   * because every sub-component would have extra overhead otherwise.
   *
   * @private
   * @fires Component#tap
   * @listens Component#touchstart
   * @listens Component#touchmove
   * @listens Component#touchleave
   * @listens Component#touchcancel
   * @listens Component#touchend
    */


  Component.prototype.emitTapEvents = function emitTapEvents() {
    // Track the start time so we can determine how long the touch lasted
    var touchStart = 0;
    var firstTouch = null;

    // Maximum movement allowed during a touch event to still be considered a tap
    // Other popular libs use anywhere from 2 (hammer.js) to 15,
    // so 10 seems like a nice, round number.
    var tapMovementThreshold = 10;

    // The maximum length a touch can be while still being considered a tap
    var touchTimeThreshold = 200;

    var couldBeTap = void 0;

    this.on('touchstart', function (event) {
      // If more than one finger, don't consider treating this as a click
      if (event.touches.length === 1) {
        // Copy pageX/pageY from the object
        firstTouch = {
          pageX: event.touches[0].pageX,
          pageY: event.touches[0].pageY
        };
        // Record start time so we can detect a tap vs. "touch and hold"
        touchStart = new Date().getTime();
        // Reset couldBeTap tracking
        couldBeTap = true;
      }
    });

    this.on('touchmove', function (event) {
      // If more than one finger, don't consider treating this as a click
      if (event.touches.length > 1) {
        couldBeTap = false;
      } else if (firstTouch) {
        // Some devices will throw touchmoves for all but the slightest of taps.
        // So, if we moved only a small distance, this could still be a tap
        var xdiff = event.touches[0].pageX - firstTouch.pageX;
        var ydiff = event.touches[0].pageY - firstTouch.pageY;
        var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);

        if (touchDistance > tapMovementThreshold) {
          couldBeTap = false;
        }
      }
    });

    var noTap = function noTap() {
      couldBeTap = false;
    };

    // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s
    this.on('touchleave', noTap);
    this.on('touchcancel', noTap);

    // When the touch ends, measure how long it took and trigger the appropriate
    // event
    this.on('touchend', function (event) {
      firstTouch = null;
      // Proceed only if the touchmove/leave/cancel event didn't happen
      if (couldBeTap === true) {
        // Measure how long the touch lasted
        var touchTime = new Date().getTime() - touchStart;

        // Make sure the touch was less than the threshold to be considered a tap
        if (touchTime < touchTimeThreshold) {
          // Don't let browser turn this into a click
          event.preventDefault();
          /**
           * Triggered when a `Component` is tapped.
           *
           * @event Component#tap
           * @type {EventTarget~Event}
           */
          this.trigger('tap');
          // It may be good to copy the touchend event object and change the
          // type to tap, if the other event properties aren't exact after
          // Events.fixEvent runs (e.g. event.target)
        }
      }
    });
  };

  /**
   * This function reports user activity whenever touch events happen. This can get
   * turned off by any sub-components that wants touch events to act another way.
   *
   * Report user touch activity when touch events occur. User activity gets used to
   * determine when controls should show/hide. It is simple when it comes to mouse
   * events, because any mouse event should show the controls. So we capture mouse
   * events that bubble up to the player and report activity when that happens.
   * With touch events it isn't as easy as `touchstart` and `touchend` toggle player
   * controls. So touch events can't help us at the player level either.
   *
   * User activity gets checked asynchronously. So what could happen is a tap event
   * on the video turns the controls off. Then the `touchend` event bubbles up to
   * the player. Which, if it reported user activity, would turn the controls right
   * back on. We also don't want to completely block touch events from bubbling up.
   * Furthermore a `touchmove` event and anything other than a tap, should not turn
   * controls back on.
   *
   * @listens Component#touchstart
   * @listens Component#touchmove
   * @listens Component#touchend
   * @listens Component#touchcancel
   */


  Component.prototype.enableTouchActivity = function enableTouchActivity() {
    // Don't continue if the root player doesn't support reporting user activity
    if (!this.player() || !this.player().reportUserActivity) {
      return;
    }

    // listener for reporting that the user is active
    var report = bind(this.player(), this.player().reportUserActivity);

    var touchHolding = void 0;

    this.on('touchstart', function () {
      report();
      // For as long as the they are touching the device or have their mouse down,
      // we consider them active even if they're not moving their finger or mouse.
      // So we want to continue to update that they are active
      this.clearInterval(touchHolding);
      // report at the same interval as activityCheck
      touchHolding = this.setInterval(report, 250);
    });

    var touchEnd = function touchEnd(event) {
      report();
      // stop the interval that maintains activity if the touch is holding
      this.clearInterval(touchHolding);
    };

    this.on('touchmove', report);
    this.on('touchend', touchEnd);
    this.on('touchcancel', touchEnd);
  };

  /**
   * A callback that has no parameters and is bound into `Component`s context.
   *
   * @callback Component~GenericCallback
   * @this Component
   */

  /**
   * Creates a function that runs after an `x` millisecond timeout. This function is a
   * wrapper around `window.setTimeout`. There are a few reasons to use this one
   * instead though:
   * 1. It gets cleared via  {@link Component#clearTimeout} when
   *    {@link Component#dispose} gets called.
   * 2. The function callback will gets turned into a {@link Component~GenericCallback}
   *
   * > Note: You can use `window.clearTimeout` on the id returned by this function. This
   *         will cause its dispose listener not to get cleaned up! Please use
   *         {@link Component#clearTimeout} or {@link Component#dispose}.
   *
   * @param {Component~GenericCallback} fn
   *        The function that will be run after `timeout`.
   *
   * @param {number} timeout
   *        Timeout in milliseconds to delay before executing the specified function.
   *
   * @return {number}
   *         Returns a timeout ID that gets used to identify the timeout. It can also
   *         get used in {@link Component#clearTimeout} to clear the timeout that
   *         was set.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}
   */


  Component.prototype.setTimeout = function setTimeout(fn, timeout) {
    fn = bind(this, fn);

    var timeoutId = window.setTimeout(fn, timeout);
    var disposeFn = function disposeFn() {
      this.clearTimeout(timeoutId);
    };

    disposeFn.guid = 'vjs-timeout-' + timeoutId;

    this.on('dispose', disposeFn);

    return timeoutId;
  };

  /**
   * Clears a timeout that gets created via `window.setTimeout` or
   * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}
   * use this function instead of `window.clearTimout`. If you don't your dispose
   * listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} timeoutId
   *        The id of the timeout to clear. The return value of
   *        {@link Component#setTimeout} or `window.setTimeout`.
   *
   * @return {number}
   *         Returns the timeout id that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}
   */


  Component.prototype.clearTimeout = function clearTimeout(timeoutId) {
    window.clearTimeout(timeoutId);

    var disposeFn = function disposeFn() {};

    disposeFn.guid = 'vjs-timeout-' + timeoutId;

    this.off('dispose', disposeFn);

    return timeoutId;
  };

  /**
   * Creates a function that gets run every `x` milliseconds. This function is a wrapper
   * around `window.setInterval`. There are a few reasons to use this one instead though.
   * 1. It gets cleared via  {@link Component#clearInterval} when
   *    {@link Component#dispose} gets called.
   * 2. The function callback will be a {@link Component~GenericCallback}
   *
   * @param {Component~GenericCallback} fn
   *        The function to run every `x` seconds.
   *
   * @param {number} interval
   *        Execute the specified function every `x` milliseconds.
   *
   * @return {number}
   *         Returns an id that can be used to identify the interval. It can also be be used in
   *         {@link Component#clearInterval} to clear the interval.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}
   */


  Component.prototype.setInterval = function setInterval(fn, interval) {
    fn = bind(this, fn);

    var intervalId = window.setInterval(fn, interval);

    var disposeFn = function disposeFn() {
      this.clearInterval(intervalId);
    };

    disposeFn.guid = 'vjs-interval-' + intervalId;

    this.on('dispose', disposeFn);

    return intervalId;
  };

  /**
   * Clears an interval that gets created via `window.setInterval` or
   * {@link Component#setInterval}. If you set an inteval via {@link Component#setInterval}
   * use this function instead of `window.clearInterval`. If you don't your dispose
   * listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} intervalId
   *        The id of the interval to clear. The return value of
   *        {@link Component#setInterval} or `window.setInterval`.
   *
   * @return {number}
   *         Returns the interval id that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}
   */


  Component.prototype.clearInterval = function clearInterval(intervalId) {
    window.clearInterval(intervalId);

    var disposeFn = function disposeFn() {};

    disposeFn.guid = 'vjs-interval-' + intervalId;

    this.off('dispose', disposeFn);

    return intervalId;
  };

  /**
   * Queues up a callback to be passed to requestAnimationFrame (rAF), but
   * with a few extra bonuses:
   *
   * - Supports browsers that do not support rAF by falling back to
   *   {@link Component#setTimeout}.
   *
   * - The callback is turned into a {@link Component~GenericCallback} (i.e.
   *   bound to the component).
   *
   * - Automatic cancellation of the rAF callback is handled if the component
   *   is disposed before it is called.
   *
   * @param  {Component~GenericCallback} fn
   *         A function that will be bound to this component and executed just
   *         before the browser's next repaint.
   *
   * @return {number}
   *         Returns an rAF ID that gets used to identify the timeout. It can
   *         also be used in {@link Component#cancelAnimationFrame} to cancel
   *         the animation frame callback.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}
   */


  Component.prototype.requestAnimationFrame = function requestAnimationFrame(fn) {
    var _this2 = this;

    if (this.supportsRaf_) {
      fn = bind(this, fn);

      var id = window.requestAnimationFrame(fn);
      var disposeFn = function disposeFn() {
        return _this2.cancelAnimationFrame(id);
      };

      disposeFn.guid = 'vjs-raf-' + id;
      this.on('dispose', disposeFn);

      return id;
    }

    // Fall back to using a timer.
    return this.setTimeout(fn, 1000 / 60);
  };

  /**
   * Cancels a queued callback passed to {@link Component#requestAnimationFrame}
   * (rAF).
   *
   * If you queue an rAF callback via {@link Component#requestAnimationFrame},
   * use this function instead of `window.cancelAnimationFrame`. If you don't,
   * your dispose listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} id
   *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.
   *
   * @return {number}
   *         Returns the rAF ID that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}
   */


  Component.prototype.cancelAnimationFrame = function cancelAnimationFrame(id) {
    if (this.supportsRaf_) {
      window.cancelAnimationFrame(id);

      var disposeFn = function disposeFn() {};

      disposeFn.guid = 'vjs-raf-' + id;

      this.off('dispose', disposeFn);

      return id;
    }

    // Fall back to using a timer.
    return this.clearTimeout(id);
  };

  /**
   * Register a `Component` with `videojs` given the name and the component.
   *
   * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s
   *         should be registered using {@link Tech.registerTech} or
   *         {@link videojs:videojs.registerTech}.
   *
   * > NOTE: This function can also be seen on videojs as
   *         {@link videojs:videojs.registerComponent}.
   *
   * @param {string} name
   *        The name of the `Component` to register.
   *
   * @param {Component} ComponentToRegister
   *        The `Component` class to register.
   *
   * @return {Component}
   *         The `Component` that was registered.
   */


  Component.registerComponent = function registerComponent(name, ComponentToRegister) {
    if (typeof name !== 'string' || !name) {
      throw new Error('Illegal component name, "' + name + '"; must be a non-empty string.');
    }

    var Tech = Component.getComponent('Tech');

    // We need to make sure this check is only done if Tech has been registered.
    var isTech = Tech && Tech.isTech(ComponentToRegister);
    var isComp = Component === ComponentToRegister || Component.prototype.isPrototypeOf(ComponentToRegister.prototype);

    if (isTech || !isComp) {
      var reason = void 0;

      if (isTech) {
        reason = 'techs must be registered using Tech.registerTech()';
      } else {
        reason = 'must be a Component subclass';
      }

      throw new Error('Illegal component, "' + name + '"; ' + reason + '.');
    }

    name = toTitleCase(name);

    if (!Component.components_) {
      Component.components_ = {};
    }

    var Player = Component.getComponent('Player');

    if (name === 'Player' && Player && Player.players) {
      var players = Player.players;
      var playerNames = Object.keys(players);

      // If we have players that were disposed, then their name will still be
      // in Players.players. So, we must loop through and verify that the value
      // for each item is not null. This allows registration of the Player component
      // after all players have been disposed or before any were created.
      if (players && playerNames.length > 0 && playerNames.map(function (pname) {
        return players[pname];
      }).every(Boolean)) {
        throw new Error('Can not register Player component after player has been created.');
      }
    }

    Component.components_[name] = ComponentToRegister;

    return ComponentToRegister;
  };

  /**
   * Get a `Component` based on the name it was registered with.
   *
   * @param {string} name
   *        The Name of the component to get.
   *
   * @return {Component}
   *         The `Component` that got registered under the given name.
   *
   * @deprecated In `videojs` 6 this will not return `Component`s that were not
   *             registered using {@link Component.registerComponent}. Currently we
   *             check the global `videojs` object for a `Component` name and
   *             return that if it exists.
   */


  Component.getComponent = function getComponent(name) {
    if (!name) {
      return;
    }

    name = toTitleCase(name);

    if (Component.components_ && Component.components_[name]) {
      return Component.components_[name];
    }
  };

  return Component;
}();

/**
 * Whether or not this component supports `requestAnimationFrame`.
 *
 * This is exposed primarily for testing purposes.
 *
 * @private
 * @type {Boolean}
 */


Component.prototype.supportsRaf_ = typeof window.requestAnimationFrame === 'function' && typeof window.cancelAnimationFrame === 'function';

Component.registerComponent('Component', Component);

/**
 * @file time-ranges.js
 * @module time-ranges
 */

/**
 * Returns the time for the specified index at the start or end
 * of a TimeRange object.
 *
 * @function time-ranges:indexFunction
 *
 * @param {number} [index=0]
 *        The range number to return the time for.
 *
 * @return {number}
 *         The time that offset at the specified index.
 *
 * @depricated index must be set to a value, in the future this will throw an error.
 */

/**
 * An object that contains ranges of time for various reasons.
 *
 * @typedef {Object} TimeRange
 *
 * @property {number} length
 *           The number of time ranges represented by this Object
 *
 * @property {time-ranges:indexFunction} start
 *           Returns the time offset at which a specified time range begins.
 *
 * @property {time-ranges:indexFunction} end
 *           Returns the time offset at which a specified time range begins.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges
 */

/**
 * Check if any of the time ranges are over the maximum index.
 *
 * @param {string} fnName
 *        The function name to use for logging
 *
 * @param {number} index
 *        The index to check
 *
 * @param {number} maxIndex
 *        The maximum possible index
 *
 * @throws {Error} if the timeRanges provided are over the maxIndex
 */
function rangeCheck(fnName, index, maxIndex) {
  if (typeof index !== 'number' || index < 0 || index > maxIndex) {
    throw new Error('Failed to execute \'' + fnName + '\' on \'TimeRanges\': The index provided (' + index + ') is non-numeric or out of bounds (0-' + maxIndex + ').');
  }
}

/**
 * Check if any of the time ranges are over the maximum index.
 *
 * @param {string} fnName
 *        The function name to use for logging
 *
 * @param {string} valueIndex
 *        The proprety that should be used to get the time. should be 'start' or 'end'
 *
 * @param {Array} ranges
 *        An array of time ranges
 *
 * @param {Array} [rangeIndex=0]
 *        The index to start the search at
 *
 * @return {number}
 *         The time that offset at the specified index.
 *
 *
 * @depricated rangeIndex must be set to a value, in the future this will throw an error.
 * @throws {Error} if rangeIndex is more than the length of ranges
 */
function getRange(fnName, valueIndex, ranges, rangeIndex) {
  rangeCheck(fnName, rangeIndex, ranges.length - 1);
  return ranges[rangeIndex][valueIndex];
}

/**
 * Create a time range object givent ranges of time.
 *
 * @param {Array} [ranges]
 *        An array of time ranges.
 */
function createTimeRangesObj(ranges) {
  if (ranges === undefined || ranges.length === 0) {
    return {
      length: 0,
      start: function start() {
        throw new Error('This TimeRanges object is empty');
      },
      end: function end() {
        throw new Error('This TimeRanges object is empty');
      }
    };
  }
  return {
    length: ranges.length,
    start: getRange.bind(null, 'start', 0, ranges),
    end: getRange.bind(null, 'end', 1, ranges)
  };
}

/**
 * Should create a fake `TimeRange` object which mimics an HTML5 time range instance.
 *
 * @param {number|Array} start
 *        The start of a single range or an array of ranges
 *
 * @param {number} end
 *        The end of a single range.
 *
 * @private
 */
function createTimeRanges(start, end) {
  if (Array.isArray(start)) {
    return createTimeRangesObj(start);
  } else if (start === undefined || end === undefined) {
    return createTimeRangesObj();
  }
  return createTimeRangesObj([[start, end]]);
}

/**
 * @file buffer.js
 * @module buffer
 */
/**
 * Compute the percentage of the media that has been buffered.
 *
 * @param {TimeRange} buffered
 *        The current `TimeRange` object representing buffered time ranges
 *
 * @param {number} duration
 *        Total duration of the media
 *
 * @return {number}
 *         Percent buffered of the total duration in decimal form.
 */
function bufferedPercent(buffered, duration) {
  var bufferedDuration = 0;
  var start = void 0;
  var end = void 0;

  if (!duration) {
    return 0;
  }

  if (!buffered || !buffered.length) {
    buffered = createTimeRanges(0, 0);
  }

  for (var i = 0; i < buffered.length; i++) {
    start = buffered.start(i);
    end = buffered.end(i);

    // buffered end can be bigger than duration by a very small fraction
    if (end > duration) {
      end = duration;
    }

    bufferedDuration += end - start;
  }

  return bufferedDuration / duration;
}

/**
 * @file fullscreen-api.js
 * @module fullscreen-api
 * @private
 */
/**
 * Store the browser-specific methods for the fullscreen API.
 *
 * @type {Object}
 * @see [Specification]{@link https://fullscreen.spec.whatwg.org}
 * @see [Map Approach From Screenfull.js]{@link https://github.com/sindresorhus/screenfull.js}
 */
var FullscreenApi = {};

// browser API methods
var apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'],
// WebKit
['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Old WebKit (Safari 5.1)
['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Mozilla
['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'],
// Microsoft
['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];

var specApi = apiMap[0];
var browserApi = void 0;

// determine the supported set of functions
for (var i = 0; i < apiMap.length; i++) {
  // check for exitFullscreen function
  if (apiMap[i][1] in document) {
    browserApi = apiMap[i];
    break;
  }
}

// map the browser API names to the spec API names
if (browserApi) {
  for (var _i = 0; _i < browserApi.length; _i++) {
    FullscreenApi[specApi[_i]] = browserApi[_i];
  }
}

/**
 * @file media-error.js
 */
/**
 * A Custom `MediaError` class which mimics the standard HTML5 `MediaError` class.
 *
 * @param {number|string|Object|MediaError} value
 *        This can be of multiple types:
 *        - number: should be a standard error code
 *        - string: an error message (the code will be 0)
 *        - Object: arbitrary properties
 *        - `MediaError` (native): used to populate a video.js `MediaError` object
 *        - `MediaError` (video.js): will return itself if it's already a
 *          video.js `MediaError` object.
 *
 * @see [MediaError Spec]{@link https://dev.w3.org/html5/spec-author-view/video.html#mediaerror}
 * @see [Encrypted MediaError Spec]{@link https://www.w3.org/TR/2013/WD-encrypted-media-20130510/#error-codes}
 *
 * @class MediaError
 */
function MediaError(value) {

  // Allow redundant calls to this constructor to avoid having `instanceof`
  // checks peppered around the code.
  if (value instanceof MediaError) {
    return value;
  }

  if (typeof value === 'number') {
    this.code = value;
  } else if (typeof value === 'string') {
    // default code is zero, so this is a custom error
    this.message = value;
  } else if (isObject(value)) {

    // We assign the `code` property manually because native `MediaError` objects
    // do not expose it as an own/enumerable property of the object.
    if (typeof value.code === 'number') {
      this.code = value.code;
    }

    assign(this, value);
  }

  if (!this.message) {
    this.message = MediaError.defaultMessages[this.code] || '';
  }
}

/**
 * The error code that refers two one of the defined `MediaError` types
 *
 * @type {Number}
 */
MediaError.prototype.code = 0;

/**
 * An optional message that to show with the error. Message is not part of the HTML5
 * video spec but allows for more informative custom errors.
 *
 * @type {String}
 */
MediaError.prototype.message = '';

/**
 * An optional status code that can be set by plugins to allow even more detail about
 * the error. For example a plugin might provide a specific HTTP status code and an
 * error message for that code. Then when the plugin gets that error this class will
 * know how to display an error message for it. This allows a custom message to show
 * up on the `Player` error overlay.
 *
 * @type {Array}
 */
MediaError.prototype.status = null;

/**
 * Errors indexed by the W3C standard. The order **CANNOT CHANGE**! See the
 * specification listed under {@link MediaError} for more information.
 *
 * @enum {array}
 * @readonly
 * @property {string} 0 - MEDIA_ERR_CUSTOM
 * @property {string} 1 - MEDIA_ERR_CUSTOM
 * @property {string} 2 - MEDIA_ERR_ABORTED
 * @property {string} 3 - MEDIA_ERR_NETWORK
 * @property {string} 4 - MEDIA_ERR_SRC_NOT_SUPPORTED
 * @property {string} 5 - MEDIA_ERR_ENCRYPTED
 */
MediaError.errorTypes = ['MEDIA_ERR_CUSTOM', 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED', 'MEDIA_ERR_ENCRYPTED'];

/**
 * The default `MediaError` messages based on the {@link MediaError.errorTypes}.
 *
 * @type {Array}
 * @constant
 */
MediaError.defaultMessages = {
  1: 'You aborted the media playback',
  2: 'A network error caused the media download to fail part-way.',
  3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',
  4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',
  5: 'The media is encrypted and we do not have the keys to decrypt it.'
};

// Add types as properties on MediaError
// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
for (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
  MediaError[MediaError.errorTypes[errNum]] = errNum;
  // values should be accessible on both the class and instance
  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
}

/**
 * @file text-track-list-converter.js Utilities for capturing text track state and
 * re-creating tracks based on a capture.
 *
 * @module text-track-list-converter
 */

/**
 * Examine a single {@link TextTrack} and return a JSON-compatible javascript object that
 * represents the {@link TextTrack}'s state.
 *
 * @param {TextTrack} track
 *        The text track to query.
 *
 * @return {Object}
 *         A serializable javascript representation of the TextTrack.
 * @private
 */
var trackToJson_ = function trackToJson_(track) {
  var ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce(function (acc, prop, i) {

    if (track[prop]) {
      acc[prop] = track[prop];
    }

    return acc;
  }, {
    cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {
      return {
        startTime: cue.startTime,
        endTime: cue.endTime,
        text: cue.text,
        id: cue.id
      };
    })
  });

  return ret;
};

/**
 * Examine a {@link Tech} and return a JSON-compatible javascript array that represents the
 * state of all {@link TextTrack}s currently configured. The return array is compatible with
 * {@link text-track-list-converter:jsonToTextTracks}.
 *
 * @param {Tech} tech
 *        The tech object to query
 *
 * @return {Array}
 *         A serializable javascript representation of the {@link Tech}s
 *         {@link TextTrackList}.
 */
var textTracksToJson = function textTracksToJson(tech) {

  var trackEls = tech.$$('track');

  var trackObjs = Array.prototype.map.call(trackEls, function (t) {
    return t.track;
  });
  var tracks = Array.prototype.map.call(trackEls, function (trackEl) {
    var json = trackToJson_(trackEl.track);

    if (trackEl.src) {
      json.src = trackEl.src;
    }
    return json;
  });

  return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {
    return trackObjs.indexOf(track) === -1;
  }).map(trackToJson_));
};

/**
 * Create a set of remote {@link TextTrack}s on a {@link Tech} based on an array of javascript
 * object {@link TextTrack} representations.
 *
 * @param {Array} json
 *        An array of `TextTrack` representation objects, like those that would be
 *        produced by `textTracksToJson`.
 *
 * @param {Tech} tech
 *        The `Tech` to create the `TextTrack`s on.
 */
var jsonToTextTracks = function jsonToTextTracks(json, tech) {
  json.forEach(function (track) {
    var addedTrack = tech.addRemoteTextTrack(track).track;

    if (!track.src && track.cues) {
      track.cues.forEach(function (cue) {
        return addedTrack.addCue(cue);
      });
    }
  });

  return tech.textTracks();
};

var textTrackConverter = { textTracksToJson: textTracksToJson, jsonToTextTracks: jsonToTextTracks, trackToJson_: trackToJson_ };

/**
 * @file modal-dialog.js
 */
var MODAL_CLASS_NAME = 'vjs-modal-dialog';
var ESC = 27;

/**
 * The `ModalDialog` displays over the video and its controls, which blocks
 * interaction with the player until it is closed.
 *
 * Modal dialogs include a "Close" button and will close when that button
 * is activated - or when ESC is pressed anywhere.
 *
 * @extends Component
 */

var ModalDialog = function (_Component) {
  inherits(ModalDialog, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Mixed} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {string} [options.description]
   *        A text description for the modal, primarily for accessibility.
   *
   * @param {boolean} [options.fillAlways=false]
   *        Normally, modals are automatically filled only the first time
   *        they open. This tells the modal to refresh its content
   *        every time it opens.
   *
   * @param {string} [options.label]
   *        A text label for the modal, primarily for accessibility.
   *
   * @param {boolean} [options.temporary=true]
   *        If `true`, the modal can only be opened once; it will be
   *        disposed as soon as it's closed.
   *
   * @param {boolean} [options.uncloseable=false]
   *        If `true`, the user will not be able to close the modal
   *        through the UI in the normal ways. Programmatic closing is
   *        still possible.
   */
  function ModalDialog(player, options) {
    classCallCheck(this, ModalDialog);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = false;

    _this.closeable(!_this.options_.uncloseable);
    _this.content(_this.options_.content);

    // Make sure the contentEl is defined AFTER any children are initialized
    // because we only want the contents of the modal in the contentEl
    // (not the UI elements like the close button).
    _this.contentEl_ = createEl('div', {
      className: MODAL_CLASS_NAME + '-content'
    }, {
      role: 'document'
    });

    _this.descEl_ = createEl('p', {
      className: MODAL_CLASS_NAME + '-description vjs-control-text',
      id: _this.el().getAttribute('aria-describedby')
    });

    textContent(_this.descEl_, _this.description());
    _this.el_.appendChild(_this.descEl_);
    _this.el_.appendChild(_this.contentEl_);
    return _this;
  }

  /**
   * Create the `ModalDialog`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */


  ModalDialog.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildCSSClass(),
      tabIndex: -1
    }, {
      'aria-describedby': this.id() + '_description',
      'aria-hidden': 'true',
      'aria-label': this.label(),
      'role': 'dialog'
    });
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  ModalDialog.prototype.buildCSSClass = function buildCSSClass() {
    return MODAL_CLASS_NAME + ' vjs-hidden ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Handles `keydown` events on the document, looking for ESC, which closes
   * the modal.
   *
   * @param {EventTarget~Event} e
   *        The keypress that triggered this event.
   *
   * @listens keydown
   */


  ModalDialog.prototype.handleKeyPress = function handleKeyPress(e) {
    if (e.which === ESC && this.closeable()) {
      this.close();
    }
  };

  /**
   * Returns the label string for this modal. Primarily used for accessibility.
   *
   * @return {string}
   *         the localized or raw label of this modal.
   */


  ModalDialog.prototype.label = function label() {
    return this.localize(this.options_.label || 'Modal Window');
  };

  /**
   * Returns the description string for this modal. Primarily used for
   * accessibility.
   *
   * @return {string}
   *         The localized or raw description of this modal.
   */


  ModalDialog.prototype.description = function description() {
    var desc = this.options_.description || this.localize('This is a modal window.');

    // Append a universal closeability message if the modal is closeable.
    if (this.closeable()) {
      desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');
    }

    return desc;
  };

  /**
   * Opens the modal.
   *
   * @fires ModalDialog#beforemodalopen
   * @fires ModalDialog#modalopen
   */


  ModalDialog.prototype.open = function open() {
    if (!this.opened_) {
      var player = this.player();

      /**
        * Fired just before a `ModalDialog` is opened.
        *
        * @event ModalDialog#beforemodalopen
        * @type {EventTarget~Event}
        */
      this.trigger('beforemodalopen');
      this.opened_ = true;

      // Fill content if the modal has never opened before and
      // never been filled.
      if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {
        this.fill();
      }

      // If the player was playing, pause it and take note of its previously
      // playing state.
      this.wasPlaying_ = !player.paused();

      if (this.options_.pauseOnOpen && this.wasPlaying_) {
        player.pause();
      }

      if (this.closeable()) {
        this.on(this.el_.ownerDocument, 'keydown', bind(this, this.handleKeyPress));
      }

      player.controls(false);
      this.show();
      this.conditionalFocus_();
      this.el().setAttribute('aria-hidden', 'false');

      /**
        * Fired just after a `ModalDialog` is opened.
        *
        * @event ModalDialog#modalopen
        * @type {EventTarget~Event}
        */
      this.trigger('modalopen');
      this.hasBeenOpened_ = true;
    }
  };

  /**
   * If the `ModalDialog` is currently open or closed.
   *
   * @param  {boolean} [value]
   *         If given, it will open (`true`) or close (`false`) the modal.
   *
   * @return {boolean}
   *         the current open state of the modaldialog
   */


  ModalDialog.prototype.opened = function opened(value) {
    if (typeof value === 'boolean') {
      this[value ? 'open' : 'close']();
    }
    return this.opened_;
  };

  /**
   * Closes the modal, does nothing if the `ModalDialog` is
   * not open.
   *
   * @fires ModalDialog#beforemodalclose
   * @fires ModalDialog#modalclose
   */


  ModalDialog.prototype.close = function close() {
    if (!this.opened_) {
      return;
    }
    var player = this.player();

    /**
      * Fired just before a `ModalDialog` is closed.
      *
      * @event ModalDialog#beforemodalclose
      * @type {EventTarget~Event}
      */
    this.trigger('beforemodalclose');
    this.opened_ = false;

    if (this.wasPlaying_ && this.options_.pauseOnOpen) {
      player.play();
    }

    if (this.closeable()) {
      this.off(this.el_.ownerDocument, 'keydown', bind(this, this.handleKeyPress));
    }

    player.controls(true);
    this.hide();
    this.el().setAttribute('aria-hidden', 'true');

    /**
      * Fired just after a `ModalDialog` is closed.
      *
      * @event ModalDialog#modalclose
      * @type {EventTarget~Event}
      */
    this.trigger('modalclose');
    this.conditionalBlur_();

    if (this.options_.temporary) {
      this.dispose();
    }
  };

  /**
   * Check to see if the `ModalDialog` is closeable via the UI.
   *
   * @param  {boolean} [value]
   *         If given as a boolean, it will set the `closeable` option.
   *
   * @return {boolean}
   *         Returns the final value of the closable option.
   */


  ModalDialog.prototype.closeable = function closeable(value) {
    if (typeof value === 'boolean') {
      var closeable = this.closeable_ = !!value;
      var close = this.getChild('closeButton');

      // If this is being made closeable and has no close button, add one.
      if (closeable && !close) {

        // The close button should be a child of the modal - not its
        // content element, so temporarily change the content element.
        var temp = this.contentEl_;

        this.contentEl_ = this.el_;
        close = this.addChild('closeButton', { controlText: 'Close Modal Dialog' });
        this.contentEl_ = temp;
        this.on(close, 'close', this.close);
      }

      // If this is being made uncloseable and has a close button, remove it.
      if (!closeable && close) {
        this.off(close, 'close', this.close);
        this.removeChild(close);
        close.dispose();
      }
    }
    return this.closeable_;
  };

  /**
   * Fill the modal's content element with the modal's "content" option.
   * The content element will be emptied before this change takes place.
   */


  ModalDialog.prototype.fill = function fill() {
    this.fillWith(this.content());
  };

  /**
   * Fill the modal's content element with arbitrary content.
   * The content element will be emptied before this change takes place.
   *
   * @fires ModalDialog#beforemodalfill
   * @fires ModalDialog#modalfill
   *
   * @param {Mixed} [content]
   *        The same rules apply to this as apply to the `content` option.
   */


  ModalDialog.prototype.fillWith = function fillWith(content) {
    var contentEl = this.contentEl();
    var parentEl = contentEl.parentNode;
    var nextSiblingEl = contentEl.nextSibling;

    /**
     * Fired just before a `ModalDialog` is filled with content.
     *
     * @event ModalDialog#beforemodalfill
     * @type {EventTarget~Event}
     */
    this.trigger('beforemodalfill');
    this.hasBeenFilled_ = true;

    // Detach the content element from the DOM before performing
    // manipulation to avoid modifying the live DOM multiple times.
    parentEl.removeChild(contentEl);
    this.empty();
    insertContent(contentEl, content);
    /**
     * Fired just after a `ModalDialog` is filled with content.
     *
     * @event ModalDialog#modalfill
     * @type {EventTarget~Event}
     */
    this.trigger('modalfill');

    // Re-inject the re-filled content element.
    if (nextSiblingEl) {
      parentEl.insertBefore(contentEl, nextSiblingEl);
    } else {
      parentEl.appendChild(contentEl);
    }

    // make sure that the close button is last in the dialog DOM
    var closeButton = this.getChild('closeButton');

    if (closeButton) {
      parentEl.appendChild(closeButton.el_);
    }
  };

  /**
   * Empties the content element. This happens anytime the modal is filled.
   *
   * @fires ModalDialog#beforemodalempty
   * @fires ModalDialog#modalempty
   */


  ModalDialog.prototype.empty = function empty() {
    /**
     * Fired just before a `ModalDialog` is emptied.
     *
     * @event ModalDialog#beforemodalempty
     * @type {EventTarget~Event}
     */
    this.trigger('beforemodalempty');
    emptyEl(this.contentEl());

    /**
     * Fired just after a `ModalDialog` is emptied.
     *
     * @event ModalDialog#modalempty
     * @type {EventTarget~Event}
     */
    this.trigger('modalempty');
  };

  /**
   * Gets or sets the modal content, which gets normalized before being
   * rendered into the DOM.
   *
   * This does not update the DOM or fill the modal, but it is called during
   * that process.
   *
   * @param  {Mixed} [value]
   *         If defined, sets the internal content value to be used on the
   *         next call(s) to `fill`. This value is normalized before being
   *         inserted. To "clear" the internal content value, pass `null`.
   *
   * @return {Mixed}
   *         The current content of the modal dialog
   */


  ModalDialog.prototype.content = function content(value) {
    if (typeof value !== 'undefined') {
      this.content_ = value;
    }
    return this.content_;
  };

  /**
   * conditionally focus the modal dialog if focus was previously on the player.
   *
   * @private
   */


  ModalDialog.prototype.conditionalFocus_ = function conditionalFocus_() {
    var activeEl = document.activeElement;
    var playerEl = this.player_.el_;

    this.previouslyActiveEl_ = null;

    if (playerEl.contains(activeEl) || playerEl === activeEl) {
      this.previouslyActiveEl_ = activeEl;

      this.focus();

      this.on(document, 'keydown', this.handleKeyDown);
    }
  };

  /**
   * conditionally blur the element and refocus the last focused element
   *
   * @private
   */


  ModalDialog.prototype.conditionalBlur_ = function conditionalBlur_() {
    if (this.previouslyActiveEl_) {
      this.previouslyActiveEl_.focus();
      this.previouslyActiveEl_ = null;
    }

    this.off(document, 'keydown', this.handleKeyDown);
  };

  /**
   * Keydown handler. Attached when modal is focused.
   *
   * @listens keydown
   */


  ModalDialog.prototype.handleKeyDown = function handleKeyDown(event) {
    // exit early if it isn't a tab key
    if (event.which !== 9) {
      return;
    }

    var focusableEls = this.focusableEls_();
    var activeEl = this.el_.querySelector(':focus');
    var focusIndex = void 0;

    for (var i = 0; i < focusableEls.length; i++) {
      if (activeEl === focusableEls[i]) {
        focusIndex = i;
        break;
      }
    }

    if (document.activeElement === this.el_) {
      focusIndex = 0;
    }

    if (event.shiftKey && focusIndex === 0) {
      focusableEls[focusableEls.length - 1].focus();
      event.preventDefault();
    } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {
      focusableEls[0].focus();
      event.preventDefault();
    }
  };

  /**
   * get all focusable elements
   *
   * @private
   */


  ModalDialog.prototype.focusableEls_ = function focusableEls_() {
    var allChildren = this.el_.querySelectorAll('*');

    return Array.prototype.filter.call(allChildren, function (child) {
      return (child instanceof window.HTMLAnchorElement || child instanceof window.HTMLAreaElement) && child.hasAttribute('href') || (child instanceof window.HTMLInputElement || child instanceof window.HTMLSelectElement || child instanceof window.HTMLTextAreaElement || child instanceof window.HTMLButtonElement) && !child.hasAttribute('disabled') || child instanceof window.HTMLIFrameElement || child instanceof window.HTMLObjectElement || child instanceof window.HTMLEmbedElement || child.hasAttribute('tabindex') && child.getAttribute('tabindex') !== -1 || child.hasAttribute('contenteditable');
    });
  };

  return ModalDialog;
}(Component);

/**
 * Default options for `ModalDialog` default options.
 *
 * @type {Object}
 * @private
 */


ModalDialog.prototype.options_ = {
  pauseOnOpen: true,
  temporary: true
};

Component.registerComponent('ModalDialog', ModalDialog);

/**
 * @file track-list.js
 */
/**
 * Common functionaliy between {@link TextTrackList}, {@link AudioTrackList}, and
 * {@link VideoTrackList}
 *
 * @extends EventTarget
 */

var TrackList = function (_EventTarget) {
  inherits(TrackList, _EventTarget);

  /**
   * Create an instance of this class
   *
   * @param {Track[]} tracks
   *        A list of tracks to initialize the list with.
   *
   * @param {Object} [list]
   *        The child object with inheritance done manually for ie8.
   *
   * @abstract
   */
  function TrackList() {
    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var _ret;

    var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    classCallCheck(this, TrackList);

    var _this = possibleConstructorReturn(this, _EventTarget.call(this));

    if (!list) {
      list = _this; // eslint-disable-line
      if (IS_IE8) {
        list = document.createElement('custom');
        for (var prop in TrackList.prototype) {
          if (prop !== 'constructor') {
            list[prop] = TrackList.prototype[prop];
          }
        }
      }
    }

    list.tracks_ = [];

    /**
     * @memberof TrackList
     * @member {number} length
     *         The current number of `Track`s in the this Trackist.
     * @instance
     */
    Object.defineProperty(list, 'length', {
      get: function get$$1() {
        return this.tracks_.length;
      }
    });

    for (var i = 0; i < tracks.length; i++) {
      list.addTrack(tracks[i]);
    }

    // must return the object, as for ie8 it will not be this
    // but a reference to a document object
    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a {@link Track} to the `TrackList`
   *
   * @param {Track} track
   *        The audio, video, or text track to add to the list.
   *
   * @fires TrackList#addtrack
   */


  TrackList.prototype.addTrack = function addTrack(track) {
    var index = this.tracks_.length;

    if (!('' + index in this)) {
      Object.defineProperty(this, index, {
        get: function get$$1() {
          return this.tracks_[index];
        }
      });
    }

    // Do not add duplicate tracks
    if (this.tracks_.indexOf(track) === -1) {
      this.tracks_.push(track);
      /**
       * Triggered when a track is added to a track list.
       *
       * @event TrackList#addtrack
       * @type {EventTarget~Event}
       * @property {Track} track
       *           A reference to track that was added.
       */
      this.trigger({
        track: track,
        type: 'addtrack'
      });
    }
  };

  /**
   * Remove a {@link Track} from the `TrackList`
   *
   * @param {Track} rtrack
   *        The audio, video, or text track to remove from the list.
   *
   * @fires TrackList#removetrack
   */


  TrackList.prototype.removeTrack = function removeTrack(rtrack) {
    var track = void 0;

    for (var i = 0, l = this.length; i < l; i++) {
      if (this[i] === rtrack) {
        track = this[i];
        if (track.off) {
          track.off();
        }

        this.tracks_.splice(i, 1);

        break;
      }
    }

    if (!track) {
      return;
    }

    /**
     * Triggered when a track is removed from track list.
     *
     * @event TrackList#removetrack
     * @type {EventTarget~Event}
     * @property {Track} track
     *           A reference to track that was removed.
     */
    this.trigger({
      track: track,
      type: 'removetrack'
    });
  };

  /**
   * Get a Track from the TrackList by a tracks id
   *
   * @param {String} id - the id of the track to get
   * @method getTrackById
   * @return {Track}
   * @private
   */


  TrackList.prototype.getTrackById = function getTrackById(id) {
    var result = null;

    for (var i = 0, l = this.length; i < l; i++) {
      var track = this[i];

      if (track.id === id) {
        result = track;
        break;
      }
    }

    return result;
  };

  return TrackList;
}(EventTarget);

/**
 * Triggered when a different track is selected/enabled.
 *
 * @event TrackList#change
 * @type {EventTarget~Event}
 */

/**
 * Events that can be called with on + eventName. See {@link EventHandler}.
 *
 * @property {Object} TrackList#allowedEvents_
 * @private
 */


TrackList.prototype.allowedEvents_ = {
  change: 'change',
  addtrack: 'addtrack',
  removetrack: 'removetrack'
};

// emulate attribute EventHandler support to allow for feature detection
for (var event in TrackList.prototype.allowedEvents_) {
  TrackList.prototype['on' + event] = null;
}

/**
 * @file audio-track-list.js
 */
/**
 * Anywhere we call this function we diverge from the spec
 * as we only support one enabled audiotrack at a time
 *
 * @param {AudioTrackList} list
 *        list to work on
 *
 * @param {AudioTrack} track
 *        The track to skip
 *
 * @private
 */
var disableOthers = function disableOthers(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    // another audio track is enabled, disable it
    list[i].enabled = false;
  }
};

/**
 * The current list of {@link AudioTrack} for a media file.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist}
 * @extends TrackList
 */

var AudioTrackList = function (_TrackList) {
  inherits(AudioTrackList, _TrackList);

  /**
   * Create an instance of this class.
   *
   * @param {AudioTrack[]} [tracks=[]]
   *        A list of `AudioTrack` to instantiate the list with.
   */
  function AudioTrackList() {
    var _this, _ret;

    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, AudioTrackList);

    var list = void 0;

    // make sure only 1 track is enabled
    // sorted from last index to first index
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].enabled) {
        disableOthers(tracks, tracks[i]);
        break;
      }
    }

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (IS_IE8) {
      list = document.createElement('custom');
      for (var prop in TrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TrackList.prototype[prop];
        }
      }
      for (var _prop in AudioTrackList.prototype) {
        if (_prop !== 'constructor') {
          list[_prop] = AudioTrackList.prototype[_prop];
        }
      }
    }

    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
    list.changing_ = false;

    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add an {@link AudioTrack} to the `AudioTrackList`.
   *
   * @param {AudioTrack} track
   *        The AudioTrack to add to the list
   *
   * @fires TrackList#addtrack
   */


  AudioTrackList.prototype.addTrack = function addTrack(track) {
    var _this2 = this;

    if (track.enabled) {
      disableOthers(this, track);
    }

    _TrackList.prototype.addTrack.call(this, track);
    // native tracks don't have this
    if (!track.addEventListener) {
      return;
    }

    /**
     * @listens AudioTrack#enabledchange
     * @fires TrackList#change
     */
    track.addEventListener('enabledchange', function () {
      // when we are disabling other tracks (since we don't support
      // more than one track at a time) we will set changing_
      // to true so that we don't trigger additional change events
      if (_this2.changing_) {
        return;
      }
      _this2.changing_ = true;
      disableOthers(_this2, track);
      _this2.changing_ = false;
      _this2.trigger('change');
    });
  };

  return AudioTrackList;
}(TrackList);

/**
 * @file video-track-list.js
 */
/**
 * Un-select all other {@link VideoTrack}s that are selected.
 *
 * @param {VideoTrackList} list
 *        list to work on
 *
 * @param {VideoTrack} track
 *        The track to skip
 *
 * @private
 */
var disableOthers$1 = function disableOthers(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    // another video track is enabled, disable it
    list[i].selected = false;
  }
};

/**
 * The current list of {@link VideoTrack} for a video.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist}
 * @extends TrackList
 */

var VideoTrackList = function (_TrackList) {
  inherits(VideoTrackList, _TrackList);

  /**
   * Create an instance of this class.
   *
   * @param {VideoTrack[]} [tracks=[]]
   *        A list of `VideoTrack` to instantiate the list with.
   */
  function VideoTrackList() {
    var _this, _ret;

    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, VideoTrackList);

    var list = void 0;

    // make sure only 1 track is enabled
    // sorted from last index to first index
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].selected) {
        disableOthers$1(tracks, tracks[i]);
        break;
      }
    }

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (IS_IE8) {
      list = document.createElement('custom');
      for (var prop in TrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TrackList.prototype[prop];
        }
      }
      for (var _prop in VideoTrackList.prototype) {
        if (_prop !== 'constructor') {
          list[_prop] = VideoTrackList.prototype[_prop];
        }
      }
    }

    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
    list.changing_ = false;

    /**
     * @member {number} VideoTrackList#selectedIndex
     *         The current index of the selected {@link VideoTrack`}.
     */
    Object.defineProperty(list, 'selectedIndex', {
      get: function get$$1() {
        for (var _i = 0; _i < this.length; _i++) {
          if (this[_i].selected) {
            return _i;
          }
        }
        return -1;
      },
      set: function set$$1() {}
    });

    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a {@link VideoTrack} to the `VideoTrackList`.
   *
   * @param {VideoTrack} track
   *        The VideoTrack to add to the list
   *
   * @fires TrackList#addtrack
   */


  VideoTrackList.prototype.addTrack = function addTrack(track) {
    var _this2 = this;

    if (track.selected) {
      disableOthers$1(this, track);
    }

    _TrackList.prototype.addTrack.call(this, track);
    // native tracks don't have this
    if (!track.addEventListener) {
      return;
    }

    /**
     * @listens VideoTrack#selectedchange
     * @fires TrackList#change
     */
    track.addEventListener('selectedchange', function () {
      if (_this2.changing_) {
        return;
      }
      _this2.changing_ = true;
      disableOthers$1(_this2, track);
      _this2.changing_ = false;
      _this2.trigger('change');
    });
  };

  return VideoTrackList;
}(TrackList);

/**
 * @file text-track-list.js
 */
/**
 * The current list of {@link TextTrack} for a media file.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist}
 * @extends TrackList
 */

var TextTrackList = function (_TrackList) {
  inherits(TextTrackList, _TrackList);

  /**
   * Create an instance of this class.
   *
   * @param {TextTrack[]} [tracks=[]]
   *        A list of `TextTrack` to instantiate the list with.
   */
  function TextTrackList() {
    var _this, _ret;

    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, TextTrackList);

    var list = void 0;

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (IS_IE8) {
      list = document.createElement('custom');
      for (var prop in TrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TrackList.prototype[prop];
        }
      }
      for (var _prop in TextTrackList.prototype) {
        if (_prop !== 'constructor') {
          list[_prop] = TextTrackList.prototype[_prop];
        }
      }
    }

    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a {@link TextTrack} to the `TextTrackList`
   *
   * @param {TextTrack} track
   *        The text track to add to the list.
   *
   * @fires TrackList#addtrack
   */


  TextTrackList.prototype.addTrack = function addTrack(track) {
    _TrackList.prototype.addTrack.call(this, track);

    /**
     * @listens TextTrack#modechange
     * @fires TrackList#change
     */
    track.addEventListener('modechange', bind(this, function () {
      this.trigger('change');
    }));

    var nonLanguageTextTrackKind = ['metadata', 'chapters'];

    if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {
      track.addEventListener('modechange', bind(this, function () {
        this.trigger('selectedlanguagechange');
      }));
    }
  };

  return TextTrackList;
}(TrackList);

/**
 * @file html-track-element-list.js
 */

/**
 * The current list of {@link HtmlTrackElement}s.
 */

var HtmlTrackElementList = function () {

  /**
   * Create an instance of this class.
   *
   * @param {HtmlTrackElement[]} [tracks=[]]
   *        A list of `HtmlTrackElement` to instantiate the list with.
   */
  function HtmlTrackElementList() {
    var trackElements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, HtmlTrackElementList);

    var list = this; // eslint-disable-line

    if (IS_IE8) {
      list = document.createElement('custom');

      for (var prop in HtmlTrackElementList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = HtmlTrackElementList.prototype[prop];
        }
      }
    }

    list.trackElements_ = [];

    /**
     * @memberof HtmlTrackElementList
     * @member {number} length
     *         The current number of `Track`s in the this Trackist.
     * @instance
     */
    Object.defineProperty(list, 'length', {
      get: function get$$1() {
        return this.trackElements_.length;
      }
    });

    for (var i = 0, length = trackElements.length; i < length; i++) {
      list.addTrackElement_(trackElements[i]);
    }

    if (IS_IE8) {
      return list;
    }
  }

  /**
   * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`
   *
   * @param {HtmlTrackElement} trackElement
   *        The track element to add to the list.
   *
   * @private
   */


  HtmlTrackElementList.prototype.addTrackElement_ = function addTrackElement_(trackElement) {
    var index = this.trackElements_.length;

    if (!('' + index in this)) {
      Object.defineProperty(this, index, {
        get: function get$$1() {
          return this.trackElements_[index];
        }
      });
    }

    // Do not add duplicate elements
    if (this.trackElements_.indexOf(trackElement) === -1) {
      this.trackElements_.push(trackElement);
    }
  };

  /**
   * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an
   * {@link TextTrack}.
   *
   * @param {TextTrack} track
   *        The track associated with a track element.
   *
   * @return {HtmlTrackElement|undefined}
   *         The track element that was found or undefined.
   *
   * @private
   */


  HtmlTrackElementList.prototype.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {
    var trackElement_ = void 0;

    for (var i = 0, length = this.trackElements_.length; i < length; i++) {
      if (track === this.trackElements_[i].track) {
        trackElement_ = this.trackElements_[i];

        break;
      }
    }

    return trackElement_;
  };

  /**
   * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`
   *
   * @param {HtmlTrackElement} trackElement
   *        The track element to remove from the list.
   *
   * @private
   */


  HtmlTrackElementList.prototype.removeTrackElement_ = function removeTrackElement_(trackElement) {
    for (var i = 0, length = this.trackElements_.length; i < length; i++) {
      if (trackElement === this.trackElements_[i]) {
        this.trackElements_.splice(i, 1);

        break;
      }
    }
  };

  return HtmlTrackElementList;
}();

/**
 * @file text-track-cue-list.js
 */
/**
 * @typedef {Object} TextTrackCueList~TextTrackCue
 *
 * @property {string} id
 *           The unique id for this text track cue
 *
 * @property {number} startTime
 *           The start time for this text track cue
 *
 * @property {number} endTime
 *           The end time for this text track cue
 *
 * @property {boolean} pauseOnExit
 *           Pause when the end time is reached if true.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcue}
 */

/**
 * A List of TextTrackCues.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist}
 */

var TextTrackCueList = function () {

  /**
   * Create an instance of this class..
   *
   * @param {Array} cues
   *        A list of cues to be initialized with
   */
  function TextTrackCueList(cues) {
    classCallCheck(this, TextTrackCueList);

    var list = this; // eslint-disable-line

    if (IS_IE8) {
      list = document.createElement('custom');

      for (var prop in TextTrackCueList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TextTrackCueList.prototype[prop];
        }
      }
    }

    TextTrackCueList.prototype.setCues_.call(list, cues);

    /**
     * @memberof TextTrackCueList
     * @member {number} length
     *         The current number of `TextTrackCue`s in the TextTrackCueList.
     * @instance
     */
    Object.defineProperty(list, 'length', {
      get: function get$$1() {
        return this.length_;
      }
    });

    if (IS_IE8) {
      return list;
    }
  }

  /**
   * A setter for cues in this list. Creates getters
   * an an index for the cues.
   *
   * @param {Array} cues
   *        An array of cues to set
   *
   * @private
   */


  TextTrackCueList.prototype.setCues_ = function setCues_(cues) {
    var oldLength = this.length || 0;
    var i = 0;
    var l = cues.length;

    this.cues_ = cues;
    this.length_ = cues.length;

    var defineProp = function defineProp(index) {
      if (!('' + index in this)) {
        Object.defineProperty(this, '' + index, {
          get: function get$$1() {
            return this.cues_[index];
          }
        });
      }
    };

    if (oldLength < l) {
      i = oldLength;

      for (; i < l; i++) {
        defineProp.call(this, i);
      }
    }
  };

  /**
   * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.
   *
   * @param {string} id
   *        The id of the cue that should be searched for.
   *
   * @return {TextTrackCueList~TextTrackCue|null}
   *         A single cue or null if none was found.
   */


  TextTrackCueList.prototype.getCueById = function getCueById(id) {
    var result = null;

    for (var i = 0, l = this.length; i < l; i++) {
      var cue = this[i];

      if (cue.id === id) {
        result = cue;
        break;
      }
    }

    return result;
  };

  return TextTrackCueList;
}();

/**
 * @file track-kinds.js
 */

/**
 * All possible `VideoTrackKind`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind
 * @typedef VideoTrack~Kind
 * @enum
 */
var VideoTrackKind = {
  alternative: 'alternative',
  captions: 'captions',
  main: 'main',
  sign: 'sign',
  subtitles: 'subtitles',
  commentary: 'commentary'
};

/**
 * All possible `AudioTrackKind`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind
 * @typedef AudioTrack~Kind
 * @enum
 */
var AudioTrackKind = {
  'alternative': 'alternative',
  'descriptions': 'descriptions',
  'main': 'main',
  'main-desc': 'main-desc',
  'translation': 'translation',
  'commentary': 'commentary'
};

/**
 * All possible `TextTrackKind`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-kind
 * @typedef TextTrack~Kind
 * @enum
 */
var TextTrackKind = {
  subtitles: 'subtitles',
  captions: 'captions',
  descriptions: 'descriptions',
  chapters: 'chapters',
  metadata: 'metadata'
};

/**
 * All possible `TextTrackMode`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode
 * @typedef TextTrack~Mode
 * @enum
 */
var TextTrackMode = {
  disabled: 'disabled',
  hidden: 'hidden',
  showing: 'showing'
};

/**
 * @file track.js
 */
/**
 * A Track class that contains all of the common functionality for {@link AudioTrack},
 * {@link VideoTrack}, and {@link TextTrack}.
 *
 * > Note: This class should not be used directly
 *
 * @see {@link https://html.spec.whatwg.org/multipage/embedded-content.html}
 * @extends EventTarget
 * @abstract
 */

var Track = function (_EventTarget) {
  inherits(Track, _EventTarget);

  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {string} [options.kind='']
   *        A valid kind for the track type you are creating.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @abstract
   */
  function Track() {
    var _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Track);

    var _this = possibleConstructorReturn(this, _EventTarget.call(this));

    var track = _this; // eslint-disable-line

    if (IS_IE8) {
      track = document.createElement('custom');
      for (var prop in Track.prototype) {
        if (prop !== 'constructor') {
          track[prop] = Track.prototype[prop];
        }
      }
    }

    var trackProps = {
      id: options.id || 'vjs_track_' + newGUID(),
      kind: options.kind || '',
      label: options.label || '',
      language: options.language || ''
    };

    /**
     * @memberof Track
     * @member {string} id
     *         The id of this track. Cannot be changed after creation.
     * @instance
     *
     * @readonly
     */

    /**
     * @memberof Track
     * @member {string} kind
     *         The kind of track that this is. Cannot be changed after creation.
     * @instance
     *
     * @readonly
     */

    /**
     * @memberof Track
     * @member {string} label
     *         The label of this track. Cannot be changed after creation.
     * @instance
     *
     * @readonly
     */

    /**
     * @memberof Track
     * @member {string} language
     *         The two letter language code for this track. Cannot be changed after
     *         creation.
     * @instance
     *
     * @readonly
     */

    var _loop = function _loop(key) {
      Object.defineProperty(track, key, {
        get: function get$$1() {
          return trackProps[key];
        },
        set: function set$$1() {}
      });
    };

    for (var key in trackProps) {
      _loop(key);
    }

    return _ret = track, possibleConstructorReturn(_this, _ret);
  }

  return Track;
}(EventTarget);

/**
 * @file url.js
 * @module url
 */
/**
 * @typedef {Object} url:URLObject
 *
 * @property {string} protocol
 *           The protocol of the url that was parsed.
 *
 * @property {string} hostname
 *           The hostname of the url that was parsed.
 *
 * @property {string} port
 *           The port of the url that was parsed.
 *
 * @property {string} pathname
 *           The pathname of the url that was parsed.
 *
 * @property {string} search
 *           The search query of the url that was parsed.
 *
 * @property {string} hash
 *           The hash of the url that was parsed.
 *
 * @property {string} host
 *           The host of the url that was parsed.
 */

/**
 * Resolve and parse the elements of a URL.
 *
 * @param  {String} url
 *         The url to parse
 *
 * @return {url:URLObject}
 *         An object of url details
 */
var parseUrl = function parseUrl(url) {
  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];

  // add the url to an anchor and let the browser parse the URL
  var a = document.createElement('a');

  a.href = url;

  // IE8 (and 9?) Fix
  // ie8 doesn't parse the URL correctly until the anchor is actually
  // added to the body, and an innerHTML is needed to trigger the parsing
  var addToBody = a.host === '' && a.protocol !== 'file:';
  var div = void 0;

  if (addToBody) {
    div = document.createElement('div');
    div.innerHTML = '<a href="' + url + '"></a>';
    a = div.firstChild;
    // prevent the div from affecting layout
    div.setAttribute('style', 'display:none; position:absolute;');
    document.body.appendChild(div);
  }

  // Copy the specific URL properties to a new object
  // This is also needed for IE8 because the anchor loses its
  // properties when it's removed from the dom
  var details = {};

  for (var i = 0; i < props.length; i++) {
    details[props[i]] = a[props[i]];
  }

  // IE9 adds the port to the host property unlike everyone else. If
  // a port identifier is added for standard ports, strip it.
  if (details.protocol === 'http:') {
    details.host = details.host.replace(/:80$/, '');
  }

  if (details.protocol === 'https:') {
    details.host = details.host.replace(/:443$/, '');
  }

  if (addToBody) {
    document.body.removeChild(div);
  }

  return details;
};

/**
 * Get absolute version of relative URL. Used to tell flash correct URL.
 *
 *
 * @param  {string} url
 *         URL to make absolute
 *
 * @return {string}
 *         Absolute URL
 *
 * @see http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue
 */
var getAbsoluteURL = function getAbsoluteURL(url) {
  // Check if absolute URL
  if (!url.match(/^https?:\/\//)) {
    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.
    var div = document.createElement('div');

    div.innerHTML = '<a href="' + url + '">x</a>';
    url = div.firstChild.href;
  }

  return url;
};

/**
 * Returns the extension of the passed file name. It will return an empty string
 * if passed an invalid path.
 *
 * @param {string} path
 *        The fileName path like '/path/to/file.mp4'
 *
 * @returns {string}
 *          The extension in lower case or an empty string if no
 *          extension could be found.
 */
var getFileExtension = function getFileExtension(path) {
  if (typeof path === 'string') {
    var splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/i;
    var pathParts = splitPathRe.exec(path);

    if (pathParts) {
      return pathParts.pop().toLowerCase();
    }
  }

  return '';
};

/**
 * Returns whether the url passed is a cross domain request or not.
 *
 * @param {string} url
 *        The url to check.
 *
 * @return {boolean}
 *         Whether it is a cross domain request or not.
 */
var isCrossOrigin = function isCrossOrigin(url) {
  var winLoc = window.location;
  var urlInfo = parseUrl(url);

  // IE8 protocol relative urls will return ':' for protocol
  var srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;

  // Check if url is for another domain/origin
  // IE8 doesn't know location.origin, so we won't rely on it here
  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;

  return crossOrigin;
};

var Url = (Object.freeze || Object)({
	parseUrl: parseUrl,
	getAbsoluteURL: getAbsoluteURL,
	getFileExtension: getFileExtension,
	isCrossOrigin: isCrossOrigin
});

/**
 * @file text-track.js
 */
/**
 * Takes a webvtt file contents and parses it into cues
 *
 * @param {string} srcContent
 *        webVTT file contents
 *
 * @param {TextTrack} track
 *        TextTrack to add cues to. Cues come from the srcContent.
 *
 * @private
 */
var parseCues = function parseCues(srcContent, track) {
  var parser = new window.WebVTT.Parser(window, window.vttjs, window.WebVTT.StringDecoder());
  var errors = [];

  parser.oncue = function (cue) {
    track.addCue(cue);
  };

  parser.onparsingerror = function (error) {
    errors.push(error);
  };

  parser.onflush = function () {
    track.trigger({
      type: 'loadeddata',
      target: track
    });
  };

  parser.parse(srcContent);
  if (errors.length > 0) {
    if (window.console && window.console.groupCollapsed) {
      window.console.groupCollapsed('Text Track parsing errors for ' + track.src);
    }
    errors.forEach(function (error) {
      return log$1.error(error);
    });
    if (window.console && window.console.groupEnd) {
      window.console.groupEnd();
    }
  }

  parser.flush();
};

/**
 * Load a `TextTrack` from a specifed url.
 *
 * @param {string} src
 *        Url to load track from.
 *
 * @param {TextTrack} track
 *        Track to add cues to. Comes from the content at the end of `url`.
 *
 * @private
 */
var loadTrack = function loadTrack(src, track) {
  var opts = {
    uri: src
  };
  var crossOrigin = isCrossOrigin(src);

  if (crossOrigin) {
    opts.cors = crossOrigin;
  }

  xhr(opts, bind(this, function (err, response, responseBody) {
    if (err) {
      return log$1.error(err, response);
    }

    track.loaded_ = true;

    // Make sure that vttjs has loaded, otherwise, wait till it finished loading
    // NOTE: this is only used for the alt/video.novtt.js build
    if (typeof window.WebVTT !== 'function') {
      if (track.tech_) {
        var loadHandler = function loadHandler() {
          return parseCues(responseBody, track);
        };

        track.tech_.on('vttjsloaded', loadHandler);
        track.tech_.on('vttjserror', function () {
          log$1.error('vttjs failed to load, stopping trying to process ' + track.src);
          track.tech_.off('vttjsloaded', loadHandler);
        });
      }
    } else {
      parseCues(responseBody, track);
    }
  }));
};

/**
 * A representation of a single `TextTrack`.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack}
 * @extends Track
 */

var TextTrack = function (_Track) {
  inherits(TextTrack, _Track);

  /**
   * Create an instance of this class.
   *
   * @param {Object} options={}
   *        Object of option names and values
   *
   * @param {Tech} options.tech
   *        A reference to the tech that owns this TextTrack.
   *
   * @param {TextTrack~Kind} [options.kind='subtitles']
   *        A valid text track kind.
   *
   * @param {TextTrack~Mode} [options.mode='disabled']
   *        A valid text track mode.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this TextTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {string} [options.srclang='']
   *        A valid two character language code. An alternative, but deprioritized
   *        vesion of `options.language`
   *
   * @param {string} [options.src]
   *        A url to TextTrack cues.
   *
   * @param {boolean} [options.default]
   *        If this track should default to on or off.
   */
  function TextTrack() {
    var _this, _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, TextTrack);

    if (!options.tech) {
      throw new Error('A tech was not provided.');
    }

    var settings = mergeOptions(options, {
      kind: TextTrackKind[options.kind] || 'subtitles',
      language: options.language || options.srclang || ''
    });
    var mode = TextTrackMode[settings.mode] || 'disabled';
    var default_ = settings['default'];

    if (settings.kind === 'metadata' || settings.kind === 'chapters') {
      mode = 'hidden';
    }
    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var tt = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);

    tt.tech_ = settings.tech;

    if (IS_IE8) {
      for (var prop in TextTrack.prototype) {
        if (prop !== 'constructor') {
          tt[prop] = TextTrack.prototype[prop];
        }
      }
    }

    tt.cues_ = [];
    tt.activeCues_ = [];

    var cues = new TextTrackCueList(tt.cues_);
    var activeCues = new TextTrackCueList(tt.activeCues_);
    var changed = false;
    var timeupdateHandler = bind(tt, function () {

      // Accessing this.activeCues for the side-effects of updating itself
      // due to it's nature as a getter function. Do not remove or cues will
      // stop updating!
      /* eslint-disable no-unused-expressions */
      this.activeCues;
      /* eslint-enable no-unused-expressions */
      if (changed) {
        this.trigger('cuechange');
        changed = false;
      }
    });

    if (mode !== 'disabled') {
      tt.tech_.ready(function () {
        tt.tech_.on('timeupdate', timeupdateHandler);
      }, true);
    }

    /**
     * @memberof TextTrack
     * @member {boolean} default
     *         If this track was set to be on or off by default. Cannot be changed after
     *         creation.
     * @instance
     *
     * @readonly
     */
    Object.defineProperty(tt, 'default', {
      get: function get$$1() {
        return default_;
      },
      set: function set$$1() {}
    });

    /**
     * @memberof TextTrack
     * @member {string} mode
     *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will
     *         not be set if setting to an invalid mode.
     * @instance
     *
     * @fires TextTrack#modechange
     */
    Object.defineProperty(tt, 'mode', {
      get: function get$$1() {
        return mode;
      },
      set: function set$$1(newMode) {
        var _this2 = this;

        if (!TextTrackMode[newMode]) {
          return;
        }
        mode = newMode;
        if (mode === 'showing') {

          this.tech_.ready(function () {
            _this2.tech_.on('timeupdate', timeupdateHandler);
          }, true);
        }
        /**
         * An event that fires when mode changes on this track. This allows
         * the TextTrackList that holds this track to act accordingly.
         *
         * > Note: This is not part of the spec!
         *
         * @event TextTrack#modechange
         * @type {EventTarget~Event}
         */
        this.trigger('modechange');
      }
    });

    /**
     * @memberof TextTrack
     * @member {TextTrackCueList} cues
     *         The text track cue list for this TextTrack.
     * @instance
     */
    Object.defineProperty(tt, 'cues', {
      get: function get$$1() {
        if (!this.loaded_) {
          return null;
        }

        return cues;
      },
      set: function set$$1() {}
    });

    /**
     * @memberof TextTrack
     * @member {TextTrackCueList} activeCues
     *         The list text track cues that are currently active for this TextTrack.
     * @instance
     */
    Object.defineProperty(tt, 'activeCues', {
      get: function get$$1() {
        if (!this.loaded_) {
          return null;
        }

        // nothing to do
        if (this.cues.length === 0) {
          return activeCues;
        }

        var ct = this.tech_.currentTime();
        var active = [];

        for (var i = 0, l = this.cues.length; i < l; i++) {
          var cue = this.cues[i];

          if (cue.startTime <= ct && cue.endTime >= ct) {
            active.push(cue);
          } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {
            active.push(cue);
          }
        }

        changed = false;

        if (active.length !== this.activeCues_.length) {
          changed = true;
        } else {
          for (var _i = 0; _i < active.length; _i++) {
            if (this.activeCues_.indexOf(active[_i]) === -1) {
              changed = true;
            }
          }
        }

        this.activeCues_ = active;
        activeCues.setCues_(this.activeCues_);

        return activeCues;
      },
      set: function set$$1() {}
    });

    if (settings.src) {
      tt.src = settings.src;
      loadTrack(settings.src, tt);
    } else {
      tt.loaded_ = true;
    }

    return _ret = tt, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a cue to the internal list of cues.
   *
   * @param {TextTrack~Cue} cue
   *        The cue to add to our internal list
   */


  TextTrack.prototype.addCue = function addCue(originalCue) {
    var cue = originalCue;

    if (window.vttjs && !(originalCue instanceof window.vttjs.VTTCue)) {
      cue = new window.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);

      for (var prop in originalCue) {
        if (!(prop in cue)) {
          cue[prop] = originalCue[prop];
        }
      }

      // make sure that `id` is copied over
      cue.id = originalCue.id;
      cue.originalCue_ = originalCue;
    }

    var tracks = this.tech_.textTracks();

    for (var i = 0; i < tracks.length; i++) {
      if (tracks[i] !== this) {
        tracks[i].removeCue(cue);
      }
    }

    this.cues_.push(cue);
    this.cues.setCues_(this.cues_);
  };

  /**
   * Remove a cue from our internal list
   *
   * @param {TextTrack~Cue} removeCue
   *        The cue to remove from our internal list
   */


  TextTrack.prototype.removeCue = function removeCue(_removeCue) {
    var i = this.cues_.length;

    while (i--) {
      var cue = this.cues_[i];

      if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {
        this.cues_.splice(i, 1);
        this.cues.setCues_(this.cues_);
        break;
      }
    }
  };

  return TextTrack;
}(Track);

/**
 * cuechange - One or more cues in the track have become active or stopped being active.
 */


TextTrack.prototype.allowedEvents_ = {
  cuechange: 'cuechange'
};

/**
 * A representation of a single `AudioTrack`. If it is part of an {@link AudioTrackList}
 * only one `AudioTrack` in the list will be enabled at a time.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack}
 * @extends Track
 */

var AudioTrack = function (_Track) {
  inherits(AudioTrack, _Track);

  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {AudioTrack~Kind} [options.kind='']
   *        A valid audio track kind
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {boolean} [options.enabled]
   *        If this track is the one that is currently playing. If this track is part of
   *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.
   */
  function AudioTrack() {
    var _this, _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, AudioTrack);

    var settings = mergeOptions(options, {
      kind: AudioTrackKind[options.kind] || ''
    });
    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var track = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);
    var enabled = false;

    if (IS_IE8) {
      for (var prop in AudioTrack.prototype) {
        if (prop !== 'constructor') {
          track[prop] = AudioTrack.prototype[prop];
        }
      }
    }
    /**
     * @memberof AudioTrack
     * @member {boolean} enabled
     *         If this `AudioTrack` is enabled or not. When setting this will
     *         fire {@link AudioTrack#enabledchange} if the state of enabled is changed.
     * @instance
     *
     * @fires VideoTrack#selectedchange
     */
    Object.defineProperty(track, 'enabled', {
      get: function get$$1() {
        return enabled;
      },
      set: function set$$1(newEnabled) {
        // an invalid or unchanged value
        if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {
          return;
        }
        enabled = newEnabled;

        /**
         * An event that fires when enabled changes on this track. This allows
         * the AudioTrackList that holds this track to act accordingly.
         *
         * > Note: This is not part of the spec! Native tracks will do
         *         this internally without an event.
         *
         * @event AudioTrack#enabledchange
         * @type {EventTarget~Event}
         */
        this.trigger('enabledchange');
      }
    });

    // if the user sets this track to selected then
    // set selected to that true value otherwise
    // we keep it false
    if (settings.enabled) {
      track.enabled = settings.enabled;
    }
    track.loaded_ = true;

    return _ret = track, possibleConstructorReturn(_this, _ret);
  }

  return AudioTrack;
}(Track);

/**
 * A representation of a single `VideoTrack`.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack}
 * @extends Track
 */

var VideoTrack = function (_Track) {
  inherits(VideoTrack, _Track);

  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {string} [options.kind='']
   *        A valid {@link VideoTrack~Kind}
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {boolean} [options.selected]
   *        If this track is the one that is currently playing.
   */
  function VideoTrack() {
    var _this, _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, VideoTrack);

    var settings = mergeOptions(options, {
      kind: VideoTrackKind[options.kind] || ''
    });

    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var track = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);
    var selected = false;

    if (IS_IE8) {
      for (var prop in VideoTrack.prototype) {
        if (prop !== 'constructor') {
          track[prop] = VideoTrack.prototype[prop];
        }
      }
    }

    /**
     * @memberof VideoTrack
     * @member {boolean} selected
     *         If this `VideoTrack` is selected or not. When setting this will
     *         fire {@link VideoTrack#selectedchange} if the state of selected changed.
     * @instance
     *
     * @fires VideoTrack#selectedchange
     */
    Object.defineProperty(track, 'selected', {
      get: function get$$1() {
        return selected;
      },
      set: function set$$1(newSelected) {
        // an invalid or unchanged value
        if (typeof newSelected !== 'boolean' || newSelected === selected) {
          return;
        }
        selected = newSelected;

        /**
         * An event that fires when selected changes on this track. This allows
         * the VideoTrackList that holds this track to act accordingly.
         *
         * > Note: This is not part of the spec! Native tracks will do
         *         this internally without an event.
         *
         * @event VideoTrack#selectedchange
         * @type {EventTarget~Event}
         */
        this.trigger('selectedchange');
      }
    });

    // if the user sets this track to selected then
    // set selected to that true value otherwise
    // we keep it false
    if (settings.selected) {
      track.selected = settings.selected;
    }

    return _ret = track, possibleConstructorReturn(_this, _ret);
  }

  return VideoTrack;
}(Track);

/**
 * @file html-track-element.js
 */

/**
 * @memberof HTMLTrackElement
 * @typedef {HTMLTrackElement~ReadyState}
 * @enum {number}
 */
var NONE = 0;
var LOADING = 1;
var LOADED = 2;
var ERROR = 3;

/**
 * A single track represented in the DOM.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement}
 * @extends EventTarget
 */

var HTMLTrackElement = function (_EventTarget) {
  inherits(HTMLTrackElement, _EventTarget);

  /**
   * Create an instance of this class.
   *
   * @param {Object} options={}
   *        Object of option names and values
   *
   * @param {Tech} options.tech
   *        A reference to the tech that owns this HTMLTrackElement.
   *
   * @param {TextTrack~Kind} [options.kind='subtitles']
   *        A valid text track kind.
   *
   * @param {TextTrack~Mode} [options.mode='disabled']
   *        A valid text track mode.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this TextTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {string} [options.srclang='']
   *        A valid two character language code. An alternative, but deprioritized
   *        vesion of `options.language`
   *
   * @param {string} [options.src]
   *        A url to TextTrack cues.
   *
   * @param {boolean} [options.default]
   *        If this track should default to on or off.
   */
  function HTMLTrackElement() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, HTMLTrackElement);

    var _this = possibleConstructorReturn(this, _EventTarget.call(this));

    var readyState = void 0;
    var trackElement = _this; // eslint-disable-line

    if (IS_IE8) {
      trackElement = document.createElement('custom');

      for (var prop in HTMLTrackElement.prototype) {
        if (prop !== 'constructor') {
          trackElement[prop] = HTMLTrackElement.prototype[prop];
        }
      }
    }

    var track = new TextTrack(options);

    trackElement.kind = track.kind;
    trackElement.src = track.src;
    trackElement.srclang = track.language;
    trackElement.label = track.label;
    trackElement['default'] = track['default'];

    /**
     * @memberof HTMLTrackElement
     * @member {HTMLTrackElement~ReadyState} readyState
     *         The current ready state of the track element.
     * @instance
     */
    Object.defineProperty(trackElement, 'readyState', {
      get: function get$$1() {
        return readyState;
      }
    });

    /**
     * @memberof HTMLTrackElement
     * @member {TextTrack} track
     *         The underlying TextTrack object.
     * @instance
     *
     */
    Object.defineProperty(trackElement, 'track', {
      get: function get$$1() {
        return track;
      }
    });

    readyState = NONE;

    /**
     * @listens TextTrack#loadeddata
     * @fires HTMLTrackElement#load
     */
    track.addEventListener('loadeddata', function () {
      readyState = LOADED;

      trackElement.trigger({
        type: 'load',
        target: trackElement
      });
    });

    if (IS_IE8) {
      var _ret;

      return _ret = trackElement, possibleConstructorReturn(_this, _ret);
    }
    return _this;
  }

  return HTMLTrackElement;
}(EventTarget);

HTMLTrackElement.prototype.allowedEvents_ = {
  load: 'load'
};

HTMLTrackElement.NONE = NONE;
HTMLTrackElement.LOADING = LOADING;
HTMLTrackElement.LOADED = LOADED;
HTMLTrackElement.ERROR = ERROR;

/*
 * This file contains all track properties that are used in
 * player.js, tech.js, html5.js and possibly other techs in the future.
 */

var NORMAL = {
  audio: {
    ListClass: AudioTrackList,
    TrackClass: AudioTrack,
    capitalName: 'Audio'
  },
  video: {
    ListClass: VideoTrackList,
    TrackClass: VideoTrack,
    capitalName: 'Video'
  },
  text: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: 'Text'
  }
};

Object.keys(NORMAL).forEach(function (type) {
  NORMAL[type].getterName = type + 'Tracks';
  NORMAL[type].privateName = type + 'Tracks_';
});

var REMOTE = {
  remoteText: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: 'RemoteText',
    getterName: 'remoteTextTracks',
    privateName: 'remoteTextTracks_'
  },
  remoteTextEl: {
    ListClass: HtmlTrackElementList,
    TrackClass: HTMLTrackElement,
    capitalName: 'RemoteTextTrackEls',
    getterName: 'remoteTextTrackEls',
    privateName: 'remoteTextTrackEls_'
  }
};

var ALL = mergeOptions(NORMAL, REMOTE);

REMOTE.names = Object.keys(REMOTE);
NORMAL.names = Object.keys(NORMAL);
ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);

/**
 * @file tech.js
 */

/**
 * An Object containing a structure like: `{src: 'url', type: 'mimetype'}` or string
 * that just contains the src url alone.
 * * `var SourceObject = {src: 'http://ex.com/video.mp4', type: 'video/mp4'};`
   * `var SourceString = 'http://example.com/some-video.mp4';`
 *
 * @typedef {Object|string} Tech~SourceObject
 *
 * @property {string} src
 *           The url to the source
 *
 * @property {string} type
 *           The mime type of the source
 */

/**
 * A function used by {@link Tech} to create a new {@link TextTrack}.
 *
 * @private
 *
 * @param {Tech} self
 *        An instance of the Tech class.
 *
 * @param {string} kind
 *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
 *
 * @param {string} [label]
 *        Label to identify the text track
 *
 * @param {string} [language]
 *        Two letter language abbreviation
 *
 * @param {Object} [options={}]
 *        An object with additional text track options
 *
 * @return {TextTrack}
 *          The text track that was created.
 */
function createTrackHelper(self, kind, label, language) {
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

  var tracks = self.textTracks();

  options.kind = kind;

  if (label) {
    options.label = label;
  }
  if (language) {
    options.language = language;
  }
  options.tech = self;

  var track = new ALL.text.TrackClass(options);

  tracks.addTrack(track);

  return track;
}

/**
 * This is the base class for media playback technology controllers, such as
 * {@link Flash} and {@link HTML5}
 *
 * @extends Component
 */

var Tech = function (_Component) {
  inherits(Tech, _Component);

  /**
   * Create an instance of this Tech.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} ready
   *        Callback function to call when the `HTML5` Tech is ready.
   */
  function Tech() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var ready = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
    classCallCheck(this, Tech);

    // we don't want the tech to report user activity automatically.
    // This is done manually in addControlsListeners
    options.reportTouchActivity = false;

    // keep track of whether the current source has played at all to
    // implement a very limited played()
    var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));

    _this.hasStarted_ = false;
    _this.on('playing', function () {
      this.hasStarted_ = true;
    });
    _this.on('loadstart', function () {
      this.hasStarted_ = false;
    });

    ALL.names.forEach(function (name) {
      var props = ALL[name];

      if (options && options[props.getterName]) {
        _this[props.privateName] = options[props.getterName];
      }
    });

    // Manually track progress in cases where the browser/flash player doesn't report it.
    if (!_this.featuresProgressEvents) {
      _this.manualProgressOn();
    }

    // Manually track timeupdates in cases where the browser/flash player doesn't report it.
    if (!_this.featuresTimeupdateEvents) {
      _this.manualTimeUpdatesOn();
    }

    ['Text', 'Audio', 'Video'].forEach(function (track) {
      if (options['native' + track + 'Tracks'] === false) {
        _this['featuresNative' + track + 'Tracks'] = false;
      }
    });

    if (options.nativeCaptions === false || options.nativeTextTracks === false) {
      _this.featuresNativeTextTracks = false;
    } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {
      _this.featuresNativeTextTracks = true;
    }

    if (!_this.featuresNativeTextTracks) {
      _this.emulateTextTracks();
    }

    _this.autoRemoteTextTracks_ = new ALL.text.ListClass();

    _this.initTrackListeners();

    // Turn on component tap events only if not using native controls
    if (!options.nativeControlsForTouch) {
      _this.emitTapEvents();
    }

    if (_this.constructor) {
      _this.name_ = _this.constructor.name || 'Unknown Tech';
    }
    return _this;
  }

  /* Fallbacks for unsupported event types
  ================================================================================ */

  /**
   * Polyfill the `progress` event for browsers that don't support it natively.
   *
   * @see {@link Tech#trackProgress}
   */


  Tech.prototype.manualProgressOn = function manualProgressOn() {
    this.on('durationchange', this.onDurationChange);

    this.manualProgress = true;

    // Trigger progress watching when a source begins loading
    this.one('ready', this.trackProgress);
  };

  /**
   * Turn off the polyfill for `progress` events that was created in
   * {@link Tech#manualProgressOn}
   */


  Tech.prototype.manualProgressOff = function manualProgressOff() {
    this.manualProgress = false;
    this.stopTrackingProgress();

    this.off('durationchange', this.onDurationChange);
  };

  /**
   * This is used to trigger a `progress` event when the buffered percent changes. It
   * sets an interval function that will be called every 500 milliseconds to check if the
   * buffer end percent has changed.
   *
   * > This function is called by {@link Tech#manualProgressOn}
   *
   * @param {EventTarget~Event} event
   *        The `ready` event that caused this to run.
   *
   * @listens Tech#ready
   * @fires Tech#progress
   */


  Tech.prototype.trackProgress = function trackProgress(event) {
    this.stopTrackingProgress();
    this.progressInterval = this.setInterval(bind(this, function () {
      // Don't trigger unless buffered amount is greater than last time

      var numBufferedPercent = this.bufferedPercent();

      if (this.bufferedPercent_ !== numBufferedPercent) {
        /**
         * See {@link Player#progress}
         *
         * @event Tech#progress
         * @type {EventTarget~Event}
         */
        this.trigger('progress');
      }

      this.bufferedPercent_ = numBufferedPercent;

      if (numBufferedPercent === 1) {
        this.stopTrackingProgress();
      }
    }), 500);
  };

  /**
   * Update our internal duration on a `durationchange` event by calling
   * {@link Tech#duration}.
   *
   * @param {EventTarget~Event} event
   *        The `durationchange` event that caused this to run.
   *
   * @listens Tech#durationchange
   */


  Tech.prototype.onDurationChange = function onDurationChange(event) {
    this.duration_ = this.duration();
  };

  /**
   * Get and create a `TimeRange` object for buffering.
   *
   * @return {TimeRange}
   *         The time range object that was created.
   */


  Tech.prototype.buffered = function buffered() {
    return createTimeRanges(0, 0);
  };

  /**
   * Get the percentage of the current video that is currently buffered.
   *
   * @return {number}
   *         A number from 0 to 1 that represents the decimal percentage of the
   *         video that is buffered.
   *
   */


  Tech.prototype.bufferedPercent = function bufferedPercent$$1() {
    return bufferedPercent(this.buffered(), this.duration_);
  };

  /**
   * Turn off the polyfill for `progress` events that was created in
   * {@link Tech#manualProgressOn}
   * Stop manually tracking progress events by clearing the interval that was set in
   * {@link Tech#trackProgress}.
   */


  Tech.prototype.stopTrackingProgress = function stopTrackingProgress() {
    this.clearInterval(this.progressInterval);
  };

  /**
   * Polyfill the `timeupdate` event for browsers that don't support it.
   *
   * @see {@link Tech#trackCurrentTime}
   */


  Tech.prototype.manualTimeUpdatesOn = function manualTimeUpdatesOn() {
    this.manualTimeUpdates = true;

    this.on('play', this.trackCurrentTime);
    this.on('pause', this.stopTrackingCurrentTime);
  };

  /**
   * Turn off the polyfill for `timeupdate` events that was created in
   * {@link Tech#manualTimeUpdatesOn}
   */


  Tech.prototype.manualTimeUpdatesOff = function manualTimeUpdatesOff() {
    this.manualTimeUpdates = false;
    this.stopTrackingCurrentTime();
    this.off('play', this.trackCurrentTime);
    this.off('pause', this.stopTrackingCurrentTime);
  };

  /**
   * Sets up an interval function to track current time and trigger `timeupdate` every
   * 250 milliseconds.
   *
   * @listens Tech#play
   * @triggers Tech#timeupdate
   */


  Tech.prototype.trackCurrentTime = function trackCurrentTime() {
    if (this.currentTimeInterval) {
      this.stopTrackingCurrentTime();
    }
    this.currentTimeInterval = this.setInterval(function () {
      /**
       * Triggered at an interval of 250ms to indicated that time is passing in the video.
       *
       * @event Tech#timeupdate
       * @type {EventTarget~Event}
       */
      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });

      // 42 = 24 fps // 250 is what Webkit uses // FF uses 15
    }, 250);
  };

  /**
   * Stop the interval function created in {@link Tech#trackCurrentTime} so that the
   * `timeupdate` event is no longer triggered.
   *
   * @listens {Tech#pause}
   */


  Tech.prototype.stopTrackingCurrentTime = function stopTrackingCurrentTime() {
    this.clearInterval(this.currentTimeInterval);

    // #1002 - if the video ends right before the next timeupdate would happen,
    // the progress bar won't make it all the way to the end
    this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
  };

  /**
   * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},
   * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.
   *
   * @fires Component#dispose
   */


  Tech.prototype.dispose = function dispose() {

    // clear out all tracks because we can't reuse them between techs
    this.clearTracks(NORMAL.names);

    // Turn off any manual progress or timeupdate tracking
    if (this.manualProgress) {
      this.manualProgressOff();
    }

    if (this.manualTimeUpdates) {
      this.manualTimeUpdatesOff();
    }

    _Component.prototype.dispose.call(this);
  };

  /**
   * Clear out a single `TrackList` or an array of `TrackLists` given their names.
   *
   * > Note: Techs without source handlers should call this between sources for `video`
   *         & `audio` tracks. You don't want to use them between tracks!
   *
   * @param {string[]|string} types
   *        TrackList names to clear, valid names are `video`, `audio`, and
   *        `text`.
   */


  Tech.prototype.clearTracks = function clearTracks(types) {
    var _this2 = this;

    types = [].concat(types);
    // clear out all tracks because we can't reuse them between techs
    types.forEach(function (type) {
      var list = _this2[type + 'Tracks']() || [];
      var i = list.length;

      while (i--) {
        var track = list[i];

        if (type === 'text') {
          _this2.removeRemoteTextTrack(track);
        }
        list.removeTrack(track);
      }
    });
  };

  /**
   * Remove any TextTracks added via addRemoteTextTrack that are
   * flagged for automatic garbage collection
   */


  Tech.prototype.cleanupAutoTextTracks = function cleanupAutoTextTracks() {
    var list = this.autoRemoteTextTracks_ || [];
    var i = list.length;

    while (i--) {
      var track = list[i];

      this.removeRemoteTextTrack(track);
    }
  };

  /**
   * Reset the tech, which will removes all sources and reset the internal readyState.
   *
   * @abstract
   */


  Tech.prototype.reset = function reset() {};

  /**
   * Get or set an error on the Tech.
   *
   * @param {MediaError} [err]
   *        Error to set on the Tech
   *
   * @return {MediaError|null}
   *         The current error object on the tech, or null if there isn't one.
   */


  Tech.prototype.error = function error(err) {
    if (err !== undefined) {
      this.error_ = new MediaError(err);
      this.trigger('error');
    }
    return this.error_;
  };

  /**
   * Returns the `TimeRange`s that have been played through for the current source.
   *
   * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.
   *         It only checks wether the source has played at all or not.
   *
   * @return {TimeRange}
   *         - A single time range if this video has played
   *         - An empty set of ranges if not.
   */


  Tech.prototype.played = function played() {
    if (this.hasStarted_) {
      return createTimeRanges(0, 0);
    }
    return createTimeRanges();
  };

  /**
   * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was
   * previously called.
   *
   * @fires Tech#timeupdate
   */


  Tech.prototype.setCurrentTime = function setCurrentTime() {
    // improve the accuracy of manual timeupdates
    if (this.manualTimeUpdates) {
      /**
       * A manual `timeupdate` event.
       *
       * @event Tech#timeupdate
       * @type {EventTarget~Event}
       */
      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
    }
  };

  /**
   * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and
   * {@link TextTrackList} events.
   *
   * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.
   *
   * @fires Tech#audiotrackchange
   * @fires Tech#videotrackchange
   * @fires Tech#texttrackchange
   */


  Tech.prototype.initTrackListeners = function initTrackListeners() {
    var _this3 = this;

    /**
     * Triggered when tracks are added or removed on the Tech {@link AudioTrackList}
     *
     * @event Tech#audiotrackchange
     * @type {EventTarget~Event}
     */

    /**
     * Triggered when tracks are added or removed on the Tech {@link VideoTrackList}
     *
     * @event Tech#videotrackchange
     * @type {EventTarget~Event}
     */

    /**
     * Triggered when tracks are added or removed on the Tech {@link TextTrackList}
     *
     * @event Tech#texttrackchange
     * @type {EventTarget~Event}
     */
    NORMAL.names.forEach(function (name) {
      var props = NORMAL[name];
      var trackListChanges = function trackListChanges() {
        _this3.trigger(name + 'trackchange');
      };

      var tracks = _this3[props.getterName]();

      tracks.addEventListener('removetrack', trackListChanges);
      tracks.addEventListener('addtrack', trackListChanges);

      _this3.on('dispose', function () {
        tracks.removeEventListener('removetrack', trackListChanges);
        tracks.removeEventListener('addtrack', trackListChanges);
      });
    });
  };

  /**
   * Emulate TextTracks using vtt.js if necessary
   *
   * @fires Tech#vttjsloaded
   * @fires Tech#vttjserror
   */


  Tech.prototype.addWebVttScript_ = function addWebVttScript_() {
    var _this4 = this;

    if (window.WebVTT) {
      return;
    }

    // Initially, Tech.el_ is a child of a dummy-div wait until the Component system
    // signals that the Tech is ready at which point Tech.el_ is part of the DOM
    // before inserting the WebVTT script
    if (document.body.contains(this.el())) {

      // load via require if available and vtt.js script location was not passed in
      // as an option. novtt builds will turn the above require call into an empty object
      // which will cause this if check to always fail.
      if (!this.options_['vtt.js'] && isPlain(vtt) && Object.keys(vtt).length > 0) {
        this.trigger('vttjsloaded');
        return;
      }

      // load vtt.js via the script location option or the cdn of no location was
      // passed in
      var script = document.createElement('script');

      script.src = this.options_['vtt.js'] || 'https://vjs.zencdn.net/vttjs/0.12.4/vtt.min.js';
      script.onload = function () {
        /**
         * Fired when vtt.js is loaded.
         *
         * @event Tech#vttjsloaded
         * @type {EventTarget~Event}
         */
        _this4.trigger('vttjsloaded');
      };
      script.onerror = function () {
        /**
         * Fired when vtt.js was not loaded due to an error
         *
         * @event Tech#vttjsloaded
         * @type {EventTarget~Event}
         */
        _this4.trigger('vttjserror');
      };
      this.on('dispose', function () {
        script.onload = null;
        script.onerror = null;
      });
      // but have not loaded yet and we set it to true before the inject so that
      // we don't overwrite the injected window.WebVTT if it loads right away
      window.WebVTT = true;
      this.el().parentNode.appendChild(script);
    } else {
      this.ready(this.addWebVttScript_);
    }
  };

  /**
   * Emulate texttracks
   *
   */


  Tech.prototype.emulateTextTracks = function emulateTextTracks() {
    var _this5 = this;

    var tracks = this.textTracks();
    var remoteTracks = this.remoteTextTracks();
    var handleAddTrack = function handleAddTrack(e) {
      return tracks.addTrack(e.track);
    };
    var handleRemoveTrack = function handleRemoveTrack(e) {
      return tracks.removeTrack(e.track);
    };

    remoteTracks.on('addtrack', handleAddTrack);
    remoteTracks.on('removetrack', handleRemoveTrack);

    this.addWebVttScript_();

    var updateDisplay = function updateDisplay() {
      return _this5.trigger('texttrackchange');
    };

    var textTracksChanges = function textTracksChanges() {
      updateDisplay();

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        track.removeEventListener('cuechange', updateDisplay);
        if (track.mode === 'showing') {
          track.addEventListener('cuechange', updateDisplay);
        }
      }
    };

    textTracksChanges();
    tracks.addEventListener('change', textTracksChanges);
    tracks.addEventListener('addtrack', textTracksChanges);
    tracks.addEventListener('removetrack', textTracksChanges);

    this.on('dispose', function () {
      remoteTracks.off('addtrack', handleAddTrack);
      remoteTracks.off('removetrack', handleRemoveTrack);
      tracks.removeEventListener('change', textTracksChanges);
      tracks.removeEventListener('addtrack', textTracksChanges);
      tracks.removeEventListener('removetrack', textTracksChanges);

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        track.removeEventListener('cuechange', updateDisplay);
      }
    });
  };

  /**
   * Create and returns a remote {@link TextTrack} object.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @return {TextTrack}
   *         The TextTrack that gets created.
   */


  Tech.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (!kind) {
      throw new Error('TextTrack kind is required but was not provided');
    }

    return createTrackHelper(this, kind, label, language);
  };

  /**
   * Create an emulated TextTrack for use by addRemoteTextTrack
   *
   * This is intended to be overridden by classes that inherit from
   * Tech in order to create native or custom TextTracks.
   *
   * @param {Object} options
   *        The object should contain the options to initialize the TextTrack with.
   *
   * @param {string} [options.kind]
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
   *
   * @param {string} [options.label].
   *        Label to identify the text track
   *
   * @param {string} [options.language]
   *        Two letter language abbreviation.
   *
   * @return {HTMLTrackElement}
   *         The track element that gets created.
   */


  Tech.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {
    var track = mergeOptions(options, {
      tech: this
    });

    return new REMOTE.remoteTextEl.TrackClass(track);
  };

  /**
   * Creates a remote text track object and returns an html track element.
   *
   * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.
   *
   * @param {Object} options
   *        See {@link Tech#createRemoteTextTrack} for more detailed properties.
   *
   * @param {boolean} [manualCleanup=true]
   *        - When false: the TextTrack will be automatically removed from the video
   *          element whenever the source changes
   *        - When True: The TextTrack will have to be cleaned up manually
   *
   * @return {HTMLTrackElement}
   *         An Html Track Element.
   *
   * @deprecated The default functionality for this function will be equivalent
   *             to "manualCleanup=false" in the future. The manualCleanup parameter will
   *             also be removed.
   */


  Tech.prototype.addRemoteTextTrack = function addRemoteTextTrack() {
    var _this6 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var manualCleanup = arguments[1];

    var htmlTrackElement = this.createRemoteTextTrack(options);

    if (manualCleanup !== true && manualCleanup !== false) {
      // deprecation warning
      log$1.warn('Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js');
      manualCleanup = true;
    }

    // store HTMLTrackElement and TextTrack to remote list
    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
    this.remoteTextTracks().addTrack(htmlTrackElement.track);

    if (manualCleanup !== true) {
      // create the TextTrackList if it doesn't exist
      this.ready(function () {
        return _this6.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);
      });
    }

    return htmlTrackElement;
  };

  /**
   * Remove a remote text track from the remote `TextTrackList`.
   *
   * @param {TextTrack} track
   *        `TextTrack` to remove from the `TextTrackList`
   */


  Tech.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);

    // remove HTMLTrackElement and TextTrack from remote list
    this.remoteTextTrackEls().removeTrackElement_(trackElement);
    this.remoteTextTracks().removeTrack(track);
    this.autoRemoteTextTracks_.removeTrack(track);
  };

  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   *
   * @abstract
   */


  Tech.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    return {};
  };

  /**
   * A method to set a poster from a `Tech`.
   *
   * @abstract
   */


  Tech.prototype.setPoster = function setPoster() {};

  /**
   * A method to check for the presence of the 'playsinine' <video> attribute.
   *
   * @abstract
   */


  Tech.prototype.playsinline = function playsinline() {};

  /**
   * A method to set or unset the 'playsinine' <video> attribute.
   *
   * @abstract
   */


  Tech.prototype.setPlaysinline = function setPlaysinline() {};

  /*
   * Check if the tech can support the given mime-type.
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param  {string} type
   *         The mimetype to check for support
   *
   * @return {string}
   *         'probably', 'maybe', or empty string
   *
   * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}
   *
   * @abstract
   */


  Tech.prototype.canPlayType = function canPlayType() {
    return '';
  };

  /**
   * Check if the type is supported by this tech.
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param {string} type
   *        The media type to check
   * @return {string} Returns the native video element's response
   */


  Tech.canPlayType = function canPlayType() {
    return '';
  };

  /**
   * Check if the tech can support the given source
   * @param {Object} srcObj
   *        The source object
   * @param {Object} options
   *        The options passed to the tech
   * @return {string} 'probably', 'maybe', or '' (empty string)
   */


  Tech.canPlaySource = function canPlaySource(srcObj, options) {
    return Tech.canPlayType(srcObj.type);
  };

  /*
   * Return whether the argument is a Tech or not.
   * Can be passed either a Class like `Html5` or a instance like `player.tech_`
   *
   * @param {Object} component
   *        The item to check
   *
   * @return {boolean}
   *         Whether it is a tech or not
   *         - True if it is a tech
   *         - False if it is not
   */


  Tech.isTech = function isTech(component) {
    return component.prototype instanceof Tech || component instanceof Tech || component === Tech;
  };

  /**
   * Registers a `Tech` into a shared list for videojs.
   *
   * @param {string} name
   *        Name of the `Tech` to register.
   *
   * @param {Object} tech
   *        The `Tech` class to register.
   */


  Tech.registerTech = function registerTech(name, tech) {
    if (!Tech.techs_) {
      Tech.techs_ = {};
    }

    if (!Tech.isTech(tech)) {
      throw new Error('Tech ' + name + ' must be a Tech');
    }

    if (!Tech.canPlayType) {
      throw new Error('Techs must have a static canPlayType method on them');
    }
    if (!Tech.canPlaySource) {
      throw new Error('Techs must have a static canPlaySource method on them');
    }

    name = toTitleCase(name);

    Tech.techs_[name] = tech;
    if (name !== 'Tech') {
      // camel case the techName for use in techOrder
      Tech.defaultTechOrder_.push(name);
    }
    return tech;
  };

  /**
   * Get a `Tech` from the shared list by name.
   *
   * @param {string} name
   *        `camelCase` or `TitleCase` name of the Tech to get
   *
   * @return {Tech|undefined}
   *         The `Tech` or undefined if there was no tech with the name requsted.
   */


  Tech.getTech = function getTech(name) {
    if (!name) {
      return;
    }

    name = toTitleCase(name);

    if (Tech.techs_ && Tech.techs_[name]) {
      return Tech.techs_[name];
    }

    if (window && window.videojs && window.videojs[name]) {
      log$1.warn('The ' + name + ' tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)');
      return window.videojs[name];
    }
  };

  return Tech;
}(Component);

/**
 * Get the {@link VideoTrackList}
 *
 * @returns {VideoTrackList}
 * @method Tech.prototype.videoTracks
 */

/**
 * Get the {@link AudioTrackList}
 *
 * @returns {AudioTrackList}
 * @method Tech.prototype.audioTracks
 */

/**
 * Get the {@link TextTrackList}
 *
 * @returns {TextTrackList}
 * @method Tech.prototype.textTracks
 */

/**
 * Get the remote element {@link TextTrackList}
 *
 * @returns {TextTrackList}
 * @method Tech.prototype.remoteTextTracks
 */

/**
 * Get the remote element {@link HtmlTrackElementList}
 *
 * @returns {HtmlTrackElementList}
 * @method Tech.prototype.remoteTextTrackEls
 */

ALL.names.forEach(function (name) {
  var props = ALL[name];

  Tech.prototype[props.getterName] = function () {
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});

/**
 * List of associated text tracks
 *
 * @type {TextTrackList}
 * @private
 * @property Tech#textTracks_
 */

/**
 * List of associated audio tracks.
 *
 * @type {AudioTrackList}
 * @private
 * @property Tech#audioTracks_
 */

/**
 * List of associated video tracks.
 *
 * @type {VideoTrackList}
 * @private
 * @property Tech#videoTracks_
 */

/**
 * Boolean indicating wether the `Tech` supports volume control.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresVolumeControl = true;

/**
 * Boolean indicating wether the `Tech` support fullscreen resize control.
 * Resizing plugins using request fullscreen reloads the plugin
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresFullscreenResize = false;

/**
 * Boolean indicating wether the `Tech` supports changing the speed at which the video
 * plays. Examples:
 *   - Set player to play 2x (twice) as fast
 *   - Set player to play 0.5x (half) as fast
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresPlaybackRate = false;

/**
 * Boolean indicating wether the `Tech` supports the `progress` event. This is currently
 * not triggered by video-js-swf. This will be used to determine if
 * {@link Tech#manualProgressOn} should be called.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresProgressEvents = false;

/**
 * Boolean indicating wether the `Tech` supports the `timeupdate` event. This is currently
 * not triggered by video-js-swf. This will be used to determine if
 * {@link Tech#manualTimeUpdates} should be called.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresTimeupdateEvents = false;

/**
 * Boolean indicating wether the `Tech` supports the native `TextTrack`s.
 * This will help us integrate with native `TextTrack`s if the browser supports them.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresNativeTextTracks = false;

/**
 * A functional mixin for techs that want to use the Source Handler pattern.
 * Source handlers are scripts for handling specific formats.
 * The source handler pattern is used for adaptive formats (HLS, DASH) that
 * manually load video data and feed it into a Source Buffer (Media Source Extensions)
 * Example: `Tech.withSourceHandlers.call(MyTech);`
 *
 * @param {Tech} _Tech
 *        The tech to add source handler functions to.
 *
 * @mixes Tech~SourceHandlerAdditions
 */
Tech.withSourceHandlers = function (_Tech) {

  /**
   * Register a source handler
   *
   * @param {Function} handler
   *        The source handler class
   *
   * @param {number} [index]
   *        Register it at the following index
   */
  _Tech.registerSourceHandler = function (handler, index) {
    var handlers = _Tech.sourceHandlers;

    if (!handlers) {
      handlers = _Tech.sourceHandlers = [];
    }

    if (index === undefined) {
      // add to the end of the list
      index = handlers.length;
    }

    handlers.splice(index, 0, handler);
  };

  /**
   * Check if the tech can support the given type. Also checks the
   * Techs sourceHandlers.
   *
   * @param {string} type
   *         The mimetype to check.
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */
  _Tech.canPlayType = function (type) {
    var handlers = _Tech.sourceHandlers || [];
    var can = void 0;

    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canPlayType(type);

      if (can) {
        return can;
      }
    }

    return '';
  };

  /**
   * Returns the first source handler that supports the source.
   *
   * TODO: Answer question: should 'probably' be prioritized over 'maybe'
   *
   * @param {Tech~SourceObject} source
   *        The source object
   *
   * @param {Object} options
   *        The options passed to the tech
   *
   * @return {SourceHandler|null}
   *          The first source handler that supports the source or null if
   *          no SourceHandler supports the source
   */
  _Tech.selectSourceHandler = function (source, options) {
    var handlers = _Tech.sourceHandlers || [];
    var can = void 0;

    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canHandleSource(source, options);

      if (can) {
        return handlers[i];
      }
    }

    return null;
  };

  /**
   * Check if the tech can support the given source.
   *
   * @param {Tech~SourceObject} srcObj
   *        The source object
   *
   * @param {Object} options
   *        The options passed to the tech
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */
  _Tech.canPlaySource = function (srcObj, options) {
    var sh = _Tech.selectSourceHandler(srcObj, options);

    if (sh) {
      return sh.canHandleSource(srcObj, options);
    }

    return '';
  };

  /**
   * When using a source handler, prefer its implementation of
   * any function normally provided by the tech.
   */
  var deferrable = ['seekable', 'duration'];

  /**
   * A wrapper around {@link Tech#seekable} that will call a `SourceHandler`s seekable
   * function if it exists, with a fallback to the Techs seekable function.
   *
   * @method _Tech.seekable
   */

  /**
   * A wrapper around {@link Tech#duration} that will call a `SourceHandler`s duration
   * function if it exists, otherwise it will fallback to the techs duration function.
   *
   * @method _Tech.duration
   */

  deferrable.forEach(function (fnName) {
    var originalFn = this[fnName];

    if (typeof originalFn !== 'function') {
      return;
    }

    this[fnName] = function () {
      if (this.sourceHandler_ && this.sourceHandler_[fnName]) {
        return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
      }
      return originalFn.apply(this, arguments);
    };
  }, _Tech.prototype);

  /**
   * Create a function for setting the source using a source object
   * and source handlers.
   * Should never be called unless a source handler was found.
   *
   * @param {Tech~SourceObject} source
   *        A source object with src and type keys
   */
  _Tech.prototype.setSource = function (source) {
    var sh = _Tech.selectSourceHandler(source, this.options_);

    if (!sh) {
      // Fall back to a native source hander when unsupported sources are
      // deliberately set
      if (_Tech.nativeSourceHandler) {
        sh = _Tech.nativeSourceHandler;
      } else {
        log$1.error('No source hander found for the current source.');
      }
    }

    // Dispose any existing source handler
    this.disposeSourceHandler();
    this.off('dispose', this.disposeSourceHandler);

    if (sh !== _Tech.nativeSourceHandler) {
      this.currentSource_ = source;
    }

    this.sourceHandler_ = sh.handleSource(source, this, this.options_);
    this.on('dispose', this.disposeSourceHandler);
  };

  /**
   * Clean up any existing SourceHandlers and listeners when the Tech is disposed.
   *
   * @listens Tech#dispose
   */
  _Tech.prototype.disposeSourceHandler = function () {
    // if we have a source and get another one
    // then we are loading something new
    // than clear all of our current tracks
    if (this.currentSource_) {
      this.clearTracks(['audio', 'video']);
      this.currentSource_ = null;
    }

    // always clean up auto-text tracks
    this.cleanupAutoTextTracks();

    if (this.sourceHandler_) {

      if (this.sourceHandler_.dispose) {
        this.sourceHandler_.dispose();
      }

      this.sourceHandler_ = null;
    }
  };
};

// The base Tech class needs to be registered as a Component. It is the only
// Tech that can be registered as a Component.
Component.registerComponent('Tech', Tech);
Tech.registerTech('Tech', Tech);

/**
 * A list of techs that should be added to techOrder on Players
 *
 * @private
 */
Tech.defaultTechOrder_ = [];

var middlewares = {};

function use(type, middleware) {
  middlewares[type] = middlewares[type] || [];
  middlewares[type].push(middleware);
}



function setSource(player, src, next) {
  player.setTimeout(function () {
    return setSourceHelper(src, middlewares[src.type], next, player);
  }, 1);
}

function setTech(middleware, tech) {
  middleware.forEach(function (mw) {
    return mw.setTech && mw.setTech(tech);
  });
}

function get$1(middleware, tech, method) {
  return middleware.reduceRight(middlewareIterator(method), tech[method]());
}

function set$1(middleware, tech, method, arg) {
  return tech[method](middleware.reduce(middlewareIterator(method), arg));
}

var allowedGetters = {
  buffered: 1,
  currentTime: 1,
  duration: 1,
  seekable: 1,
  played: 1
};

var allowedSetters = {
  setCurrentTime: 1
};

function middlewareIterator(method) {
  return function (value, mw) {
    if (mw[method]) {
      return mw[method](value);
    }

    return value;
  };
}

function setSourceHelper() {
  var src = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var middleware = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var next = arguments[2];
  var player = arguments[3];
  var acc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
  var lastRun = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var mwFactory = middleware[0],
      mwrest = middleware.slice(1);

  // if mwFactory is a string, then we're at a fork in the road

  if (typeof mwFactory === 'string') {
    setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);

    // if we have an mwFactory, call it with the player to get the mw,
    // then call the mw's setSource method
  } else if (mwFactory) {
    var mw = mwFactory(player);

    mw.setSource(assign({}, src), function (err, _src) {

      // something happened, try the next middleware on the current level
      // make sure to use the old src
      if (err) {
        return setSourceHelper(src, mwrest, next, player, acc, lastRun);
      }

      // we've succeeded, now we need to go deeper
      acc.push(mw);

      // if it's the same time, continue does the current chain
      // otherwise, we want to go down the new chain
      setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);
    });
  } else if (mwrest.length) {
    setSourceHelper(src, mwrest, next, player, acc, lastRun);
  } else if (lastRun) {
    next(src, acc);
  } else {
    setSourceHelper(src, middlewares['*'], next, player, acc, true);
  }
}

/**
 * @module filter-source
 */
/**
 * Filter out single bad source objects or multiple source objects in an
 * array. Also flattens nested source object arrays into a 1 dimensional
 * array of source objects.
 *
 * @param {Tech~SourceObject|Tech~SourceObject[]} src
 *        The src object to filter
 *
 * @return {Tech~SourceObject[]}
 *         An array of sourceobjects containing only valid sources
 *
 * @private
 */
var filterSource = function filterSource(src) {
  // traverse array
  if (Array.isArray(src)) {
    var newsrc = [];

    src.forEach(function (srcobj) {
      srcobj = filterSource(srcobj);

      if (Array.isArray(srcobj)) {
        newsrc = newsrc.concat(srcobj);
      } else if (isObject(srcobj)) {
        newsrc.push(srcobj);
      }
    });

    src = newsrc;
  } else if (typeof src === 'string' && src.trim()) {
    // convert string into object
    src = [{ src: src }];
  } else if (isObject(src) && typeof src.src === 'string' && src.src && src.src.trim()) {
    // src is already valid
    src = [src];
  } else {
    // invalid source, turn it into an empty array
    src = [];
  }

  return src;
};

/**
 * @file loader.js
 */
/**
 * The `MediaLoader` is the `Component` that decides which playback technology to load
 * when a player is initialized.
 *
 * @extends Component
 */

var MediaLoader = function (_Component) {
  inherits(MediaLoader, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value stroe of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function that is run when this component is ready.
   */
  function MediaLoader(player, options, ready) {
    classCallCheck(this, MediaLoader);

    // MediaLoader has no element
    var options_ = mergeOptions({ createEl: false }, options);

    // If there are no sources when the player is initialized,
    // load the first supported playback technology.

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options_, ready));

    if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {
      for (var i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {
        var techName = toTitleCase(j[i]);
        var tech = Tech.getTech(techName);

        // Support old behavior of techs being registered as components.
        // Remove once that deprecated behavior is removed.
        if (!techName) {
          tech = Component.getComponent(techName);
        }

        // Check if the browser supports this technology
        if (tech && tech.isSupported()) {
          player.loadTech_(techName);
          break;
        }
      }
    } else {
      // Loop through playback technologies (HTML5, Flash) and check for support.
      // Then load the best source.
      // A few assumptions here:
      //   All playback technologies respect preload false.
      player.src(options.playerOptions.sources);
    }
    return _this;
  }

  return MediaLoader;
}(Component);

Component.registerComponent('MediaLoader', MediaLoader);

/**
 * @file button.js
 */
/**
 * Clickable Component which is clickable or keyboard actionable,
 * but is not a native HTML button.
 *
 * @extends Component
 */

var ClickableComponent = function (_Component) {
  inherits(ClickableComponent, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  function ClickableComponent(player, options) {
    classCallCheck(this, ClickableComponent);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.emitTapEvents();

    _this.enable();
    return _this;
  }

  /**
   * Create the `Component`s DOM element.
   *
   * @param {string} [tag=div]
   *        The element's node type.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element.
   *
   * @param {Object} [attributes={}]
   *        An object of attributes that should be set on the element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  ClickableComponent.prototype.createEl = function createEl$$1() {
    var tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    props = assign({
      innerHTML: '<span aria-hidden="true" class="vjs-icon-placeholder"></span>',
      className: this.buildCSSClass(),
      tabIndex: 0
    }, props);

    if (tag === 'button') {
      log$1.error('Creating a ClickableComponent with an HTML element of ' + tag + ' is not supported; use a Button instead.');
    }

    // Add ARIA attributes for clickable element which is not a native HTML button
    attributes = assign({
      'role': 'button',

      // let the screen reader user know that the text of the element may change
      'aria-live': 'polite'
    }, attributes);

    this.tabIndex_ = props.tabIndex;

    var el = _Component.prototype.createEl.call(this, tag, props, attributes);

    this.createControlTextEl(el);

    return el;
  };

  /**
   * Create a control text element on this `Component`
   *
   * @param {Element} [el]
   *        Parent element for the control text.
   *
   * @return {Element}
   *         The control text element that gets created.
   */


  ClickableComponent.prototype.createControlTextEl = function createControlTextEl(el) {
    this.controlTextEl_ = createEl('span', {
      className: 'vjs-control-text'
    });

    if (el) {
      el.appendChild(this.controlTextEl_);
    }

    this.controlText(this.controlText_, el);

    return this.controlTextEl_;
  };

  /**
   * Get or set the localize text to use for the controls on the `Component`.
   *
   * @param {string} [text]
   *        Control text for element.
   *
   * @param {Element} [el=this.el()]
   *        Element to set the title on.
   *
   * @return {string}
   *         - The control text when getting
   */


  ClickableComponent.prototype.controlText = function controlText(text) {
    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.el();

    if (!text) {
      return this.controlText_ || 'Need Text';
    }

    var localizedText = this.localize(text);

    this.controlText_ = text;
    textContent(this.controlTextEl_, localizedText);
    if (!this.nonIconControl) {
      // Set title attribute if only an icon is shown
      el.setAttribute('title', localizedText);
    }
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  ClickableComponent.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-control vjs-button ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Enable this `Component`s element.
   */


  ClickableComponent.prototype.enable = function enable() {
    if (!this.enabled_) {
      this.enabled_ = true;
      this.removeClass('vjs-disabled');
      this.el_.setAttribute('aria-disabled', 'false');
      if (typeof this.tabIndex_ !== 'undefined') {
        this.el_.setAttribute('tabIndex', this.tabIndex_);
      }
      this.on(['tap', 'click'], this.handleClick);
      this.on('focus', this.handleFocus);
      this.on('blur', this.handleBlur);
    }
  };

  /**
   * Disable this `Component`s element.
   */


  ClickableComponent.prototype.disable = function disable() {
    this.enabled_ = false;
    this.addClass('vjs-disabled');
    this.el_.setAttribute('aria-disabled', 'true');
    if (typeof this.tabIndex_ !== 'undefined') {
      this.el_.removeAttribute('tabIndex');
    }
    this.off(['tap', 'click'], this.handleClick);
    this.off('focus', this.handleFocus);
    this.off('blur', this.handleBlur);
  };

  /**
   * This gets called when a `ClickableComponent` gets:
   * - Clicked (via the `click` event, listening starts in the constructor)
   * - Tapped (via the `tap` event, listening starts in the constructor)
   * - The following things happen in order:
   *   1. {@link ClickableComponent#handleFocus} is called via a `focus` event on the
   *      `ClickableComponent`.
   *   2. {@link ClickableComponent#handleFocus} adds a listener for `keydown` on using
   *      {@link ClickableComponent#handleKeyPress}.
   *   3. `ClickableComponent` has not had a `blur` event (`blur` means that focus was lost). The user presses
   *      the space or enter key.
   *   4. {@link ClickableComponent#handleKeyPress} calls this function with the `keydown`
   *      event as a parameter.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   * @abstract
   */


  ClickableComponent.prototype.handleClick = function handleClick(event) {};

  /**
   * This gets called when a `ClickableComponent` gains focus via a `focus` event.
   * Turns on listening for `keydown` events. When they happen it
   * calls `this.handleKeyPress`.
   *
   * @param {EventTarget~Event} event
   *        The `focus` event that caused this function to be called.
   *
   * @listens focus
   */


  ClickableComponent.prototype.handleFocus = function handleFocus(event) {
    on(document, 'keydown', bind(this, this.handleKeyPress));
  };

  /**
   * Called when this ClickableComponent has focus and a key gets pressed down. By
   * default it will call `this.handleClick` when the key is space or enter.
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */


  ClickableComponent.prototype.handleKeyPress = function handleKeyPress(event) {

    // Support Space (32) or Enter (13) key operation to fire a click event
    if (event.which === 32 || event.which === 13) {
      event.preventDefault();
      this.trigger('click');
    } else if (_Component.prototype.handleKeyPress) {

      // Pass keypress handling up for unsupported keys
      _Component.prototype.handleKeyPress.call(this, event);
    }
  };

  /**
   * Called when a `ClickableComponent` loses focus. Turns off the listener for
   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.
   *
   * @param {EventTarget~Event} event
   *        The `blur` event that caused this function to be called.
   *
   * @listens blur
   */


  ClickableComponent.prototype.handleBlur = function handleBlur(event) {
    off(document, 'keydown', bind(this, this.handleKeyPress));
  };

  return ClickableComponent;
}(Component);

Component.registerComponent('ClickableComponent', ClickableComponent);

/**
 * @file poster-image.js
 */
/**
 * A `ClickableComponent` that handles showing the poster image for the player.
 *
 * @extends ClickableComponent
 */

var PosterImage = function (_ClickableComponent) {
  inherits(PosterImage, _ClickableComponent);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PosterImage(player, options) {
    classCallCheck(this, PosterImage);

    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));

    _this.update();
    player.on('posterchange', bind(_this, _this.update));
    return _this;
  }

  /**
   * Clean up and dispose of the `PosterImage`.
   */


  PosterImage.prototype.dispose = function dispose() {
    this.player().off('posterchange', this.update);
    _ClickableComponent.prototype.dispose.call(this);
  };

  /**
   * Create the `PosterImage`s DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  PosterImage.prototype.createEl = function createEl$$1() {
    var el = createEl('div', {
      className: 'vjs-poster',

      // Don't want poster to be tabbable.
      tabIndex: -1
    });

    // To ensure the poster image resizes while maintaining its original aspect
    // ratio, use a div with `background-size` when available. For browsers that
    // do not support `background-size` (e.g. IE8), fall back on using a regular
    // img element.
    if (!BACKGROUND_SIZE_SUPPORTED) {
      this.fallbackImg_ = createEl('img');
      el.appendChild(this.fallbackImg_);
    }

    return el;
  };

  /**
   * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.
   *
   * @listens Player#posterchange
   *
   * @param {EventTarget~Event} [event]
   *        The `Player#posterchange` event that triggered this function.
   */


  PosterImage.prototype.update = function update(event) {
    var url = this.player().poster();

    this.setSrc(url);

    // If there's no poster source we should display:none on this component
    // so it's not still clickable or right-clickable
    if (url) {
      this.show();
    } else {
      this.hide();
    }
  };

  /**
   * Set the source of the `PosterImage` depending on the display method.
   *
   * @param {string} url
   *        The URL to the source for the `PosterImage`.
   */


  PosterImage.prototype.setSrc = function setSrc(url) {
    if (this.fallbackImg_) {
      this.fallbackImg_.src = url;
    } else {
      var backgroundImage = '';

      // Any falsey values should stay as an empty string, otherwise
      // this will throw an extra error
      if (url) {
        backgroundImage = 'url("' + url + '")';
      }

      this.el_.style.backgroundImage = backgroundImage;
    }
  };

  /**
   * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See
   * {@link ClickableComponent#handleClick} for instances where this will be triggered.
   *
   * @listens tap
   * @listens click
   * @listens keydown
   *
   * @param {EventTarget~Event} event
   +        The `click`, `tap` or `keydown` event that caused this function to be called.
   */


  PosterImage.prototype.handleClick = function handleClick(event) {
    // We don't want a click to trigger playback when controls are disabled
    if (!this.player_.controls()) {
      return;
    }

    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };

  return PosterImage;
}(ClickableComponent);

Component.registerComponent('PosterImage', PosterImage);

/**
 * @file text-track-display.js
 */
var darkGray = '#222';
var lightGray = '#ccc';
var fontMap = {
  monospace: 'monospace',
  sansSerif: 'sans-serif',
  serif: 'serif',
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: 'sans-serif',
  proportionalSerif: 'serif',
  casual: '"Comic Sans MS", Impact, fantasy',
  script: '"Monotype Corsiva", cursive',
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};

/**
 * Construct an rgba color from a given hex color code.
 *
 * @param {number} color
 *        Hex number for color, like #f0e.
 *
 * @param {number} opacity
 *        Value for opacity, 0.0 - 1.0.
 *
 * @return {string}
 *         The rgba color that was created, like 'rgba(255, 0, 0, 0.3)'.
 *
 * @private
 */
function constructColor(color, opacity) {
  return 'rgba(' +
  // color looks like "#f0e"
  parseInt(color[1] + color[1], 16) + ',' + parseInt(color[2] + color[2], 16) + ',' + parseInt(color[3] + color[3], 16) + ',' + opacity + ')';
}

/**
 * Try to update the style of a DOM element. Some style changes will throw an error,
 * particularly in IE8. Those should be noops.
 *
 * @param {Element} el
 *        The DOM element to be styled.
 *
 * @param {string} style
 *        The CSS property on the element that should be styled.
 *
 * @param {string} rule
 *        The style rule that should be applied to the property.
 *
 * @private
 */
function tryUpdateStyle(el, style, rule) {
  try {
    el.style[style] = rule;
  } catch (e) {

    // Satisfies linter.
    return;
  }
}

/**
 * The component for displaying text track cues.
 *
 * @extends Component
 */

var TextTrackDisplay = function (_Component) {
  inherits(TextTrackDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when `TextTrackDisplay` is ready.
   */
  function TextTrackDisplay(player, options, ready) {
    classCallCheck(this, TextTrackDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options, ready));

    player.on('loadstart', bind(_this, _this.toggleDisplay));
    player.on('texttrackchange', bind(_this, _this.updateDisplay));
    player.on('loadstart', bind(_this, _this.preselectTrack));

    // This used to be called during player init, but was causing an error
    // if a track should show by default and the display hadn't loaded yet.
    // Should probably be moved to an external track loader when we support
    // tracks that don't need a display.
    player.ready(bind(_this, function () {
      if (player.tech_ && player.tech_.featuresNativeTextTracks) {
        this.hide();
        return;
      }

      player.on('fullscreenchange', bind(this, this.updateDisplay));

      var tracks = this.options_.playerOptions.tracks || [];

      for (var i = 0; i < tracks.length; i++) {
        this.player_.addRemoteTextTrack(tracks[i], true);
      }

      this.preselectTrack();
    }));
    return _this;
  }

  /**
  * Preselect a track following this precedence:
  * - matches the previously selected {@link TextTrack}'s language and kind
  * - matches the previously selected {@link TextTrack}'s language only
  * - is the first default captions track
  * - is the first default descriptions track
  *
  * @listens Player#loadstart
  */


  TextTrackDisplay.prototype.preselectTrack = function preselectTrack() {
    var modes = { captions: 1, subtitles: 1 };
    var trackList = this.player_.textTracks();
    var userPref = this.player_.cache_.selectedLanguage;
    var firstDesc = void 0;
    var firstCaptions = void 0;
    var preferredTrack = void 0;

    for (var i = 0; i < trackList.length; i++) {
      var track = trackList[i];

      if (userPref && userPref.enabled && userPref.language === track.language) {
        // Always choose the track that matches both language and kind
        if (track.kind === userPref.kind) {
          preferredTrack = track;
          // or choose the first track that matches language
        } else if (!preferredTrack) {
          preferredTrack = track;
        }

        // clear everything if offTextTrackMenuItem was clicked
      } else if (userPref && !userPref.enabled) {
        preferredTrack = null;
        firstDesc = null;
        firstCaptions = null;
      } else if (track['default']) {
        if (track.kind === 'descriptions' && !firstDesc) {
          firstDesc = track;
        } else if (track.kind in modes && !firstCaptions) {
          firstCaptions = track;
        }
      }
    }

    // The preferredTrack matches the user preference and takes
    // precendence over all the other tracks.
    // So, display the preferredTrack before the first default track
    // and the subtitles/captions track before the descriptions track
    if (preferredTrack) {
      preferredTrack.mode = 'showing';
    } else if (firstCaptions) {
      firstCaptions.mode = 'showing';
    } else if (firstDesc) {
      firstDesc.mode = 'showing';
    }
  };

  /**
   * Turn display of {@link TextTrack}'s from the current state into the other state.
   * There are only two states:
   * - 'shown'
   * - 'hidden'
   *
   * @listens Player#loadstart
   */


  TextTrackDisplay.prototype.toggleDisplay = function toggleDisplay() {
    if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {
      this.hide();
    } else {
      this.show();
    }
  };

  /**
   * Create the {@link Component}'s DOM element.
   *
   * @return {Element}
   *         The element that was created.
   */


  TextTrackDisplay.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-text-track-display'
    }, {
      'aria-live': 'off',
      'aria-atomic': 'true'
    });
  };

  /**
   * Clear all displayed {@link TextTrack}s.
   */


  TextTrackDisplay.prototype.clearDisplay = function clearDisplay() {
    if (typeof window.WebVTT === 'function') {
      window.WebVTT.processCues(window, [], this.el_);
    }
  };

  /**
   * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or
   * a {@link Player#fullscreenchange} is fired.
   *
   * @listens Player#texttrackchange
   * @listens Player#fullscreenchange
   */


  TextTrackDisplay.prototype.updateDisplay = function updateDisplay() {
    var tracks = this.player_.textTracks();

    this.clearDisplay();

    // Track display prioritization model: if multiple tracks are 'showing',
    //  display the first 'subtitles' or 'captions' track which is 'showing',
    //  otherwise display the first 'descriptions' track which is 'showing'

    var descriptionsTrack = null;
    var captionsSubtitlesTrack = null;
    var i = tracks.length;

    while (i--) {
      var track = tracks[i];

      if (track.mode === 'showing') {
        if (track.kind === 'descriptions') {
          descriptionsTrack = track;
        } else {
          captionsSubtitlesTrack = track;
        }
      }
    }

    if (captionsSubtitlesTrack) {
      if (this.getAttribute('aria-live') !== 'off') {
        this.setAttribute('aria-live', 'off');
      }
      this.updateForTrack(captionsSubtitlesTrack);
    } else if (descriptionsTrack) {
      if (this.getAttribute('aria-live') !== 'assertive') {
        this.setAttribute('aria-live', 'assertive');
      }
      this.updateForTrack(descriptionsTrack);
    }
  };

  /**
   * Add an {@link Texttrack} to to the {@link Tech}s {@link TextTrackList}.
   *
   * @param {TextTrack} track
   *        Text track object to be added to the list.
   */


  TextTrackDisplay.prototype.updateForTrack = function updateForTrack(track) {
    if (typeof window.WebVTT !== 'function' || !track.activeCues) {
      return;
    }

    var overrides = this.player_.textTrackSettings.getValues();
    var cues = [];

    for (var _i = 0; _i < track.activeCues.length; _i++) {
      cues.push(track.activeCues[_i]);
    }

    window.WebVTT.processCues(window, cues, this.el_);

    var i = cues.length;

    while (i--) {
      var cue = cues[i];

      if (!cue) {
        continue;
      }

      var cueDiv = cue.displayState;

      if (overrides.color) {
        cueDiv.firstChild.style.color = overrides.color;
      }
      if (overrides.textOpacity) {
        tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));
      }
      if (overrides.backgroundColor) {
        cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
      }
      if (overrides.backgroundOpacity) {
        tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));
      }
      if (overrides.windowColor) {
        if (overrides.windowOpacity) {
          tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));
        } else {
          cueDiv.style.backgroundColor = overrides.windowColor;
        }
      }
      if (overrides.edgeStyle) {
        if (overrides.edgeStyle === 'dropshadow') {
          cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;
        } else if (overrides.edgeStyle === 'raised') {
          cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;
        } else if (overrides.edgeStyle === 'depressed') {
          cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;
        } else if (overrides.edgeStyle === 'uniform') {
          cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;
        }
      }
      if (overrides.fontPercent && overrides.fontPercent !== 1) {
        var fontSize = window.parseFloat(cueDiv.style.fontSize);

        cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';
        cueDiv.style.height = 'auto';
        cueDiv.style.top = 'auto';
        cueDiv.style.bottom = '2px';
      }
      if (overrides.fontFamily && overrides.fontFamily !== 'default') {
        if (overrides.fontFamily === 'small-caps') {
          cueDiv.firstChild.style.fontVariant = 'small-caps';
        } else {
          cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
        }
      }
    }
  };

  return TextTrackDisplay;
}(Component);

Component.registerComponent('TextTrackDisplay', TextTrackDisplay);

/**
 * @file loading-spinner.js
 */
/**
 * A loading spinner for use during waiting/loading events.
 *
 * @extends Component
 */

var LoadingSpinner = function (_Component) {
  inherits(LoadingSpinner, _Component);

  function LoadingSpinner() {
    classCallCheck(this, LoadingSpinner);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the `LoadingSpinner`s DOM element.
   *
   * @return {Element}
   *         The dom element that gets created.
   */
  LoadingSpinner.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-loading-spinner',
      dir: 'ltr'
    });
  };

  return LoadingSpinner;
}(Component);

Component.registerComponent('LoadingSpinner', LoadingSpinner);

/**
 * @file button.js
 */
/**
 * Base class for all buttons.
 *
 * @extends ClickableComponent
 */

var Button = function (_ClickableComponent) {
  inherits(Button, _ClickableComponent);

  function Button() {
    classCallCheck(this, Button);
    return possibleConstructorReturn(this, _ClickableComponent.apply(this, arguments));
  }

  /**
   * Create the `Button`s DOM element.
   *
   * @param {string} [tag="button"]
   *        The element's node type. This argument is IGNORED: no matter what
   *        is passed, it will always create a `button` element.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element.
   *
   * @param {Object} [attributes={}]
   *        An object of attributes that should be set on the element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  Button.prototype.createEl = function createEl(tag) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    tag = 'button';

    props = assign({
      innerHTML: '<span aria-hidden="true" class="vjs-icon-placeholder"></span>',
      className: this.buildCSSClass()
    }, props);

    // Add attributes for button element
    attributes = assign({

      // Necessary since the default button type is "submit"
      'type': 'button',

      // let the screen reader user know that the text of the button may change
      'aria-live': 'polite'
    }, attributes);

    var el = Component.prototype.createEl.call(this, tag, props, attributes);

    this.createControlTextEl(el);

    return el;
  };

  /**
   * Add a child `Component` inside of this `Button`.
   *
   * @param {string|Component} child
   *        The name or instance of a child to add.
   *
   * @param {Object} [options={}]
   *        The key/value store of options that will get passed to children of
   *        the child.
   *
   * @return {Component}
   *         The `Component` that gets added as a child. When using a string the
   *         `Component` will get created by this process.
   *
   * @deprecated since version 5
   */


  Button.prototype.addChild = function addChild(child) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var className = this.constructor.name;

    log$1.warn('Adding an actionable (user controllable) child to a Button (' + className + ') is not supported; use a ClickableComponent instead.');

    // Avoid the error message generated by ClickableComponent's addChild method
    return Component.prototype.addChild.call(this, child, options);
  };

  /**
   * Enable the `Button` element so that it can be activated or clicked. Use this with
   * {@link Button#disable}.
   */


  Button.prototype.enable = function enable() {
    _ClickableComponent.prototype.enable.call(this);
    this.el_.removeAttribute('disabled');
  };

  /**
   * Enable the `Button` element so that it cannot be activated or clicked. Use this with
   * {@link Button#enable}.
   */


  Button.prototype.disable = function disable() {
    _ClickableComponent.prototype.disable.call(this);
    this.el_.setAttribute('disabled', 'disabled');
  };

  /**
   * This gets called when a `Button` has focus and `keydown` is triggered via a key
   * press.
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to get called.
   *
   * @listens keydown
   */


  Button.prototype.handleKeyPress = function handleKeyPress(event) {

    // Ignore Space (32) or Enter (13) key operation, which is handled by the browser for a button.
    if (event.which === 32 || event.which === 13) {
      return;
    }

    // Pass keypress handling up for unsupported keys
    _ClickableComponent.prototype.handleKeyPress.call(this, event);
  };

  return Button;
}(ClickableComponent);

Component.registerComponent('Button', Button);

/**
 * @file big-play-button.js
 */
/**
 * The initial play button that shows before the video has played. The hiding of the
 * `BigPlayButton` get done via CSS and `Player` states.
 *
 * @extends Button
 */

var BigPlayButton = function (_Button) {
  inherits(BigPlayButton, _Button);

  function BigPlayButton() {
    classCallCheck(this, BigPlayButton);
    return possibleConstructorReturn(this, _Button.apply(this, arguments));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.
   */
  BigPlayButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-big-play-button';
  };

  /**
   * This gets called when a `BigPlayButton` "clicked". See {@link ClickableComponent}
   * for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  BigPlayButton.prototype.handleClick = function handleClick(event) {
    var playPromise = this.player_.play();

    var cb = this.player_.getChild('controlBar');
    var playToggle = cb && cb.getChild('playToggle');

    if (!playToggle) {
      this.player_.focus();
      return;
    }

    if (playPromise) {
      playPromise.then(function () {
        return playToggle.focus();
      });
    } else {
      this.setTimeout(function () {
        playToggle.focus();
      }, 1);
    }
  };

  return BigPlayButton;
}(Button);

/**
 * The text that should display over the `BigPlayButton`s controls. Added to for localization.
 *
 * @type {string}
 * @private
 */


BigPlayButton.prototype.controlText_ = 'Play Video';

Component.registerComponent('BigPlayButton', BigPlayButton);

/**
 * @file close-button.js
 */
/**
 * The `CloseButton` is a `{@link Button}` that fires a `close` event when
 * it gets clicked.
 *
 * @extends Button
 */

var CloseButton = function (_Button) {
  inherits(CloseButton, _Button);

  /**
   * Creates an instance of the this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  function CloseButton(player, options) {
    classCallCheck(this, CloseButton);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.controlText(options && options.controlText || _this.localize('Close'));
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  CloseButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-close-button ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * This gets called when a `CloseButton` gets clicked. See
   * {@link ClickableComponent#handleClick} for more information on when this will be
   * triggered
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   * @fires CloseButton#close
   */


  CloseButton.prototype.handleClick = function handleClick(event) {

    /**
     * Triggered when the a `CloseButton` is clicked.
     *
     * @event CloseButton#close
     * @type {EventTarget~Event}
     *
     * @property {boolean} [bubbles=false]
     *           set to false so that the close event does not
     *           bubble up to parents if there is no listener
     */
    this.trigger({ type: 'close', bubbles: false });
  };

  return CloseButton;
}(Button);

Component.registerComponent('CloseButton', CloseButton);

/**
 * @file play-toggle.js
 */
/**
 * Button to toggle between play and pause.
 *
 * @extends Button
 */

var PlayToggle = function (_Button) {
  inherits(PlayToggle, _Button);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PlayToggle(player, options) {
    classCallCheck(this, PlayToggle);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.on(player, 'play', _this.handlePlay);
    _this.on(player, 'pause', _this.handlePause);
    _this.on(player, 'ended', _this.handleEnded);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  PlayToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-play-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * This gets called when an `PlayToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  PlayToggle.prototype.handleClick = function handleClick(event) {
    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };

  /**
   * Add the vjs-playing class to the element so it can change appearance.
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#play
   */


  PlayToggle.prototype.handlePlay = function handlePlay(event) {
    this.removeClass('vjs-ended');
    this.removeClass('vjs-paused');
    this.addClass('vjs-playing');
    // change the button text to "Pause"
    this.controlText('Pause');
  };

  /**
   * Add the vjs-paused class to the element so it can change appearance.
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#pause
   */


  PlayToggle.prototype.handlePause = function handlePause(event) {
    this.removeClass('vjs-playing');
    this.addClass('vjs-paused');
    // change the button text to "Play"
    this.controlText('Play');
  };

  /**
   * Add the vjs-ended class to the element so it can change appearance
   *
   */


  PlayToggle.prototype.handleEnded = function handleEnded(event) {
    this.removeClass('vjs-playing');
    this.addClass('vjs-ended');
    // change the button text to "Replay"
    this.controlText('Replay');
  };

  return PlayToggle;
}(Button);

/**
 * The text that should display over the `PlayToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


PlayToggle.prototype.controlText_ = 'Play';

Component.registerComponent('PlayToggle', PlayToggle);

/**
 * @file format-time.js
 * @module Format-time
 */

/**
 * Format seconds as a time string, H:MM:SS or M:SS. Supplying a guide (in seconds)
 * will force a number of leading zeros to cover the length of the guide.
 *
 * @param {number} seconds
 *        Number of seconds to be turned into a string
 *
 * @param {number} guide
 *        Number (in seconds) to model the string after
 *
 * @return {string}
 *         Time formatted as H:MM:SS or M:SS
 */
function formatTime(seconds) {
  var guide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : seconds;

  seconds = seconds < 0 ? 0 : seconds;
  var s = Math.floor(seconds % 60);
  var m = Math.floor(seconds / 60 % 60);
  var h = Math.floor(seconds / 3600);
  var gm = Math.floor(guide / 60 % 60);
  var gh = Math.floor(guide / 3600);

  // handle invalid times
  if (isNaN(seconds) || seconds === Infinity) {
    // '-' is false for all relational operators (e.g. <, >=) so this setting
    // will add the minimum number of fields specified by the guide
    h = m = s = '-';
  }

  // Check if we need to show hours
  h = h > 0 || gh > 0 ? h + ':' : '';

  // If hours are showing, we may need to add a leading zero.
  // Always show at least one digit of minutes.
  m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';

  // Check if leading zero is need for seconds
  s = s < 10 ? '0' + s : s;

  return h + m + s;
}

/**
 * @file current-time-display.js
 */
/**
 * Displays the current time
 *
 * @extends Component
 */

var CurrentTimeDisplay = function (_Component) {
  inherits(CurrentTimeDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function CurrentTimeDisplay(player, options) {
    classCallCheck(this, CurrentTimeDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.throttledUpdateContent = throttle(bind(_this, _this.updateContent), 25);
    _this.on(player, 'timeupdate', _this.throttledUpdateContent);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  CurrentTimeDisplay.prototype.createEl = function createEl$$1() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-current-time vjs-time-control vjs-control'
    });

    this.contentEl_ = createEl('div', {
      className: 'vjs-current-time-display'
    }, {
      // tell screen readers not to automatically read the time as it changes
      'aria-live': 'off'
    }, createEl('span', {
      className: 'vjs-control-text',
      textContent: this.localize('Current Time')
    }));

    this.updateTextNode_();
    el.appendChild(this.contentEl_);
    return el;
  };

  /**
   * Updates the "current time" text node with new content using the
   * contents of the `formattedTime_` property.
   *
   * @private
   */


  CurrentTimeDisplay.prototype.updateTextNode_ = function updateTextNode_() {
    if (this.textNode_) {
      this.contentEl_.removeChild(this.textNode_);
    }
    this.textNode_ = document.createTextNode(' ' + (this.formattedTime_ || '0:00'));
    this.contentEl_.appendChild(this.textNode_);
  };

  /**
   * Update current time display
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` event that caused this function to run.
   *
   * @listens Player#timeupdate
   */


  CurrentTimeDisplay.prototype.updateContent = function updateContent(event) {
    // Allows for smooth scrubbing, when player can't keep up.
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    var formattedTime = formatTime(time, this.player_.duration());

    if (formattedTime !== this.formattedTime_) {
      this.formattedTime_ = formattedTime;
      this.requestAnimationFrame(this.updateTextNode_);
    }
  };

  return CurrentTimeDisplay;
}(Component);

Component.registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);

/**
 * @file duration-display.js
 */
/**
 * Displays the duration
 *
 * @extends Component
 */

var DurationDisplay = function (_Component) {
  inherits(DurationDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function DurationDisplay(player, options) {
    classCallCheck(this, DurationDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.throttledUpdateContent = throttle(bind(_this, _this.updateContent), 25);

    _this.on(player, ['durationchange',

    // Also listen for timeupdate and loadedmetadata because removing those
    // listeners could have broken dependent applications/libraries. These
    // can likely be removed for 7.0.
    'loadedmetadata', 'timeupdate'], _this.throttledUpdateContent);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  DurationDisplay.prototype.createEl = function createEl$$1() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-duration vjs-time-control vjs-control'
    });

    this.contentEl_ = createEl('div', {
      className: 'vjs-duration-display'
    }, {
      // tell screen readers not to automatically read the time as it changes
      'aria-live': 'off'
    }, createEl('span', {
      className: 'vjs-control-text',
      textContent: this.localize('Duration Time')
    }));

    this.updateTextNode_();
    el.appendChild(this.contentEl_);
    return el;
  };

  /**
   * Updates the "current time" text node with new content using the
   * contents of the `formattedTime_` property.
   *
   * @private
   */


  DurationDisplay.prototype.updateTextNode_ = function updateTextNode_() {
    if (this.textNode_) {
      this.contentEl_.removeChild(this.textNode_);
    }
    this.textNode_ = document.createTextNode(' ' + (this.formattedTime_ || '0:00'));
    this.contentEl_.appendChild(this.textNode_);
  };

  /**
   * Update duration time display.
   *
   * @param {EventTarget~Event} [event]
   *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused
   *        this function to be called.
   *
   * @listens Player#durationchange
   * @listens Player#timeupdate
   * @listens Player#loadedmetadata
   */


  DurationDisplay.prototype.updateContent = function updateContent(event) {
    var duration = this.player_.duration();

    if (duration && this.duration_ !== duration) {
      this.duration_ = duration;
      this.formattedTime_ = formatTime(duration);
      this.requestAnimationFrame(this.updateTextNode_);
    }
  };

  return DurationDisplay;
}(Component);

Component.registerComponent('DurationDisplay', DurationDisplay);

/**
 * @file time-divider.js
 */
/**
 * The separator between the current time and duration.
 * Can be hidden if it's not needed in the design.
 *
 * @extends Component
 */

var TimeDivider = function (_Component) {
  inherits(TimeDivider, _Component);

  function TimeDivider() {
    classCallCheck(this, TimeDivider);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  TimeDivider.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-time-control vjs-time-divider',
      innerHTML: '<div><span>/</span></div>'
    });
  };

  return TimeDivider;
}(Component);

Component.registerComponent('TimeDivider', TimeDivider);

/**
 * @file remaining-time-display.js
 */
/**
 * Displays the time left in the video
 *
 * @extends Component
 */

var RemainingTimeDisplay = function (_Component) {
  inherits(RemainingTimeDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function RemainingTimeDisplay(player, options) {
    classCallCheck(this, RemainingTimeDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.throttledUpdateContent = throttle(bind(_this, _this.updateContent), 25);
    _this.on(player, ['timeupdate', 'durationchange'], _this.throttledUpdateContent);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  RemainingTimeDisplay.prototype.createEl = function createEl$$1() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-remaining-time vjs-time-control vjs-control'
    });

    this.contentEl_ = createEl('div', {
      className: 'vjs-remaining-time-display'
    }, {
      // tell screen readers not to automatically read the time as it changes
      'aria-live': 'off'
    }, createEl('span', {
      className: 'vjs-control-text',
      textContent: this.localize('Remaining Time')
    }));

    this.updateTextNode_();
    el.appendChild(this.contentEl_);
    return el;
  };

  /**
   * Updates the "remaining time" text node with new content using the
   * contents of the `formattedTime_` property.
   *
   * @private
   */


  RemainingTimeDisplay.prototype.updateTextNode_ = function updateTextNode_() {
    if (this.textNode_) {
      this.contentEl_.removeChild(this.textNode_);
    }
    this.textNode_ = document.createTextNode(' -' + (this.formattedTime_ || '0:00'));
    this.contentEl_.appendChild(this.textNode_);
  };

  /**
   * Update remaining time display.
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` or `durationchange` event that caused this to run.
   *
   * @listens Player#timeupdate
   * @listens Player#durationchange
   */


  RemainingTimeDisplay.prototype.updateContent = function updateContent(event) {
    if (this.player_.duration()) {
      var formattedTime = formatTime(this.player_.remainingTime());

      if (formattedTime !== this.formattedTime_) {
        this.formattedTime_ = formattedTime;
        this.requestAnimationFrame(this.updateTextNode_);
      }
    }
  };

  return RemainingTimeDisplay;
}(Component);

Component.registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);

/**
 * @file live-display.js
 */
// TODO - Future make it click to snap to live

/**
 * Displays the live indicator when duration is Infinity.
 *
 * @extends Component
 */

var LiveDisplay = function (_Component) {
  inherits(LiveDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function LiveDisplay(player, options) {
    classCallCheck(this, LiveDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.updateShowing();
    _this.on(_this.player(), 'durationchange', _this.updateShowing);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  LiveDisplay.prototype.createEl = function createEl$$1() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-live-control vjs-control'
    });

    this.contentEl_ = createEl('div', {
      className: 'vjs-live-display',
      innerHTML: '<span class="vjs-control-text">' + this.localize('Stream Type') + '</span>' + this.localize('LIVE')
    }, {
      'aria-live': 'off'
    });

    el.appendChild(this.contentEl_);
    return el;
  };

  /**
   * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide
   * it accordingly
   *
   * @param {EventTarget~Event} [event]
   *        The {@link Player#durationchange} event that caused this function to run.
   *
   * @listens Player#durationchange
   */


  LiveDisplay.prototype.updateShowing = function updateShowing(event) {
    if (this.player().duration() === Infinity) {
      this.show();
    } else {
      this.hide();
    }
  };

  return LiveDisplay;
}(Component);

Component.registerComponent('LiveDisplay', LiveDisplay);

/**
 * @file slider.js
 */
/**
 * The base functionality for a slider. Can be vertical or horizontal.
 * For instance the volume bar or the seek bar on a video is a slider.
 *
 * @extends Component
 */

var Slider = function (_Component) {
  inherits(Slider, _Component);

  /**
   * Create an instance of this class
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function Slider(player, options) {
    classCallCheck(this, Slider);

    // Set property names to bar to match with the child Slider class is looking for
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.bar = _this.getChild(_this.options_.barName);

    // Set a horizontal or vertical class on the slider depending on the slider type
    _this.vertical(!!_this.options_.vertical);

    _this.on('mousedown', _this.handleMouseDown);
    _this.on('touchstart', _this.handleMouseDown);
    _this.on('focus', _this.handleFocus);
    _this.on('blur', _this.handleBlur);
    _this.on('click', _this.handleClick);

    _this.on(player, 'controlsvisible', _this.update);

    if (_this.playerEvent) {
      _this.on(player, _this.playerEvent, _this.update);
    }
    return _this;
  }

  /**
   * Create the `Button`s DOM element.
   *
   * @param {string} type
   *        Type of element to create.
   *
   * @param {Object} [props={}]
   *        List of properties in Object form.
   *
   * @param {Object} [attributes={}]
   *        list of attributes in Object form.
   *
   * @return {Element}
   *         The element that gets created.
   */


  Slider.prototype.createEl = function createEl$$1(type) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    // Add the slider element class to all sub classes
    props.className = props.className + ' vjs-slider';
    props = assign({
      tabIndex: 0
    }, props);

    attributes = assign({
      'role': 'slider',
      'aria-valuenow': 0,
      'aria-valuemin': 0,
      'aria-valuemax': 100,
      'tabIndex': 0
    }, attributes);

    return _Component.prototype.createEl.call(this, type, props, attributes);
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `Slider`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   * @fires Slider#slideractive
   */


  Slider.prototype.handleMouseDown = function handleMouseDown(event) {
    var doc = this.bar.el_.ownerDocument;

    event.preventDefault();
    blockTextSelection();

    this.addClass('vjs-sliding');
    /**
     * Triggered when the slider is in an active state
     *
     * @event Slider#slideractive
     * @type {EventTarget~Event}
     */
    this.trigger('slideractive');

    this.on(doc, 'mousemove', this.handleMouseMove);
    this.on(doc, 'mouseup', this.handleMouseUp);
    this.on(doc, 'touchmove', this.handleMouseMove);
    this.on(doc, 'touchend', this.handleMouseUp);

    this.handleMouseMove(event);
  };

  /**
   * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.
   * The `mousemove` and `touchmove` events will only only trigger this function during
   * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and
   * {@link Slider#handleMouseUp}.
   *
   * @param {EventTarget~Event} event
   *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered
   *        this function
   *
   * @listens mousemove
   * @listens touchmove
   */


  Slider.prototype.handleMouseMove = function handleMouseMove(event) {};

  /**
   * Handle `mouseup` or `touchend` events on the `Slider`.
   *
   * @param {EventTarget~Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   * @fires Slider#sliderinactive
   */


  Slider.prototype.handleMouseUp = function handleMouseUp() {
    var doc = this.bar.el_.ownerDocument;

    unblockTextSelection();

    this.removeClass('vjs-sliding');
    /**
     * Triggered when the slider is no longer in an active state.
     *
     * @event Slider#sliderinactive
     * @type {EventTarget~Event}
     */
    this.trigger('sliderinactive');

    this.off(doc, 'mousemove', this.handleMouseMove);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchmove', this.handleMouseMove);
    this.off(doc, 'touchend', this.handleMouseUp);

    this.update();
  };

  /**
   * Update the progress bar of the `Slider`.
   *
   * @returns {number}
   *          The percentage of progress the progress bar represents as a
   *          number from 0 to 1.
   */


  Slider.prototype.update = function update() {

    // In VolumeBar init we have a setTimeout for update that pops and update
    // to the end of the execution stack. The player is destroyed before then
    // update will cause an error
    if (!this.el_) {
      return;
    }

    // If scrubbing, we could use a cached value to make the handle keep up
    // with the user's mouse. On HTML5 browsers scrubbing is really smooth, but
    // some flash players are slow, so we might want to utilize this later.
    // var progress =  (this.player_.scrubbing()) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();
    var progress = this.getPercent();
    var bar = this.bar;

    // If there's no bar...
    if (!bar) {
      return;
    }

    // Protect against no duration and other division issues
    if (typeof progress !== 'number' || progress !== progress || progress < 0 || progress === Infinity) {
      progress = 0;
    }

    // Convert to a percentage for setting
    var percentage = (progress * 100).toFixed(2) + '%';
    var style = bar.el().style;

    // Set the new bar width or height
    if (this.vertical()) {
      style.height = percentage;
    } else {
      style.width = percentage;
    }

    return progress;
  };

  /**
   * Calculate distance for slider
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run.
   *
   * @return {number}
   *         The current position of the Slider.
   *         - postition.x for vertical `Slider`s
   *         - postition.y for horizontal `Slider`s
   */


  Slider.prototype.calculateDistance = function calculateDistance(event) {
    var position = getPointerPosition(this.el_, event);

    if (this.vertical()) {
      return position.y;
    }
    return position.x;
  };

  /**
   * Handle a `focus` event on this `Slider`.
   *
   * @param {EventTarget~Event} event
   *        The `focus` event that caused this function to run.
   *
   * @listens focus
   */


  Slider.prototype.handleFocus = function handleFocus() {
    this.on(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);
  };

  /**
   * Handle a `keydown` event on the `Slider`. Watches for left, rigth, up, and down
   * arrow keys. This function will only be called when the slider has focus. See
   * {@link Slider#handleFocus} and {@link Slider#handleBlur}.
   *
   * @param {EventTarget~Event} event
   *        the `keydown` event that caused this function to run.
   *
   * @listens keydown
   */


  Slider.prototype.handleKeyPress = function handleKeyPress(event) {
    // Left and Down Arrows
    if (event.which === 37 || event.which === 40) {
      event.preventDefault();
      this.stepBack();

      // Up and Right Arrows
    } else if (event.which === 38 || event.which === 39) {
      event.preventDefault();
      this.stepForward();
    }
  };

  /**
   * Handle a `blur` event on this `Slider`.
   *
   * @param {EventTarget~Event} event
   *        The `blur` event that caused this function to run.
   *
   * @listens blur
   */

  Slider.prototype.handleBlur = function handleBlur() {
    this.off(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);
  };

  /**
   * Listener for click events on slider, used to prevent clicks
   *   from bubbling up to parent elements like button menus.
   *
   * @param {Object} event
   *        Event that caused this object to run
   */


  Slider.prototype.handleClick = function handleClick(event) {
    event.stopImmediatePropagation();
    event.preventDefault();
  };

  /**
   * Get/set if slider is horizontal for vertical
   *
   * @param {boolean} [bool]
   *        - true if slider is vertical,
   *        - false is horizontal
   *
   * @return {boolean}
   *         - true if slider is vertical, and getting
   *         - false if the slider is horizontal, and getting
   */


  Slider.prototype.vertical = function vertical(bool) {
    if (bool === undefined) {
      return this.vertical_ || false;
    }

    this.vertical_ = !!bool;

    if (this.vertical_) {
      this.addClass('vjs-slider-vertical');
    } else {
      this.addClass('vjs-slider-horizontal');
    }
  };

  return Slider;
}(Component);

Component.registerComponent('Slider', Slider);

/**
 * @file load-progress-bar.js
 */
/**
 * Shows loading progress
 *
 * @extends Component
 */

var LoadProgressBar = function (_Component) {
  inherits(LoadProgressBar, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function LoadProgressBar(player, options) {
    classCallCheck(this, LoadProgressBar);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.partEls_ = [];
    _this.on(player, 'progress', _this.update);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  LoadProgressBar.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-load-progress',
      innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Loaded') + '</span>: 0%</span>'
    });
  };

  /**
   * Update progress bar
   *
   * @param {EventTarget~Event} [event]
   *        The `progress` event that caused this function to run.
   *
   * @listens Player#progress
   */


  LoadProgressBar.prototype.update = function update(event) {
    var buffered = this.player_.buffered();
    var duration = this.player_.duration();
    var bufferedEnd = this.player_.bufferedEnd();
    var children = this.partEls_;

    // get the percent width of a time compared to the total end
    var percentify = function percentify(time, end) {
      // no NaN
      var percent = time / end || 0;

      return (percent >= 1 ? 1 : percent) * 100 + '%';
    };

    // update the width of the progress bar
    this.el_.style.width = percentify(bufferedEnd, duration);

    // add child elements to represent the individual buffered time ranges
    for (var i = 0; i < buffered.length; i++) {
      var start = buffered.start(i);
      var end = buffered.end(i);
      var part = children[i];

      if (!part) {
        part = this.el_.appendChild(createEl());
        children[i] = part;
      }

      // set the percent based on the width of the progress bar (bufferedEnd)
      part.style.left = percentify(start, bufferedEnd);
      part.style.width = percentify(end - start, bufferedEnd);
    }

    // remove unused buffered range elements
    for (var _i = children.length; _i > buffered.length; _i--) {
      this.el_.removeChild(children[_i - 1]);
    }
    children.length = buffered.length;
  };

  return LoadProgressBar;
}(Component);

Component.registerComponent('LoadProgressBar', LoadProgressBar);

/**
 * @file time-tooltip.js
 */
/**
 * Time tooltips display a time above the progress bar.
 *
 * @extends Component
 */

var TimeTooltip = function (_Component) {
  inherits(TimeTooltip, _Component);

  function TimeTooltip() {
    classCallCheck(this, TimeTooltip);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the time tooltip DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  TimeTooltip.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-time-tooltip'
    });
  };

  /**
   * Updates the position of the time tooltip relative to the `SeekBar`.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */


  TimeTooltip.prototype.update = function update(seekBarRect, seekBarPoint, content) {
    var tooltipRect = getBoundingClientRect(this.el_);
    var playerRect = getBoundingClientRect(this.player_.el());
    var seekBarPointPx = seekBarRect.width * seekBarPoint;

    // do nothing if either rect isn't available
    // for example, if the player isn't in the DOM for testing
    if (!playerRect || !tooltipRect) {
      return;
    }

    // This is the space left of the `seekBarPoint` available within the bounds
    // of the player. We calculate any gap between the left edge of the player
    // and the left edge of the `SeekBar` and add the number of pixels in the
    // `SeekBar` before hitting the `seekBarPoint`
    var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;

    // This is the space right of the `seekBarPoint` available within the bounds
    // of the player. We calculate the number of pixels from the `seekBarPoint`
    // to the right edge of the `SeekBar` and add to that any gap between the
    // right edge of the `SeekBar` and the player.
    var spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);

    // This is the number of pixels by which the tooltip will need to be pulled
    // further to the right to center it over the `seekBarPoint`.
    var pullTooltipBy = tooltipRect.width / 2;

    // Adjust the `pullTooltipBy` distance to the left or right depending on
    // the results of the space calculations above.
    if (spaceLeftOfPoint < pullTooltipBy) {
      pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
    } else if (spaceRightOfPoint < pullTooltipBy) {
      pullTooltipBy = spaceRightOfPoint;
    }

    // Due to the imprecision of decimal/ratio based calculations and varying
    // rounding behaviors, there are cases where the spacing adjustment is off
    // by a pixel or two. This adds insurance to these calculations.
    if (pullTooltipBy < 0) {
      pullTooltipBy = 0;
    } else if (pullTooltipBy > tooltipRect.width) {
      pullTooltipBy = tooltipRect.width;
    }

    this.el_.style.right = '-' + pullTooltipBy + 'px';
    textContent(this.el_, content);
  };

  return TimeTooltip;
}(Component);

Component.registerComponent('TimeTooltip', TimeTooltip);

/**
 * @file play-progress-bar.js
 */
/**
 * Used by {@link SeekBar} to display media playback progress as part of the
 * {@link ProgressControl}.
 *
 * @extends Component
 */

var PlayProgressBar = function (_Component) {
  inherits(PlayProgressBar, _Component);

  function PlayProgressBar() {
    classCallCheck(this, PlayProgressBar);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */
  PlayProgressBar.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-play-progress vjs-slider-bar',
      innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 0%</span>'
    });
  };

  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   * {@link TimeTooltip} child.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */


  PlayProgressBar.prototype.update = function update(seekBarRect, seekBarPoint) {
    var _this2 = this;

    // If there is an existing rAF ID, cancel it so we don't over-queue.
    if (this.rafId_) {
      this.cancelAnimationFrame(this.rafId_);
    }

    this.rafId_ = this.requestAnimationFrame(function () {
      var time = _this2.player_.scrubbing() ? _this2.player_.getCache().currentTime : _this2.player_.currentTime();

      var content = formatTime(time, _this2.player_.duration());
      var timeTooltip = _this2.getChild('timeTooltip');

      if (timeTooltip) {
        timeTooltip.update(seekBarRect, seekBarPoint, content);
      }
    });
  };

  return PlayProgressBar;
}(Component);

/**
 * Default options for {@link PlayProgressBar}.
 *
 * @type {Object}
 * @private
 */


PlayProgressBar.prototype.options_ = {
  children: []
};

// Time tooltips should not be added to a player on mobile devices or IE8
if ((!IE_VERSION || IE_VERSION > 8) && !IS_IOS && !IS_ANDROID) {
  PlayProgressBar.prototype.options_.children.push('timeTooltip');
}

Component.registerComponent('PlayProgressBar', PlayProgressBar);

/**
 * @file mouse-time-display.js
 */
/**
 * The {@link MouseTimeDisplay} component tracks mouse movement over the
 * {@link ProgressControl}. It displays an indicator and a {@link TimeTooltip}
 * indicating the time which is represented by a given point in the
 * {@link ProgressControl}.
 *
 * @extends Component
 */

var MouseTimeDisplay = function (_Component) {
  inherits(MouseTimeDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function MouseTimeDisplay(player, options) {
    classCallCheck(this, MouseTimeDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.update = throttle(bind(_this, _this.update), 25);
    return _this;
  }

  /**
   * Create the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */


  MouseTimeDisplay.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-mouse-display'
    });
  };

  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   * {@link TimeTooltip} child.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */


  MouseTimeDisplay.prototype.update = function update(seekBarRect, seekBarPoint) {
    var _this2 = this;

    // If there is an existing rAF ID, cancel it so we don't over-queue.
    if (this.rafId_) {
      this.cancelAnimationFrame(this.rafId_);
    }

    this.rafId_ = this.requestAnimationFrame(function () {
      var duration = _this2.player_.duration();
      var content = formatTime(seekBarPoint * duration, duration);

      _this2.el_.style.left = seekBarRect.width * seekBarPoint + 'px';
      _this2.getChild('timeTooltip').update(seekBarRect, seekBarPoint, content);
    });
  };

  return MouseTimeDisplay;
}(Component);

/**
 * Default options for `MouseTimeDisplay`
 *
 * @type {Object}
 * @private
 */


MouseTimeDisplay.prototype.options_ = {
  children: ['timeTooltip']
};

Component.registerComponent('MouseTimeDisplay', MouseTimeDisplay);

/**
 * @file seek-bar.js
 */
// The number of seconds the `step*` functions move the timeline.
var STEP_SECONDS = 5;

/**
 * Seek bar and container for the progress bars. Uses {@link PlayProgressBar}
 * as its `bar`.
 *
 * @extends Slider
 */

var SeekBar = function (_Slider) {
  inherits(SeekBar, _Slider);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function SeekBar(player, options) {
    classCallCheck(this, SeekBar);

    var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));

    _this.update = throttle(bind(_this, _this.update), 50);
    _this.on(player, ['timeupdate', 'ended'], _this.update);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  SeekBar.prototype.createEl = function createEl$$1() {
    return _Slider.prototype.createEl.call(this, 'div', {
      className: 'vjs-progress-holder'
    }, {
      'aria-label': this.localize('Progress Bar')
    });
  };

  /**
   * Update the seek bar's UI.
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` or `ended` event that caused this to run.
   *
   * @listens Player#timeupdate
   * @listens Player#ended
   */


  SeekBar.prototype.update = function update() {
    var percent = _Slider.prototype.update.call(this);
    var duration = this.player_.duration();

    // Allows for smooth scrubbing, when player can't keep up.
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();

    // machine readable value of progress bar (percentage complete)
    this.el_.setAttribute('aria-valuenow', (percent * 100).toFixed(2));

    // human readable value of progress bar (time complete)
    this.el_.setAttribute('aria-valuetext', this.localize('progress bar timing: currentTime={1} duration={2}', [formatTime(time, duration), formatTime(duration, duration)], '{1} of {2}'));

    // Update the `PlayProgressBar`.
    this.bar.update(getBoundingClientRect(this.el_), percent);

    return percent;
  };

  /**
   * Get the percentage of media played so far.
   *
   * @return {number}
   *         The percentage of media played so far (0 to 1).
   */


  SeekBar.prototype.getPercent = function getPercent() {

    // Allows for smooth scrubbing, when player can't keep up.
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();

    var percent = time / this.player_.duration();

    return percent >= 1 ? 1 : percent;
  };

  /**
   * Handle mouse down on seek bar
   *
   * @param {EventTarget~Event} event
   *        The `mousedown` event that caused this to run.
   *
   * @listens mousedown
   */


  SeekBar.prototype.handleMouseDown = function handleMouseDown(event) {
    this.player_.scrubbing(true);

    this.videoWasPlaying = !this.player_.paused();
    this.player_.pause();

    _Slider.prototype.handleMouseDown.call(this, event);
  };

  /**
   * Handle mouse move on seek bar
   *
   * @param {EventTarget~Event} event
   *        The `mousemove` event that caused this to run.
   *
   * @listens mousemove
   */


  SeekBar.prototype.handleMouseMove = function handleMouseMove(event) {
    var newTime = this.calculateDistance(event) * this.player_.duration();

    // Don't let video end while scrubbing.
    if (newTime === this.player_.duration()) {
      newTime = newTime - 0.1;
    }

    // Set new time (tell player to seek to new time)
    this.player_.currentTime(newTime);
  };

  /**
   * Handle mouse up on seek bar
   *
   * @param {EventTarget~Event} event
   *        The `mouseup` event that caused this to run.
   *
   * @listens mouseup
   */


  SeekBar.prototype.handleMouseUp = function handleMouseUp(event) {
    _Slider.prototype.handleMouseUp.call(this, event);

    this.player_.scrubbing(false);
    if (this.videoWasPlaying) {
      this.player_.play();
    }
  };

  /**
   * Move more quickly fast forward for keyboard-only users
   */


  SeekBar.prototype.stepForward = function stepForward() {
    this.player_.currentTime(this.player_.currentTime() + STEP_SECONDS);
  };

  /**
   * Move more quickly rewind for keyboard-only users
   */


  SeekBar.prototype.stepBack = function stepBack() {
    this.player_.currentTime(this.player_.currentTime() - STEP_SECONDS);
  };

  /**
   * Toggles the playback state of the player
   * This gets called when enter or space is used on the seekbar
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called
   *
   */


  SeekBar.prototype.handleAction = function handleAction(event) {
    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };

  /**
   * Called when this SeekBar has focus and a key gets pressed down. By
   * default it will call `this.handleAction` when the key is space or enter.
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */


  SeekBar.prototype.handleKeyPress = function handleKeyPress(event) {

    // Support Space (32) or Enter (13) key operation to fire a click event
    if (event.which === 32 || event.which === 13) {
      event.preventDefault();
      this.handleAction(event);
    } else if (_Slider.prototype.handleKeyPress) {

      // Pass keypress handling up for unsupported keys
      _Slider.prototype.handleKeyPress.call(this, event);
    }
  };

  return SeekBar;
}(Slider);

/**
 * Default options for the `SeekBar`
 *
 * @type {Object}
 * @private
 */


SeekBar.prototype.options_ = {
  children: ['loadProgressBar', 'playProgressBar'],
  barName: 'playProgressBar'
};

// MouseTimeDisplay tooltips should not be added to a player on mobile devices or IE8
if ((!IE_VERSION || IE_VERSION > 8) && !IS_IOS && !IS_ANDROID) {
  SeekBar.prototype.options_.children.splice(1, 0, 'mouseTimeDisplay');
}

/**
 * Call the update event for this Slider when this event happens on the player.
 *
 * @type {string}
 */
SeekBar.prototype.playerEvent = 'timeupdate';

Component.registerComponent('SeekBar', SeekBar);

/**
 * @file progress-control.js
 */
/**
 * The Progress Control component contains the seek bar, load progress,
 * and play progress.
 *
 * @extends Component
 */

var ProgressControl = function (_Component) {
  inherits(ProgressControl, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function ProgressControl(player, options) {
    classCallCheck(this, ProgressControl);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.handleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);
    _this.on(_this.el_, 'mousemove', _this.handleMouseMove);

    _this.throttledHandleMouseSeek = throttle(bind(_this, _this.handleMouseSeek), 25);
    _this.on(['mousedown', 'touchstart'], _this.handleMouseDown);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  ProgressControl.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-progress-control vjs-control'
    });
  };

  /**
   * When the mouse moves over the `ProgressControl`, the pointer position
   * gets passed down to the `MouseTimeDisplay` component.
   *
   * @param {EventTarget~Event} event
   *        The `mousemove` event that caused this function to run.
   *
   * @listen mousemove
   */


  ProgressControl.prototype.handleMouseMove = function handleMouseMove(event) {
    var seekBar = this.getChild('seekBar');
    var mouseTimeDisplay = seekBar.getChild('mouseTimeDisplay');
    var seekBarEl = seekBar.el();
    var seekBarRect = getBoundingClientRect(seekBarEl);
    var seekBarPoint = getPointerPosition(seekBarEl, event).x;

    // The default skin has a gap on either side of the `SeekBar`. This means
    // that it's possible to trigger this behavior outside the boundaries of
    // the `SeekBar`. This ensures we stay within it at all times.
    if (seekBarPoint > 1) {
      seekBarPoint = 1;
    } else if (seekBarPoint < 0) {
      seekBarPoint = 0;
    }

    if (mouseTimeDisplay) {
      mouseTimeDisplay.update(seekBarRect, seekBarPoint);
    }
  };

  /**
   * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.
   *
   * @method ProgressControl#throttledHandleMouseSeek
   * @param {EventTarget~Event} event
   *        The `mousemove` event that caused this function to run.
   *
   * @listen mousemove
   * @listen touchmove
   */

  /**
   * Handle `mousemove` or `touchmove` events on the `ProgressControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousemove
   * @listens touchmove
   */


  ProgressControl.prototype.handleMouseSeek = function handleMouseSeek(event) {
    var seekBar = this.getChild('seekBar');

    seekBar.handleMouseMove(event);
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `ProgressControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */


  ProgressControl.prototype.handleMouseDown = function handleMouseDown(event) {
    var doc = this.el_.ownerDocument;

    this.on(doc, 'mousemove', this.throttledHandleMouseSeek);
    this.on(doc, 'touchmove', this.throttledHandleMouseSeek);
    this.on(doc, 'mouseup', this.handleMouseUp);
    this.on(doc, 'touchend', this.handleMouseUp);
  };

  /**
   * Handle `mouseup` or `touchend` events on the `ProgressControl`.
   *
   * @param {EventTarget~Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   */


  ProgressControl.prototype.handleMouseUp = function handleMouseUp(event) {
    var doc = this.el_.ownerDocument;

    this.off(doc, 'mousemove', this.throttledHandleMouseSeek);
    this.off(doc, 'touchmove', this.throttledHandleMouseSeek);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchend', this.handleMouseUp);
  };

  return ProgressControl;
}(Component);

/**
 * Default options for `ProgressControl`
 *
 * @type {Object}
 * @private
 */


ProgressControl.prototype.options_ = {
  children: ['seekBar']
};

Component.registerComponent('ProgressControl', ProgressControl);

/**
 * @file fullscreen-toggle.js
 */
/**
 * Toggle fullscreen video
 *
 * @extends Button
 */

var FullscreenToggle = function (_Button) {
  inherits(FullscreenToggle, _Button);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function FullscreenToggle(player, options) {
    classCallCheck(this, FullscreenToggle);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.on(player, 'fullscreenchange', _this.handleFullscreenChange);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  FullscreenToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-fullscreen-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * Handles fullscreenchange on the player and change control text accordingly.
   *
   * @param {EventTarget~Event} [event]
   *        The {@link Player#fullscreenchange} event that caused this function to be
   *        called.
   *
   * @listens Player#fullscreenchange
   */


  FullscreenToggle.prototype.handleFullscreenChange = function handleFullscreenChange(event) {
    if (this.player_.isFullscreen()) {
      this.controlText('Non-Fullscreen');
    } else {
      this.controlText('Fullscreen');
    }
  };

  /**
   * This gets called when an `FullscreenToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  FullscreenToggle.prototype.handleClick = function handleClick(event) {
    if (!this.player_.isFullscreen()) {
      this.player_.requestFullscreen();
    } else {
      this.player_.exitFullscreen();
    }
  };

  return FullscreenToggle;
}(Button);

/**
 * The text that should display over the `FullscreenToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


FullscreenToggle.prototype.controlText_ = 'Fullscreen';

Component.registerComponent('FullscreenToggle', FullscreenToggle);

/**
 * Check if volume control is supported and if it isn't hide the
 * `Component` that was passed  using the `vjs-hidden` class.
 *
 * @param {Component} self
 *        The component that should be hidden if volume is unsupported
 *
 * @param {Player} player
 *        A reference to the player
 *
 * @private
 */
var checkVolumeSupport = function checkVolumeSupport(self, player) {
  // hide volume controls when they're not supported by the current tech
  if (player.tech_ && !player.tech_.featuresVolumeControl) {
    self.addClass('vjs-hidden');
  }

  self.on(player, 'loadstart', function () {
    if (!player.tech_.featuresVolumeControl) {
      self.addClass('vjs-hidden');
    } else {
      self.removeClass('vjs-hidden');
    }
  });
};

/**
 * @file volume-level.js
 */
/**
 * Shows volume level
 *
 * @extends Component
 */

var VolumeLevel = function (_Component) {
  inherits(VolumeLevel, _Component);

  function VolumeLevel() {
    classCallCheck(this, VolumeLevel);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  VolumeLevel.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-level',
      innerHTML: '<span class="vjs-control-text"></span>'
    });
  };

  return VolumeLevel;
}(Component);

Component.registerComponent('VolumeLevel', VolumeLevel);

/**
 * @file volume-bar.js
 */
// Required children
/**
 * The bar that contains the volume level and can be clicked on to adjust the level
 *
 * @extends Slider
 */

var VolumeBar = function (_Slider) {
  inherits(VolumeBar, _Slider);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function VolumeBar(player, options) {
    classCallCheck(this, VolumeBar);

    var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));

    _this.on('slideractive', _this.updateLastVolume_);
    _this.on(player, 'volumechange', _this.updateARIAAttributes);
    player.ready(function () {
      return _this.updateARIAAttributes();
    });
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  VolumeBar.prototype.createEl = function createEl() {
    return _Slider.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-bar vjs-slider-bar'
    }, {
      'aria-label': this.localize('Volume Level'),
      'aria-live': 'polite'
    });
  };

  /**
   * Handle movement events on the {@link VolumeMenuButton}.
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run.
   *
   * @listens mousemove
   */


  VolumeBar.prototype.handleMouseMove = function handleMouseMove(event) {
    this.checkMuted();
    this.player_.volume(this.calculateDistance(event));
  };

  /**
   * If the player is muted unmute it.
   */


  VolumeBar.prototype.checkMuted = function checkMuted() {
    if (this.player_.muted()) {
      this.player_.muted(false);
    }
  };

  /**
   * Get percent of volume level
   *
   * @return {number}
   *         Volume level percent as a decimal number.
   */


  VolumeBar.prototype.getPercent = function getPercent() {
    if (this.player_.muted()) {
      return 0;
    }
    return this.player_.volume();
  };

  /**
   * Increase volume level for keyboard users
   */


  VolumeBar.prototype.stepForward = function stepForward() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() + 0.1);
  };

  /**
   * Decrease volume level for keyboard users
   */


  VolumeBar.prototype.stepBack = function stepBack() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() - 0.1);
  };

  /**
   * Update ARIA accessibility attributes
   *
   * @param {EventTarget~Event} [event]
   *        The `volumechange` event that caused this function to run.
   *
   * @listens Player#volumechange
   */


  VolumeBar.prototype.updateARIAAttributes = function updateARIAAttributes(event) {
    var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();

    this.el_.setAttribute('aria-valuenow', ariaValue);
    this.el_.setAttribute('aria-valuetext', ariaValue + '%');
  };

  /**
   * Returns the current value of the player volume as a percentage
   *
   * @private
   */


  VolumeBar.prototype.volumeAsPercentage_ = function volumeAsPercentage_() {
    return Math.round(this.player_.volume() * 100);
  };

  /**
   * When user starts dragging the VolumeBar, store the volume and listen for
   * the end of the drag. When the drag ends, if the volume was set to zero,
   * set lastVolume to the stored volume.
   *
   * @listens slideractive
   * @private
   */


  VolumeBar.prototype.updateLastVolume_ = function updateLastVolume_() {
    var _this2 = this;

    var volumeBeforeDrag = this.player_.volume();

    this.one('sliderinactive', function () {
      if (_this2.player_.volume() === 0) {
        _this2.player_.lastVolume_(volumeBeforeDrag);
      }
    });
  };

  return VolumeBar;
}(Slider);

/**
 * Default options for the `VolumeBar`
 *
 * @type {Object}
 * @private
 */


VolumeBar.prototype.options_ = {
  children: ['volumeLevel'],
  barName: 'volumeLevel'
};

/**
 * Call the update event for this Slider when this event happens on the player.
 *
 * @type {string}
 */
VolumeBar.prototype.playerEvent = 'volumechange';

Component.registerComponent('VolumeBar', VolumeBar);

/**
 * @file volume-control.js
 */
// Required children
/**
 * The component for controlling the volume level
 *
 * @extends Component
 */

var VolumeControl = function (_Component) {
  inherits(VolumeControl, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function VolumeControl(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, VolumeControl);

    options.vertical = options.vertical || false;

    // Pass the vertical option down to the VolumeBar if
    // the VolumeBar is turned on.
    if (typeof options.volumeBar === 'undefined' || isPlain(options.volumeBar)) {
      options.volumeBar = options.volumeBar || {};
      options.volumeBar.vertical = options.vertical;
    }

    // hide this control if volume support is missing
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    checkVolumeSupport(_this, player);

    _this.throttledHandleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);

    _this.on('mousedown', _this.handleMouseDown);
    _this.on('touchstart', _this.handleMouseDown);

    // while the slider is active (the mouse has been pressed down and
    // is dragging) or in focus we do not want to hide the VolumeBar
    _this.on(_this.volumeBar, ['focus', 'slideractive'], function () {
      _this.volumeBar.addClass('vjs-slider-active');
      _this.addClass('vjs-slider-active');
      _this.trigger('slideractive');
    });

    _this.on(_this.volumeBar, ['blur', 'sliderinactive'], function () {
      _this.volumeBar.removeClass('vjs-slider-active');
      _this.removeClass('vjs-slider-active');
      _this.trigger('sliderinactive');
    });
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  VolumeControl.prototype.createEl = function createEl() {
    var orientationClass = 'vjs-volume-horizontal';

    if (this.options_.vertical) {
      orientationClass = 'vjs-volume-vertical';
    }

    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-control vjs-control ' + orientationClass
    });
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */


  VolumeControl.prototype.handleMouseDown = function handleMouseDown(event) {
    var doc = this.el_.ownerDocument;

    this.on(doc, 'mousemove', this.throttledHandleMouseMove);
    this.on(doc, 'touchmove', this.throttledHandleMouseMove);
    this.on(doc, 'mouseup', this.handleMouseUp);
    this.on(doc, 'touchend', this.handleMouseUp);
  };

  /**
   * Handle `mouseup` or `touchend` events on the `VolumeControl`.
   *
   * @param {EventTarget~Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   */


  VolumeControl.prototype.handleMouseUp = function handleMouseUp(event) {
    var doc = this.el_.ownerDocument;

    this.off(doc, 'mousemove', this.throttledHandleMouseMove);
    this.off(doc, 'touchmove', this.throttledHandleMouseMove);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchend', this.handleMouseUp);
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */


  VolumeControl.prototype.handleMouseMove = function handleMouseMove(event) {
    this.volumeBar.handleMouseMove(event);
  };

  return VolumeControl;
}(Component);

/**
 * Default options for the `VolumeControl`
 *
 * @type {Object}
 * @private
 */


VolumeControl.prototype.options_ = {
  children: ['volumeBar']
};

Component.registerComponent('VolumeControl', VolumeControl);

/**
 * @file mute-toggle.js
 */
/**
 * A button component for muting the audio.
 *
 * @extends Button
 */

var MuteToggle = function (_Button) {
  inherits(MuteToggle, _Button);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function MuteToggle(player, options) {
    classCallCheck(this, MuteToggle);

    // hide this control if volume support is missing
    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    checkVolumeSupport(_this, player);

    _this.on(player, ['loadstart', 'volumechange'], _this.update);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  MuteToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-mute-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * This gets called when an `MuteToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  MuteToggle.prototype.handleClick = function handleClick(event) {
    var vol = this.player_.volume();
    var lastVolume = this.player_.lastVolume_();

    if (vol === 0) {
      var volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;

      this.player_.volume(volumeToSet);
      this.player_.muted(false);
    } else {
      this.player_.muted(this.player_.muted() ? false : true);
    }
  };

  /**
   * Update the `MuteToggle` button based on the state of `volume` and `muted`
   * on the player.
   *
   * @param {EventTarget~Event} [event]
   *        The {@link Player#loadstart} event if this function was called
   *        through an event.
   *
   * @listens Player#loadstart
   * @listens Player#volumechange
   */


  MuteToggle.prototype.update = function update(event) {
    this.updateIcon_();
    this.updateControlText_();
  };

  /**
   * Update the appearance of the `MuteToggle` icon.
   *
   * Possible states (given `level` variable below):
   * - 0: crossed out
   * - 1: zero bars of volume
   * - 2: one bar of volume
   * - 3: two bars of volume
   *
   * @private
   */


  MuteToggle.prototype.updateIcon_ = function updateIcon_() {
    var vol = this.player_.volume();
    var level = 3;

    if (vol === 0 || this.player_.muted()) {
      level = 0;
    } else if (vol < 0.33) {
      level = 1;
    } else if (vol < 0.67) {
      level = 2;
    }

    // TODO improve muted icon classes
    for (var i = 0; i < 4; i++) {
      removeClass(this.el_, 'vjs-vol-' + i);
    }
    addClass(this.el_, 'vjs-vol-' + level);
  };

  /**
   * If `muted` has changed on the player, update the control text
   * (`title` attribute on `vjs-mute-control` element and content of
   * `vjs-control-text` element).
   *
   * @private
   */


  MuteToggle.prototype.updateControlText_ = function updateControlText_() {
    var soundOff = this.player_.muted() || this.player_.volume() === 0;
    var text = soundOff ? 'Unmute' : 'Mute';

    if (this.controlText() !== text) {
      this.controlText(text);
    }
  };

  return MuteToggle;
}(Button);

/**
 * The text that should display over the `MuteToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


MuteToggle.prototype.controlText_ = 'Mute';

Component.registerComponent('MuteToggle', MuteToggle);

/**
 * @file volume-control.js
 */
// Required children
/**
 * A Component to contain the MuteToggle and VolumeControl so that
 * they can work together.
 *
 * @extends Component
 */

var VolumePanel = function (_Component) {
  inherits(VolumePanel, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function VolumePanel(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, VolumePanel);

    if (typeof options.inline !== 'undefined') {
      options.inline = options.inline;
    } else {
      options.inline = true;
    }

    // pass the inline option down to the VolumeControl as vertical if
    // the VolumeControl is on.
    if (typeof options.volumeControl === 'undefined' || isPlain(options.volumeControl)) {
      options.volumeControl = options.volumeControl || {};
      options.volumeControl.vertical = !options.inline;
    }

    // hide this control if volume support is missing
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    checkVolumeSupport(_this, player);

    // while the slider is active (the mouse has been pressed down and
    // is dragging) or in focus we do not want to hide the VolumeBar
    _this.on(_this.volumeControl, ['slideractive'], _this.sliderActive_);
    _this.on(_this.muteToggle, 'focus', _this.sliderActive_);

    _this.on(_this.volumeControl, ['sliderinactive'], _this.sliderInactive_);
    _this.on(_this.muteToggle, 'blur', _this.sliderInactive_);
    return _this;
  }

  /**
   * Add vjs-slider-active class to the VolumePanel
   *
   * @listens VolumeControl#slideractive
   * @private
   */


  VolumePanel.prototype.sliderActive_ = function sliderActive_() {
    this.addClass('vjs-slider-active');
  };

  /**
   * Removes vjs-slider-active class to the VolumePanel
   *
   * @listens VolumeControl#sliderinactive
   * @private
   */


  VolumePanel.prototype.sliderInactive_ = function sliderInactive_() {
    this.removeClass('vjs-slider-active');
  };

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  VolumePanel.prototype.createEl = function createEl() {
    var orientationClass = 'vjs-volume-panel-horizontal';

    if (!this.options_.inline) {
      orientationClass = 'vjs-volume-panel-vertical';
    }

    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-panel vjs-control ' + orientationClass
    });
  };

  return VolumePanel;
}(Component);

/**
 * Default options for the `VolumeControl`
 *
 * @type {Object}
 * @private
 */


VolumePanel.prototype.options_ = {
  children: ['muteToggle', 'volumeControl']
};

Component.registerComponent('VolumePanel', VolumePanel);

/**
 * @file menu.js
 */
/**
 * The Menu component is used to build popup menus, including subtitle and
 * captions selection menus.
 *
 * @extends Component
 */

var Menu = function (_Component) {
  inherits(Menu, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        the player that this component should attach to
   *
   * @param {Object} [options]
   *        Object of option names and values
   *
   */
  function Menu(player, options) {
    classCallCheck(this, Menu);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    if (options) {
      _this.menuButton_ = options.menuButton;
    }

    _this.focusedChild_ = -1;

    _this.on('keydown', _this.handleKeyPress);
    return _this;
  }

  /**
   * Add a {@link MenuItem} to the menu.
   *
   * @param {Object|string} component
   *        The name or instance of the `MenuItem` to add.
   *
   */


  Menu.prototype.addItem = function addItem(component) {
    this.addChild(component);
    component.on('click', bind(this, function (event) {
      // Unpress the associated MenuButton, and move focus back to it
      if (this.menuButton_) {
        this.menuButton_.unpressButton();

        // don't focus menu button if item is a caption settings item
        // because focus will move elsewhere and it logs an error on IE8
        if (component.name() !== 'CaptionSettingsMenuItem') {
          this.menuButton_.focus();
        }
      }
    }));
  };

  /**
   * Create the `Menu`s DOM element.
   *
   * @return {Element}
   *         the element that was created
   */


  Menu.prototype.createEl = function createEl$$1() {
    var contentElType = this.options_.contentElType || 'ul';

    this.contentEl_ = createEl(contentElType, {
      className: 'vjs-menu-content'
    });

    this.contentEl_.setAttribute('role', 'menu');

    var el = _Component.prototype.createEl.call(this, 'div', {
      append: this.contentEl_,
      className: 'vjs-menu'
    });

    el.appendChild(this.contentEl_);

    // Prevent clicks from bubbling up. Needed for Menu Buttons,
    // where a click on the parent is significant
    on(el, 'click', function (event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    });

    return el;
  };

  /**
   * Handle a `keydown` event on this menu. This listener is added in the constructor.
   *
   * @param {EventTarget~Event} event
   *        A `keydown` event that happened on the menu.
   *
   * @listens keydown
   */


  Menu.prototype.handleKeyPress = function handleKeyPress(event) {
    // Left and Down Arrows
    if (event.which === 37 || event.which === 40) {
      event.preventDefault();
      this.stepForward();

      // Up and Right Arrows
    } else if (event.which === 38 || event.which === 39) {
      event.preventDefault();
      this.stepBack();
    }
  };

  /**
   * Move to next (lower) menu item for keyboard users.
   */


  Menu.prototype.stepForward = function stepForward() {
    var stepChild = 0;

    if (this.focusedChild_ !== undefined) {
      stepChild = this.focusedChild_ + 1;
    }
    this.focus(stepChild);
  };

  /**
   * Move to previous (higher) menu item for keyboard users.
   */


  Menu.prototype.stepBack = function stepBack() {
    var stepChild = 0;

    if (this.focusedChild_ !== undefined) {
      stepChild = this.focusedChild_ - 1;
    }
    this.focus(stepChild);
  };

  /**
   * Set focus on a {@link MenuItem} in the `Menu`.
   *
   * @param {Object|string} [item=0]
   *        Index of child item set focus on.
   */


  Menu.prototype.focus = function focus() {
    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    var children = this.children().slice();
    var haveTitle = children.length && children[0].className && /vjs-menu-title/.test(children[0].className);

    if (haveTitle) {
      children.shift();
    }

    if (children.length > 0) {
      if (item < 0) {
        item = 0;
      } else if (item >= children.length) {
        item = children.length - 1;
      }

      this.focusedChild_ = item;

      children[item].el_.focus();
    }
  };

  return Menu;
}(Component);

Component.registerComponent('Menu', Menu);

/**
 * @file menu-button.js
 */
/**
 * A `MenuButton` class for any popup {@link Menu}.
 *
 * @extends Component
 */

var MenuButton = function (_Component) {
  inherits(MenuButton, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function MenuButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, MenuButton);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.menuButton_ = new Button(player, options);

    _this.menuButton_.controlText(_this.controlText_);
    _this.menuButton_.el_.setAttribute('aria-haspopup', 'true');

    // Add buildCSSClass values to the button, not the wrapper
    var buttonClass = Button.prototype.buildCSSClass();

    _this.menuButton_.el_.className = _this.buildCSSClass() + ' ' + buttonClass;
    _this.menuButton_.removeClass('vjs-control');

    _this.addChild(_this.menuButton_);

    _this.update();

    _this.enabled_ = true;

    _this.on(_this.menuButton_, 'tap', _this.handleClick);
    _this.on(_this.menuButton_, 'click', _this.handleClick);
    _this.on(_this.menuButton_, 'focus', _this.handleFocus);
    _this.on(_this.menuButton_, 'blur', _this.handleBlur);

    _this.on('keydown', _this.handleSubmenuKeyPress);
    return _this;
  }

  /**
   * Update the menu based on the current state of its items.
   */


  MenuButton.prototype.update = function update() {
    var menu = this.createMenu();

    if (this.menu) {
      this.removeChild(this.menu);
    }

    this.menu = menu;
    this.addChild(menu);

    /**
     * Track the state of the menu button
     *
     * @type {Boolean}
     * @private
     */
    this.buttonPressed_ = false;
    this.menuButton_.el_.setAttribute('aria-expanded', 'false');

    if (this.items && this.items.length <= this.hideThreshold_) {
      this.hide();
    } else {
      this.show();
    }
  };

  /**
   * Create the menu and add all items to it.
   *
   * @return {Menu}
   *         The constructed menu
   */


  MenuButton.prototype.createMenu = function createMenu() {
    var menu = new Menu(this.player_, { menuButton: this });

    /**
     * Hide the menu if the number of items is less than or equal to this threshold. This defaults
     * to 0 and whenever we add items which can be hidden to the menu we'll increment it. We list
     * it here because every time we run `createMenu` we need to reset the value.
     *
     * @protected
     * @type {Number}
     */
    this.hideThreshold_ = 0;

    // Add a title list item to the top
    if (this.options_.title) {
      var title = createEl('li', {
        className: 'vjs-menu-title',
        innerHTML: toTitleCase(this.options_.title),
        tabIndex: -1
      });

      this.hideThreshold_ += 1;

      menu.children_.unshift(title);
      prependTo(title, menu.contentEl());
    }

    this.items = this.createItems();

    if (this.items) {
      // Add menu items to the menu
      for (var i = 0; i < this.items.length; i++) {
        menu.addItem(this.items[i]);
      }
    }

    return menu;
  };

  /**
   * Create the list of menu items. Specific to each subclass.
   *
   * @abstract
   */


  MenuButton.prototype.createItems = function createItems() {};

  /**
   * Create the `MenuButtons`s DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  MenuButton.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildWrapperCSSClass()
    }, {});
  };

  /**
   * Allow sub components to stack CSS class names for the wrapper element
   *
   * @return {string}
   *         The constructed wrapper DOM `className`
   */


  MenuButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    var menuButtonClass = 'vjs-menu-button';

    // If the inline option is passed, we want to use different styles altogether.
    if (this.options_.inline === true) {
      menuButtonClass += '-inline';
    } else {
      menuButtonClass += '-popup';
    }

    // TODO: Fix the CSS so that this isn't necessary
    var buttonClass = Button.prototype.buildCSSClass();

    return 'vjs-menu-button ' + menuButtonClass + ' ' + buttonClass + ' ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  MenuButton.prototype.buildCSSClass = function buildCSSClass() {
    var menuButtonClass = 'vjs-menu-button';

    // If the inline option is passed, we want to use different styles altogether.
    if (this.options_.inline === true) {
      menuButtonClass += '-inline';
    } else {
      menuButtonClass += '-popup';
    }

    return 'vjs-menu-button ' + menuButtonClass + ' ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Get or set the localized control text that will be used for accessibility.
   *
   * > NOTE: This will come from the internal `menuButton_` element.
   *
   * @param {string} [text]
   *        Control text for element.
   *
   * @param {Element} [el=this.menuButton_.el()]
   *        Element to set the title on.
   *
   * @return {string}
   *         - The control text when getting
   */


  MenuButton.prototype.controlText = function controlText(text) {
    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.menuButton_.el();

    return this.menuButton_.controlText(text, el);
  };

  /**
   * Handle a click on a `MenuButton`.
   * See {@link ClickableComponent#handleClick} for instances where this is called.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  MenuButton.prototype.handleClick = function handleClick(event) {
    // When you click the button it adds focus, which will show the menu.
    // So we'll remove focus when the mouse leaves the button. Focus is needed
    // for tab navigation.

    this.one(this.menu.contentEl(), 'mouseleave', bind(this, function (e) {
      this.unpressButton();
      this.el_.blur();
    }));
    if (this.buttonPressed_) {
      this.unpressButton();
    } else {
      this.pressButton();
    }
  };

  /**
   * Set the focus to the actual button, not to this element
   */


  MenuButton.prototype.focus = function focus() {
    this.menuButton_.focus();
  };

  /**
   * Remove the focus from the actual button, not this element
   */


  MenuButton.prototype.blur = function blur() {
    this.menuButton_.blur();
  };

  /**
   * This gets called when a `MenuButton` gains focus via a `focus` event.
   * Turns on listening for `keydown` events. When they happen it
   * calls `this.handleKeyPress`.
   *
   * @param {EventTarget~Event} event
   *        The `focus` event that caused this function to be called.
   *
   * @listens focus
   */


  MenuButton.prototype.handleFocus = function handleFocus() {
    on(document, 'keydown', bind(this, this.handleKeyPress));
  };

  /**
   * Called when a `MenuButton` loses focus. Turns off the listener for
   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.
   *
   * @param {EventTarget~Event} event
   *        The `blur` event that caused this function to be called.
   *
   * @listens blur
   */


  MenuButton.prototype.handleBlur = function handleBlur() {
    off(document, 'keydown', bind(this, this.handleKeyPress));
  };

  /**
   * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See
   * {@link ClickableComponent#handleKeyPress} for instances where this is called.
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */


  MenuButton.prototype.handleKeyPress = function handleKeyPress(event) {

    // Escape (27) key or Tab (9) key unpress the 'button'
    if (event.which === 27 || event.which === 9) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      // Don't preventDefault for Tab key - we still want to lose focus
      if (event.which !== 9) {
        event.preventDefault();
        // Set focus back to the menu button's button
        this.menuButton_.el_.focus();
      }
      // Up (38) key or Down (40) key press the 'button'
    } else if (event.which === 38 || event.which === 40) {
      if (!this.buttonPressed_) {
        this.pressButton();
        event.preventDefault();
      }
    }
  };

  /**
   * Handle a `keydown` event on a sub-menu. The listener for this is added in
   * the constructor.
   *
   * @param {EventTarget~Event} event
   *        Key press event
   *
   * @listens keydown
   */


  MenuButton.prototype.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {

    // Escape (27) key or Tab (9) key unpress the 'button'
    if (event.which === 27 || event.which === 9) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      // Don't preventDefault for Tab key - we still want to lose focus
      if (event.which !== 9) {
        event.preventDefault();
        // Set focus back to the menu button's button
        this.menuButton_.el_.focus();
      }
    }
  };

  /**
   * Put the current `MenuButton` into a pressed state.
   */


  MenuButton.prototype.pressButton = function pressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = true;
      this.menu.lockShowing();
      this.menuButton_.el_.setAttribute('aria-expanded', 'true');
      // set the focus into the submenu
      this.menu.focus();
    }
  };

  /**
   * Take the current `MenuButton` out of a pressed state.
   */


  MenuButton.prototype.unpressButton = function unpressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = false;
      this.menu.unlockShowing();
      this.menuButton_.el_.setAttribute('aria-expanded', 'false');
    }
  };

  /**
   * Disable the `MenuButton`. Don't allow it to be clicked.
   */


  MenuButton.prototype.disable = function disable() {
    this.unpressButton();

    this.enabled_ = false;
    this.addClass('vjs-disabled');

    this.menuButton_.disable();
  };

  /**
   * Enable the `MenuButton`. Allow it to be clicked.
   */


  MenuButton.prototype.enable = function enable() {
    this.enabled_ = true;
    this.removeClass('vjs-disabled');

    this.menuButton_.enable();
  };

  return MenuButton;
}(Component);

Component.registerComponent('MenuButton', MenuButton);

/**
 * @file track-button.js
 */
/**
 * The base class for buttons that toggle specific  track types (e.g. subtitles).
 *
 * @extends MenuButton
 */

var TrackButton = function (_MenuButton) {
  inherits(TrackButton, _MenuButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function TrackButton(player, options) {
    classCallCheck(this, TrackButton);

    var tracks = options.tracks;

    var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));

    if (_this.items.length <= 1) {
      _this.hide();
    }

    if (!tracks) {
      return possibleConstructorReturn(_this);
    }

    var updateHandler = bind(_this, _this.update);

    tracks.addEventListener('removetrack', updateHandler);
    tracks.addEventListener('addtrack', updateHandler);
    _this.player_.on('ready', updateHandler);

    _this.player_.on('dispose', function () {
      tracks.removeEventListener('removetrack', updateHandler);
      tracks.removeEventListener('addtrack', updateHandler);
    });
    return _this;
  }

  return TrackButton;
}(MenuButton);

Component.registerComponent('TrackButton', TrackButton);

/**
 * @file menu-item.js
 */
/**
 * The component for a menu item. `<li>`
 *
 * @extends ClickableComponent
 */

var MenuItem = function (_ClickableComponent) {
  inherits(MenuItem, _ClickableComponent);

  /**
   * Creates an instance of the this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   *
   */
  function MenuItem(player, options) {
    classCallCheck(this, MenuItem);

    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));

    _this.selectable = options.selectable;

    _this.selected(options.selected);

    if (_this.selectable) {
      // TODO: May need to be either menuitemcheckbox or menuitemradio,
      //       and may need logical grouping of menu items.
      _this.el_.setAttribute('role', 'menuitemcheckbox');
    } else {
      _this.el_.setAttribute('role', 'menuitem');
    }
    return _this;
  }

  /**
   * Create the `MenuItem's DOM element
   *
   * @param {string} [type=li]
   *        Element's node type, not actually used, always set to `li`.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element
   *
   * @param {Object} [attrs={}]
   *        An object of attributes that should be set on the element
   *
   * @return {Element}
   *         The element that gets created.
   */


  MenuItem.prototype.createEl = function createEl(type, props, attrs) {
    // The control is textual, not just an icon
    this.nonIconControl = true;

    return _ClickableComponent.prototype.createEl.call(this, 'li', assign({
      className: 'vjs-menu-item',
      innerHTML: '<span class="vjs-menu-item-text">' + this.localize(this.options_.label) + '</span>',
      tabIndex: -1
    }, props), attrs);
  };

  /**
   * Any click on a `MenuItem` puts int into the selected state.
   * See {@link ClickableComponent#handleClick} for instances where this is called.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  MenuItem.prototype.handleClick = function handleClick(event) {
    this.selected(true);
  };

  /**
   * Set the state for this menu item as selected or not.
   *
   * @param {boolean} selected
   *        if the menu item is selected or not
   */


  MenuItem.prototype.selected = function selected(_selected) {
    if (this.selectable) {
      if (_selected) {
        this.addClass('vjs-selected');
        this.el_.setAttribute('aria-checked', 'true');
        // aria-checked isn't fully supported by browsers/screen readers,
        // so indicate selected state to screen reader in the control text.
        this.controlText(', selected');
      } else {
        this.removeClass('vjs-selected');
        this.el_.setAttribute('aria-checked', 'false');
        // Indicate un-selected state to screen reader
        // Note that a space clears out the selected state text
        this.controlText(' ');
      }
    }
  };

  return MenuItem;
}(ClickableComponent);

Component.registerComponent('MenuItem', MenuItem);

/**
 * @file text-track-menu-item.js
 */
/**
 * The specific menu item type for selecting a language within a text track kind
 *
 * @extends MenuItem
 */

var TextTrackMenuItem = function (_MenuItem) {
  inherits(TextTrackMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function TextTrackMenuItem(player, options) {
    classCallCheck(this, TextTrackMenuItem);

    var track = options.track;
    var tracks = player.textTracks();

    // Modify options for parent MenuItem class's init.
    options.label = track.label || track.language || 'Unknown';
    options.selected = track.mode === 'showing';

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.track = track;
    var changeHandler = bind(_this, _this.handleTracksChange);
    var selectedLanguageChangeHandler = bind(_this, _this.handleSelectedLanguageChange);

    player.on(['loadstart', 'texttrackchange'], changeHandler);
    tracks.addEventListener('change', changeHandler);
    tracks.addEventListener('selectedlanguagechange', selectedLanguageChangeHandler);
    _this.on('dispose', function () {
      tracks.removeEventListener('change', changeHandler);
      tracks.removeEventListener('selectedlanguagechange', selectedLanguageChangeHandler);
    });

    // iOS7 doesn't dispatch change events to TextTrackLists when an
    // associated track's mode changes. Without something like
    // Object.observe() (also not present on iOS7), it's not
    // possible to detect changes to the mode attribute and polyfill
    // the change event. As a poor substitute, we manually dispatch
    // change events whenever the controls modify the mode.
    if (tracks.onchange === undefined) {
      var event = void 0;

      _this.on(['tap', 'click'], function () {
        if (_typeof(window.Event) !== 'object') {
          // Android 2.3 throws an Illegal Constructor error for window.Event
          try {
            event = new window.Event('change');
          } catch (err) {
            // continue regardless of error
          }
        }

        if (!event) {
          event = document.createEvent('Event');
          event.initEvent('change', true, true);
        }

        tracks.dispatchEvent(event);
      });
    }
    return _this;
  }

  /**
   * This gets called when an `TextTrackMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  TextTrackMenuItem.prototype.handleClick = function handleClick(event) {
    var kind = this.track.kind;
    var kinds = this.track.kinds;
    var tracks = this.player_.textTracks();

    if (!kinds) {
      kinds = [kind];
    }

    _MenuItem.prototype.handleClick.call(this, event);

    if (!tracks) {
      return;
    }

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      if (track === this.track && kinds.indexOf(track.kind) > -1) {
        if (track.mode !== 'showing') {
          track.mode = 'showing';
        }
      } else if (track.mode !== 'disabled') {
        track.mode = 'disabled';
      }
    }
  };

  /**
   * Handle text track list change
   *
   * @param {EventTarget~Event} event
   *        The `change` event that caused this function to be called.
   *
   * @listens TextTrackList#change
   */


  TextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    this.selected(this.track.mode === 'showing');
  };

  TextTrackMenuItem.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
    if (this.track.mode === 'showing') {
      var selectedLanguage = this.player_.cache_.selectedLanguage;

      // Don't replace the kind of track across the same language
      if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {
        return;
      }

      this.player_.cache_.selectedLanguage = {
        enabled: true,
        language: this.track.language,
        kind: this.track.kind
      };
    }
  };

  return TextTrackMenuItem;
}(MenuItem);

Component.registerComponent('TextTrackMenuItem', TextTrackMenuItem);

/**
 * @file off-text-track-menu-item.js
 */
/**
 * A special menu item for turning of a specific type of text track
 *
 * @extends TextTrackMenuItem
 */

var OffTextTrackMenuItem = function (_TextTrackMenuItem) {
  inherits(OffTextTrackMenuItem, _TextTrackMenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function OffTextTrackMenuItem(player, options) {
    classCallCheck(this, OffTextTrackMenuItem);

    // Create pseudo track info
    // Requires options['kind']
    options.track = {
      player: player,
      kind: options.kind,
      kinds: options.kinds,
      'default': false,
      mode: 'disabled'
    };

    if (!options.kinds) {
      options.kinds = [options.kind];
    }

    if (options.label) {
      options.track.label = options.label;
    } else {
      options.track.label = options.kinds.join(' and ') + ' off';
    }

    // MenuItem is selectable
    options.selectable = true;

    var _this = possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));

    _this.selected(true);
    return _this;
  }

  /**
   * Handle text track change
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run
   */


  OffTextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var selected = true;

    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];

      if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === 'showing') {
        selected = false;
        break;
      }
    }

    this.selected(selected);
  };

  OffTextTrackMenuItem.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
    var tracks = this.player().textTracks();
    var allHidden = true;

    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];

      if (['captions', 'descriptions', 'subtitles'].indexOf(track.kind) > -1 && track.mode === 'showing') {
        allHidden = false;
        break;
      }
    }

    if (allHidden) {
      this.player_.cache_.selectedLanguage = {
        enabled: false
      };
    }
  };

  return OffTextTrackMenuItem;
}(TextTrackMenuItem);

Component.registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);

/**
 * @file text-track-button.js
 */
/**
 * The base class for buttons that toggle specific text track types (e.g. subtitles)
 *
 * @extends MenuButton
 */

var TextTrackButton = function (_TrackButton) {
  inherits(TextTrackButton, _TrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function TextTrackButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, TextTrackButton);

    options.tracks = player.textTracks();

    return possibleConstructorReturn(this, _TrackButton.call(this, player, options));
  }

  /**
   * Create a menu item for each text track
   *
   * @param {TextTrackMenuItem[]} [items=[]]
   *        Existing array of items to use during creation
   *
   * @return {TextTrackMenuItem[]}
   *         Array of menu items that were created
   */


  TextTrackButton.prototype.createItems = function createItems() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var TrackMenuItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TextTrackMenuItem;


    // Label is an overide for the [track] off label
    // USed to localise captions/subtitles
    var label = void 0;

    if (this.label_) {
      label = this.label_ + ' off';
    }
    // Add an OFF menu item to turn all tracks off
    items.push(new OffTextTrackMenuItem(this.player_, {
      kinds: this.kinds_,
      kind: this.kind_,
      label: label
    }));

    this.hideThreshold_ += 1;

    var tracks = this.player_.textTracks();

    if (!Array.isArray(this.kinds_)) {
      this.kinds_ = [this.kind_];
    }

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      // only add tracks that are of an appropriate kind and have a label
      if (this.kinds_.indexOf(track.kind) > -1) {

        var item = new TrackMenuItem(this.player_, {
          track: track,
          // MenuItem is selectable
          selectable: true
        });

        item.addClass('vjs-' + track.kind + '-menu-item');
        items.push(item);
      }
    }

    return items;
  };

  return TextTrackButton;
}(TrackButton);

Component.registerComponent('TextTrackButton', TextTrackButton);

/**
 * @file chapters-track-menu-item.js
 */
/**
 * The chapter track menu item
 *
 * @extends MenuItem
 */

var ChaptersTrackMenuItem = function (_MenuItem) {
  inherits(ChaptersTrackMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function ChaptersTrackMenuItem(player, options) {
    classCallCheck(this, ChaptersTrackMenuItem);

    var track = options.track;
    var cue = options.cue;
    var currentTime = player.currentTime();

    // Modify options for parent MenuItem class's init.
    options.selectable = true;
    options.label = cue.text;
    options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.track = track;
    _this.cue = cue;
    track.addEventListener('cuechange', bind(_this, _this.update));
    return _this;
  }

  /**
   * This gets called when an `ChaptersTrackMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  ChaptersTrackMenuItem.prototype.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this);
    this.player_.currentTime(this.cue.startTime);
    this.update(this.cue.startTime);
  };

  /**
   * Update chapter menu item
   *
   * @param {EventTarget~Event} [event]
   *        The `cuechange` event that caused this function to run.
   *
   * @listens TextTrack#cuechange
   */


  ChaptersTrackMenuItem.prototype.update = function update(event) {
    var cue = this.cue;
    var currentTime = this.player_.currentTime();

    // vjs.log(currentTime, cue.startTime);
    this.selected(cue.startTime <= currentTime && currentTime < cue.endTime);
  };

  return ChaptersTrackMenuItem;
}(MenuItem);

Component.registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);

/**
 * @file chapters-button.js
 */
/**
 * The button component for toggling and selecting chapters
 * Chapters act much differently than other text tracks
 * Cues are navigation vs. other tracks of alternative languages
 *
 * @extends TextTrackButton
 */

var ChaptersButton = function (_TextTrackButton) {
  inherits(ChaptersButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this function is ready.
   */
  function ChaptersButton(player, options, ready) {
    classCallCheck(this, ChaptersButton);
    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  ChaptersButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  ChaptersButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Update the menu based on the current state of its items.
   *
   * @param {EventTarget~Event} [event]
   *        An event that triggered this function to run.
   *
   * @listens TextTrackList#addtrack
   * @listens TextTrackList#removetrack
   * @listens TextTrackList#change
   */


  ChaptersButton.prototype.update = function update(event) {
    if (!this.track_ || event && (event.type === 'addtrack' || event.type === 'removetrack')) {
      this.setTrack(this.findChaptersTrack());
    }
    _TextTrackButton.prototype.update.call(this);
  };

  /**
   * Set the currently selected track for the chapters button.
   *
   * @param {TextTrack} track
   *        The new track to select. Nothing will change if this is the currently selected
   *        track.
   */


  ChaptersButton.prototype.setTrack = function setTrack(track) {
    if (this.track_ === track) {
      return;
    }

    if (!this.updateHandler_) {
      this.updateHandler_ = this.update.bind(this);
    }

    // here this.track_ refers to the old track instance
    if (this.track_) {
      var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);

      if (remoteTextTrackEl) {
        remoteTextTrackEl.removeEventListener('load', this.updateHandler_);
      }

      this.track_ = null;
    }

    this.track_ = track;

    // here this.track_ refers to the new track instance
    if (this.track_) {
      this.track_.mode = 'hidden';

      var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);

      if (_remoteTextTrackEl) {
        _remoteTextTrackEl.addEventListener('load', this.updateHandler_);
      }
    }
  };

  /**
   * Find the track object that is currently in use by this ChaptersButton
   *
   * @return {TextTrack|undefined}
   *         The current track or undefined if none was found.
   */


  ChaptersButton.prototype.findChaptersTrack = function findChaptersTrack() {
    var tracks = this.player_.textTracks() || [];

    for (var i = tracks.length - 1; i >= 0; i--) {
      // We will always choose the last track as our chaptersTrack
      var track = tracks[i];

      if (track.kind === this.kind_) {
        return track;
      }
    }
  };

  /**
   * Get the caption for the ChaptersButton based on the track label. This will also
   * use the current tracks localized kind as a fallback if a label does not exist.
   *
   * @return {string}
   *         The tracks current label or the localized track kind.
   */


  ChaptersButton.prototype.getMenuCaption = function getMenuCaption() {
    if (this.track_ && this.track_.label) {
      return this.track_.label;
    }
    return this.localize(toTitleCase(this.kind_));
  };

  /**
   * Create menu from chapter track
   *
   * @return {Menu}
   *         New menu for the chapter buttons
   */


  ChaptersButton.prototype.createMenu = function createMenu() {
    this.options_.title = this.getMenuCaption();
    return _TextTrackButton.prototype.createMenu.call(this);
  };

  /**
   * Create a menu item for each text track
   *
   * @return {TextTrackMenuItem[]}
   *         Array of menu items
   */


  ChaptersButton.prototype.createItems = function createItems() {
    var items = [];

    if (!this.track_) {
      return items;
    }

    var cues = this.track_.cues;

    if (!cues) {
      return items;
    }

    for (var i = 0, l = cues.length; i < l; i++) {
      var cue = cues[i];
      var mi = new ChaptersTrackMenuItem(this.player_, { track: this.track_, cue: cue });

      items.push(mi);
    }

    return items;
  };

  return ChaptersButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


ChaptersButton.prototype.kind_ = 'chapters';

/**
 * The text that should display over the `ChaptersButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
ChaptersButton.prototype.controlText_ = 'Chapters';

Component.registerComponent('ChaptersButton', ChaptersButton);

/**
 * @file descriptions-button.js
 */
/**
 * The button component for toggling and selecting descriptions
 *
 * @extends TextTrackButton
 */

var DescriptionsButton = function (_TextTrackButton) {
  inherits(DescriptionsButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this component is ready.
   */
  function DescriptionsButton(player, options, ready) {
    classCallCheck(this, DescriptionsButton);

    var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));

    var tracks = player.textTracks();
    var changeHandler = bind(_this, _this.handleTracksChange);

    tracks.addEventListener('change', changeHandler);
    _this.on('dispose', function () {
      tracks.removeEventListener('change', changeHandler);
    });
    return _this;
  }

  /**
   * Handle text track change
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run
   *
   * @listens TextTrackList#change
   */


  DescriptionsButton.prototype.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var disabled = false;

    // Check whether a track of a different kind is showing
    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];

      if (track.kind !== this.kind_ && track.mode === 'showing') {
        disabled = true;
        break;
      }
    }

    // If another track is showing, disable this menu button
    if (disabled) {
      this.disable();
    } else {
      this.enable();
    }
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  DescriptionsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  DescriptionsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  return DescriptionsButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


DescriptionsButton.prototype.kind_ = 'descriptions';

/**
 * The text that should display over the `DescriptionsButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
DescriptionsButton.prototype.controlText_ = 'Descriptions';

Component.registerComponent('DescriptionsButton', DescriptionsButton);

/**
 * @file subtitles-button.js
 */
/**
 * The button component for toggling and selecting subtitles
 *
 * @extends TextTrackButton
 */

var SubtitlesButton = function (_TextTrackButton) {
  inherits(SubtitlesButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this component is ready.
   */
  function SubtitlesButton(player, options, ready) {
    classCallCheck(this, SubtitlesButton);
    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  SubtitlesButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  SubtitlesButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  return SubtitlesButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


SubtitlesButton.prototype.kind_ = 'subtitles';

/**
 * The text that should display over the `SubtitlesButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
SubtitlesButton.prototype.controlText_ = 'Subtitles';

Component.registerComponent('SubtitlesButton', SubtitlesButton);

/**
 * @file caption-settings-menu-item.js
 */
/**
 * The menu item for caption track settings menu
 *
 * @extends TextTrackMenuItem
 */

var CaptionSettingsMenuItem = function (_TextTrackMenuItem) {
  inherits(CaptionSettingsMenuItem, _TextTrackMenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function CaptionSettingsMenuItem(player, options) {
    classCallCheck(this, CaptionSettingsMenuItem);

    options.track = {
      player: player,
      kind: options.kind,
      label: options.kind + ' settings',
      selectable: false,
      'default': false,
      mode: 'disabled'
    };

    // CaptionSettingsMenuItem has no concept of 'selected'
    options.selectable = false;

    options.name = 'CaptionSettingsMenuItem';

    var _this = possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));

    _this.addClass('vjs-texttrack-settings');
    _this.controlText(', opens ' + options.kind + ' settings dialog');
    return _this;
  }

  /**
   * This gets called when an `CaptionSettingsMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  CaptionSettingsMenuItem.prototype.handleClick = function handleClick(event) {
    this.player().getChild('textTrackSettings').open();
  };

  return CaptionSettingsMenuItem;
}(TextTrackMenuItem);

Component.registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);

/**
 * @file captions-button.js
 */
/**
 * The button component for toggling and selecting captions
 *
 * @extends TextTrackButton
 */

var CaptionsButton = function (_TextTrackButton) {
  inherits(CaptionsButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this component is ready.
   */
  function CaptionsButton(player, options, ready) {
    classCallCheck(this, CaptionsButton);
    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  CaptionsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  CaptionsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create caption menu items
   *
   * @return {CaptionSettingsMenuItem[]}
   *         The array of current menu items.
   */


  CaptionsButton.prototype.createItems = function createItems() {
    var items = [];

    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks)) {
      items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.kind_ }));

      this.hideThreshold_ += 1;
    }

    return _TextTrackButton.prototype.createItems.call(this, items);
  };

  return CaptionsButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


CaptionsButton.prototype.kind_ = 'captions';

/**
 * The text that should display over the `CaptionsButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
CaptionsButton.prototype.controlText_ = 'Captions';

Component.registerComponent('CaptionsButton', CaptionsButton);

/**
 * @file subs-caps-menu-item.js
 */
/**
 * SubsCapsMenuItem has an [cc] icon to distinguish captions from subtitles
 * in the SubsCapsMenu.
 *
 * @extends TextTrackMenuItem
 */

var SubsCapsMenuItem = function (_TextTrackMenuItem) {
  inherits(SubsCapsMenuItem, _TextTrackMenuItem);

  function SubsCapsMenuItem() {
    classCallCheck(this, SubsCapsMenuItem);
    return possibleConstructorReturn(this, _TextTrackMenuItem.apply(this, arguments));
  }

  SubsCapsMenuItem.prototype.createEl = function createEl(type, props, attrs) {
    var innerHTML = '<span class="vjs-menu-item-text">' + this.localize(this.options_.label);

    if (this.options_.track.kind === 'captions') {
      innerHTML += '\n        <span aria-hidden="true" class="vjs-icon-placeholder"></span>\n        <span class="vjs-control-text"> ' + this.localize('Captions') + '</span>\n      ';
    }

    innerHTML += '</span>';

    var el = _TextTrackMenuItem.prototype.createEl.call(this, type, assign({
      innerHTML: innerHTML
    }, props), attrs);

    return el;
  };

  return SubsCapsMenuItem;
}(TextTrackMenuItem);

Component.registerComponent('SubsCapsMenuItem', SubsCapsMenuItem);

/**
 * @file sub-caps-button.js
 */
/**
 * The button component for toggling and selecting captions and/or subtitles
 *
 * @extends TextTrackButton
 */

var SubsCapsButton = function (_TextTrackButton) {
  inherits(SubsCapsButton, _TextTrackButton);

  function SubsCapsButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, SubsCapsButton);

    // Although North America uses "captions" in most cases for
    // "captions and subtitles" other locales use "subtitles"
    var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options));

    _this.label_ = 'subtitles';
    if (['en', 'en-us', 'en-ca', 'fr-ca'].indexOf(_this.player_.language_) > -1) {
      _this.label_ = 'captions';
    }
    _this.menuButton_.controlText(toTitleCase(_this.label_));
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  SubsCapsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-subs-caps-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  SubsCapsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-subs-caps-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create caption/subtitles menu items
   *
   * @return {CaptionSettingsMenuItem[]}
   *         The array of current menu items.
   */


  SubsCapsButton.prototype.createItems = function createItems() {
    var items = [];

    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks)) {
      items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.label_ }));

      this.hideThreshold_ += 1;
    }

    items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);
    return items;
  };

  return SubsCapsButton;
}(TextTrackButton);

/**
 * `kind`s of TextTrack to look for to associate it with this menu.
 *
 * @type {array}
 * @private
 */


SubsCapsButton.prototype.kinds_ = ['captions', 'subtitles'];

/**
 * The text that should display over the `SubsCapsButton`s controls.
 *
 *
 * @type {string}
 * @private
 */
SubsCapsButton.prototype.controlText_ = 'Subtitles';

Component.registerComponent('SubsCapsButton', SubsCapsButton);

/**
 * @file audio-track-menu-item.js
 */
/**
 * An {@link AudioTrack} {@link MenuItem}
 *
 * @extends MenuItem
 */

var AudioTrackMenuItem = function (_MenuItem) {
  inherits(AudioTrackMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function AudioTrackMenuItem(player, options) {
    classCallCheck(this, AudioTrackMenuItem);

    var track = options.track;
    var tracks = player.audioTracks();

    // Modify options for parent MenuItem class's init.
    options.label = track.label || track.language || 'Unknown';
    options.selected = track.enabled;

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.track = track;

    var changeHandler = bind(_this, _this.handleTracksChange);

    tracks.addEventListener('change', changeHandler);
    _this.on('dispose', function () {
      tracks.removeEventListener('change', changeHandler);
    });
    return _this;
  }

  /**
   * This gets called when an `AudioTrackMenuItem is "clicked". See {@link ClickableComponent}
   * for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  AudioTrackMenuItem.prototype.handleClick = function handleClick(event) {
    var tracks = this.player_.audioTracks();

    _MenuItem.prototype.handleClick.call(this, event);

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      track.enabled = track === this.track;
    }
  };

  /**
   * Handle any {@link AudioTrack} change.
   *
   * @param {EventTarget~Event} [event]
   *        The {@link AudioTrackList#change} event that caused this to run.
   *
   * @listens AudioTrackList#change
   */


  AudioTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    this.selected(this.track.enabled);
  };

  return AudioTrackMenuItem;
}(MenuItem);

Component.registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);

/**
 * @file audio-track-button.js
 */
/**
 * The base class for buttons that toggle specific {@link AudioTrack} types.
 *
 * @extends TrackButton
 */

var AudioTrackButton = function (_TrackButton) {
  inherits(AudioTrackButton, _TrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function AudioTrackButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, AudioTrackButton);

    options.tracks = player.audioTracks();

    return possibleConstructorReturn(this, _TrackButton.call(this, player, options));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  AudioTrackButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-audio-button ' + _TrackButton.prototype.buildCSSClass.call(this);
  };

  AudioTrackButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-audio-button ' + _TrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create a menu item for each audio track
   *
   * @param {AudioTrackMenuItem[]} [items=[]]
   *        An array of existing menu items to use.
   *
   * @return {AudioTrackMenuItem[]}
   *         An array of menu items
   */


  AudioTrackButton.prototype.createItems = function createItems() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    // if there's only one audio track, there no point in showing it
    this.hideThreshold_ = 1;

    var tracks = this.player_.audioTracks();

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      items.push(new AudioTrackMenuItem(this.player_, {
        track: track,
        // MenuItem is selectable
        selectable: true
      }));
    }

    return items;
  };

  return AudioTrackButton;
}(TrackButton);

/**
 * The text that should display over the `AudioTrackButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


AudioTrackButton.prototype.controlText_ = 'Audio Track';
Component.registerComponent('AudioTrackButton', AudioTrackButton);

/**
 * @file playback-rate-menu-item.js
 */
/**
 * The specific menu item type for selecting a playback rate.
 *
 * @extends MenuItem
 */

var PlaybackRateMenuItem = function (_MenuItem) {
  inherits(PlaybackRateMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PlaybackRateMenuItem(player, options) {
    classCallCheck(this, PlaybackRateMenuItem);

    var label = options.rate;
    var rate = parseFloat(label, 10);

    // Modify options for parent MenuItem class's init.
    options.label = label;
    options.selected = rate === 1;
    options.selectable = true;

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.label = label;
    _this.rate = rate;

    _this.on(player, 'ratechange', _this.update);
    return _this;
  }

  /**
   * This gets called when an `PlaybackRateMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  PlaybackRateMenuItem.prototype.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this);
    this.player().playbackRate(this.rate);
  };

  /**
   * Update the PlaybackRateMenuItem when the playbackrate changes.
   *
   * @param {EventTarget~Event} [event]
   *        The `ratechange` event that caused this function to run.
   *
   * @listens Player#ratechange
   */


  PlaybackRateMenuItem.prototype.update = function update(event) {
    this.selected(this.player().playbackRate() === this.rate);
  };

  return PlaybackRateMenuItem;
}(MenuItem);

/**
 * The text that should display over the `PlaybackRateMenuItem`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


PlaybackRateMenuItem.prototype.contentElType = 'button';

Component.registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);

/**
 * @file playback-rate-menu-button.js
 */
/**
 * The component for controlling the playback rate.
 *
 * @extends MenuButton
 */

var PlaybackRateMenuButton = function (_MenuButton) {
  inherits(PlaybackRateMenuButton, _MenuButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PlaybackRateMenuButton(player, options) {
    classCallCheck(this, PlaybackRateMenuButton);

    var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));

    _this.updateVisibility();
    _this.updateLabel();

    _this.on(player, 'loadstart', _this.updateVisibility);
    _this.on(player, 'ratechange', _this.updateLabel);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  PlaybackRateMenuButton.prototype.createEl = function createEl$$1() {
    var el = _MenuButton.prototype.createEl.call(this);

    this.labelEl_ = createEl('div', {
      className: 'vjs-playback-rate-value',
      innerHTML: 1.0
    });

    el.appendChild(this.labelEl_);

    return el;
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  PlaybackRateMenuButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-playback-rate ' + _MenuButton.prototype.buildCSSClass.call(this);
  };

  PlaybackRateMenuButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-playback-rate ' + _MenuButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create the playback rate menu
   *
   * @return {Menu}
   *         Menu object populated with {@link PlaybackRateMenuItem}s
   */


  PlaybackRateMenuButton.prototype.createMenu = function createMenu() {
    var menu = new Menu(this.player());
    var rates = this.playbackRates();

    if (rates) {
      for (var i = rates.length - 1; i >= 0; i--) {
        menu.addChild(new PlaybackRateMenuItem(this.player(), { rate: rates[i] + 'x' }));
      }
    }

    return menu;
  };

  /**
   * Updates ARIA accessibility attributes
   */


  PlaybackRateMenuButton.prototype.updateARIAAttributes = function updateARIAAttributes() {
    // Current playback rate
    this.el().setAttribute('aria-valuenow', this.player().playbackRate());
  };

  /**
   * This gets called when an `PlaybackRateMenuButton` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  PlaybackRateMenuButton.prototype.handleClick = function handleClick(event) {
    // select next rate option
    var currentRate = this.player().playbackRate();
    var rates = this.playbackRates();

    // this will select first one if the last one currently selected
    var newRate = rates[0];

    for (var i = 0; i < rates.length; i++) {
      if (rates[i] > currentRate) {
        newRate = rates[i];
        break;
      }
    }
    this.player().playbackRate(newRate);
  };

  /**
   * Get possible playback rates
   *
   * @return {Array}
   *         All possible playback rates
   */


  PlaybackRateMenuButton.prototype.playbackRates = function playbackRates() {
    return this.options_.playbackRates || this.options_.playerOptions && this.options_.playerOptions.playbackRates;
  };

  /**
   * Get whether playback rates is supported by the tech
   * and an array of playback rates exists
   *
   * @return {boolean}
   *         Whether changing playback rate is supported
   */


  PlaybackRateMenuButton.prototype.playbackRateSupported = function playbackRateSupported() {
    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
  };

  /**
   * Hide playback rate controls when they're no playback rate options to select
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#loadstart
   */


  PlaybackRateMenuButton.prototype.updateVisibility = function updateVisibility(event) {
    if (this.playbackRateSupported()) {
      this.removeClass('vjs-hidden');
    } else {
      this.addClass('vjs-hidden');
    }
  };

  /**
   * Update button label when rate changed
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#ratechange
   */


  PlaybackRateMenuButton.prototype.updateLabel = function updateLabel(event) {
    if (this.playbackRateSupported()) {
      this.labelEl_.innerHTML = this.player().playbackRate() + 'x';
    }
  };

  return PlaybackRateMenuButton;
}(MenuButton);

/**
 * The text that should display over the `FullscreenToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


PlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';

Component.registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);

/**
 * @file spacer.js
 */
/**
 * Just an empty spacer element that can be used as an append point for plugins, etc.
 * Also can be used to create space between elements when necessary.
 *
 * @extends Component
 */

var Spacer = function (_Component) {
  inherits(Spacer, _Component);

  function Spacer() {
    classCallCheck(this, Spacer);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  Spacer.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-spacer ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  Spacer.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildCSSClass()
    });
  };

  return Spacer;
}(Component);

Component.registerComponent('Spacer', Spacer);

/**
 * @file custom-control-spacer.js
 */
/**
 * Spacer specifically meant to be used as an insertion point for new plugins, etc.
 *
 * @extends Spacer
 */

var CustomControlSpacer = function (_Spacer) {
  inherits(CustomControlSpacer, _Spacer);

  function CustomControlSpacer() {
    classCallCheck(this, CustomControlSpacer);
    return possibleConstructorReturn(this, _Spacer.apply(this, arguments));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  CustomControlSpacer.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-custom-control-spacer ' + _Spacer.prototype.buildCSSClass.call(this);
  };

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  CustomControlSpacer.prototype.createEl = function createEl() {
    var el = _Spacer.prototype.createEl.call(this, {
      className: this.buildCSSClass()
    });

    // No-flex/table-cell mode requires there be some content
    // in the cell to fill the remaining space of the table.
    el.innerHTML = '&nbsp;';
    return el;
  };

  return CustomControlSpacer;
}(Spacer);

Component.registerComponent('CustomControlSpacer', CustomControlSpacer);

/**
 * @file control-bar.js
 */
// Required children
/**
 * Container of main controls.
 *
 * @extends Component
 */

var ControlBar = function (_Component) {
  inherits(ControlBar, _Component);

  function ControlBar() {
    classCallCheck(this, ControlBar);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  ControlBar.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-control-bar',
      dir: 'ltr'
    }, {
      // The control bar is a group, but we don't aria-label it to avoid
      //  over-announcing by JAWS
      role: 'group'
    });
  };

  return ControlBar;
}(Component);

/**
 * Default options for `ControlBar`
 *
 * @type {Object}
 * @private
 */


ControlBar.prototype.options_ = {
  children: ['playToggle', 'volumePanel', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subsCapsButton', 'audioTrackButton', 'fullscreenToggle']
};

Component.registerComponent('ControlBar', ControlBar);

/**
 * @file error-display.js
 */
/**
 * A display that indicates an error has occurred. This means that the video
 * is unplayable.
 *
 * @extends ModalDialog
 */

var ErrorDisplay = function (_ModalDialog) {
  inherits(ErrorDisplay, _ModalDialog);

  /**
   * Creates an instance of this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  function ErrorDisplay(player, options) {
    classCallCheck(this, ErrorDisplay);

    var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));

    _this.on(player, 'error', _this.open);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   *
   * @deprecated Since version 5.
   */


  ErrorDisplay.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-error-display ' + _ModalDialog.prototype.buildCSSClass.call(this);
  };

  /**
   * Gets the localized error message based on the `Player`s error.
   *
   * @return {string}
   *         The `Player`s error message localized or an empty string.
   */


  ErrorDisplay.prototype.content = function content() {
    var error = this.player().error();

    return error ? this.localize(error.message) : '';
  };

  return ErrorDisplay;
}(ModalDialog);

/**
 * The default options for an `ErrorDisplay`.
 *
 * @private
 */


ErrorDisplay.prototype.options_ = mergeOptions(ModalDialog.prototype.options_, {
  pauseOnOpen: false,
  fillAlways: true,
  temporary: false,
  uncloseable: true
});

Component.registerComponent('ErrorDisplay', ErrorDisplay);

/**
 * @file text-track-settings.js
 */
var LOCAL_STORAGE_KEY = 'vjs-text-track-settings';

var COLOR_BLACK = ['#000', 'Black'];
var COLOR_BLUE = ['#00F', 'Blue'];
var COLOR_CYAN = ['#0FF', 'Cyan'];
var COLOR_GREEN = ['#0F0', 'Green'];
var COLOR_MAGENTA = ['#F0F', 'Magenta'];
var COLOR_RED = ['#F00', 'Red'];
var COLOR_WHITE = ['#FFF', 'White'];
var COLOR_YELLOW = ['#FF0', 'Yellow'];

var OPACITY_OPAQUE = ['1', 'Opaque'];
var OPACITY_SEMI = ['0.5', 'Semi-Transparent'];
var OPACITY_TRANS = ['0', 'Transparent'];

// Configuration for the various <select> elements in the DOM of this component.
//
// Possible keys include:
//
// `default`:
//   The default option index. Only needs to be provided if not zero.
// `parser`:
//   A function which is used to parse the value from the selected option in
//   a customized way.
// `selector`:
//   The selector used to find the associated <select> element.
var selectConfigs = {
  backgroundColor: {
    selector: '.vjs-bg-color > select',
    id: 'captions-background-color-%s',
    label: 'Color',
    options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
  },

  backgroundOpacity: {
    selector: '.vjs-bg-opacity > select',
    id: 'captions-background-opacity-%s',
    label: 'Transparency',
    options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]
  },

  color: {
    selector: '.vjs-fg-color > select',
    id: 'captions-foreground-color-%s',
    label: 'Color',
    options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
  },

  edgeStyle: {
    selector: '.vjs-edge-style > select',
    id: '%s',
    label: 'Text Edge Style',
    options: [['none', 'None'], ['raised', 'Raised'], ['depressed', 'Depressed'], ['uniform', 'Uniform'], ['dropshadow', 'Dropshadow']]
  },

  fontFamily: {
    selector: '.vjs-font-family > select',
    id: 'captions-font-family-%s',
    label: 'Font Family',
    options: [['proportionalSansSerif', 'Proportional Sans-Serif'], ['monospaceSansSerif', 'Monospace Sans-Serif'], ['proportionalSerif', 'Proportional Serif'], ['monospaceSerif', 'Monospace Serif'], ['casual', 'Casual'], ['script', 'Script'], ['small-caps', 'Small Caps']]
  },

  fontPercent: {
    selector: '.vjs-font-percent > select',
    id: 'captions-font-size-%s',
    label: 'Font Size',
    options: [['0.50', '50%'], ['0.75', '75%'], ['1.00', '100%'], ['1.25', '125%'], ['1.50', '150%'], ['1.75', '175%'], ['2.00', '200%'], ['3.00', '300%'], ['4.00', '400%']],
    'default': 2,
    parser: function parser(v) {
      return v === '1.00' ? null : Number(v);
    }
  },

  textOpacity: {
    selector: '.vjs-text-opacity > select',
    id: 'captions-foreground-opacity-%s',
    label: 'Transparency',
    options: [OPACITY_OPAQUE, OPACITY_SEMI]
  },

  // Options for this object are defined below.
  windowColor: {
    selector: '.vjs-window-color > select',
    id: 'captions-window-color-%s',
    label: 'Color'
  },

  // Options for this object are defined below.
  windowOpacity: {
    selector: '.vjs-window-opacity > select',
    id: 'captions-window-opacity-%s',
    label: 'Transparency',
    options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]
  }
};

selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;

/**
 * Get the actual value of an option.
 *
 * @param  {string} value
 *         The value to get
 *
 * @param  {Function} [parser]
 *         Optional function to adjust the value.
 *
 * @return {Mixed}
 *         - Will be `undefined` if no value exists
 *         - Will be `undefined` if the given value is "none".
 *         - Will be the actual value otherwise.
 *
 * @private
 */
function parseOptionValue(value, parser) {
  if (parser) {
    value = parser(value);
  }

  if (value && value !== 'none') {
    return value;
  }
}

/**
 * Gets the value of the selected <option> element within a <select> element.
 *
 * @param  {Element} el
 *         the element to look in
 *
 * @param  {Function} [parser]
 *         Optional function to adjust the value.
 *
 * @return {Mixed}
 *         - Will be `undefined` if no value exists
 *         - Will be `undefined` if the given value is "none".
 *         - Will be the actual value otherwise.
 *
 * @private
 */
function getSelectedOptionValue(el, parser) {
  var value = el.options[el.options.selectedIndex].value;

  return parseOptionValue(value, parser);
}

/**
 * Sets the selected <option> element within a <select> element based on a
 * given value.
 *
 * @param {Element} el
 *        The element to look in.
 *
 * @param {string} value
 *        the property to look on.
 *
 * @param {Function} [parser]
 *        Optional function to adjust the value before comparing.
 *
 * @private
 */
function setSelectedOption(el, value, parser) {
  if (!value) {
    return;
  }

  for (var i = 0; i < el.options.length; i++) {
    if (parseOptionValue(el.options[i].value, parser) === value) {
      el.selectedIndex = i;
      break;
    }
  }
}

/**
 * Manipulate Text Tracks settings.
 *
 * @extends ModalDialog
 */

var TextTrackSettings = function (_ModalDialog) {
  inherits(TextTrackSettings, _ModalDialog);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *         The key/value store of player options.
   */
  function TextTrackSettings(player, options) {
    classCallCheck(this, TextTrackSettings);

    options.temporary = false;

    var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));

    _this.updateDisplay = bind(_this, _this.updateDisplay);

    // fill the modal and pretend we have opened it
    _this.fill();
    _this.hasBeenOpened_ = _this.hasBeenFilled_ = true;

    _this.endDialog = createEl('p', {
      className: 'vjs-control-text',
      textContent: _this.localize('End of dialog window.')
    });
    _this.el().appendChild(_this.endDialog);

    _this.setDefaults();

    // Grab `persistTextTrackSettings` from the player options if not passed in child options
    if (options.persistTextTrackSettings === undefined) {
      _this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings;
    }

    _this.on(_this.$('.vjs-done-button'), 'click', function () {
      _this.saveSettings();
      _this.close();
    });

    _this.on(_this.$('.vjs-default-button'), 'click', function () {
      _this.setDefaults();
      _this.updateDisplay();
    });

    each(selectConfigs, function (config) {
      _this.on(_this.$(config.selector), 'change', _this.updateDisplay);
    });

    if (_this.options_.persistTextTrackSettings) {
      _this.restoreSettings();
    }
    return _this;
  }

  /**
   * Create a <select> element with configured options.
   *
   * @param {string} key
   *        Configuration key to use during creation.
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElSelect_ = function createElSelect_(key) {
    var _this2 = this;

    var legendId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'label';

    var config = selectConfigs[key];
    var id = config.id.replace('%s', this.id_);

    return ['<' + type + ' id="' + id + '" class="' + (type === 'label' ? 'vjs-label' : '') + '">', this.localize(config.label), '</' + type + '>', '<select aria-labelledby="' + legendId + ' ' + id + '">'].concat(config.options.map(function (o) {
      var optionId = id + '-' + o[1];

      return ['<option id="' + optionId + '" value="' + o[0] + '" ', 'aria-labelledby="' + legendId + ' ' + id + ' ' + optionId + '">', _this2.localize(o[1]), '</option>'].join('');
    })).concat('</select>').join('');
  };

  /**
   * Create foreground color element for the component
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElFgColor_ = function createElFgColor_() {
    var legendId = 'captions-text-legend-' + this.id_;

    return ['<fieldset class="vjs-fg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize('Text'), '</legend>', this.createElSelect_('color', legendId), '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_('textOpacity', legendId), '</span>', '</fieldset>'].join('');
  };

  /**
   * Create background color element for the component
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElBgColor_ = function createElBgColor_() {
    var legendId = 'captions-background-' + this.id_;

    return ['<fieldset class="vjs-bg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize('Background'), '</legend>', this.createElSelect_('backgroundColor', legendId), '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_('backgroundOpacity', legendId), '</span>', '</fieldset>'].join('');
  };

  /**
   * Create window color element for the component
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElWinColor_ = function createElWinColor_() {
    var legendId = 'captions-window-' + this.id_;

    return ['<fieldset class="vjs-window-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize('Window'), '</legend>', this.createElSelect_('windowColor', legendId), '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_('windowOpacity', legendId), '</span>', '</fieldset>'].join('');
  };

  /**
   * Create color elements for the component
   *
   * @return {Element}
   *         The element that was created
   *
   * @private
   */


  TextTrackSettings.prototype.createElColors_ = function createElColors_() {
    return createEl('div', {
      className: 'vjs-track-settings-colors',
      innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join('')
    });
  };

  /**
   * Create font elements for the component
   *
   * @return {Element}
   *         The element that was created.
   *
   * @private
   */


  TextTrackSettings.prototype.createElFont_ = function createElFont_() {
    return createEl('div', {
      className: 'vjs-track-settings-font">',
      innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_('fontPercent', '', 'legend'), '</fieldset>', '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_('edgeStyle', '', 'legend'), '</fieldset>', '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_('fontFamily', '', 'legend'), '</fieldset>'].join('')
    });
  };

  /**
   * Create controls for the component
   *
   * @return {Element}
   *         The element that was created.
   *
   * @private
   */


  TextTrackSettings.prototype.createElControls_ = function createElControls_() {
    var defaultsDescription = this.localize('restore all settings to the default values');

    return createEl('div', {
      className: 'vjs-track-settings-controls',
      innerHTML: ['<button class="vjs-default-button" title="' + defaultsDescription + '">', this.localize('Reset'), '<span class="vjs-control-text"> ' + defaultsDescription + '</span>', '</button>', '<button class="vjs-done-button">' + this.localize('Done') + '</button>'].join('')
    });
  };

  TextTrackSettings.prototype.content = function content() {
    return [this.createElColors_(), this.createElFont_(), this.createElControls_()];
  };

  TextTrackSettings.prototype.label = function label() {
    return this.localize('Caption Settings Dialog');
  };

  TextTrackSettings.prototype.description = function description() {
    return this.localize('Beginning of dialog window. Escape will cancel and close the window.');
  };

  TextTrackSettings.prototype.buildCSSClass = function buildCSSClass() {
    return _ModalDialog.prototype.buildCSSClass.call(this) + ' vjs-text-track-settings';
  };

  /**
   * Gets an object of text track settings (or null).
   *
   * @return {Object}
   *         An object with config values parsed from the DOM or localStorage.
   */


  TextTrackSettings.prototype.getValues = function getValues() {
    var _this3 = this;

    return reduce(selectConfigs, function (accum, config, key) {
      var value = getSelectedOptionValue(_this3.$(config.selector), config.parser);

      if (value !== undefined) {
        accum[key] = value;
      }

      return accum;
    }, {});
  };

  /**
   * Sets text track settings from an object of values.
   *
   * @param {Object} values
   *        An object with config values parsed from the DOM or localStorage.
   */


  TextTrackSettings.prototype.setValues = function setValues(values) {
    var _this4 = this;

    each(selectConfigs, function (config, key) {
      setSelectedOption(_this4.$(config.selector), values[key], config.parser);
    });
  };

  /**
   * Sets all `<select>` elements to their default values.
   */


  TextTrackSettings.prototype.setDefaults = function setDefaults() {
    var _this5 = this;

    each(selectConfigs, function (config) {
      var index = config.hasOwnProperty('default') ? config['default'] : 0;

      _this5.$(config.selector).selectedIndex = index;
    });
  };

  /**
   * Restore texttrack settings from localStorage
   */


  TextTrackSettings.prototype.restoreSettings = function restoreSettings() {
    var values = void 0;

    try {
      values = JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY));
    } catch (err) {
      log$1.warn(err);
    }

    if (values) {
      this.setValues(values);
    }
  };

  /**
   * Save text track settings to localStorage
   */


  TextTrackSettings.prototype.saveSettings = function saveSettings() {
    if (!this.options_.persistTextTrackSettings) {
      return;
    }

    var values = this.getValues();

    try {
      if (Object.keys(values).length) {
        window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(values));
      } else {
        window.localStorage.removeItem(LOCAL_STORAGE_KEY);
      }
    } catch (err) {
      log$1.warn(err);
    }
  };

  /**
   * Update display of text track settings
   */


  TextTrackSettings.prototype.updateDisplay = function updateDisplay() {
    var ttDisplay = this.player_.getChild('textTrackDisplay');

    if (ttDisplay) {
      ttDisplay.updateDisplay();
    }
  };

  /**
   * conditionally blur the element and refocus the captions button
   *
   * @private
   */


  TextTrackSettings.prototype.conditionalBlur_ = function conditionalBlur_() {
    this.previouslyActiveEl_ = null;
    this.off(document, 'keydown', this.handleKeyDown);

    var cb = this.player_.controlBar;
    var subsCapsBtn = cb && cb.subsCapsButton;
    var ccBtn = cb && cb.captionsButton;

    if (subsCapsBtn) {
      subsCapsBtn.focus();
    } else if (ccBtn) {
      ccBtn.focus();
    }
  };

  return TextTrackSettings;
}(ModalDialog);

Component.registerComponent('TextTrackSettings', TextTrackSettings);

var _templateObject$2 = taggedTemplateLiteralLoose(['Text Tracks are being loaded from another origin but the crossorigin attribute isn\'t used.\n            This may prevent text tracks from loading.'], ['Text Tracks are being loaded from another origin but the crossorigin attribute isn\'t used.\n            This may prevent text tracks from loading.']);

/**
 * @file html5.js
 */
/**
 * HTML5 Media Controller - Wrapper for HTML5 Media API
 *
 * @mixes Tech~SouceHandlerAdditions
 * @extends Tech
 */

var Html5 = function (_Tech) {
  inherits(Html5, _Tech);

  /**
   * Create an instance of this Tech.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} ready
   *        Callback function to call when the `HTML5` Tech is ready.
   */
  function Html5(options, ready) {
    classCallCheck(this, Html5);

    var _this = possibleConstructorReturn(this, _Tech.call(this, options, ready));

    var source = options.source;
    var crossoriginTracks = false;

    // Set the source if one is provided
    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)
    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source
    // anyway so the error gets fired.
    if (source && (_this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
      _this.setSource(source);
    } else {
      _this.handleLateInit_(_this.el_);
    }

    if (_this.el_.hasChildNodes()) {

      var nodes = _this.el_.childNodes;
      var nodesLength = nodes.length;
      var removeNodes = [];

      while (nodesLength--) {
        var node = nodes[nodesLength];
        var nodeName = node.nodeName.toLowerCase();

        if (nodeName === 'track') {
          if (!_this.featuresNativeTextTracks) {
            // Empty video tag tracks so the built-in player doesn't use them also.
            // This may not be fast enough to stop HTML5 browsers from reading the tags
            // so we'll need to turn off any default tracks if we're manually doing
            // captions and subtitles. videoElement.textTracks
            removeNodes.push(node);
          } else {
            // store HTMLTrackElement and TextTrack to remote list
            _this.remoteTextTrackEls().addTrackElement_(node);
            _this.remoteTextTracks().addTrack(node.track);
            _this.textTracks().addTrack(node.track);
            if (!crossoriginTracks && !_this.el_.hasAttribute('crossorigin') && isCrossOrigin(node.src)) {
              crossoriginTracks = true;
            }
          }
        }
      }

      for (var i = 0; i < removeNodes.length; i++) {
        _this.el_.removeChild(removeNodes[i]);
      }
    }

    _this.proxyNativeTracks_();
    if (_this.featuresNativeTextTracks && crossoriginTracks) {
      log$1.warn(tsml(_templateObject$2));
    }

    // Determine if native controls should be used
    // Our goal should be to get the custom controls on mobile solid everywhere
    // so we can remove this all together. Right now this will block custom
    // controls on touch enabled laptops like the Chrome Pixel
    if ((TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {
      _this.setControls(true);
    }

    // on iOS, we want to proxy `webkitbeginfullscreen` and `webkitendfullscreen`
    // into a `fullscreenchange` event
    _this.proxyWebkitFullscreen_();

    _this.triggerReady();
    return _this;
  }

  /**
   * Dispose of `HTML5` media element and remove all tracks.
   */


  Html5.prototype.dispose = function dispose() {
    Html5.disposeMediaElement(this.el_);
    // tech will handle clearing of the emulated track list
    _Tech.prototype.dispose.call(this);
  };

  /**
   * Proxy all native track list events to our track lists if the browser we are playing
   * in supports that type of track list.
   *
   * @private
   */


  Html5.prototype.proxyNativeTracks_ = function proxyNativeTracks_() {
    var _this2 = this;

    NORMAL.names.forEach(function (name) {
      var props = NORMAL[name];
      var elTracks = _this2.el()[props.getterName];
      var techTracks = _this2[props.getterName]();

      if (!_this2['featuresNative' + props.capitalName + 'Tracks'] || !elTracks || !elTracks.addEventListener) {
        return;
      }
      var listeners = {
        change: function change(e) {
          techTracks.trigger({
            type: 'change',
            target: techTracks,
            currentTarget: techTracks,
            srcElement: techTracks
          });
        },
        addtrack: function addtrack(e) {
          techTracks.addTrack(e.track);
        },
        removetrack: function removetrack(e) {
          techTracks.removeTrack(e.track);
        }
      };
      var removeOldTracks = function removeOldTracks() {
        var removeTracks = [];

        for (var i = 0; i < techTracks.length; i++) {
          var found = false;

          for (var j = 0; j < elTracks.length; j++) {
            if (elTracks[j] === techTracks[i]) {
              found = true;
              break;
            }
          }

          if (!found) {
            removeTracks.push(techTracks[i]);
          }
        }

        while (removeTracks.length) {
          techTracks.removeTrack(removeTracks.shift());
        }
      };

      Object.keys(listeners).forEach(function (eventName) {
        var listener = listeners[eventName];

        elTracks.addEventListener(eventName, listener);
        _this2.on('dispose', function (e) {
          return elTracks.removeEventListener(eventName, listener);
        });
      });

      // Remove (native) tracks that are not used anymore
      _this2.on('loadstart', removeOldTracks);
      _this2.on('dispose', function (e) {
        return _this2.off('loadstart', removeOldTracks);
      });
    });
  };

  /**
   * Create the `Html5` Tech's DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  Html5.prototype.createEl = function createEl$$1() {
    var el = this.options_.tag;

    // Check if this browser supports moving the element into the box.
    // On the iPhone video will break if you move the element,
    // So we have to create a brand new element.
    // If we ingested the player div, we do not need to move the media element.
    if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {

      // If the original tag is still there, clone and remove it.
      if (el) {
        var clone = el.cloneNode(true);

        if (el.parentNode) {
          el.parentNode.insertBefore(clone, el);
        }
        Html5.disposeMediaElement(el);
        el = clone;
      } else {
        el = document.createElement('video');

        // determine if native controls should be used
        var tagAttributes = this.options_.tag && getAttributes(this.options_.tag);
        var attributes = mergeOptions({}, tagAttributes);

        if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
          delete attributes.controls;
        }

        setAttributes(el, assign(attributes, {
          id: this.options_.techId,
          'class': 'vjs-tech'
        }));
      }

      el.playerId = this.options_.playerId;
    }

    // Update specific tag settings, in case they were overridden
    var settingsAttrs = ['autoplay', 'preload', 'loop', 'muted', 'playsinline'];

    for (var i = settingsAttrs.length - 1; i >= 0; i--) {
      var attr = settingsAttrs[i];
      var overwriteAttrs = {};

      if (typeof this.options_[attr] !== 'undefined') {
        overwriteAttrs[attr] = this.options_[attr];
      }
      setAttributes(el, overwriteAttrs);
    }

    return el;
  };

  /**
   * This will be triggered if the loadstart event has already fired, before videojs was
   * ready. Two known examples of when this can happen are:
   * 1. If we're loading the playback object after it has started loading
   * 2. The media is already playing the (often with autoplay on) then
   *
   * This function will fire another loadstart so that videojs can catchup.
   *
   * @fires Tech#loadstart
   *
   * @return {undefined}
   *         returns nothing.
   */


  Html5.prototype.handleLateInit_ = function handleLateInit_(el) {
    if (el.networkState === 0 || el.networkState === 3) {
      // The video element hasn't started loading the source yet
      // or didn't find a source
      return;
    }

    if (el.readyState === 0) {
      // NetworkState is set synchronously BUT loadstart is fired at the
      // end of the current stack, usually before setInterval(fn, 0).
      // So at this point we know loadstart may have already fired or is
      // about to fire, and either way the player hasn't seen it yet.
      // We don't want to fire loadstart prematurely here and cause a
      // double loadstart so we'll wait and see if it happens between now
      // and the next loop, and fire it if not.
      // HOWEVER, we also want to make sure it fires before loadedmetadata
      // which could also happen between now and the next loop, so we'll
      // watch for that also.
      var loadstartFired = false;
      var setLoadstartFired = function setLoadstartFired() {
        loadstartFired = true;
      };

      this.on('loadstart', setLoadstartFired);

      var triggerLoadstart = function triggerLoadstart() {
        // We did miss the original loadstart. Make sure the player
        // sees loadstart before loadedmetadata
        if (!loadstartFired) {
          this.trigger('loadstart');
        }
      };

      this.on('loadedmetadata', triggerLoadstart);

      this.ready(function () {
        this.off('loadstart', setLoadstartFired);
        this.off('loadedmetadata', triggerLoadstart);

        if (!loadstartFired) {
          // We did miss the original native loadstart. Fire it now.
          this.trigger('loadstart');
        }
      });

      return;
    }

    // From here on we know that loadstart already fired and we missed it.
    // The other readyState events aren't as much of a problem if we double
    // them, so not going to go to as much trouble as loadstart to prevent
    // that unless we find reason to.
    var eventsToTrigger = ['loadstart'];

    // loadedmetadata: newly equal to HAVE_METADATA (1) or greater
    eventsToTrigger.push('loadedmetadata');

    // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater
    if (el.readyState >= 2) {
      eventsToTrigger.push('loadeddata');
    }

    // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater
    if (el.readyState >= 3) {
      eventsToTrigger.push('canplay');
    }

    // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)
    if (el.readyState >= 4) {
      eventsToTrigger.push('canplaythrough');
    }

    // We still need to give the player time to add event listeners
    this.ready(function () {
      eventsToTrigger.forEach(function (type) {
        this.trigger(type);
      }, this);
    });
  };

  /**
   * Set current time for the `HTML5` tech.
   *
   * @param {number} seconds
   *        Set the current time of the media to this.
   */


  Html5.prototype.setCurrentTime = function setCurrentTime(seconds) {
    try {
      this.el_.currentTime = seconds;
    } catch (e) {
      log$1(e, 'Video is not ready. (Video.js)');
      // this.warning(VideoJS.warnings.videoNotReady);
    }
  };

  /**
   * Get the current duration of the HTML5 media element.
   *
   * @return {number}
   *         The duration of the media or 0 if there is no duration.
   */


  Html5.prototype.duration = function duration() {
    var _this3 = this;

    // Android Chrome will report duration as Infinity for VOD HLS until after
    // playback has started, which triggers the live display erroneously.
    // Return NaN if playback has not started and trigger a durationupdate once
    // the duration can be reliably known.
    if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {
      // Wait for the first `timeupdate` with currentTime > 0 - there may be
      // several with 0
      var checkProgress = function checkProgress() {
        if (_this3.el_.currentTime > 0) {
          // Trigger durationchange for genuinely live video
          if (_this3.el_.duration === Infinity) {
            _this3.trigger('durationchange');
          }
          _this3.off('timeupdate', checkProgress);
        }
      };

      this.on('timeupdate', checkProgress);
      return NaN;
    }
    return this.el_.duration || NaN;
  };

  /**
   * Get the current width of the HTML5 media element.
   *
   * @return {number}
   *         The width of the HTML5 media element.
   */


  Html5.prototype.width = function width() {
    return this.el_.offsetWidth;
  };

  /**
   * Get the current height of the HTML5 media element.
   *
   * @return {number}
   *         The heigth of the HTML5 media element.
   */


  Html5.prototype.height = function height() {
    return this.el_.offsetHeight;
  };

  /**
   * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into
   * `fullscreenchange` event.
   *
   * @private
   * @fires fullscreenchange
   * @listens webkitendfullscreen
   * @listens webkitbeginfullscreen
   * @listens webkitbeginfullscreen
   */


  Html5.prototype.proxyWebkitFullscreen_ = function proxyWebkitFullscreen_() {
    var _this4 = this;

    if (!('webkitDisplayingFullscreen' in this.el_)) {
      return;
    }

    var endFn = function endFn() {
      this.trigger('fullscreenchange', { isFullscreen: false });
    };

    var beginFn = function beginFn() {
      if ('webkitPresentationMode' in this.el_ && this.el_.webkitPresentationMode !== 'picture-in-picture') {
        this.one('webkitendfullscreen', endFn);

        this.trigger('fullscreenchange', { isFullscreen: true });
      }
    };

    this.on('webkitbeginfullscreen', beginFn);
    this.on('dispose', function () {
      _this4.off('webkitbeginfullscreen', beginFn);
      _this4.off('webkitendfullscreen', endFn);
    });
  };

  /**
   * Check if fullscreen is supported on the current playback device.
   *
   * @return {boolean}
   *         - True if fullscreen is supported.
   *         - False if fullscreen is not supported.
   */


  Html5.prototype.supportsFullScreen = function supportsFullScreen() {
    if (typeof this.el_.webkitEnterFullScreen === 'function') {
      var userAgent = window.navigator && window.navigator.userAgent || '';

      // Seems to be broken in Chromium/Chrome && Safari in Leopard
      if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Request that the `HTML5` Tech enter fullscreen.
   */


  Html5.prototype.enterFullScreen = function enterFullScreen() {
    var video = this.el_;

    if (video.paused && video.networkState <= video.HAVE_METADATA) {
      // attempt to prime the video element for programmatic access
      // this isn't necessary on the desktop but shouldn't hurt
      this.el_.play();

      // playing and pausing synchronously during the transition to fullscreen
      // can get iOS ~6.1 devices into a play/pause loop
      this.setTimeout(function () {
        video.pause();
        video.webkitEnterFullScreen();
      }, 0);
    } else {
      video.webkitEnterFullScreen();
    }
  };

  /**
   * Request that the `HTML5` Tech exit fullscreen.
   */


  Html5.prototype.exitFullScreen = function exitFullScreen() {
    this.el_.webkitExitFullScreen();
  };

  /**
   * A getter/setter for the `Html5` Tech's source object.
   * > Note: Please use {@link Html5#setSource}
   *
   * @param {Tech~SourceObject} [src]
   *        The source object you want to set on the `HTML5` techs element.
   *
   * @return {Tech~SourceObject|undefined}
   *         - The current source object when a source is not passed in.
   *         - undefined when setting
   *
   * @deprecated Since version 5.
   */


  Html5.prototype.src = function src(_src) {
    if (_src === undefined) {
      return this.el_.src;
    }

    // Setting src through `src` instead of `setSrc` will be deprecated
    this.setSrc(_src);
  };

  /**
   * Reset the tech by removing all sources and then calling
   * {@link Html5.resetMediaElement}.
   */


  Html5.prototype.reset = function reset() {
    Html5.resetMediaElement(this.el_);
  };

  /**
   * Get the current source on the `HTML5` Tech. Falls back to returning the source from
   * the HTML5 media element.
   *
   * @return {Tech~SourceObject}
   *         The current source object from the HTML5 tech. With a fallback to the
   *         elements source.
   */


  Html5.prototype.currentSrc = function currentSrc() {
    if (this.currentSource_) {
      return this.currentSource_.src;
    }
    return this.el_.currentSrc;
  };

  /**
   * Set controls attribute for the HTML5 media Element.
   *
   * @param {string} val
   *        Value to set the controls attribute to
   */


  Html5.prototype.setControls = function setControls(val) {
    this.el_.controls = !!val;
  };

  /**
   * Create and returns a remote {@link TextTrack} object.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @return {TextTrack}
   *         The TextTrack that gets created.
   */


  Html5.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (!this.featuresNativeTextTracks) {
      return _Tech.prototype.addTextTrack.call(this, kind, label, language);
    }

    return this.el_.addTextTrack(kind, label, language);
  };

  /**
   * Creates either native TextTrack or an emulated TextTrack depending
   * on the value of `featuresNativeTextTracks`
   *
   * @param {Object} options
   *        The object should contain the options to intialize the TextTrack with.
   *
   * @param {string} [options.kind]
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
   *
   * @param {string} [options.label].
   *        Label to identify the text track
   *
   * @param {string} [options.language]
   *        Two letter language abbreviation.
   *
   * @param {boolean} [options.default]
   *        Default this track to on.
   *
   * @param {string} [options.id]
   *        The internal id to assign this track.
   *
   * @param {string} [options.src]
   *        A source url for the track.
   *
   * @return {HTMLTrackElement}
   *         The track element that gets created.
   */


  Html5.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {
    if (!this.featuresNativeTextTracks) {
      return _Tech.prototype.createRemoteTextTrack.call(this, options);
    }
    var htmlTrackElement = document.createElement('track');

    if (options.kind) {
      htmlTrackElement.kind = options.kind;
    }
    if (options.label) {
      htmlTrackElement.label = options.label;
    }
    if (options.language || options.srclang) {
      htmlTrackElement.srclang = options.language || options.srclang;
    }
    if (options['default']) {
      htmlTrackElement['default'] = options['default'];
    }
    if (options.id) {
      htmlTrackElement.id = options.id;
    }
    if (options.src) {
      htmlTrackElement.src = options.src;
    }

    return htmlTrackElement;
  };

  /**
   * Creates a remote text track object and returns an html track element.
   *
   * @param {Object} options The object should contain values for
   * kind, language, label, and src (location of the WebVTT file)
   * @param {Boolean} [manualCleanup=true] if set to false, the TextTrack will be
   * automatically removed from the video element whenever the source changes
   * @return {HTMLTrackElement} An Html Track Element.
   * This can be an emulated {@link HTMLTrackElement} or a native one.
   * @deprecated The default value of the "manualCleanup" parameter will default
   * to "false" in upcoming versions of Video.js
   */


  Html5.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);

    if (this.featuresNativeTextTracks) {
      this.el().appendChild(htmlTrackElement);
    }

    return htmlTrackElement;
  };

  /**
   * Remove remote `TextTrack` from `TextTrackList` object
   *
   * @param {TextTrack} track
   *        `TextTrack` object to remove
   */


  Html5.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    _Tech.prototype.removeRemoteTextTrack.call(this, track);

    if (this.featuresNativeTextTracks) {
      var tracks = this.$$('track');

      var i = tracks.length;

      while (i--) {
        if (track === tracks[i] || track === tracks[i].track) {
          this.el().removeChild(tracks[i]);
        }
      }
    }
  };

  /**
   * Get the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#playsinline
   * @return {boolean}
   *         - The value of `playsinline` from the media element.
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */


  Html5.prototype.playsinline = function playsinline() {
    return this.el_.hasAttribute('playsinline');
  };

  /**
   * Set the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#setPlaysinline
   * @param {boolean} playsinline
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */


  Html5.prototype.setPlaysinline = function setPlaysinline(value) {
    if (value) {
      this.el_.setAttribute('playsinline', 'playsinline');
    } else {
      this.el_.removeAttribute('playsinline');
    }
  };

  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   */


  Html5.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    if (typeof this.el().getVideoPlaybackQuality === 'function') {
      return this.el().getVideoPlaybackQuality();
    }

    var videoPlaybackQuality = {};

    if (typeof this.el().webkitDroppedFrameCount !== 'undefined' && typeof this.el().webkitDecodedFrameCount !== 'undefined') {
      videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
      videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
    }

    if (window.performance && typeof window.performance.now === 'function') {
      videoPlaybackQuality.creationTime = window.performance.now();
    } else if (window.performance && window.performance.timing && typeof window.performance.timing.navigationStart === 'number') {
      videoPlaybackQuality.creationTime = window.Date.now() - window.performance.timing.navigationStart;
    }

    return videoPlaybackQuality;
  };

  return Html5;
}(Tech);

/* HTML5 Support Testing ---------------------------------------------------- */

if (isReal()) {

  /**
   * Element for testing browser HTML5 media capabilities
   *
   * @type {Element}
   * @constant
   * @private
   */
  Html5.TEST_VID = document.createElement('video');
  var track = document.createElement('track');

  track.kind = 'captions';
  track.srclang = 'en';
  track.label = 'English';
  Html5.TEST_VID.appendChild(track);
}

/**
 * Check if HTML5 media is supported by this browser/device.
 *
 * @return {boolean}
 *         - True if HTML5 media is supported.
 *         - False if HTML5 media is not supported.
 */
Html5.isSupported = function () {
  // IE9 with no Media Player is a LIAR! (#984)
  try {
    Html5.TEST_VID.volume = 0.5;
  } catch (e) {
    return false;
  }

  return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
};

/**
 * Check if the tech can support the given type
 *
 * @param {string} type
 *        The mimetype to check
 * @return {string} 'probably', 'maybe', or '' (empty string)
 */
Html5.canPlayType = function (type) {
  return Html5.TEST_VID.canPlayType(type);
};

/**
 * Check if the tech can support the given source
 * @param {Object} srcObj
 *        The source object
 * @param {Object} options
 *        The options passed to the tech
 * @return {string} 'probably', 'maybe', or '' (empty string)
 */
Html5.canPlaySource = function (srcObj, options) {
  return Html5.canPlayType(srcObj.type);
};

/**
 * Check if the volume can be changed in this browser/device.
 * Volume cannot be changed in a lot of mobile devices.
 * Specifically, it can't be changed from 1 on iOS.
 *
 * @return {boolean}
 *         - True if volume can be controlled
 *         - False otherwise
 */
Html5.canControlVolume = function () {
  // IE will error if Windows Media Player not installed #3315
  try {
    var volume = Html5.TEST_VID.volume;

    Html5.TEST_VID.volume = volume / 2 + 0.1;
    return volume !== Html5.TEST_VID.volume;
  } catch (e) {
    return false;
  }
};

/**
 * Check if the playback rate can be changed in this browser/device.
 *
 * @return {boolean}
 *         - True if playback rate can be controlled
 *         - False otherwise
 */
Html5.canControlPlaybackRate = function () {
  // Playback rate API is implemented in Android Chrome, but doesn't do anything
  // https://github.com/videojs/video.js/issues/3180
  if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {
    return false;
  }
  // IE will error if Windows Media Player not installed #3315
  try {
    var playbackRate = Html5.TEST_VID.playbackRate;

    Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
    return playbackRate !== Html5.TEST_VID.playbackRate;
  } catch (e) {
    return false;
  }
};

/**
 * Check to see if native `TextTrack`s are supported by this browser/device.
 *
 * @return {boolean}
 *         - True if native `TextTrack`s are supported.
 *         - False otherwise
 */
Html5.supportsNativeTextTracks = function () {
  return IS_ANY_SAFARI;
};

/**
 * Check to see if native `VideoTrack`s are supported by this browser/device
 *
 * @return {boolean}
 *        - True if native `VideoTrack`s are supported.
 *        - False otherwise
 */
Html5.supportsNativeVideoTracks = function () {
  return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
};

/**
 * Check to see if native `AudioTrack`s are supported by this browser/device
 *
 * @return {boolean}
 *        - True if native `AudioTrack`s are supported.
 *        - False otherwise
 */
Html5.supportsNativeAudioTracks = function () {
  return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
};

/**
 * An array of events available on the Html5 tech.
 *
 * @private
 * @type {Array}
 */
Html5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'resize', 'volumechange'];

/**
 * Boolean indicating whether the `Tech` supports volume control.
 *
 * @type {boolean}
 * @default {@link Html5.canControlVolume}
 */
Html5.prototype.featuresVolumeControl = Html5.canControlVolume();

/**
 * Boolean indicating whether the `Tech` supports changing the speed at which the media
 * plays. Examples:
 *   - Set player to play 2x (twice) as fast
 *   - Set player to play 0.5x (half) as fast
 *
 * @type {boolean}
 * @default {@link Html5.canControlPlaybackRate}
 */
Html5.prototype.featuresPlaybackRate = Html5.canControlPlaybackRate();

/**
 * Boolean indicating whether the `HTML5` tech currently supports the media element
 * moving in the DOM. iOS breaks if you move the media element, so this is set this to
 * false there. Everywhere else this should be true.
 *
 * @type {boolean}
 * @default
 */
Html5.prototype.movingMediaElementInDOM = !IS_IOS;

// TODO: Previous comment: No longer appears to be used. Can probably be removed.
//       Is this true?
/**
 * Boolean indicating whether the `HTML5` tech currently supports automatic media resize
 * when going into fullscreen.
 *
 * @type {boolean}
 * @default
 */
Html5.prototype.featuresFullscreenResize = true;

/**
 * Boolean indicating whether the `HTML5` tech currently supports the progress event.
 * If this is false, manual `progress` events will be triggred instead.
 *
 * @type {boolean}
 * @default
 */
Html5.prototype.featuresProgressEvents = true;

/**
 * Boolean indicating whether the `HTML5` tech currently supports the timeupdate event.
 * If this is false, manual `timeupdate` events will be triggred instead.
 *
 * @default
 */
Html5.prototype.featuresTimeupdateEvents = true;

/**
 * Boolean indicating whether the `HTML5` tech currently supports native `TextTrack`s.
 *
 * @type {boolean}
 * @default {@link Html5.supportsNativeTextTracks}
 */
Html5.prototype.featuresNativeTextTracks = Html5.supportsNativeTextTracks();

/**
 * Boolean indicating whether the `HTML5` tech currently supports native `VideoTrack`s.
 *
 * @type {boolean}
 * @default {@link Html5.supportsNativeVideoTracks}
 */
Html5.prototype.featuresNativeVideoTracks = Html5.supportsNativeVideoTracks();

/**
 * Boolean indicating whether the `HTML5` tech currently supports native `AudioTrack`s.
 *
 * @type {boolean}
 * @default {@link Html5.supportsNativeAudioTracks}
 */
Html5.prototype.featuresNativeAudioTracks = Html5.supportsNativeAudioTracks();

// HTML5 Feature detection and Device Fixes --------------------------------- //
var canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;
var mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
var mp4RE = /^video\/mp4/i;

Html5.patchCanPlayType = function () {

  // Android 4.0 and above can play HLS to some extent but it reports being unable to do so
  if (ANDROID_VERSION >= 4.0 && !IS_FIREFOX) {
    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mpegurlRE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };

    // Override Android 2.2 and less canPlayType method which is broken
  } else if (IS_OLD_ANDROID) {
    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mp4RE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };
  }
};

Html5.unpatchCanPlayType = function () {
  var r = Html5.TEST_VID.constructor.prototype.canPlayType;

  Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;
  return r;
};

// by default, patch the media element
Html5.patchCanPlayType();

Html5.disposeMediaElement = function (el) {
  if (!el) {
    return;
  }

  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }

  // remove any child track or source nodes to prevent their loading
  while (el.hasChildNodes()) {
    el.removeChild(el.firstChild);
  }

  // remove any src reference. not setting `src=''` because that causes a warning
  // in firefox
  el.removeAttribute('src');

  // force the media element to update its loading state by calling load()
  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)
  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function () {
      try {
        el.load();
      } catch (e) {
        // not supported
      }
    })();
  }
};

Html5.resetMediaElement = function (el) {
  if (!el) {
    return;
  }

  var sources = el.querySelectorAll('source');
  var i = sources.length;

  while (i--) {
    el.removeChild(sources[i]);
  }

  // remove any src reference.
  // not setting `src=''` because that throws an error
  el.removeAttribute('src');

  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function () {
      try {
        el.load();
      } catch (e) {
        // satisfy linter
      }
    })();
  }
};

/* Native HTML5 element property wrapping ----------------------------------- */
// Wrap native properties with a getter
[
/**
 * Get the value of `paused` from the media element. `paused` indicates whether the media element
 * is currently paused or not.
 *
 * @method Html5#paused
 * @return {boolean}
 *         The value of `paused` from the media element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}
 */
'paused',

/**
 * Get the value of `currentTime` from the media element. `currentTime` indicates
 * the current second that the media is at in playback.
 *
 * @method Html5#currentTime
 * @return {number}
 *         The value of `currentTime` from the media element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}
 */
'currentTime',

/**
 * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`
 * object that represents the parts of the media that are already downloaded and
 * available for playback.
 *
 * @method Html5#buffered
 * @return {TimeRange}
 *         The value of `buffered` from the media element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}
 */
'buffered',

/**
 * Get the value of `volume` from the media element. `volume` indicates
 * the current playback volume of audio for a media. `volume` will be a value from 0
 * (silent) to 1 (loudest and default).
 *
 * @method Html5#volume
 * @return {number}
 *         The value of `volume` from the media element. Value will be between 0-1.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
 */
'volume',

/**
 * Get the value of `muted` from the media element. `muted` indicates
 * that the volume for the media should be set to silent. This does not actually change
 * the `volume` attribute.
 *
 * @method Html5#muted
 * @return {boolean}
 *         - True if the value of `volume` should be ignored and the audio set to silent.
 *         - False if the value of `volume` should be used.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
 */
'muted',

/**
 * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
 * that the volume for the media should be set to silent when the video first starts.
 * This does not actually change the `volume` attribute. After playback has started `muted`
 * will indicate the current status of the volume and `defaultMuted` will not.
 *
 * @method Html5.prototype.defaultMuted
 * @return {boolean}
 *         - True if the value of `volume` should be ignored and the audio set to silent.
 *         - False if the value of `volume` should be used.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
 */
'defaultMuted',

/**
 * Get the value of `poster` from the media element. `poster` indicates
 * that the url of an image file that can/will be shown when no media data is available.
 *
 * @method Html5#poster
 * @return {string}
 *         The value of `poster` from the media element. Value will be a url to an
 *         image.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}
 */
'poster',

/**
 * Get the value of `preload` from the media element. `preload` indicates
 * what should download before the media is interacted with. It can have the following
 * values:
 * - none: nothing should be downloaded
 * - metadata: poster and the first few frames of the media may be downloaded to get
 *   media dimensions and other metadata
 * - auto: allow the media and metadata for the media to be downloaded before
 *    interaction
 *
 * @method Html5#preload
 * @return {string}
 *         The value of `preload` from the media element. Will be 'none', 'metadata',
 *         or 'auto'.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
 */
'preload',

/**
 * Get the value of `autoplay` from the media element. `autoplay` indicates
 * that the media should start to play as soon as the page is ready.
 *
 * @method Html5#autoplay
 * @return {boolean}
 *         - The value of `autoplay` from the media element.
 *         - True indicates that the media should start as soon as the page loads.
 *         - False indicates that the media should not start as soon as the page loads.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
 */
'autoplay',

/**
 * Get the value of `controls` from the media element. `controls` indicates
 * whether the native media controls should be shown or hidden.
 *
 * @method Html5#controls
 * @return {boolean}
 *         - The value of `controls` from the media element.
 *         - True indicates that native controls should be showing.
 *         - False indicates that native controls should be hidden.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}
 */
'controls',

/**
 * Get the value of `loop` from the media element. `loop` indicates
 * that the media should return to the start of the media and continue playing once
 * it reaches the end.
 *
 * @method Html5#loop
 * @return {boolean}
 *         - The value of `loop` from the media element.
 *         - True indicates that playback should seek back to start once
 *           the end of a media is reached.
 *         - False indicates that playback should not loop back to the start when the
 *           end of the media is reached.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
 */
'loop',

/**
 * Get the value of the `error` from the media element. `error` indicates any
 * MediaError that may have occured during playback. If error returns null there is no
 * current error.
 *
 * @method Html5#error
 * @return {MediaError|null}
 *         The value of `error` from the media element. Will be `MediaError` if there
 *         is a current error and null otherwise.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}
 */
'error',

/**
 * Get the value of `seeking` from the media element. `seeking` indicates whether the
 * media is currently seeking to a new position or not.
 *
 * @method Html5#seeking
 * @return {boolean}
 *         - The value of `seeking` from the media element.
 *         - True indicates that the media is currently seeking to a new position.
 *         - Flase indicates that the media is not seeking to a new position at this time.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}
 */
'seeking',

/**
 * Get the value of `seekable` from the media element. `seekable` returns a
 * `TimeRange` object indicating ranges of time that can currently be `seeked` to.
 *
 * @method Html5#seekable
 * @return {TimeRange}
 *         The value of `seekable` from the media element. A `TimeRange` object
 *         indicating the current ranges of time that can be seeked to.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}
 */
'seekable',

/**
 * Get the value of `ended` from the media element. `ended` indicates whether
 * the media has reached the end or not.
 *
 * @method Html5#ended
 * @return {boolean}
 *         - The value of `ended` from the media element.
 *         - True indicates that the media has ended.
 *         - False indicates that the media has not ended.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
 */
'ended',

/**
 * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
 * whether the media should start muted or not. Only changes the default state of the
 * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the
 * current state.
 *
 * @method Html5#defaultMuted
 * @return {boolean}
 *         - The value of `defaultMuted` from the media element.
 *         - True indicates that the media should start muted.
 *         - False indicates that the media should not start muted
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
 */
'defaultMuted',

/**
 * Get the value of `playbackRate` from the media element. `playbackRate` indicates
 * the rate at which the media is currently playing back. Examples:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5#playbackRate
 * @return {number}
 *         The value of `playbackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
 */
'playbackRate',

/**
 * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates
 * the rate at which the media is currently playing back. This value will not indicate the current
 * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.
 *
 * Examples:
 *   - if defaultPlaybackRate is set to 2, media will play twice as fast.
 *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5.prototype.defaultPlaybackRate
 * @return {number}
 *         The value of `defaultPlaybackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
 */
'defaultPlaybackRate',

/**
 * Get the value of `played` from the media element. `played` returns a `TimeRange`
 * object representing points in the media timeline that have been played.
 *
 * @method Html5#played
 * @return {TimeRange}
 *         The value of `played` from the media element. A `TimeRange` object indicating
 *         the ranges of time that have been played.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}
 */
'played',

/**
 * Get the value of `networkState` from the media element. `networkState` indicates
 * the current network state. It returns an enumeration from the following list:
 * - 0: NETWORK_EMPTY
 * - 1: NEWORK_IDLE
 * - 2: NETWORK_LOADING
 * - 3: NETWORK_NO_SOURCE
 *
 * @method Html5#networkState
 * @return {number}
 *         The value of `networkState` from the media element. This will be a number
 *         from the list in the description.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}
 */
'networkState',

/**
 * Get the value of `readyState` from the media element. `readyState` indicates
 * the current state of the media element. It returns an enumeration from the
 * following list:
 * - 0: HAVE_NOTHING
 * - 1: HAVE_METADATA
 * - 2: HAVE_CURRENT_DATA
 * - 3: HAVE_FUTURE_DATA
 * - 4: HAVE_ENOUGH_DATA
 *
 * @method Html5#readyState
 * @return {number}
 *         The value of `readyState` from the media element. This will be a number
 *         from the list in the description.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}
 */
'readyState',

/**
 * Get the value of `videoWidth` from the video element. `videoWidth` indicates
 * the current width of the video in css pixels.
 *
 * @method Html5#videoWidth
 * @return {number}
 *         The value of `videoWidth` from the video element. This will be a number
 *         in css pixels.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
 */
'videoWidth',

/**
 * Get the value of `videoHeight` from the video element. `videoHeigth` indicates
 * the current height of the video in css pixels.
 *
 * @method Html5#videoHeight
 * @return {number}
 *         The value of `videoHeight` from the video element. This will be a number
 *         in css pixels.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
 */
'videoHeight'].forEach(function (prop) {
  Html5.prototype[prop] = function () {
    return this.el_[prop];
  };
});

// Wrap native properties with a setter in this format:
// set + toTitleCase(name)
[
/**
 * Set the value of `volume` on the media element. `volume` indicates the current
 * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
 * so on.
 *
 * @method Html5#setVolume
 * @param {number} percentAsDecimal
 *        The volume percent as a decimal. Valid range is from 0-1.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
 */
'volume',

/**
 * Set the value of `muted` on the media element. `muted` indicates that the current
 * audio level should be silent.
 *
 * @method Html5#setMuted
 * @param {boolean} muted
 *        - True if the audio should be set to silent
 *        - False otherwise
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
 */
'muted',

/**
 * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current
 * audio level should be silent, but will only effect the muted level on intial playback..
 *
 * @method Html5.prototype.setDefaultMuted
 * @param {boolean} defaultMuted
 *        - True if the audio should be set to silent
 *        - False otherwise
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
 */
'defaultMuted',

/**
 * Set the value of `src` on the media element. `src` indicates the current
 * {@link Tech~SourceObject} for the media.
 *
 * @method Html5#setSrc
 * @param {Tech~SourceObject} src
 *        The source object to set as the current source.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}
 */
'src',

/**
 * Set the value of `poster` on the media element. `poster` is the url to
 * an image file that can/will be shown when no media data is available.
 *
 * @method Html5#setPoster
 * @param {string} poster
 *        The url to an image that should be used as the `poster` for the media
 *        element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}
 */
'poster',

/**
 * Set the value of `preload` on the media element. `preload` indicates
 * what should download before the media is interacted with. It can have the following
 * values:
 * - none: nothing should be downloaded
 * - metadata: poster and the first few frames of the media may be downloaded to get
 *   media dimensions and other metadata
 * - auto: allow the media and metadata for the media to be downloaded before
 *    interaction
 *
 * @method Html5#setPreload
 * @param {string} preload
 *         The value of `preload` to set on the media element. Must be 'none', 'metadata',
 *         or 'auto'.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
 */
'preload',

/**
 * Set the value of `autoplay` on the media element. `autoplay` indicates
 * that the media should start to play as soon as the page is ready.
 *
 * @method Html5#setAutoplay
 * @param {boolean} autoplay
 *         - True indicates that the media should start as soon as the page loads.
 *         - False indicates that the media should not start as soon as the page loads.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
 */
'autoplay',

/**
 * Set the value of `loop` on the media element. `loop` indicates
 * that the media should return to the start of the media and continue playing once
 * it reaches the end.
 *
 * @method Html5#setLoop
 * @param {boolean} loop
 *         - True indicates that playback should seek back to start once
 *           the end of a media is reached.
 *         - False indicates that playback should not loop back to the start when the
 *           end of the media is reached.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
 */
'loop',

/**
 * Set the value of `playbackRate` on the media element. `playbackRate` indicates
 * the rate at which the media should play back. Examples:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5#setPlaybackRate
 * @return {number}
 *         The value of `playbackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
 */
'playbackRate',

/**
 * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates
 * the rate at which the media should play back upon initial startup. Changing this value
 * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.
 *
 * Example Values:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5.prototype.setDefaultPlaybackRate
 * @return {number}
 *         The value of `defaultPlaybackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}
 */
'defaultPlaybackRate'].forEach(function (prop) {
  Html5.prototype['set' + toTitleCase(prop)] = function (v) {
    this.el_[prop] = v;
  };
});

// wrap native functions with a function
[
/**
 * A wrapper around the media elements `pause` function. This will call the `HTML5`
 * media elements `pause` function.
 *
 * @method Html5#pause
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}
 */
'pause',

/**
 * A wrapper around the media elements `load` function. This will call the `HTML5`s
 * media element `load` function.
 *
 * @method Html5#load
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}
 */
'load',

/**
 * A wrapper around the media elements `play` function. This will call the `HTML5`s
 * media element `play` function.
 *
 * @method Html5#play
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}
 */
'play'].forEach(function (prop) {
  Html5.prototype[prop] = function () {
    return this.el_[prop]();
  };
});

Tech.withSourceHandlers(Html5);

/**
 * Native source handler for Html5, simply passes the source to the media element.
 *
 * @proprety {Tech~SourceObject} source
 *        The source object
 *
 * @proprety {Html5} tech
 *        The instance of the HTML5 tech.
 */
Html5.nativeSourceHandler = {};

/**
 * Check if the media element can play the given mime type.
 *
 * @param {string} type
 *        The mimetype to check
 *
 * @return {string}
 *         'probably', 'maybe', or '' (empty string)
 */
Html5.nativeSourceHandler.canPlayType = function (type) {
  // IE9 on Windows 7 without MediaPlayer throws an error here
  // https://github.com/videojs/video.js/issues/519
  try {
    return Html5.TEST_VID.canPlayType(type);
  } catch (e) {
    return '';
  }
};

/**
 * Check if the media element can handle a source natively.
 *
 * @param {Tech~SourceObject} source
 *         The source object
 *
 * @param {Object} [options]
 *         Options to be passed to the tech.
 *
 * @return {string}
 *         'probably', 'maybe', or '' (empty string).
 */
Html5.nativeSourceHandler.canHandleSource = function (source, options) {

  // If a type was provided we should rely on that
  if (source.type) {
    return Html5.nativeSourceHandler.canPlayType(source.type);

    // If no type, fall back to checking 'video/[EXTENSION]'
  } else if (source.src) {
    var ext = getFileExtension(source.src);

    return Html5.nativeSourceHandler.canPlayType('video/' + ext);
  }

  return '';
};

/**
 * Pass the source to the native media element.
 *
 * @param {Tech~SourceObject} source
 *        The source object
 *
 * @param {Html5} tech
 *        The instance of the Html5 tech
 *
 * @param {Object} [options]
 *        The options to pass to the source
 */
Html5.nativeSourceHandler.handleSource = function (source, tech, options) {
  tech.setSrc(source.src);
};

/**
 * A noop for the native dispose function, as cleanup is not needed.
 */
Html5.nativeSourceHandler.dispose = function () {};

// Register the native source handler
Html5.registerSourceHandler(Html5.nativeSourceHandler);

Tech.registerTech('Html5', Html5);

var _templateObject$1 = taggedTemplateLiteralLoose(['\n        Using the tech directly can be dangerous. I hope you know what you\'re doing.\n        See https://github.com/videojs/video.js/issues/2617 for more info.\n      '], ['\n        Using the tech directly can be dangerous. I hope you know what you\'re doing.\n        See https://github.com/videojs/video.js/issues/2617 for more info.\n      ']);

/**
 * @file player.js
 */
// Subclasses Component
// The following imports are used only to ensure that the corresponding modules
// are always included in the video.js package. Importing the modules will
// execute them and they will register themselves with video.js.
// Import Html5 tech, at least for disposing the original video tag.
// The following tech events are simply re-triggered
// on the player when they happen
var TECH_EVENTS_RETRIGGER = [
/**
 * Fired while the user agent is downloading media data.
 *
 * @event Player#progress
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `progress` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechProgress_
 * @fires Player#progress
 * @listens Tech#progress
 */
'progress',

/**
 * Fires when the loading of an audio/video is aborted.
 *
 * @event Player#abort
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `abort` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechAbort_
 * @fires Player#abort
 * @listens Tech#abort
 */
'abort',

/**
 * Fires when the browser is intentionally not getting media data.
 *
 * @event Player#suspend
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `suspend` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechSuspend_
 * @fires Player#suspend
 * @listens Tech#suspend
 */
'suspend',

/**
 * Fires when the current playlist is empty.
 *
 * @event Player#emptied
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `emptied` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechEmptied_
 * @fires Player#emptied
 * @listens Tech#emptied
 */
'emptied',
/**
 * Fires when the browser is trying to get media data, but data is not available.
 *
 * @event Player#stalled
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `stalled` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechStalled_
 * @fires Player#stalled
 * @listens Tech#stalled
 */
'stalled',

/**
 * Fires when the browser has loaded meta data for the audio/video.
 *
 * @event Player#loadedmetadata
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `stalled` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechLoadedmetadata_
 * @fires Player#loadedmetadata
 * @listens Tech#loadedmetadata
 */
'loadedmetadata',

/**
 * Fires when the browser has loaded the current frame of the audio/video.
 *
 * @event Player#loadeddata
 * @type {event}
 */
/**
 * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechLoaddeddata_
 * @fires Player#loadeddata
 * @listens Tech#loadeddata
 */
'loadeddata',

/**
 * Fires when the current playback position has changed.
 *
 * @event Player#timeupdate
 * @type {event}
 */
/**
 * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechTimeUpdate_
 * @fires Player#timeupdate
 * @listens Tech#timeupdate
 */
'timeupdate',

/**
 * Fires when the playing speed of the audio/video is changed
 *
 * @event Player#ratechange
 * @type {event}
 */
/**
 * Retrigger the `ratechange` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechRatechange_
 * @fires Player#ratechange
 * @listens Tech#ratechange
 */
'ratechange',

/**
 * Fires when the video's intrinsic dimensions change
 *
 * @event Player#resize
 * @type {event}
 */
/**
 * Retrigger the `resize` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechResize_
 * @fires Player#resize
 * @listens Tech#resize
 */
'resize',

/**
 * Fires when the volume has been changed
 *
 * @event Player#volumechange
 * @type {event}
 */
/**
 * Retrigger the `volumechange` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechVolumechange_
 * @fires Player#volumechange
 * @listens Tech#volumechange
 */
'volumechange',

/**
 * Fires when the text track has been changed
 *
 * @event Player#texttrackchange
 * @type {event}
 */
/**
 * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechTexttrackchange_
 * @fires Player#texttrackchange
 * @listens Tech#texttrackchange
 */
'texttrackchange'];

/**
 * An instance of the `Player` class is created when any of the Video.js setup methods
 * are used to initialize a video.
 *
 * After an instance has been created it can be accessed globally in two ways:
 * 1. By calling `videojs('example_video_1');`
 * 2. By using it directly via  `videojs.players.example_video_1;`
 *
 * @extends Component
 */

var Player = function (_Component) {
  inherits(Player, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Element} tag
   *        The original video DOM element used for configuring options.
   *
   * @param {Object} [options]
   *        Object of option names and values.
   *
   * @param {Component~ReadyCallback} [ready]
   *        Ready callback function.
   */
  function Player(tag, options, ready) {
    classCallCheck(this, Player);

    // Make sure tag ID exists
    tag.id = tag.id || 'vjs_video_' + newGUID();

    // Set Options
    // The options argument overrides options set in the video tag
    // which overrides globally set options.
    // This latter part coincides with the load order
    // (tag must exist before Player)
    options = assign(Player.getTagSettings(tag), options);

    // Delay the initialization of children because we need to set up
    // player properties first, and can't use `this` before `super()`
    options.initChildren = false;

    // Same with creating the element
    options.createEl = false;

    // we don't want the player to report touch activity on itself
    // see enableTouchActivity in Component
    options.reportTouchActivity = false;

    // If language is not set, get the closest lang attribute
    if (!options.language) {
      if (typeof tag.closest === 'function') {
        var closest = tag.closest('[lang]');

        if (closest) {
          options.language = closest.getAttribute('lang');
        }
      } else {
        var element = tag;

        while (element && element.nodeType === 1) {
          if (getAttributes(element).hasOwnProperty('lang')) {
            options.language = element.getAttribute('lang');
            break;
          }
          element = element.parentNode;
        }
      }
    }

    // Run base component initializing with new options

    // Turn off API access because we're loading a new tech that might load asynchronously
    var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));

    _this.isReady_ = false;

    // if the global option object was accidentally blown away by
    // someone, bail early with an informative error
    if (!_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) {
      throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');
    }

    // Store the original tag used to set options
    _this.tag = tag;

    // Store the tag attributes used to restore html5 element
    _this.tagAttributes = tag && getAttributes(tag);

    // Update current language
    _this.language(_this.options_.language);

    // Update Supported Languages
    if (options.languages) {
      // Normalise player option languages to lowercase
      var languagesToLower = {};

      Object.getOwnPropertyNames(options.languages).forEach(function (name$$1) {
        languagesToLower[name$$1.toLowerCase()] = options.languages[name$$1];
      });
      _this.languages_ = languagesToLower;
    } else {
      _this.languages_ = Player.prototype.options_.languages;
    }

    // Cache for video property values.
    _this.cache_ = {};

    // Set poster
    _this.poster_ = options.poster || '';

    // Set controls
    _this.controls_ = !!options.controls;

    // Set default values for lastVolume
    _this.cache_.lastVolume = 1;

    // Original tag settings stored in options
    // now remove immediately so native controls don't flash.
    // May be turned back on by HTML5 tech if nativeControlsForTouch is true
    tag.controls = false;

    /*
     * Store the internal state of scrubbing
     *
     * @private
     * @return {Boolean} True if the user is scrubbing
     */
    _this.scrubbing_ = false;

    _this.el_ = _this.createEl();

    // Make this an evented object and use `el_` as its event bus.
    evented(_this, { eventBusKey: 'el_' });

    // We also want to pass the original player options to each component and plugin
    // as well so they don't need to reach back into the player for options later.
    // We also need to do another copy of this.options_ so we don't end up with
    // an infinite loop.
    var playerOptionsCopy = mergeOptions(_this.options_);

    // Load plugins
    if (options.plugins) {
      var plugins = options.plugins;

      Object.keys(plugins).forEach(function (name$$1) {
        if (typeof this[name$$1] === 'function') {
          this[name$$1](plugins[name$$1]);
        } else {
          throw new Error('plugin "' + name$$1 + '" does not exist');
        }
      }, _this);
    }

    _this.options_.playerOptions = playerOptionsCopy;

    _this.middleware_ = [];

    _this.initChildren();

    // Set isAudio based on whether or not an audio tag was used
    _this.isAudio(tag.nodeName.toLowerCase() === 'audio');

    // Update controls className. Can't do this when the controls are initially
    // set because the element doesn't exist yet.
    if (_this.controls()) {
      _this.addClass('vjs-controls-enabled');
    } else {
      _this.addClass('vjs-controls-disabled');
    }

    // Set ARIA label and region role depending on player type
    _this.el_.setAttribute('role', 'region');
    if (_this.isAudio()) {
      _this.el_.setAttribute('aria-label', _this.localize('Audio Player'));
    } else {
      _this.el_.setAttribute('aria-label', _this.localize('Video Player'));
    }

    if (_this.isAudio()) {
      _this.addClass('vjs-audio');
    }

    if (_this.flexNotSupported_()) {
      _this.addClass('vjs-no-flex');
    }

    // TODO: Make this smarter. Toggle user state between touching/mousing
    // using events, since devices can have both touch and mouse events.
    // if (browser.TOUCH_ENABLED) {
    //   this.addClass('vjs-touch-enabled');
    // }

    // iOS Safari has broken hover handling
    if (!IS_IOS) {
      _this.addClass('vjs-workinghover');
    }

    // Make player easily findable by ID
    Player.players[_this.id_] = _this;

    // Add a major version class to aid css in plugins
    var majorVersion = version.split('.')[0];

    _this.addClass('vjs-v' + majorVersion);

    // When the player is first initialized, trigger activity so components
    // like the control bar show themselves if needed
    _this.userActive(true);
    _this.reportUserActivity();
    _this.listenForUserActivity_();

    _this.on('fullscreenchange', _this.handleFullscreenChange_);
    _this.on('stageclick', _this.handleStageClick_);

    _this.changingSrc_ = false;
    return _this;
  }

  /**
   * Destroys the video player and does any necessary cleanup.
   *
   * This is especially helpful if you are dynamically adding and removing videos
   * to/from the DOM.
   *
   * @fires Player#dispose
   */


  Player.prototype.dispose = function dispose() {
    /**
     * Called when the player is being disposed of.
     *
     * @event Player#dispose
     * @type {EventTarget~Event}
     */
    this.trigger('dispose');
    // prevent dispose from being called twice
    this.off('dispose');

    if (this.styleEl_ && this.styleEl_.parentNode) {
      this.styleEl_.parentNode.removeChild(this.styleEl_);
    }

    // Kill reference to this player
    Player.players[this.id_] = null;

    if (this.tag && this.tag.player) {
      this.tag.player = null;
    }

    if (this.el_ && this.el_.player) {
      this.el_.player = null;
    }

    if (this.tech_) {
      this.tech_.dispose();
    }

    _Component.prototype.dispose.call(this);
  };

  /**
   * Create the `Player`'s DOM element.
   *
   * @return {Element}
   *         The DOM element that gets created.
   */


  Player.prototype.createEl = function createEl$$1() {
    var tag = this.tag;
    var el = void 0;
    var playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute('data-vjs-player');

    if (playerElIngest) {
      el = this.el_ = tag.parentNode;
    } else {
      el = this.el_ = _Component.prototype.createEl.call(this, 'div');
    }

    // set tabindex to -1 so we could focus on the player element
    tag.setAttribute('tabindex', '-1');

    // Remove width/height attrs from tag so CSS can make it 100% width/height
    tag.removeAttribute('width');
    tag.removeAttribute('height');

    // Copy over all the attributes from the tag, including ID and class
    // ID will now reference player box, not the video tag
    var attrs = getAttributes(tag);

    Object.getOwnPropertyNames(attrs).forEach(function (attr) {
      // workaround so we don't totally break IE7
      // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7
      if (attr === 'class') {
        el.className += ' ' + attrs[attr];
      } else {
        el.setAttribute(attr, attrs[attr]);
      }
    });

    // Update tag id/class for use as HTML5 playback tech
    // Might think we should do this after embedding in container so .vjs-tech class
    // doesn't flash 100% width/height, but class only applies with .video-js parent
    tag.playerId = tag.id;
    tag.id += '_html5_api';
    tag.className = 'vjs-tech';

    // Make player findable on elements
    tag.player = el.player = this;
    // Default state of video is paused
    this.addClass('vjs-paused');

    // Add a style element in the player that we'll use to set the width/height
    // of the player in a way that's still overrideable by CSS, just like the
    // video element
    if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true) {
      this.styleEl_ = createStyleElement('vjs-styles-dimensions');
      var defaultsStyleEl = $('.vjs-styles-defaults');
      var head = $('head');

      head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
    }

    // Pass in the width/height/aspectRatio options which will update the style el
    this.width(this.options_.width);
    this.height(this.options_.height);
    this.fluid(this.options_.fluid);
    this.aspectRatio(this.options_.aspectRatio);

    // Hide any links within the video/audio tag, because IE doesn't hide them completely.
    var links = tag.getElementsByTagName('a');

    for (var i = 0; i < links.length; i++) {
      var linkEl = links.item(i);

      addClass(linkEl, 'vjs-hidden');
      linkEl.setAttribute('hidden', 'hidden');
    }

    // insertElFirst seems to cause the networkState to flicker from 3 to 2, so
    // keep track of the original for later so we can know if the source originally failed
    tag.initNetworkState_ = tag.networkState;

    // Wrap video tag in div (el/box) container
    if (tag.parentNode && !playerElIngest) {
      tag.parentNode.insertBefore(el, tag);
    }

    // insert the tag as the first child of the player element
    // then manually add it to the children array so that this.addChild
    // will work properly for other components
    //
    // Breaks iPhone, fixed in HTML5 setup.
    prependTo(tag, el);
    this.children_.unshift(tag);

    // Set lang attr on player to ensure CSS :lang() in consistent with player
    // if it's been set to something different to the doc
    this.el_.setAttribute('lang', this.language_);

    this.el_ = el;

    return el;
  };

  /**
   * A getter/setter for the `Player`'s width.
   *
   * @param {number} [value]
   *        The value to set the `Player's width to.
   *
   * @return {number}
   *         The current width of the `Player` when getting.
   */


  Player.prototype.width = function width(value) {
    return this.dimension('width', value);
  };

  /**
   * A getter/setter for the `Player`'s height.
   *
   * @param {number} [value]
   *        The value to set the `Player's heigth to.
   *
   * @return {number}
   *         The current height of the `Player` when getting.
   */


  Player.prototype.height = function height(value) {
    return this.dimension('height', value);
  };

  /**
   * A getter/setter for the `Player`'s width & height.
   *
   * @param {string} dimension
   *        This string can be:
   *        - 'width'
   *        - 'height'
   *
   * @param {number} [value]
   *        Value for dimension specified in the first argument.
   *
   * @return {number}
   *         The dimension arguments value when getting (width/height).
   */


  Player.prototype.dimension = function dimension(_dimension, value) {
    var privDimension = _dimension + '_';

    if (value === undefined) {
      return this[privDimension] || 0;
    }

    if (value === '') {
      // If an empty string is given, reset the dimension to be automatic
      this[privDimension] = undefined;
    } else {
      var parsedVal = parseFloat(value);

      if (isNaN(parsedVal)) {
        log$1.error('Improper value "' + value + '" supplied for for ' + _dimension);
        return;
      }

      this[privDimension] = parsedVal;
    }

    this.updateStyleEl_();
  };

  /**
   * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.
   *
   * @param {boolean} [bool]
   *        - A value of true adds the class.
   *        - A value of false removes the class.
   *        - No value will toggle the fluid class.
   *
   * @return {boolean|undefined}
   *         - The value of fluid when getting.
   *         - `undefined` when setting.
   */


  Player.prototype.fluid = function fluid(bool) {
    if (bool === undefined) {
      return !!this.fluid_;
    }

    this.fluid_ = !!bool;

    if (bool) {
      this.addClass('vjs-fluid');
    } else {
      this.removeClass('vjs-fluid');
    }

    this.updateStyleEl_();
  };

  /**
   * Get/Set the aspect ratio
   *
   * @param {string} [ratio]
   *        Aspect ratio for player
   *
   * @return {string|undefined}
   *         returns the current aspect ratio when getting
   */

  /**
   * A getter/setter for the `Player`'s aspect ratio.
   *
   * @param {string} [ratio]
   *        The value to set the `Player's aspect ratio to.
   *
   * @return {string|undefined}
   *         - The current aspect ratio of the `Player` when getting.
   *         - undefined when setting
   */


  Player.prototype.aspectRatio = function aspectRatio(ratio) {
    if (ratio === undefined) {
      return this.aspectRatio_;
    }

    // Check for width:height format
    if (!/^\d+\:\d+$/.test(ratio)) {
      throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');
    }
    this.aspectRatio_ = ratio;

    // We're assuming if you set an aspect ratio you want fluid mode,
    // because in fixed mode you could calculate width and height yourself.
    this.fluid(true);

    this.updateStyleEl_();
  };

  /**
   * Update styles of the `Player` element (height, width and aspect ratio).
   *
   * @private
   * @listens Tech#loadedmetadata
   */


  Player.prototype.updateStyleEl_ = function updateStyleEl_() {
    if (window.VIDEOJS_NO_DYNAMIC_STYLE === true) {
      var _width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;
      var _height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;
      var techEl = this.tech_ && this.tech_.el();

      if (techEl) {
        if (_width >= 0) {
          techEl.width = _width;
        }
        if (_height >= 0) {
          techEl.height = _height;
        }
      }

      return;
    }

    var width = void 0;
    var height = void 0;
    var aspectRatio = void 0;
    var idClass = void 0;

    // The aspect ratio is either used directly or to calculate width and height.
    if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {
      // Use any aspectRatio that's been specifically set
      aspectRatio = this.aspectRatio_;
    } else if (this.videoWidth() > 0) {
      // Otherwise try to get the aspect ratio from the video metadata
      aspectRatio = this.videoWidth() + ':' + this.videoHeight();
    } else {
      // Or use a default. The video element's is 2:1, but 16:9 is more common.
      aspectRatio = '16:9';
    }

    // Get the ratio as a decimal we can use to calculate dimensions
    var ratioParts = aspectRatio.split(':');
    var ratioMultiplier = ratioParts[1] / ratioParts[0];

    if (this.width_ !== undefined) {
      // Use any width that's been specifically set
      width = this.width_;
    } else if (this.height_ !== undefined) {
      // Or calulate the width from the aspect ratio if a height has been set
      width = this.height_ / ratioMultiplier;
    } else {
      // Or use the video's metadata, or use the video el's default of 300
      width = this.videoWidth() || 300;
    }

    if (this.height_ !== undefined) {
      // Use any height that's been specifically set
      height = this.height_;
    } else {
      // Otherwise calculate the height from the ratio and the width
      height = width * ratioMultiplier;
    }

    // Ensure the CSS class is valid by starting with an alpha character
    if (/^[^a-zA-Z]/.test(this.id())) {
      idClass = 'dimensions-' + this.id();
    } else {
      idClass = this.id() + '-dimensions';
    }

    // Ensure the right class is still on the player for the style element
    this.addClass(idClass);

    setTextContent(this.styleEl_, '\n      .' + idClass + ' {\n        width: ' + width + 'px;\n        height: ' + height + 'px;\n      }\n\n      .' + idClass + '.vjs-fluid {\n        padding-top: ' + ratioMultiplier * 100 + '%;\n      }\n    ');
  };

  /**
   * Load/Create an instance of playback {@link Tech} including element
   * and API methods. Then append the `Tech` element in `Player` as a child.
   *
   * @param {string} techName
   *        name of the playback technology
   *
   * @param {string} source
   *        video source
   *
   * @private
   */


  Player.prototype.loadTech_ = function loadTech_(techName, source) {
    var _this2 = this;

    // Pause and remove current playback technology
    if (this.tech_) {
      this.unloadTech_();
    }

    var titleTechName = toTitleCase(techName);
    var camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);

    // get rid of the HTML5 video tag as soon as we are using another tech
    if (titleTechName !== 'Html5' && this.tag) {
      Tech.getTech('Html5').disposeMediaElement(this.tag);
      this.tag.player = null;
      this.tag = null;
    }

    this.techName_ = titleTechName;

    // Turn off API access because we're loading a new tech that might load asynchronously
    this.isReady_ = false;

    // Grab tech-specific options from player options and add source and parent element to use.
    var techOptions = {
      source: source,
      'nativeControlsForTouch': this.options_.nativeControlsForTouch,
      'playerId': this.id(),
      'techId': this.id() + '_' + titleTechName + '_api',
      'autoplay': this.options_.autoplay,
      'playsinline': this.options_.playsinline,
      'preload': this.options_.preload,
      'loop': this.options_.loop,
      'muted': this.options_.muted,
      'poster': this.poster(),
      'language': this.language(),
      'playerElIngest': this.playerElIngest_ || false,
      'vtt.js': this.options_['vtt.js']
    };

    ALL.names.forEach(function (name$$1) {
      var props = ALL[name$$1];

      techOptions[props.getterName] = _this2[props.privateName];
    });

    assign(techOptions, this.options_[titleTechName]);
    assign(techOptions, this.options_[camelTechName]);
    assign(techOptions, this.options_[techName.toLowerCase()]);

    if (this.tag) {
      techOptions.tag = this.tag;
    }

    if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {
      techOptions.startTime = this.cache_.currentTime;
    }

    // Initialize tech instance
    var TechClass = Tech.getTech(techName);

    if (!TechClass) {
      throw new Error('No Tech named \'' + titleTechName + '\' exists! \'' + titleTechName + '\' should be registered using videojs.registerTech()\'');
    }

    this.tech_ = new TechClass(techOptions);

    // player.triggerReady is always async, so don't need this to be async
    this.tech_.ready(bind(this, this.handleTechReady_), true);

    textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);

    // Listen to all HTML5-defined events and trigger them on the player
    TECH_EVENTS_RETRIGGER.forEach(function (event) {
      _this2.on(_this2.tech_, event, _this2['handleTech' + toTitleCase(event) + '_']);
    });
    this.on(this.tech_, 'loadstart', this.handleTechLoadStart_);
    this.on(this.tech_, 'waiting', this.handleTechWaiting_);
    this.on(this.tech_, 'canplay', this.handleTechCanPlay_);
    this.on(this.tech_, 'canplaythrough', this.handleTechCanPlayThrough_);
    this.on(this.tech_, 'playing', this.handleTechPlaying_);
    this.on(this.tech_, 'ended', this.handleTechEnded_);
    this.on(this.tech_, 'seeking', this.handleTechSeeking_);
    this.on(this.tech_, 'seeked', this.handleTechSeeked_);
    this.on(this.tech_, 'play', this.handleTechPlay_);
    this.on(this.tech_, 'firstplay', this.handleTechFirstPlay_);
    this.on(this.tech_, 'pause', this.handleTechPause_);
    this.on(this.tech_, 'durationchange', this.handleTechDurationChange_);
    this.on(this.tech_, 'fullscreenchange', this.handleTechFullscreenChange_);
    this.on(this.tech_, 'error', this.handleTechError_);
    this.on(this.tech_, 'loadedmetadata', this.updateStyleEl_);
    this.on(this.tech_, 'posterchange', this.handleTechPosterChange_);
    this.on(this.tech_, 'textdata', this.handleTechTextData_);

    this.usingNativeControls(this.techGet_('controls'));

    if (this.controls() && !this.usingNativeControls()) {
      this.addTechControlsListeners_();
    }

    // Add the tech element in the DOM if it was not already there
    // Make sure to not insert the original video element if using Html5
    if (this.tech_.el().parentNode !== this.el() && (titleTechName !== 'Html5' || !this.tag)) {
      prependTo(this.tech_.el(), this.el());
    }

    // Get rid of the original video tag reference after the first tech is loaded
    if (this.tag) {
      this.tag.player = null;
      this.tag = null;
    }
  };

  /**
   * Unload and dispose of the current playback {@link Tech}.
   *
   * @private
   */


  Player.prototype.unloadTech_ = function unloadTech_() {
    var _this3 = this;

    // Save the current text tracks so that we can reuse the same text tracks with the next tech
    ALL.names.forEach(function (name$$1) {
      var props = ALL[name$$1];

      _this3[props.privateName] = _this3[props.getterName]();
    });
    this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);

    this.isReady_ = false;

    this.tech_.dispose();

    this.tech_ = false;
  };

  /**
   * Return a reference to the current {@link Tech}.
   * It will print a warning by default about the danger of using the tech directly
   * but any argument that is passed in will silence the warning.
   *
   * @param {*} [safety]
   *        Anything passed in to silence the warning
   *
   * @return {Tech}
   *         The Tech
   */


  Player.prototype.tech = function tech(safety) {
    if (safety === undefined) {
      log$1.warn(tsml(_templateObject$1));
    }

    return this.tech_;
  };

  /**
   * Set up click and touch listeners for the playback element
   *
   * - On desktops: a click on the video itself will toggle playback
   * - On mobile devices: a click on the video toggles controls
   *   which is done by toggling the user state between active and
   *   inactive
   * - A tap can signal that a user has become active or has become inactive
   *   e.g. a quick tap on an iPhone movie should reveal the controls. Another
   *   quick tap should hide them again (signaling the user is in an inactive
   *   viewing state)
   * - In addition to this, we still want the user to be considered inactive after
   *   a few seconds of inactivity.
   *
   * > Note: the only part of iOS interaction we can't mimic with this setup
   * is a touch and hold on the video element counting as activity in order to
   * keep the controls showing, but that shouldn't be an issue. A touch and hold
   * on any controls will still keep the user active
   *
   * @private
   */


  Player.prototype.addTechControlsListeners_ = function addTechControlsListeners_() {
    // Make sure to remove all the previous listeners in case we are called multiple times.
    this.removeTechControlsListeners_();

    // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do
    // trigger mousedown/up.
    // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object
    // Any touch events are set to block the mousedown event from happening
    this.on(this.tech_, 'mousedown', this.handleTechClick_);

    // If the controls were hidden we don't want that to change without a tap event
    // so we'll check if the controls were already showing before reporting user
    // activity
    this.on(this.tech_, 'touchstart', this.handleTechTouchStart_);
    this.on(this.tech_, 'touchmove', this.handleTechTouchMove_);
    this.on(this.tech_, 'touchend', this.handleTechTouchEnd_);

    // The tap listener needs to come after the touchend listener because the tap
    // listener cancels out any reportedUserActivity when setting userActive(false)
    this.on(this.tech_, 'tap', this.handleTechTap_);
  };

  /**
   * Remove the listeners used for click and tap controls. This is needed for
   * toggling to controls disabled, where a tap/touch should do nothing.
   *
   * @private
   */


  Player.prototype.removeTechControlsListeners_ = function removeTechControlsListeners_() {
    // We don't want to just use `this.off()` because there might be other needed
    // listeners added by techs that extend this.
    this.off(this.tech_, 'tap', this.handleTechTap_);
    this.off(this.tech_, 'touchstart', this.handleTechTouchStart_);
    this.off(this.tech_, 'touchmove', this.handleTechTouchMove_);
    this.off(this.tech_, 'touchend', this.handleTechTouchEnd_);
    this.off(this.tech_, 'mousedown', this.handleTechClick_);
  };

  /**
   * Player waits for the tech to be ready
   *
   * @private
   */


  Player.prototype.handleTechReady_ = function handleTechReady_() {
    this.triggerReady();

    // Keep the same volume as before
    if (this.cache_.volume) {
      this.techCall_('setVolume', this.cache_.volume);
    }

    // Look if the tech found a higher resolution poster while loading
    this.handleTechPosterChange_();

    // Update the duration if available
    this.handleTechDurationChange_();

    // Chrome and Safari both have issues with autoplay.
    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.
    // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)
    // This fixes both issues. Need to wait for API, so it updates displays correctly
    if ((this.src() || this.currentSrc()) && this.tag && this.options_.autoplay && this.paused()) {
      try {
        // Chrome Fix. Fixed in Chrome v16.
        delete this.tag.poster;
      } catch (e) {
        log$1('deleting tag.poster throws in some browsers', e);
      }
      this.play();
    }
  };

  /**
   * Retrigger the `loadstart` event that was triggered by the {@link Tech}. This
   * function will also trigger {@link Player#firstplay} if it is the first loadstart
   * for a video.
   *
   * @fires Player#loadstart
   * @fires Player#firstplay
   * @listens Tech#loadstart
   * @private
   */


  Player.prototype.handleTechLoadStart_ = function handleTechLoadStart_() {
    // TODO: Update to use `emptied` event instead. See #1277.

    this.removeClass('vjs-ended');
    this.removeClass('vjs-seeking');

    // reset the error state
    this.error(null);

    // If it's already playing we want to trigger a firstplay event now.
    // The firstplay event relies on both the play and loadstart events
    // which can happen in any order for a new source
    if (!this.paused()) {
      /**
       * Fired when the user agent begins looking for media data
       *
       * @event Player#loadstart
       * @type {EventTarget~Event}
       */
      this.trigger('loadstart');
      this.trigger('firstplay');
    } else {
      // reset the hasStarted state
      this.hasStarted(false);
      this.trigger('loadstart');
    }
  };

  /**
   * Add/remove the vjs-has-started class
   *
   * @fires Player#firstplay
   *
   * @param {boolean} hasStarted
   *        - true: adds the class
   *        - false: remove the class
   *
   * @return {boolean}
   *         the boolean value of hasStarted
   */


  Player.prototype.hasStarted = function hasStarted(_hasStarted) {
    if (_hasStarted !== undefined) {
      // only update if this is a new value
      if (this.hasStarted_ !== _hasStarted) {
        this.hasStarted_ = _hasStarted;
        if (_hasStarted) {
          this.addClass('vjs-has-started');
          // trigger the firstplay event if this newly has played
          this.trigger('firstplay');
        } else {
          this.removeClass('vjs-has-started');
        }
      }
      return;
    }
    return !!this.hasStarted_;
  };

  /**
   * Fired whenever the media begins or resumes playback
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}
   * @fires Player#play
   * @listens Tech#play
   * @private
   */


  Player.prototype.handleTechPlay_ = function handleTechPlay_() {
    this.removeClass('vjs-ended');
    this.removeClass('vjs-paused');
    this.addClass('vjs-playing');

    // hide the poster when the user hits play
    this.hasStarted(true);
    /**
     * Triggered whenever an {@link Tech#play} event happens. Indicates that
     * playback has started or resumed.
     *
     * @event Player#play
     * @type {EventTarget~Event}
     */
    this.trigger('play');
  };

  /**
   * Retrigger the `waiting` event that was triggered by the {@link Tech}.
   *
   * @fires Player#waiting
   * @listens Tech#waiting
   * @private
   */


  Player.prototype.handleTechWaiting_ = function handleTechWaiting_() {
    var _this4 = this;

    this.addClass('vjs-waiting');
    /**
     * A readyState change on the DOM element has caused playback to stop.
     *
     * @event Player#waiting
     * @type {EventTarget~Event}
     */
    this.trigger('waiting');
    this.one('timeupdate', function () {
      return _this4.removeClass('vjs-waiting');
    });
  };

  /**
   * Retrigger the `canplay` event that was triggered by the {@link Tech}.
   * > Note: This is not consistent between browsers. See #1351
   *
   * @fires Player#canplay
   * @listens Tech#canplay
   * @private
   */


  Player.prototype.handleTechCanPlay_ = function handleTechCanPlay_() {
    this.removeClass('vjs-waiting');
    /**
     * The media has a readyState of HAVE_FUTURE_DATA or greater.
     *
     * @event Player#canplay
     * @type {EventTarget~Event}
     */
    this.trigger('canplay');
  };

  /**
   * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.
   *
   * @fires Player#canplaythrough
   * @listens Tech#canplaythrough
   * @private
   */


  Player.prototype.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {
    this.removeClass('vjs-waiting');
    /**
     * The media has a readyState of HAVE_ENOUGH_DATA or greater. This means that the
     * entire media file can be played without buffering.
     *
     * @event Player#canplaythrough
     * @type {EventTarget~Event}
     */
    this.trigger('canplaythrough');
  };

  /**
   * Retrigger the `playing` event that was triggered by the {@link Tech}.
   *
   * @fires Player#playing
   * @listens Tech#playing
   * @private
   */


  Player.prototype.handleTechPlaying_ = function handleTechPlaying_() {
    this.removeClass('vjs-waiting');
    /**
     * The media is no longer blocked from playback, and has started playing.
     *
     * @event Player#playing
     * @type {EventTarget~Event}
     */
    this.trigger('playing');
  };

  /**
   * Retrigger the `seeking` event that was triggered by the {@link Tech}.
   *
   * @fires Player#seeking
   * @listens Tech#seeking
   * @private
   */


  Player.prototype.handleTechSeeking_ = function handleTechSeeking_() {
    this.addClass('vjs-seeking');
    /**
     * Fired whenever the player is jumping to a new time
     *
     * @event Player#seeking
     * @type {EventTarget~Event}
     */
    this.trigger('seeking');
  };

  /**
   * Retrigger the `seeked` event that was triggered by the {@link Tech}.
   *
   * @fires Player#seeked
   * @listens Tech#seeked
   * @private
   */


  Player.prototype.handleTechSeeked_ = function handleTechSeeked_() {
    this.removeClass('vjs-seeking');
    /**
     * Fired when the player has finished jumping to a new time
     *
     * @event Player#seeked
     * @type {EventTarget~Event}
     */
    this.trigger('seeked');
  };

  /**
   * Retrigger the `firstplay` event that was triggered by the {@link Tech}.
   *
   * @fires Player#firstplay
   * @listens Tech#firstplay
   * @deprecated As of 6.0 firstplay event is deprecated.
   * @deprecated As of 6.0 passing the `starttime` option to the player and the firstplay event are deprecated.
   * @private
   */


  Player.prototype.handleTechFirstPlay_ = function handleTechFirstPlay_() {
    // If the first starttime attribute is specified
    // then we will start at the given offset in seconds
    if (this.options_.starttime) {
      log$1.warn('Passing the `starttime` option to the player will be deprecated in 6.0');
      this.currentTime(this.options_.starttime);
    }

    this.addClass('vjs-has-started');
    /**
     * Fired the first time a video is played. Not part of the HLS spec, and this is
     * probably not the best implementation yet, so use sparingly. If you don't have a
     * reason to prevent playback, use `myPlayer.one('play');` instead.
     *
     * @event Player#firstplay
     * @deprecated As of 6.0 firstplay event is deprecated.
     * @type {EventTarget~Event}
     */
    this.trigger('firstplay');
  };

  /**
   * Retrigger the `pause` event that was triggered by the {@link Tech}.
   *
   * @fires Player#pause
   * @listens Tech#pause
   * @private
   */


  Player.prototype.handleTechPause_ = function handleTechPause_() {
    this.removeClass('vjs-playing');
    this.addClass('vjs-paused');
    /**
     * Fired whenever the media has been paused
     *
     * @event Player#pause
     * @type {EventTarget~Event}
     */
    this.trigger('pause');
  };

  /**
   * Retrigger the `ended` event that was triggered by the {@link Tech}.
   *
   * @fires Player#ended
   * @listens Tech#ended
   * @private
   */


  Player.prototype.handleTechEnded_ = function handleTechEnded_() {
    this.addClass('vjs-ended');
    if (this.options_.loop) {
      this.currentTime(0);
      this.play();
    } else if (!this.paused()) {
      this.pause();
    }

    /**
     * Fired when the end of the media resource is reached (currentTime == duration)
     *
     * @event Player#ended
     * @type {EventTarget~Event}
     */
    this.trigger('ended');
  };

  /**
   * Fired when the duration of the media resource is first known or changed
   *
   * @listens Tech#durationchange
   * @private
   */


  Player.prototype.handleTechDurationChange_ = function handleTechDurationChange_() {
    this.duration(this.techGet_('duration'));
  };

  /**
   * Handle a click on the media element to play/pause
   *
   * @param {EventTarget~Event} event
   *        the event that caused this function to trigger
   *
   * @listens Tech#mousedown
   * @private
   */


  Player.prototype.handleTechClick_ = function handleTechClick_(event) {
    // We're using mousedown to detect clicks thanks to Flash, but mousedown
    // will also be triggered with right-clicks, so we need to prevent that
    if (event.button !== 0) {
      return;
    }

    // When controls are disabled a click should not toggle playback because
    // the click is considered a control
    if (this.controls()) {
      if (this.paused()) {
        this.play();
      } else {
        this.pause();
      }
    }
  };

  /**
   * Handle a tap on the media element. It will toggle the user
   * activity state, which hides and shows the controls.
   *
   * @listens Tech#tap
   * @private
   */


  Player.prototype.handleTechTap_ = function handleTechTap_() {
    this.userActive(!this.userActive());
  };

  /**
   * Handle touch to start
   *
   * @listens Tech#touchstart
   * @private
   */


  Player.prototype.handleTechTouchStart_ = function handleTechTouchStart_() {
    this.userWasActive = this.userActive();
  };

  /**
   * Handle touch to move
   *
   * @listens Tech#touchmove
   * @private
   */


  Player.prototype.handleTechTouchMove_ = function handleTechTouchMove_() {
    if (this.userWasActive) {
      this.reportUserActivity();
    }
  };

  /**
   * Handle touch to end
   *
   * @param {EventTarget~Event} event
   *        the touchend event that triggered
   *        this function
   *
   * @listens Tech#touchend
   * @private
   */


  Player.prototype.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {
    // Stop the mouse events from also happening
    event.preventDefault();
  };

  /**
   * Fired when the player switches in or out of fullscreen mode
   *
   * @private
   * @listens Player#fullscreenchange
   */


  Player.prototype.handleFullscreenChange_ = function handleFullscreenChange_() {
    if (this.isFullscreen()) {
      this.addClass('vjs-fullscreen');
    } else {
      this.removeClass('vjs-fullscreen');
    }
  };

  /**
   * native click events on the SWF aren't triggered on IE11, Win8.1RT
   * use stageclick events triggered from inside the SWF instead
   *
   * @private
   * @listens stageclick
   */


  Player.prototype.handleStageClick_ = function handleStageClick_() {
    this.reportUserActivity();
  };

  /**
   * Handle Tech Fullscreen Change
   *
   * @param {EventTarget~Event} event
   *        the fullscreenchange event that triggered this function
   *
   * @param {Object} data
   *        the data that was sent with the event
   *
   * @private
   * @listens Tech#fullscreenchange
   * @fires Player#fullscreenchange
   */


  Player.prototype.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {
    if (data) {
      this.isFullscreen(data.isFullscreen);
    }
    /**
     * Fired when going in and out of fullscreen.
     *
     * @event Player#fullscreenchange
     * @type {EventTarget~Event}
     */
    this.trigger('fullscreenchange');
  };

  /**
   * Fires when an error occurred during the loading of an audio/video.
   *
   * @private
   * @listens Tech#error
   */


  Player.prototype.handleTechError_ = function handleTechError_() {
    var error = this.tech_.error();

    this.error(error);
  };

  /**
   * Retrigger the `textdata` event that was triggered by the {@link Tech}.
   *
   * @fires Player#textdata
   * @listens Tech#textdata
   * @private
   */


  Player.prototype.handleTechTextData_ = function handleTechTextData_() {
    var data = null;

    if (arguments.length > 1) {
      data = arguments[1];
    }

    /**
     * Fires when we get a textdata event from tech
     *
     * @event Player#textdata
     * @type {EventTarget~Event}
     */
    this.trigger('textdata', data);
  };

  /**
   * Get object for cached values.
   *
   * @return {Object}
   *         get the current object cache
   */


  Player.prototype.getCache = function getCache() {
    return this.cache_;
  };

  /**
   * Pass values to the playback tech
   *
   * @param {string} [method]
   *        the method to call
   *
   * @param {Object} arg
   *        the argument to pass
   *
   * @private
   */


  Player.prototype.techCall_ = function techCall_(method, arg) {
    // If it's not ready yet, call method when it is

    this.ready(function () {
      if (method in allowedSetters) {
        return set$1(this.middleware_, this.tech_, method, arg);
      }

      try {
        if (this.tech_) {
          this.tech_[method](arg);
        }
      } catch (e) {
        log$1(e);
        throw e;
      }
    }, true);
  };

  /**
   * Get calls can't wait for the tech, and sometimes don't need to.
   *
   * @param {string} method
   *        Tech method
   *
   * @return {Function|undefined}
   *         the method or undefined
   *
   * @private
   */


  Player.prototype.techGet_ = function techGet_(method) {
    if (this.tech_ && this.tech_.isReady_) {

      if (method in allowedGetters) {
        return get$1(this.middleware_, this.tech_, method);
      }

      // Flash likes to die and reload when you hide or reposition it.
      // In these cases the object methods go away and we get errors.
      // When that happens we'll catch the errors and inform tech that it's not ready any more.
      try {
        return this.tech_[method]();
      } catch (e) {
        // When building additional tech libs, an expected method may not be defined yet
        if (this.tech_[method] === undefined) {
          log$1('Video.js: ' + method + ' method not defined for ' + this.techName_ + ' playback technology.', e);

          // When a method isn't available on the object it throws a TypeError
        } else if (e.name === 'TypeError') {
          log$1('Video.js: ' + method + ' unavailable on ' + this.techName_ + ' playback technology element.', e);
          this.tech_.isReady_ = false;
        } else {
          log$1(e);
        }
        throw e;
      }
    }

    return;
  };

  /**
   * start media playback
   *
   * @return {Promise|undefined}
   *         Returns a `Promise` if the browser returns one, for most browsers this will
   *         return undefined.
   */


  Player.prototype.play = function play() {
    if (this.changingSrc_) {
      this.ready(function () {
        var retval = this.techGet_('play');

        // silence errors (unhandled promise from play)
        if (retval !== undefined && typeof retval.then === 'function') {
          retval.then(null, function (e) {});
        }
      });

      // Only calls the tech's play if we already have a src loaded
    } else if (this.isReady_ && (this.src() || this.currentSrc())) {
      return this.techGet_('play');
    } else {
      this.ready(function () {
        this.tech_.one('loadstart', function () {
          var retval = this.play();

          // silence errors (unhandled promise from play)
          if (retval !== undefined && typeof retval.then === 'function') {
            retval.then(null, function (e) {});
          }
        });
      });
    }
  };

  /**
   * Pause the video playback
   *
   * @return {Player}
   *         A reference to the player object this function was called on
   */


  Player.prototype.pause = function pause() {
    this.techCall_('pause');
  };

  /**
   * Check if the player is paused or has yet to play
   *
   * @return {boolean}
   *         - false: if the media is currently playing
   *         - true: if media is not currently playing
   */


  Player.prototype.paused = function paused() {
    // The initial state of paused should be true (in Safari it's actually false)
    return this.techGet_('paused') === false ? false : true;
  };

  /**
   * Get a TimeRange object representing the current ranges of time that the user
   * has played.
   *
   * @return {TimeRange}
   *         A time range object that represents all the increments of time that have
   *         been played.
   */


  Player.prototype.played = function played() {
    return this.techGet_('played') || createTimeRanges(0, 0);
  };

  /**
   * Returns whether or not the user is "scrubbing". Scrubbing is
   * when the user has clicked the progress bar handle and is
   * dragging it along the progress bar.
   *
   * @param {boolean} [isScrubbing]
   *        wether the user is or is not scrubbing
   *
   * @return {boolean}
   *         The value of scrubbing when getting
   */


  Player.prototype.scrubbing = function scrubbing(isScrubbing) {
    if (typeof isScrubbing === 'undefined') {
      return this.scrubbing_;
    }
    this.scrubbing_ = !!isScrubbing;

    if (isScrubbing) {
      this.addClass('vjs-scrubbing');
    } else {
      this.removeClass('vjs-scrubbing');
    }
  };

  /**
   * Get or set the current time (in seconds)
   *
   * @param {number|string} [seconds]
   *        The time to seek to in seconds
   *
   * @return {number}
   *         - the current time in seconds when getting
   */


  Player.prototype.currentTime = function currentTime(seconds) {
    if (typeof seconds !== 'undefined') {
      this.techCall_('setCurrentTime', seconds);
      return;
    }

    // cache last currentTime and return. default to 0 seconds
    //
    // Caching the currentTime is meant to prevent a massive amount of reads on the tech's
    // currentTime when scrubbing, but may not provide much performance benefit afterall.
    // Should be tested. Also something has to read the actual current time or the cache will
    // never get updated.
    this.cache_.currentTime = this.techGet_('currentTime') || 0;
    return this.cache_.currentTime;
  };

  /**
   * Normally gets the length in time of the video in seconds;
   * in all but the rarest use cases an argument will NOT be passed to the method
   *
   * > **NOTE**: The video must have started loading before the duration can be
   * known, and in the case of Flash, may not be known until the video starts
   * playing.
   *
   * @fires Player#durationchange
   *
   * @param {number} [seconds]
   *        The duration of the video to set in seconds
   *
   * @return {number}
   *         - The duration of the video in seconds when getting
   */


  Player.prototype.duration = function duration(seconds) {
    if (seconds === undefined) {
      // return NaN if the duration is not known
      return this.cache_.duration !== undefined ? this.cache_.duration : NaN;
    }

    seconds = parseFloat(seconds);

    // Standardize on Inifity for signaling video is live
    if (seconds < 0) {
      seconds = Infinity;
    }

    if (seconds !== this.cache_.duration) {
      // Cache the last set value for optimized scrubbing (esp. Flash)
      this.cache_.duration = seconds;

      if (seconds === Infinity) {
        this.addClass('vjs-live');
      } else {
        this.removeClass('vjs-live');
      }
      /**
       * @event Player#durationchange
       * @type {EventTarget~Event}
       */
      this.trigger('durationchange');
    }
  };

  /**
   * Calculates how much time is left in the video. Not part
   * of the native video API.
   *
   * @return {number}
   *         The time remaining in seconds
   */


  Player.prototype.remainingTime = function remainingTime() {
    return this.duration() - this.currentTime();
  };

  //
  // Kind of like an array of portions of the video that have been downloaded.

  /**
   * Get a TimeRange object with an array of the times of the video
   * that have been downloaded. If you just want the percent of the
   * video that's been downloaded, use bufferedPercent.
   *
   * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}
   *
   * @return {TimeRange}
   *         A mock TimeRange object (following HTML spec)
   */


  Player.prototype.buffered = function buffered() {
    var buffered = this.techGet_('buffered');

    if (!buffered || !buffered.length) {
      buffered = createTimeRanges(0, 0);
    }

    return buffered;
  };

  /**
   * Get the percent (as a decimal) of the video that's been downloaded.
   * This method is not a part of the native HTML video API.
   *
   * @return {number}
   *         A decimal between 0 and 1 representing the percent
   *         that is bufferred 0 being 0% and 1 being 100%
   */


  Player.prototype.bufferedPercent = function bufferedPercent$$1() {
    return bufferedPercent(this.buffered(), this.duration());
  };

  /**
   * Get the ending time of the last buffered time range
   * This is used in the progress bar to encapsulate all time ranges.
   *
   * @return {number}
   *         The end of the last buffered time range
   */


  Player.prototype.bufferedEnd = function bufferedEnd() {
    var buffered = this.buffered();
    var duration = this.duration();
    var end = buffered.end(buffered.length - 1);

    if (end > duration) {
      end = duration;
    }

    return end;
  };

  /**
   * Get or set the current volume of the media
   *
   * @param  {number} [percentAsDecimal]
   *         The new volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number}
   *         The current volume as a percent when getting
   */


  Player.prototype.volume = function volume(percentAsDecimal) {
    var vol = void 0;

    if (percentAsDecimal !== undefined) {
      // Force value to between 0 and 1
      vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));
      this.cache_.volume = vol;
      this.techCall_('setVolume', vol);

      if (vol > 0) {
        this.lastVolume_(vol);
      }

      return;
    }

    // Default to 1 when returning current volume.
    vol = parseFloat(this.techGet_('volume'));
    return isNaN(vol) ? 1 : vol;
  };

  /**
   * Get the current muted state, or turn mute on or off
   *
   * @param {boolean} [muted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean}
   *         - true if mute is on and getting
   *         - false if mute is off and getting
   */


  Player.prototype.muted = function muted(_muted) {
    if (_muted !== undefined) {
      this.techCall_('setMuted', _muted);
      return;
    }
    return this.techGet_('muted') || false;
  };

  /**
   * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted
   * indicates the state of muted on intial playback.
   *
   * ```js
   *   var myPlayer = videojs('some-player-id');
   *
   *   myPlayer.src("http://www.example.com/path/to/video.mp4");
   *
   *   // get, should be false
   *   console.log(myPlayer.defaultMuted());
   *   // set to true
   *   myPlayer.defaultMuted(true);
   *   // get should be true
   *   console.log(myPlayer.defaultMuted());
   * ```
   *
   * @param {boolean} [defaultMuted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean|Player}
   *         - true if defaultMuted is on and getting
   *         - false if defaultMuted is off and getting
   *         - A reference to the current player when setting
   */


  Player.prototype.defaultMuted = function defaultMuted(_defaultMuted) {
    if (_defaultMuted !== undefined) {
      return this.techCall_('setDefaultMuted', _defaultMuted);
    }
    return this.techGet_('defaultMuted') || false;
  };

  /**
   * Get the last volume, or set it
   *
   * @param  {number} [percentAsDecimal]
   *         The new last volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number}
   *         the current value of lastVolume as a percent when getting
   *
   * @private
   */


  Player.prototype.lastVolume_ = function lastVolume_(percentAsDecimal) {
    if (percentAsDecimal !== undefined && percentAsDecimal !== 0) {
      this.cache_.lastVolume = percentAsDecimal;
      return;
    }
    return this.cache_.lastVolume;
  };

  /**
   * Check if current tech can support native fullscreen
   * (e.g. with built in controls like iOS, so not our flash swf)
   *
   * @return {boolean}
   *         if native fullscreen is supported
   */


  Player.prototype.supportsFullScreen = function supportsFullScreen() {
    return this.techGet_('supportsFullScreen') || false;
  };

  /**
   * Check if the player is in fullscreen mode or tell the player that it
   * is or is not in fullscreen mode.
   *
   * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
   * property and instead document.fullscreenElement is used. But isFullscreen is
   * still a valuable property for internal player workings.
   *
   * @param  {boolean} [isFS]
   *         Set the players current fullscreen state
   *
   * @return {boolean}
   *         - true if fullscreen is on and getting
   *         - false if fullscreen is off and getting
   */


  Player.prototype.isFullscreen = function isFullscreen(isFS) {
    if (isFS !== undefined) {
      this.isFullscreen_ = !!isFS;
      return;
    }
    return !!this.isFullscreen_;
  };

  /**
   * Increase the size of the video to full screen
   * In some browsers, full screen is not supported natively, so it enters
   * "full window mode", where the video fills the browser window.
   * In browsers and devices that support native full screen, sometimes the
   * browser's default controls will be shown, and not the Video.js custom skin.
   * This includes most mobile devices (iOS, Android) and older versions of
   * Safari.
   *
   * @fires Player#fullscreenchange
   */


  Player.prototype.requestFullscreen = function requestFullscreen() {
    var fsApi = FullscreenApi;

    this.isFullscreen(true);

    if (fsApi.requestFullscreen) {
      // the browser supports going fullscreen at the element level so we can
      // take the controls fullscreen as well as the video

      // Trigger fullscreenchange event after change
      // We have to specifically add this each time, and remove
      // when canceling fullscreen. Otherwise if there's multiple
      // players on a page, they would all be reacting to the same fullscreen
      // events
      on(document, fsApi.fullscreenchange, bind(this, function documentFullscreenChange(e) {
        this.isFullscreen(document[fsApi.fullscreenElement]);

        // If cancelling fullscreen, remove event listener.
        if (this.isFullscreen() === false) {
          off(document, fsApi.fullscreenchange, documentFullscreenChange);
        }
        /**
         * @event Player#fullscreenchange
         * @type {EventTarget~Event}
         */
        this.trigger('fullscreenchange');
      }));

      this.el_[fsApi.requestFullscreen]();
    } else if (this.tech_.supportsFullScreen()) {
      // we can't take the video.js controls fullscreen but we can go fullscreen
      // with native controls
      this.techCall_('enterFullScreen');
    } else {
      // fullscreen isn't supported so we'll just stretch the video element to
      // fill the viewport
      this.enterFullWindow();
      /**
       * @event Player#fullscreenchange
       * @type {EventTarget~Event}
       */
      this.trigger('fullscreenchange');
    }
  };

  /**
   * Return the video to its normal size after having been in full screen mode
   *
   * @fires Player#fullscreenchange
   */


  Player.prototype.exitFullscreen = function exitFullscreen() {
    var fsApi = FullscreenApi;

    this.isFullscreen(false);

    // Check for browser element fullscreen support
    if (fsApi.requestFullscreen) {
      document[fsApi.exitFullscreen]();
    } else if (this.tech_.supportsFullScreen()) {
      this.techCall_('exitFullScreen');
    } else {
      this.exitFullWindow();
      /**
       * @event Player#fullscreenchange
       * @type {EventTarget~Event}
       */
      this.trigger('fullscreenchange');
    }
  };

  /**
   * When fullscreen isn't supported we can stretch the
   * video container to as wide as the browser will let us.
   *
   * @fires Player#enterFullWindow
   */


  Player.prototype.enterFullWindow = function enterFullWindow() {
    this.isFullWindow = true;

    // Storing original doc overflow value to return to when fullscreen is off
    this.docOrigOverflow = document.documentElement.style.overflow;

    // Add listener for esc key to exit fullscreen
    on(document, 'keydown', bind(this, this.fullWindowOnEscKey));

    // Hide any scroll bars
    document.documentElement.style.overflow = 'hidden';

    // Apply fullscreen styles
    addClass(document.body, 'vjs-full-window');

    /**
     * @event Player#enterFullWindow
     * @type {EventTarget~Event}
     */
    this.trigger('enterFullWindow');
  };

  /**
   * Check for call to either exit full window or
   * full screen on ESC key
   *
   * @param {string} event
   *        Event to check for key press
   */


  Player.prototype.fullWindowOnEscKey = function fullWindowOnEscKey(event) {
    if (event.keyCode === 27) {
      if (this.isFullscreen() === true) {
        this.exitFullscreen();
      } else {
        this.exitFullWindow();
      }
    }
  };

  /**
   * Exit full window
   *
   * @fires Player#exitFullWindow
   */


  Player.prototype.exitFullWindow = function exitFullWindow() {
    this.isFullWindow = false;
    off(document, 'keydown', this.fullWindowOnEscKey);

    // Unhide scroll bars.
    document.documentElement.style.overflow = this.docOrigOverflow;

    // Remove fullscreen styles
    removeClass(document.body, 'vjs-full-window');

    // Resize the box, controller, and poster to original sizes
    // this.positionAll();
    /**
     * @event Player#exitFullWindow
     * @type {EventTarget~Event}
     */
    this.trigger('exitFullWindow');
  };

  /**
   * Check whether the player can play a given mimetype
   *
   * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype
   *
   * @param {string} type
   *        The mimetype to check
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */


  Player.prototype.canPlayType = function canPlayType(type) {
    var can = void 0;

    // Loop through each playback technology in the options order
    for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {
      var techName = j[i];
      var tech = Tech.getTech(techName);

      // Support old behavior of techs being registered as components.
      // Remove once that deprecated behavior is removed.
      if (!tech) {
        tech = Component.getComponent(techName);
      }

      // Check if the current tech is defined before continuing
      if (!tech) {
        log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
        continue;
      }

      // Check if the browser supports this technology
      if (tech.isSupported()) {
        can = tech.canPlayType(type);

        if (can) {
          return can;
        }
      }
    }

    return '';
  };

  /**
   * Select source based on tech-order or source-order
   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,
   * defaults to tech-order selection
   *
   * @param {Array} sources
   *        The sources for a media asset
   *
   * @return {Object|boolean}
   *         Object of source and tech order or false
   */


  Player.prototype.selectSource = function selectSource(sources) {
    var _this5 = this;

    // Get only the techs specified in `techOrder` that exist and are supported by the
    // current platform
    var techs = this.options_.techOrder.map(function (techName) {
      return [techName, Tech.getTech(techName)];
    }).filter(function (_ref) {
      var techName = _ref[0],
          tech = _ref[1];

      // Check if the current tech is defined before continuing
      if (tech) {
        // Check if the browser supports this technology
        return tech.isSupported();
      }

      log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
      return false;
    });

    // Iterate over each `innerArray` element once per `outerArray` element and execute
    // `tester` with both. If `tester` returns a non-falsy value, exit early and return
    // that value.
    var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair(outerArray, innerArray, tester) {
      var found = void 0;

      outerArray.some(function (outerChoice) {
        return innerArray.some(function (innerChoice) {
          found = tester(outerChoice, innerChoice);

          if (found) {
            return true;
          }
        });
      });

      return found;
    };

    var foundSourceAndTech = void 0;
    var flip = function flip(fn) {
      return function (a, b) {
        return fn(b, a);
      };
    };
    var finder = function finder(_ref2, source) {
      var techName = _ref2[0],
          tech = _ref2[1];

      if (tech.canPlaySource(source, _this5.options_[techName.toLowerCase()])) {
        return { source: source, tech: techName };
      }
    };

    // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources
    // to select from them based on their priority.
    if (this.options_.sourceOrder) {
      // Source-first ordering
      foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));
    } else {
      // Tech-first ordering
      foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
    }

    return foundSourceAndTech || false;
  };

  /**
   * Get or set the video source.
   *
   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]
   *        A SourceObject, an array of SourceObjects, or a string referencing
   *        a URL to a media source. It is _highly recommended_ that an object
   *        or array of objects is used here, so that source selection
   *        algorithms can take the `type` into account.
   *
   *        If not provided, this method acts as a getter.
   *
   * @return {string|undefined}
   *         If the `source` argument is missing, returns the current source
   *         URL. Otherwise, returns nothing/undefined.
   */


  Player.prototype.src = function src(source) {
    var _this6 = this;

    // getter usage
    if (typeof source === 'undefined') {
      return this.cache_.src;
    }
    // filter out invalid sources and turn our source into
    // an array of source objects
    var sources = filterSource(source);

    // if a source was passed in then it is invalid because
    // it was filtered to a zero length Array. So we have to
    // show an error
    if (!sources.length) {
      this.setTimeout(function () {
        this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });
      }, 0);
      return;
    }

    // intial sources
    this.cache_.sources = sources;
    this.changingSrc_ = true;

    // intial source
    this.cache_.source = sources[0];

    // middlewareSource is the source after it has been changed by middleware
    setSource(this, sources[0], function (middlewareSource, mws) {
      _this6.middleware_ = mws;

      var err = _this6.src_(middlewareSource);

      if (err) {
        if (sources.length > 1) {
          return _this6.src(sources.slice(1));
        }

        // We need to wrap this in a timeout to give folks a chance to add error event handlers
        _this6.setTimeout(function () {
          this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });
        }, 0);

        // we could not find an appropriate tech, but let's still notify the delegate that this is it
        // this needs a better comment about why this is needed
        _this6.triggerReady();

        return;
      }

      _this6.changingSrc_ = false;
      // video element listed source
      _this6.cache_.src = middlewareSource.src;

      setTech(mws, _this6.tech_);
    });
  };

  /**
   * Set the source object on the tech, returns a boolean that indicates wether
   * there is a tech that can play the source or not
   *
   * @param {Tech~SourceObject} source
   *        The source object to set on the Tech
   *
   * @return {Boolean}
   *         - True if there is no Tech to playback this source
   *         - False otherwise
   *
   * @private
   */


  Player.prototype.src_ = function src_(source) {
    var sourceTech = this.selectSource([source]);

    if (!sourceTech) {
      return true;
    }

    if (!titleCaseEquals(sourceTech.tech, this.techName_)) {
      this.changingSrc_ = true;

      // load this technology with the chosen source
      this.loadTech_(sourceTech.tech, sourceTech.source);
      return false;
    }

    // wait until the tech is ready to set the source
    this.ready(function () {

      // The setSource tech method was added with source handlers
      // so older techs won't support it
      // We need to check the direct prototype for the case where subclasses
      // of the tech do not support source handlers
      if (this.tech_.constructor.prototype.hasOwnProperty('setSource')) {
        this.techCall_('setSource', source);
      } else {
        this.techCall_('src', source.src);
      }

      if (this.options_.preload === 'auto') {
        this.load();
      }

      if (this.options_.autoplay) {
        this.play();
      }

      // Set the source synchronously if possible (#2326)
    }, true);

    return false;
  };

  /**
   * Begin loading the src data.
   */


  Player.prototype.load = function load() {
    this.techCall_('load');
  };

  /**
   * Reset the player. Loads the first tech in the techOrder,
   * and calls `reset` on the tech`.
   */


  Player.prototype.reset = function reset() {
    this.loadTech_(this.options_.techOrder[0], null);
    this.techCall_('reset');
  };

  /**
   * Returns all of the current source objects.
   *
   * @return {Tech~SourceObject[]}
   *         The current source objects
   */


  Player.prototype.currentSources = function currentSources() {
    var source = this.currentSource();
    var sources = [];

    // assume `{}` or `{ src }`
    if (Object.keys(source).length !== 0) {
      sources.push(source);
    }

    return this.cache_.sources || sources;
  };

  /**
   * Returns the current source object.
   *
   * @return {Tech~SourceObject}
   *         The current source object
   */


  Player.prototype.currentSource = function currentSource() {
    return this.cache_.source || {};
  };

  /**
   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
   * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.
   *
   * @return {string}
   *         The current source
   */


  Player.prototype.currentSrc = function currentSrc() {
    return this.currentSource() && this.currentSource().src || '';
  };

  /**
   * Get the current source type e.g. video/mp4
   * This can allow you rebuild the current source object so that you could load the same
   * source and tech later
   *
   * @return {string}
   *         The source MIME type
   */


  Player.prototype.currentType = function currentType() {
    return this.currentSource() && this.currentSource().type || '';
  };

  /**
   * Get or set the preload attribute
   *
   * @param {boolean} [value]
   *        - true means that we should preload
   *        - false maens that we should not preload
   *
   * @return {string}
   *         The preload attribute value when getting
   */


  Player.prototype.preload = function preload(value) {
    if (value !== undefined) {
      this.techCall_('setPreload', value);
      this.options_.preload = value;
      return;
    }
    return this.techGet_('preload');
  };

  /**
   * Get or set the autoplay attribute.
   *
   * @param {boolean} [value]
   *        - true means that we should autoplay
   *        - false means that we should not autoplay
   *
   * @return {string}
   *         The current value of autoplay when getting
   */


  Player.prototype.autoplay = function autoplay(value) {
    if (value !== undefined) {
      this.techCall_('setAutoplay', value);
      this.options_.autoplay = value;
      return;
    }
    return this.techGet_('autoplay', value);
  };

  /**
   * Set or unset the playsinline attribute.
   * Playsinline tells the browser that non-fullscreen playback is preferred.
   *
   * @param {boolean} [value]
   *        - true means that we should try to play inline by default
   *        - false means that we should use the browser's default playback mode,
   *          which in most cases is inline. iOS Safari is a notable exception
   *          and plays fullscreen by default.
   *
   * @return {string|Player}
   *         - the current value of playsinline
   *         - the player when setting
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */


  Player.prototype.playsinline = function playsinline(value) {
    if (value !== undefined) {
      this.techCall_('setPlaysinline', value);
      this.options_.playsinline = value;
      return this;
    }
    return this.techGet_('playsinline');
  };

  /**
   * Get or set the loop attribute on the video element.
   *
   * @param {boolean} [value]
   *        - true means that we should loop the video
   *        - false means that we should not loop the video
   *
   * @return {string}
   *         The current value of loop when getting
   */


  Player.prototype.loop = function loop(value) {
    if (value !== undefined) {
      this.techCall_('setLoop', value);
      this.options_.loop = value;
      return;
    }
    return this.techGet_('loop');
  };

  /**
   * Get or set the poster image source url
   *
   * @fires Player#posterchange
   *
   * @param {string} [src]
   *        Poster image source URL
   *
   * @return {string}
   *         The current value of poster when getting
   */


  Player.prototype.poster = function poster(src) {
    if (src === undefined) {
      return this.poster_;
    }

    // The correct way to remove a poster is to set as an empty string
    // other falsey values will throw errors
    if (!src) {
      src = '';
    }

    // update the internal poster variable
    this.poster_ = src;

    // update the tech's poster
    this.techCall_('setPoster', src);

    // alert components that the poster has been set
    /**
     * This event fires when the poster image is changed on the player.
     *
     * @event Player#posterchange
     * @type {EventTarget~Event}
     */
    this.trigger('posterchange');
  };

  /**
   * Some techs (e.g. YouTube) can provide a poster source in an
   * asynchronous way. We want the poster component to use this
   * poster source so that it covers up the tech's controls.
   * (YouTube's play button). However we only want to use this
   * source if the player user hasn't set a poster through
   * the normal APIs.
   *
   * @fires Player#posterchange
   * @listens Tech#posterchange
   * @private
   */


  Player.prototype.handleTechPosterChange_ = function handleTechPosterChange_() {
    if (!this.poster_ && this.tech_ && this.tech_.poster) {
      this.poster_ = this.tech_.poster() || '';

      // Let components know the poster has changed
      this.trigger('posterchange');
    }
  };

  /**
   * Get or set whether or not the controls are showing.
   *
   * @fires Player#controlsenabled
   *
   * @param {boolean} [bool]
   *        - true to turn controls on
   *        - false to turn controls off
   *
   * @return {boolean}
   *         The current value of controls when getting
   */


  Player.prototype.controls = function controls(bool) {
    if (bool !== undefined) {
      bool = !!bool;

      // Don't trigger a change event unless it actually changed
      if (this.controls_ !== bool) {
        this.controls_ = bool;

        if (this.usingNativeControls()) {
          this.techCall_('setControls', bool);
        }

        if (bool) {
          this.removeClass('vjs-controls-disabled');
          this.addClass('vjs-controls-enabled');
          /**
           * @event Player#controlsenabled
           * @type {EventTarget~Event}
           */
          this.trigger('controlsenabled');

          if (!this.usingNativeControls()) {
            this.addTechControlsListeners_();
          }
        } else {
          this.removeClass('vjs-controls-enabled');
          this.addClass('vjs-controls-disabled');
          /**
           * @event Player#controlsdisabled
           * @type {EventTarget~Event}
           */
          this.trigger('controlsdisabled');

          if (!this.usingNativeControls()) {
            this.removeTechControlsListeners_();
          }
        }
      }
      return;
    }
    return !!this.controls_;
  };

  /**
   * Toggle native controls on/off. Native controls are the controls built into
   * devices (e.g. default iPhone controls), Flash, or other techs
   * (e.g. Vimeo Controls)
   * **This should only be set by the current tech, because only the tech knows
   * if it can support native controls**
   *
   * @fires Player#usingnativecontrols
   * @fires Player#usingcustomcontrols
   *
   * @param {boolean} [bool]
   *        - true to turn native controls on
   *        - false to turn native controls off
   *
   * @return {boolean}
   *         The current value of native controls when getting
   */


  Player.prototype.usingNativeControls = function usingNativeControls(bool) {
    if (bool !== undefined) {
      bool = !!bool;

      // Don't trigger a change event unless it actually changed
      if (this.usingNativeControls_ !== bool) {
        this.usingNativeControls_ = bool;
        if (bool) {
          this.addClass('vjs-using-native-controls');

          /**
           * player is using the native device controls
           *
           * @event Player#usingnativecontrols
           * @type {EventTarget~Event}
           */
          this.trigger('usingnativecontrols');
        } else {
          this.removeClass('vjs-using-native-controls');

          /**
           * player is using the custom HTML controls
           *
           * @event Player#usingcustomcontrols
           * @type {EventTarget~Event}
           */
          this.trigger('usingcustomcontrols');
        }
      }
      return;
    }
    return !!this.usingNativeControls_;
  };

  /**
   * Set or get the current MediaError
   *
   * @fires Player#error
   *
   * @param  {MediaError|string|number} [err]
   *         A MediaError or a string/number to be turned
   *         into a MediaError
   *
   * @return {MediaError|null}
   *         The current MediaError when getting (or null)
   */


  Player.prototype.error = function error(err) {
    if (err === undefined) {
      return this.error_ || null;
    }

    // restoring to default
    if (err === null) {
      this.error_ = err;
      this.removeClass('vjs-error');
      if (this.errorDisplay) {
        this.errorDisplay.close();
      }
      return;
    }

    this.error_ = new MediaError(err);

    // add the vjs-error classname to the player
    this.addClass('vjs-error');

    // log the name of the error type and any message
    // ie8 just logs "[object object]" if you just log the error object
    log$1.error('(CODE:' + this.error_.code + ' ' + MediaError.errorTypes[this.error_.code] + ')', this.error_.message, this.error_);

    /**
     * @event Player#error
     * @type {EventTarget~Event}
     */
    this.trigger('error');

    return;
  };

  /**
   * Report user activity
   *
   * @param {Object} event
   *        Event object
   */


  Player.prototype.reportUserActivity = function reportUserActivity(event) {
    this.userActivity_ = true;
  };

  /**
   * Get/set if user is active
   *
   * @fires Player#useractive
   * @fires Player#userinactive
   *
   * @param {boolean} [bool]
   *        - true if the user is active
   *        - false if the user is inactive
   *
   * @return {boolean}
   *         The current value of userActive when getting
   */


  Player.prototype.userActive = function userActive(bool) {
    if (bool !== undefined) {
      bool = !!bool;
      if (bool !== this.userActive_) {
        this.userActive_ = bool;
        if (bool) {
          // If the user was inactive and is now active we want to reset the
          // inactivity timer
          this.userActivity_ = true;
          this.removeClass('vjs-user-inactive');
          this.addClass('vjs-user-active');
          /**
           * @event Player#useractive
           * @type {EventTarget~Event}
           */
          this.trigger('useractive');
        } else {
          // We're switching the state to inactive manually, so erase any other
          // activity
          this.userActivity_ = false;

          // Chrome/Safari/IE have bugs where when you change the cursor it can
          // trigger a mousemove event. This causes an issue when you're hiding
          // the cursor when the user is inactive, and a mousemove signals user
          // activity. Making it impossible to go into inactive mode. Specifically
          // this happens in fullscreen when we really need to hide the cursor.
          //
          // When this gets resolved in ALL browsers it can be removed
          // https://code.google.com/p/chromium/issues/detail?id=103041
          if (this.tech_) {
            this.tech_.one('mousemove', function (e) {
              e.stopPropagation();
              e.preventDefault();
            });
          }

          this.removeClass('vjs-user-active');
          this.addClass('vjs-user-inactive');
          /**
           * @event Player#userinactive
           * @type {EventTarget~Event}
           */
          this.trigger('userinactive');
        }
      }
      return;
    }
    return this.userActive_;
  };

  /**
   * Listen for user activity based on timeout value
   *
   * @private
   */


  Player.prototype.listenForUserActivity_ = function listenForUserActivity_() {
    var mouseInProgress = void 0;
    var lastMoveX = void 0;
    var lastMoveY = void 0;
    var handleActivity = bind(this, this.reportUserActivity);

    var handleMouseMove = function handleMouseMove(e) {
      // #1068 - Prevent mousemove spamming
      // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970
      if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
        lastMoveX = e.screenX;
        lastMoveY = e.screenY;
        handleActivity();
      }
    };

    var handleMouseDown = function handleMouseDown() {
      handleActivity();
      // For as long as the they are touching the device or have their mouse down,
      // we consider them active even if they're not moving their finger or mouse.
      // So we want to continue to update that they are active
      this.clearInterval(mouseInProgress);
      // Setting userActivity=true now and setting the interval to the same time
      // as the activityCheck interval (250) should ensure we never miss the
      // next activityCheck
      mouseInProgress = this.setInterval(handleActivity, 250);
    };

    var handleMouseUp = function handleMouseUp(event) {
      handleActivity();
      // Stop the interval that maintains activity if the mouse/touch is down
      this.clearInterval(mouseInProgress);
    };

    // Any mouse movement will be considered user activity
    this.on('mousedown', handleMouseDown);
    this.on('mousemove', handleMouseMove);
    this.on('mouseup', handleMouseUp);

    // Listen for keyboard navigation
    // Shouldn't need to use inProgress interval because of key repeat
    this.on('keydown', handleActivity);
    this.on('keyup', handleActivity);

    // Run an interval every 250 milliseconds instead of stuffing everything into
    // the mousemove/touchmove function itself, to prevent performance degradation.
    // `this.reportUserActivity` simply sets this.userActivity_ to true, which
    // then gets picked up by this loop
    // http://ejohn.org/blog/learning-from-twitter/
    var inactivityTimeout = void 0;

    this.setInterval(function () {
      // Check to see if mouse/touch activity has happened
      if (this.userActivity_) {
        // Reset the activity tracker
        this.userActivity_ = false;

        // If the user state was inactive, set the state to active
        this.userActive(true);

        // Clear any existing inactivity timeout to start the timer over
        this.clearTimeout(inactivityTimeout);

        var timeout = this.options_.inactivityTimeout;

        if (timeout > 0) {
          // In <timeout> milliseconds, if no more activity has occurred the
          // user will be considered inactive
          inactivityTimeout = this.setTimeout(function () {
            // Protect against the case where the inactivityTimeout can trigger just
            // before the next user activity is picked up by the activity check loop
            // causing a flicker
            if (!this.userActivity_) {
              this.userActive(false);
            }
          }, timeout);
        }
      }
    }, 250);
  };

  /**
   * Gets or sets the current playback rate. A playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed
   * playback, for instance.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate
   *
   * @param {number} [rate]
   *       New playback rate to set.
   *
   * @return {number}
   *         The current playback rate when getting or 1.0
   */


  Player.prototype.playbackRate = function playbackRate(rate) {
    if (rate !== undefined) {
      this.techCall_('setPlaybackRate', rate);
      return;
    }

    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.techGet_('playbackRate');
    }
    return 1.0;
  };

  /**
   * Gets or sets the current default playback rate. A default playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.
   * defaultPlaybackRate will only represent what the intial playbackRate of a video was, not
   * not the current playbackRate.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate
   *
   * @param {number} [rate]
   *       New default playback rate to set.
   *
   * @return {number|Player}
   *         - The default playback rate when getting or 1.0
   *         - the player when setting
   */


  Player.prototype.defaultPlaybackRate = function defaultPlaybackRate(rate) {
    if (rate !== undefined) {
      return this.techCall_('setDefaultPlaybackRate', rate);
    }

    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.techGet_('defaultPlaybackRate');
    }
    return 1.0;
  };

  /**
   * Gets or sets the audio flag
   *
   * @param {boolean} bool
   *        - true signals that this is an audio player
   *        - false signals that this is not an audio player
   *
   * @return {boolean}
   *         The current value of isAudio when getting
   */


  Player.prototype.isAudio = function isAudio(bool) {
    if (bool !== undefined) {
      this.isAudio_ = !!bool;
      return;
    }

    return !!this.isAudio_;
  };

  /**
   * A helper method for adding a {@link TextTrack} to our
   * {@link TextTrackList}.
   *
   * In addition to the W3C settings we allow adding additional info through options.
   *
   * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
   *
   * @param {string} [kind]
   *        the kind of TextTrack you are adding
   *
   * @param {string} [label]
   *        the label to give the TextTrack label
   *
   * @param {string} [language]
   *        the language to set on the TextTrack
   *
   * @return {TextTrack|undefined}
   *         the TextTrack that was added or undefined
   *         if there is no tech
   */


  Player.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (this.tech_) {
      return this.tech_.addTextTrack(kind, label, language);
    }
  };

  /**
   * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}. It will
   * automatically removed from the video element whenever the source changes, unless
   * manualCleanup is set to false.
   *
   * @param {Object} options
   *        Options to pass to {@link HTMLTrackElement} during creation. See
   *        {@link HTMLTrackElement} for object properties that you should use.
   *
   * @param {boolean} [manualCleanup=true] if set to false, the TextTrack will be
   *
   * @return {HtmlTrackElement}
   *         the HTMLTrackElement that was created and added
   *         to the HtmlTrackElementList and the remote
   *         TextTrackList
   *
   * @deprecated The default value of the "manualCleanup" parameter will default
   *             to "false" in upcoming versions of Video.js
   */


  Player.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    if (this.tech_) {
      return this.tech_.addRemoteTextTrack(options, manualCleanup);
    }
  };

  /**
   * Remove a remote {@link TextTrack} from the respective
   * {@link TextTrackList} and {@link HtmlTrackElementList}.
   *
   * @param {Object} track
   *        Remote {@link TextTrack} to remove
   *
   * @return {undefined}
   *         does not return anything
   */


  Player.prototype.removeRemoteTextTrack = function removeRemoteTextTrack() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$track = _ref3.track,
        track = _ref3$track === undefined ? arguments[0] : _ref3$track;

    // destructure the input into an object with a track argument, defaulting to arguments[0]
    // default the whole argument to an empty object if nothing was passed in

    if (this.tech_) {
      return this.tech_.removeRemoteTextTrack(track);
    }
  };

  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object|undefined}
   *         An object with supported media playback quality metrics or undefined if there
   *         is no tech or the tech does not support it.
   */


  Player.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    return this.techGet_('getVideoPlaybackQuality');
  };

  /**
   * Get video width
   *
   * @return {number}
   *         current video width
   */


  Player.prototype.videoWidth = function videoWidth() {
    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
  };

  /**
   * Get video height
   *
   * @return {number}
   *         current video height
   */


  Player.prototype.videoHeight = function videoHeight() {
    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
  };

  /**
   * The player's language code
   * NOTE: The language should be set in the player options if you want the
   * the controls to be built with a specific language. Changing the lanugage
   * later will not update controls text.
   *
   * @param {string} [code]
   *        the language code to set the player to
   *
   * @return {string}
   *         The current language code when getting
   */


  Player.prototype.language = function language(code) {
    if (code === undefined) {
      return this.language_;
    }

    this.language_ = String(code).toLowerCase();
  };

  /**
   * Get the player's language dictionary
   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time
   * Languages specified directly in the player options have precedence
   *
   * @return {Array}
   *         An array of of supported languages
   */


  Player.prototype.languages = function languages() {
    return mergeOptions(Player.prototype.options_.languages, this.languages_);
  };

  /**
   * returns a JavaScript object reperesenting the current track
   * information. **DOES not return it as JSON**
   *
   * @return {Object}
   *         Object representing the current of track info
   */


  Player.prototype.toJSON = function toJSON() {
    var options = mergeOptions(this.options_);
    var tracks = options.tracks;

    options.tracks = [];

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      // deep merge tracks and null out player so no circular references
      track = mergeOptions(track);
      track.player = undefined;
      options.tracks[i] = track;
    }

    return options;
  };

  /**
   * Creates a simple modal dialog (an instance of the {@link ModalDialog}
   * component) that immediately overlays the player with arbitrary
   * content and removes itself when closed.
   *
   * @param {string|Function|Element|Array|null} content
   *        Same as {@link ModalDialog#content}'s param of the same name.
   *        The most straight-forward usage is to provide a string or DOM
   *        element.
   *
   * @param {Object} [options]
   *        Extra options which will be passed on to the {@link ModalDialog}.
   *
   * @return {ModalDialog}
   *         the {@link ModalDialog} that was created
   */


  Player.prototype.createModal = function createModal(content, options) {
    var _this7 = this;

    options = options || {};
    options.content = content || '';

    var modal = new ModalDialog(this, options);

    this.addChild(modal);
    modal.on('dispose', function () {
      _this7.removeChild(modal);
    });

    modal.open();
    return modal;
  };

  /**
   * Gets tag settings
   *
   * @param {Element} tag
   *        The player tag
   *
   * @return {Object}
   *         An object containing all of the settings
   *         for a player tag
   */


  Player.getTagSettings = function getTagSettings(tag) {
    var baseOptions = {
      sources: [],
      tracks: []
    };

    var tagOptions = getAttributes(tag);
    var dataSetup = tagOptions['data-setup'];

    if (hasClass(tag, 'vjs-fluid')) {
      tagOptions.fluid = true;
    }

    // Check if data-setup attr exists.
    if (dataSetup !== null) {
      // Parse options JSON
      // If empty string, make it a parsable json object.
      var _safeParseTuple = safeParseTuple(dataSetup || '{}'),
          err = _safeParseTuple[0],
          data = _safeParseTuple[1];

      if (err) {
        log$1.error(err);
      }
      assign(tagOptions, data);
    }

    assign(baseOptions, tagOptions);

    // Get tag children settings
    if (tag.hasChildNodes()) {
      var children = tag.childNodes;

      for (var i = 0, j = children.length; i < j; i++) {
        var child = children[i];
        // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/
        var childName = child.nodeName.toLowerCase();

        if (childName === 'source') {
          baseOptions.sources.push(getAttributes(child));
        } else if (childName === 'track') {
          baseOptions.tracks.push(getAttributes(child));
        }
      }
    }

    return baseOptions;
  };

  /**
   * Determine wether or not flexbox is supported
   *
   * @return {boolean}
   *         - true if flexbox is supported
   *         - false if flexbox is not supported
   */


  Player.prototype.flexNotSupported_ = function flexNotSupported_() {
    var elem = document.createElement('i');

    // Note: We don't actually use flexBasis (or flexOrder), but it's one of the more
    // common flex features that we can rely on when checking for flex support.
    return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style ||
    // IE10-specific (2012 flex spec)
    'msFlexOrder' in elem.style);
  };

  return Player;
}(Component);

/**
 * Get the {@link VideoTrackList}
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist
 *
 * @return {VideoTrackList}
 *         the current video track list
 *
 * @method Player.prototype.videoTracks
 */

/**
 * Get the {@link AudioTrackList}
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist
 *
 * @return {AudioTrackList}
 *         the current audio track list
 *
 * @method Player.prototype.audioTracks
 */

/**
 * Get the {@link TextTrackList}
 *
 * @link http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks
 *
 * @return {TextTrackList}
 *         the current text track list
 *
 * @method Player.prototype.textTracks
 */

/**
 * Get the remote {@link TextTrackList}
 *
 * @return {TextTrackList}
 *         The current remote text track list
 *
 * @method Player.prototype.remoteTextTracks
 */

/**
 * Get the remote {@link HtmlTrackElementList} tracks.
 *
 * @return {HtmlTrackElementList}
 *         The current remote text track element list
 *
 * @method Player.prototype.remoteTextTrackEls
 */

ALL.names.forEach(function (name$$1) {
  var props = ALL[name$$1];

  Player.prototype[props.getterName] = function () {
    if (this.tech_) {
      return this.tech_[props.getterName]();
    }

    // if we have not yet loadTech_, we create {video,audio,text}Tracks_
    // these will be passed to the tech during loading
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});

/**
 * Global player list
 *
 * @type {Object}
 */
Player.players = {};

var navigator = window.navigator;

/*
 * Player instance options, surfaced using options
 * options = Player.prototype.options_
 * Make changes in options, not here.
 *
 * @type {Object}
 * @private
 */
Player.prototype.options_ = {
  // Default order of fallback technology
  techOrder: Tech.defaultTechOrder_,

  html5: {},
  flash: {},

  // default inactivity timeout
  inactivityTimeout: 2000,

  // default playback rates
  playbackRates: [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],

  // Included control sets
  children: ['mediaLoader', 'posterImage', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'controlBar', 'errorDisplay', 'textTrackSettings'],

  language: navigator && (navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language) || 'en',

  // locales and their language translations
  languages: {},

  // Default message to show when a video cannot be played.
  notSupportedMessage: 'No compatible source was found for this media.'
};

[
/**
 * Returns whether or not the player is in the "ended" state.
 *
 * @return {Boolean} True if the player is in the ended state, false if not.
 * @method Player#ended
 */
'ended',
/**
 * Returns whether or not the player is in the "seeking" state.
 *
 * @return {Boolean} True if the player is in the seeking state, false if not.
 * @method Player#seeking
 */
'seeking',
/**
 * Returns the TimeRanges of the media that are currently available
 * for seeking to.
 *
 * @return {TimeRanges} the seekable intervals of the media timeline
 * @method Player#seekable
 */
'seekable',
/**
 * Returns the current state of network activity for the element, from
 * the codes in the list below.
 * - NETWORK_EMPTY (numeric value 0)
 *   The element has not yet been initialised. All attributes are in
 *   their initial states.
 * - NETWORK_IDLE (numeric value 1)
 *   The element's resource selection algorithm is active and has
 *   selected a resource, but it is not actually using the network at
 *   this time.
 * - NETWORK_LOADING (numeric value 2)
 *   The user agent is actively trying to download data.
 * - NETWORK_NO_SOURCE (numeric value 3)
 *   The element's resource selection algorithm is active, but it has
 *   not yet found a resource to use.
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
 * @return {number} the current network activity state
 * @method Player#networkState
 */
'networkState',
/**
 * Returns a value that expresses the current state of the element
 * with respect to rendering the current playback position, from the
 * codes in the list below.
 * - HAVE_NOTHING (numeric value 0)
 *   No information regarding the media resource is available.
 * - HAVE_METADATA (numeric value 1)
 *   Enough of the resource has been obtained that the duration of the
 *   resource is available.
 * - HAVE_CURRENT_DATA (numeric value 2)
 *   Data for the immediate current playback position is available.
 * - HAVE_FUTURE_DATA (numeric value 3)
 *   Data for the immediate current playback position is available, as
 *   well as enough data for the user agent to advance the current
 *   playback position in the direction of playback.
 * - HAVE_ENOUGH_DATA (numeric value 4)
 *   The user agent estimates that enough data is available for
 *   playback to proceed uninterrupted.
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
 * @return {number} the current playback rendering state
 * @method Player#readyState
 */
'readyState'].forEach(function (fn) {
  Player.prototype[fn] = function () {
    return this.techGet_(fn);
  };
});

TECH_EVENTS_RETRIGGER.forEach(function (event) {
  Player.prototype['handleTech' + toTitleCase(event) + '_'] = function () {
    return this.trigger(event);
  };
});

/**
 * Fired when the player has initial duration and dimension information
 *
 * @event Player#loadedmetadata
 * @type {EventTarget~Event}
 */

/**
 * Fired when the player has downloaded data at the current playback position
 *
 * @event Player#loadeddata
 * @type {EventTarget~Event}
 */

/**
 * Fired when the current playback position has changed *
 * During playback this is fired every 15-250 milliseconds, depending on the
 * playback technology in use.
 *
 * @event Player#timeupdate
 * @type {EventTarget~Event}
 */

/**
 * Fired when the volume changes
 *
 * @event Player#volumechange
 * @type {EventTarget~Event}
 */

/**
 * Reports whether or not a player has a plugin available.
 *
 * This does not report whether or not the plugin has ever been initialized
 * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.
 *
 * @method Player#hasPlugin
 * @param  {string}  name
 *         The name of a plugin.
 *
 * @return {boolean}
 *         Whether or not this player has the requested plugin available.
 */

/**
 * Reports whether or not a player is using a plugin by name.
 *
 * For basic plugins, this only reports whether the plugin has _ever_ been
 * initialized on this player.
 *
 * @method Player#usingPlugin
 * @param  {string} name
 *         The name of a plugin.
 *
 * @return {boolean}
 *         Whether or not this player is using the requested plugin.
 */

Component.registerComponent('Player', Player);

/**
 * @file plugin.js
 */
/**
 * The base plugin name.
 *
 * @private
 * @constant
 * @type {string}
 */
var BASE_PLUGIN_NAME = 'plugin';

/**
 * The key on which a player's active plugins cache is stored.
 *
 * @private
 * @constant
 * @type     {string}
 */
var PLUGIN_CACHE_KEY = 'activePlugins_';

/**
 * Stores registered plugins in a private space.
 *
 * @private
 * @type    {Object}
 */
var pluginStorage = {};

/**
 * Reports whether or not a plugin has been registered.
 *
 * @private
 * @param   {string} name
 *          The name of a plugin.
 *
 * @returns {boolean}
 *          Whether or not the plugin has been registered.
 */
var pluginExists = function pluginExists(name) {
  return pluginStorage.hasOwnProperty(name);
};

/**
 * Get a single registered plugin by name.
 *
 * @private
 * @param   {string} name
 *          The name of a plugin.
 *
 * @returns {Function|undefined}
 *          The plugin (or undefined).
 */
var getPlugin = function getPlugin(name) {
  return pluginExists(name) ? pluginStorage[name] : undefined;
};

/**
 * Marks a plugin as "active" on a player.
 *
 * Also, ensures that the player has an object for tracking active plugins.
 *
 * @private
 * @param   {Player} player
 *          A Video.js player instance.
 *
 * @param   {string} name
 *          The name of a plugin.
 */
var markPluginAsActive = function markPluginAsActive(player, name) {
  player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};
  player[PLUGIN_CACHE_KEY][name] = true;
};

/**
 * Triggers a pair of plugin setup events.
 *
 * @private
 * @param  {Player} player
 *         A Video.js player instance.
 *
 * @param  {Plugin~PluginEventHash} hash
 *         A plugin event hash.
 *
 * @param  {Boolean} [before]
 *         If true, prefixes the event name with "before". In other words,
 *         use this to trigger "beforepluginsetup" instead of "pluginsetup".
 */
var triggerSetupEvent = function triggerSetupEvent(player, hash, before) {
  var eventName = (before ? 'before' : '') + 'pluginsetup';

  player.trigger(eventName, hash);
  player.trigger(eventName + ':' + hash.name, hash);
};

/**
 * Takes a basic plugin function and returns a wrapper function which marks
 * on the player that the plugin has been activated.
 *
 * @private
 * @param   {string} name
 *          The name of the plugin.
 *
 * @param   {Function} plugin
 *          The basic plugin.
 *
 * @returns {Function}
 *          A wrapper function for the given plugin.
 */
var createBasicPlugin = function createBasicPlugin(name, plugin) {
  var basicPluginWrapper = function basicPluginWrapper() {

    // We trigger the "beforepluginsetup" and "pluginsetup" events on the player
    // regardless, but we want the hash to be consistent with the hash provided
    // for advanced plugins.
    //
    // The only potentially counter-intuitive thing here is the `instance` in
    // the "pluginsetup" event is the value returned by the `plugin` function.
    triggerSetupEvent(this, { name: name, plugin: plugin, instance: null }, true);

    var instance = plugin.apply(this, arguments);

    markPluginAsActive(this, name);
    triggerSetupEvent(this, { name: name, plugin: plugin, instance: instance });

    return instance;
  };

  Object.keys(plugin).forEach(function (prop) {
    basicPluginWrapper[prop] = plugin[prop];
  });

  return basicPluginWrapper;
};

/**
 * Takes a plugin sub-class and returns a factory function for generating
 * instances of it.
 *
 * This factory function will replace itself with an instance of the requested
 * sub-class of Plugin.
 *
 * @private
 * @param   {string} name
 *          The name of the plugin.
 *
 * @param   {Plugin} PluginSubClass
 *          The advanced plugin.
 *
 * @returns {Function}
 */
var createPluginFactory = function createPluginFactory(name, PluginSubClass) {

  // Add a `name` property to the plugin prototype so that each plugin can
  // refer to itself by name.
  PluginSubClass.prototype.name = name;

  return function () {
    triggerSetupEvent(this, { name: name, plugin: PluginSubClass, instance: null }, true);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var instance = new (Function.prototype.bind.apply(PluginSubClass, [null].concat([this].concat(args))))();

    // The plugin is replaced by a function that returns the current instance.
    this[name] = function () {
      return instance;
    };

    triggerSetupEvent(this, instance.getEventHash());

    return instance;
  };
};

/**
 * Parent class for all advanced plugins.
 *
 * @mixes   module:evented~EventedMixin
 * @mixes   module:stateful~StatefulMixin
 * @fires   Player#beforepluginsetup
 * @fires   Player#beforepluginsetup:$name
 * @fires   Player#pluginsetup
 * @fires   Player#pluginsetup:$name
 * @listens Player#dispose
 * @throws  {Error}
 *          If attempting to instantiate the base {@link Plugin} class
 *          directly instead of via a sub-class.
 */

var Plugin = function () {

  /**
   * Creates an instance of this class.
   *
   * Sub-classes should call `super` to ensure plugins are properly initialized.
   *
   * @param {Player} player
   *        A Video.js player instance.
   */
  function Plugin(player) {
    classCallCheck(this, Plugin);

    if (this.constructor === Plugin) {
      throw new Error('Plugin must be sub-classed; not directly instantiated.');
    }

    this.player = player;

    // Make this object evented, but remove the added `trigger` method so we
    // use the prototype version instead.
    evented(this);
    delete this.trigger;

    stateful(this, this.constructor.defaultState);
    markPluginAsActive(player, this.name);

    // Auto-bind the dispose method so we can use it as a listener and unbind
    // it later easily.
    this.dispose = bind(this, this.dispose);

    // If the player is disposed, dispose the plugin.
    player.on('dispose', this.dispose);
  }

  /**
   * Each event triggered by plugins includes a hash of additional data with
   * conventional properties.
   *
   * This returns that object or mutates an existing hash.
   *
   * @param   {Object} [hash={}]
   *          An object to be used as event an event hash.
   *
   * @returns {Plugin~PluginEventHash}
   *          An event hash object with provided properties mixed-in.
   */


  Plugin.prototype.getEventHash = function getEventHash() {
    var hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    hash.name = this.name;
    hash.plugin = this.constructor;
    hash.instance = this;
    return hash;
  };

  /**
   * Triggers an event on the plugin object and overrides
   * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash={}]
   *          Additional data hash to merge with a
   *          {@link Plugin~PluginEventHash|PluginEventHash}.
   *
   * @returns {boolean}
   *          Whether or not default was prevented.
   */


  Plugin.prototype.trigger = function trigger$$1(event) {
    var hash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return trigger(this.eventBusEl_, event, this.getEventHash(hash));
  };

  /**
   * Handles "statechanged" events on the plugin. No-op by default, override by
   * subclassing.
   *
   * @abstract
   * @param    {Event} e
   *           An event object provided by a "statechanged" event.
   *
   * @param    {Object} e.changes
   *           An object describing changes that occurred with the "statechanged"
   *           event.
   */


  Plugin.prototype.handleStateChanged = function handleStateChanged(e) {};

  /**
   * Disposes a plugin.
   *
   * Subclasses can override this if they want, but for the sake of safety,
   * it's probably best to subscribe the "dispose" event.
   *
   * @fires Plugin#dispose
   */


  Plugin.prototype.dispose = function dispose() {
    var name = this.name,
        player = this.player;

    /**
     * Signals that a advanced plugin is about to be disposed.
     *
     * @event Plugin#dispose
     * @type  {EventTarget~Event}
     */

    this.trigger('dispose');
    this.off();
    player.off('dispose', this.dispose);

    // Eliminate any possible sources of leaking memory by clearing up
    // references between the player and the plugin instance and nulling out
    // the plugin's state and replacing methods with a function that throws.
    player[PLUGIN_CACHE_KEY][name] = false;
    this.player = this.state = null;

    // Finally, replace the plugin name on the player with a new factory
    // function, so that the plugin is ready to be set up again.
    player[name] = createPluginFactory(name, pluginStorage[name]);
  };

  /**
   * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).
   *
   * @param   {string|Function} plugin
   *          If a string, matches the name of a plugin. If a function, will be
   *          tested directly.
   *
   * @returns {boolean}
   *          Whether or not a plugin is a basic plugin.
   */


  Plugin.isBasic = function isBasic(plugin) {
    var p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;

    return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);
  };

  /**
   * Register a Video.js plugin.
   *
   * @param   {string} name
   *          The name of the plugin to be registered. Must be a string and
   *          must not match an existing plugin or a method on the `Player`
   *          prototype.
   *
   * @param   {Function} plugin
   *          A sub-class of `Plugin` or a function for basic plugins.
   *
   * @returns {Function}
   *          For advanced plugins, a factory function for that plugin. For
   *          basic plugins, a wrapper function that initializes the plugin.
   */


  Plugin.registerPlugin = function registerPlugin(name, plugin) {
    if (typeof name !== 'string') {
      throw new Error('Illegal plugin name, "' + name + '", must be a string, was ' + (typeof name === 'undefined' ? 'undefined' : _typeof(name)) + '.');
    }

    if (pluginExists(name)) {
      log$1.warn('A plugin named "' + name + '" already exists. You may want to avoid re-registering plugins!');
    } else if (Player.prototype.hasOwnProperty(name)) {
      throw new Error('Illegal plugin name, "' + name + '", cannot share a name with an existing player method!');
    }

    if (typeof plugin !== 'function') {
      throw new Error('Illegal plugin for "' + name + '", must be a function, was ' + (typeof plugin === 'undefined' ? 'undefined' : _typeof(plugin)) + '.');
    }

    pluginStorage[name] = plugin;

    // Add a player prototype method for all sub-classed plugins (but not for
    // the base Plugin class).
    if (name !== BASE_PLUGIN_NAME) {
      if (Plugin.isBasic(plugin)) {
        Player.prototype[name] = createBasicPlugin(name, plugin);
      } else {
        Player.prototype[name] = createPluginFactory(name, plugin);
      }
    }

    return plugin;
  };

  /**
   * De-register a Video.js plugin.
   *
   * @param {string} name
   *        The name of the plugin to be deregistered.
   */


  Plugin.deregisterPlugin = function deregisterPlugin(name) {
    if (name === BASE_PLUGIN_NAME) {
      throw new Error('Cannot de-register base plugin.');
    }
    if (pluginExists(name)) {
      delete pluginStorage[name];
      delete Player.prototype[name];
    }
  };

  /**
   * Gets an object containing multiple Video.js plugins.
   *
   * @param   {Array} [names]
   *          If provided, should be an array of plugin names. Defaults to _all_
   *          plugin names.
   *
   * @returns {Object|undefined}
   *          An object containing plugin(s) associated with their name(s) or
   *          `undefined` if no matching plugins exist).
   */


  Plugin.getPlugins = function getPlugins() {
    var names = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.keys(pluginStorage);

    var result = void 0;

    names.forEach(function (name) {
      var plugin = getPlugin(name);

      if (plugin) {
        result = result || {};
        result[name] = plugin;
      }
    });

    return result;
  };

  /**
   * Gets a plugin's version, if available
   *
   * @param   {string} name
   *          The name of a plugin.
   *
   * @returns {string}
   *          The plugin's version or an empty string.
   */


  Plugin.getPluginVersion = function getPluginVersion(name) {
    var plugin = getPlugin(name);

    return plugin && plugin.VERSION || '';
  };

  return Plugin;
}();

/**
 * Gets a plugin by name if it exists.
 *
 * @static
 * @method   getPlugin
 * @memberOf Plugin
 * @param    {string} name
 *           The name of a plugin.
 *
 * @returns  {Function|undefined}
 *           The plugin (or `undefined`).
 */


Plugin.getPlugin = getPlugin;

/**
 * The name of the base plugin class as it is registered.
 *
 * @type {string}
 */
Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;

Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);

/**
 * Documented in player.js
 *
 * @ignore
 */
Player.prototype.usingPlugin = function (name) {
  return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;
};

/**
 * Documented in player.js
 *
 * @ignore
 */
Player.prototype.hasPlugin = function (name) {
  return !!pluginExists(name);
};

/**
 * Signals that a plugin is about to be set up on a player.
 *
 * @event    Player#beforepluginsetup
 * @type     {Plugin~PluginEventHash}
 */

/**
 * Signals that a plugin is about to be set up on a player - by name. The name
 * is the name of the plugin.
 *
 * @event    Player#beforepluginsetup:$name
 * @type     {Plugin~PluginEventHash}
 */

/**
 * Signals that a plugin has just been set up on a player.
 *
 * @event    Player#pluginsetup
 * @type     {Plugin~PluginEventHash}
 */

/**
 * Signals that a plugin has just been set up on a player - by name. The name
 * is the name of the plugin.
 *
 * @event    Player#pluginsetup:$name
 * @type     {Plugin~PluginEventHash}
 */

/**
 * @typedef  {Object} Plugin~PluginEventHash
 *
 * @property {string} instance
 *           For basic plugins, the return value of the plugin function. For
 *           advanced plugins, the plugin instance on which the event is fired.
 *
 * @property {string} name
 *           The name of the plugin.
 *
 * @property {string} plugin
 *           For basic plugins, the plugin function. For advanced plugins, the
 *           plugin class/constructor.
 */

/**
 * @file extend.js
 * @module extend
 */

/**
 * A combination of node inherits and babel's inherits (after transpile).
 * Both work the same but node adds `super_` to the subClass
 * and Bable adds the superClass as __proto__. Both seem useful.
 *
 * @param {Object} subClass
 *        The class to inherit to
 *
 * @param {Object} superClass
 *        The class to inherit from
 *
 * @private
 */
var _inherits = function _inherits(subClass, superClass) {
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (superClass) {
    // node
    subClass.super_ = superClass;
  }
};

/**
 * Function for subclassing using the same inheritance that
 * videojs uses internally
 *
 * @static
 * @const
 *
 * @param {Object} superClass
 *        The class to inherit from
 *
 * @param {Object} [subClassMethods={}]
 *        The class to inherit to
 *
 * @return {Object}
 *         The new object with subClassMethods that inherited superClass.
 */
var extendFn = function extendFn(superClass) {
  var subClassMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var subClass = function subClass() {
    superClass.apply(this, arguments);
  };

  var methods = {};

  if ((typeof subClassMethods === 'undefined' ? 'undefined' : _typeof(subClassMethods)) === 'object') {
    if (subClassMethods.constructor !== Object.prototype.constructor) {
      subClass = subClassMethods.constructor;
    }
    methods = subClassMethods;
  } else if (typeof subClassMethods === 'function') {
    subClass = subClassMethods;
  }

  _inherits(subClass, superClass);

  // Extend subObj's prototype with functions and other properties from props
  for (var name in methods) {
    if (methods.hasOwnProperty(name)) {
      subClass.prototype[name] = methods[name];
    }
  }

  return subClass;
};

/**
 * @file video.js
 * @module videojs
 */
// Include the built-in techs
// HTML5 Element Shim for IE8
if (typeof HTMLVideoElement === 'undefined' && isReal()) {
  document.createElement('video');
  document.createElement('audio');
  document.createElement('track');
}

/**
 * Doubles as the main function for users to create a player instance and also
 * the main library object.
 * The `videojs` function can be used to initialize or retrieve a player.
  *
 * @param {string|Element} id
 *        Video element or video element ID
 *
 * @param {Object} [options]
 *        Optional options object for config/settings
 *
 * @param {Component~ReadyCallback} [ready]
 *        Optional ready callback
 *
 * @return {Player}
 *         A player instance
 */
function videojs(id, options, ready) {
  var tag = void 0;

  // Allow for element or ID to be passed in
  // String ID
  if (typeof id === 'string') {
    var players = videojs.getPlayers();

    // Adjust for jQuery ID syntax
    if (id.indexOf('#') === 0) {
      id = id.slice(1);
    }

    // If a player instance has already been created for this ID return it.
    if (players[id]) {

      // If options or ready function are passed, warn
      if (options) {
        log$1.warn('Player "' + id + '" is already initialised. Options will not be applied.');
      }

      if (ready) {
        players[id].ready(ready);
      }

      return players[id];
    }

    // Otherwise get element for ID
    tag = $('#' + id);

    // ID is a media element
  } else {
    tag = id;
  }

  // Check for a useable element
  // re: nodeName, could be a box div also
  if (!tag || !tag.nodeName) {
    throw new TypeError('The element or ID supplied is not valid. (videojs)');
  }

  // Element may have a player attr referring to an already created player instance.
  // If so return that otherwise set up a new player below
  if (tag.player || Player.players[tag.playerId]) {
    return tag.player || Player.players[tag.playerId];
  }

  options = options || {};

  videojs.hooks('beforesetup').forEach(function (hookFunction) {
    var opts = hookFunction(tag, mergeOptions(options));

    if (!isObject(opts) || Array.isArray(opts)) {
      log$1.error('please return an object in beforesetup hooks');
      return;
    }

    options = mergeOptions(options, opts);
  });

  var PlayerComponent = Component.getComponent('Player');
  // If not, set up a new player
  var player = new PlayerComponent(tag, options, ready);

  videojs.hooks('setup').forEach(function (hookFunction) {
    return hookFunction(player);
  });

  return player;
}

/**
 * An Object that contains lifecycle hooks as keys which point to an array
 * of functions that are run when a lifecycle is triggered
 */
videojs.hooks_ = {};

/**
 * Get a list of hooks for a specific lifecycle
 * @function videojs.hooks
 *
 * @param {string} type
 *        the lifecyle to get hooks from
 *
 * @param {Function} [fn]
 *        Optionally add a hook to the lifecycle that your are getting.
 *
 * @return {Array}
 *         an array of hooks, or an empty array if there are none.
 */
videojs.hooks = function (type, fn) {
  videojs.hooks_[type] = videojs.hooks_[type] || [];
  if (fn) {
    videojs.hooks_[type] = videojs.hooks_[type].concat(fn);
  }
  return videojs.hooks_[type];
};

/**
 * Add a function hook to a specific videojs lifecycle.
 *
 * @param {string} type
 *        the lifecycle to hook the function to.
 *
 * @param {Function|Function[]}
 *        The function or array of functions to attach.
 */
videojs.hook = function (type, fn) {
  videojs.hooks(type, fn);
};

/**
 * Remove a hook from a specific videojs lifecycle.
 *
 * @param {string} type
 *        the lifecycle that the function hooked to
 *
 * @param {Function} fn
 *        The hooked function to remove
 *
 * @return {boolean}
 *         The function that was removed or undef
 */
videojs.removeHook = function (type, fn) {
  var index = videojs.hooks(type).indexOf(fn);

  if (index <= -1) {
    return false;
  }

  videojs.hooks_[type] = videojs.hooks_[type].slice();
  videojs.hooks_[type].splice(index, 1);

  return true;
};

// Add default styles
if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {
  var style = $('.vjs-styles-defaults');

  if (!style) {
    style = createStyleElement('vjs-styles-defaults');
    var head = $('head');

    if (head) {
      head.insertBefore(style, head.firstChild);
    }
    setTextContent(style, '\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid {\n        padding-top: 56.25%\n      }\n    ');
  }
}

// Run Auto-load players
// You have to wait at least once in case this script is loaded after your
// video in the DOM (weird behavior only with minified version)
autoSetupTimeout(1, videojs);

/**
 * Current software version. Follows semver.
 *
 * @type {string}
 */
videojs.VERSION = version;

/**
 * The global options object. These are the settings that take effect
 * if no overrides are specified when the player is created.
 *
 * @type {Object}
 */
videojs.options = Player.prototype.options_;

/**
 * Get an object with the currently created players, keyed by player ID
 *
 * @return {Object}
 *         The created players
 */
videojs.getPlayers = function () {
  return Player.players;
};

/**
 * Expose players object.
 *
 * @memberOf videojs
 * @property {Object} players
 */
videojs.players = Player.players;

/**
 * Get a component class object by name
 *
 * @borrows Component.getComponent as videojs.getComponent
 */
videojs.getComponent = Component.getComponent;

/**
 * Register a component so it can referred to by name. Used when adding to other
 * components, either through addChild `component.addChild('myComponent')` or through
 * default children options  `{ children: ['myComponent'] }`.
 *
 * > NOTE: You could also just initialize the component before adding.
 * `component.addChild(new MyComponent());`
 *
 * @param {string} name
 *        The class name of the component
 *
 * @param {Component} comp
 *        The component class
 *
 * @return {Component}
 *         The newly registered component
 */
videojs.registerComponent = function (name$$1, comp) {
  if (Tech.isTech(comp)) {
    log$1.warn('The ' + name$$1 + ' tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)');
  }

  Component.registerComponent.call(Component, name$$1, comp);
};

/**
 * Get a Tech class object by name
 *
 * @borrows Tech.getTech as videojs.getTech
 */
videojs.getTech = Tech.getTech;

/**
 * Register a Tech so it can referred to by name.
 * This is used in the tech order for the player.
 *
 * @borrows Tech.registerTech as videojs.registerTech
 */
videojs.registerTech = Tech.registerTech;

videojs.use = use;

/**
 * A suite of browser and device tests from {@link browser}.
 *
 * @type {Object}
 * @private
 */
videojs.browser = browser;

/**
 * Whether or not the browser supports touch events. Included for backward
 * compatibility with 4.x, but deprecated. Use `videojs.browser.TOUCH_ENABLED`
 * instead going forward.
 *
 * @deprecated since version 5.0
 * @type {boolean}
 */
videojs.TOUCH_ENABLED = TOUCH_ENABLED;

/**
 * Subclass an existing class
 * Mimics ES6 subclassing with the `extend` keyword
 *
 * @borrows extend:extendFn as videojs.extend
 */
videojs.extend = extendFn;

/**
 * Merge two options objects recursively
 * Performs a deep merge like lodash.merge but **only merges plain objects**
 * (not arrays, elements, anything else)
 * Other values will be copied directly from the second object.
 *
 * @borrows merge-options:mergeOptions as videojs.mergeOptions
 */
videojs.mergeOptions = mergeOptions;

/**
 * Change the context (this) of a function
 *
 * > NOTE: as of v5.0 we require an ES5 shim, so you should use the native
 * `function() {}.bind(newContext);` instead of this.
 *
 * @borrows fn:bind as videojs.bind
 */
videojs.bind = bind;

/**
 * Register a Video.js plugin.
 *
 * @borrows plugin:registerPlugin as videojs.registerPlugin
 * @method registerPlugin
 *
 * @param  {string} name
 *         The name of the plugin to be registered. Must be a string and
 *         must not match an existing plugin or a method on the `Player`
 *         prototype.
 *
 * @param  {Function} plugin
 *         A sub-class of `Plugin` or a function for basic plugins.
 *
 * @return {Function}
 *         For advanced plugins, a factory function for that plugin. For
 *         basic plugins, a wrapper function that initializes the plugin.
 */
videojs.registerPlugin = Plugin.registerPlugin;

/**
 * Deprecated method to register a plugin with Video.js
 *
 * @deprecated
 *        videojs.plugin() is deprecated; use videojs.registerPlugin() instead
 *
 * @param {string} name
 *        The plugin name
 *
 * @param {Plugin|Function} plugin
 *         The plugin sub-class or function
 */
videojs.plugin = function (name$$1, plugin) {
  log$1.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');
  return Plugin.registerPlugin(name$$1, plugin);
};

/**
 * Gets an object containing multiple Video.js plugins.
 *
 * @param  {Array} [names]
 *         If provided, should be an array of plugin names. Defaults to _all_
 *         plugin names.
 *
 * @return {Object|undefined}
 *         An object containing plugin(s) associated with their name(s) or
 *         `undefined` if no matching plugins exist).
 */
videojs.getPlugins = Plugin.getPlugins;

/**
 * Gets a plugin by name if it exists.
 *
 * @param  {string} name
 *         The name of a plugin.
 *
 * @return {Function|undefined}
 *         The plugin (or `undefined`).
 */
videojs.getPlugin = Plugin.getPlugin;

/**
 * Gets a plugin's version, if available
 *
 * @param  {string} name
 *         The name of a plugin.
 *
 * @return {string}
 *         The plugin's version or an empty string.
 */
videojs.getPluginVersion = Plugin.getPluginVersion;

/**
 * Adding languages so that they're available to all players.
 * Example: `videojs.addLanguage('es', { 'Hello': 'Hola' });`
 *
 * @param {string} code
 *        The language code or dictionary property
 *
 * @param {Object} data
 *        The data values to be translated
 *
 * @return {Object}
 *         The resulting language dictionary object
 */
videojs.addLanguage = function (code, data) {
  var _mergeOptions;

  code = ('' + code).toLowerCase();

  videojs.options.languages = mergeOptions(videojs.options.languages, (_mergeOptions = {}, _mergeOptions[code] = data, _mergeOptions));

  return videojs.options.languages[code];
};

/**
 * Log messages
 *
 * @borrows log:log as videojs.log
 */
videojs.log = log$1;

/**
 * Creates an emulated TimeRange object.
 *
 * @borrows time-ranges:createTimeRanges as videojs.createTimeRange
 */
/**
 * @borrows time-ranges:createTimeRanges as videojs.createTimeRanges
 */
videojs.createTimeRange = videojs.createTimeRanges = createTimeRanges;

/**
 * Format seconds as a time string, H:MM:SS or M:SS
 * Supplying a guide (in seconds) will force a number of leading zeros
 * to cover the length of the guide
 *
 * @borrows format-time:formatTime as videojs.formatTime
 */
videojs.formatTime = formatTime;

/**
 * Resolve and parse the elements of a URL
 *
 * @borrows url:parseUrl as videojs.parseUrl
 */
videojs.parseUrl = parseUrl;

/**
 * Returns whether the url passed is a cross domain request or not.
 *
 * @borrows url:isCrossOrigin as videojs.isCrossOrigin
 */
videojs.isCrossOrigin = isCrossOrigin;

/**
 * Event target class.
 *
 * @borrows EventTarget as videojs.EventTarget
 */
videojs.EventTarget = EventTarget;

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 *
 * @borrows events:on as videojs.on
 */
videojs.on = on;

/**
 * Trigger a listener only once for an event
 *
 * @borrows events:one as videojs.one
 */
videojs.one = one;

/**
 * Removes event listeners from an element
 *
 * @borrows events:off as videojs.off
 */
videojs.off = off;

/**
 * Trigger an event for an element
 *
 * @borrows events:trigger as videojs.trigger
 */
videojs.trigger = trigger;

/**
 * A cross-browser XMLHttpRequest wrapper. Here's a simple example:
 *
 * @param {Object} options
 *        settings for the request.
 *
 * @return {XMLHttpRequest|XDomainRequest}
 *         The request object.
 *
 * @see https://github.com/Raynos/xhr
 */
videojs.xhr = xhr;

/**
 * TextTrack class
 *
 * @borrows TextTrack as videojs.TextTrack
 */
videojs.TextTrack = TextTrack;

/**
 * export the AudioTrack class so that source handlers can create
 * AudioTracks and then add them to the players AudioTrackList
 *
 * @borrows AudioTrack as videojs.AudioTrack
 */
videojs.AudioTrack = AudioTrack;

/**
 * export the VideoTrack class so that source handlers can create
 * VideoTracks and then add them to the players VideoTrackList
 *
 * @borrows VideoTrack as videojs.VideoTrack
 */
videojs.VideoTrack = VideoTrack;

/**
 * Determines, via duck typing, whether or not a value is a DOM element.
 *
 * @borrows dom:isEl as videojs.isEl
 * @deprecated Use videojs.dom.isEl() instead
 */

/**
 * Determines, via duck typing, whether or not a value is a text node.
 *
 * @borrows dom:isTextNode as videojs.isTextNode
 * @deprecated Use videojs.dom.isTextNode() instead
 */

/**
 * Creates an element and applies properties.
 *
 * @borrows dom:createEl as videojs.createEl
 * @deprecated Use videojs.dom.createEl() instead
 */

/**
 * Check if an element has a CSS class
 *
 * @borrows dom:hasElClass as videojs.hasClass
 * @deprecated Use videojs.dom.hasClass() instead
 */

/**
 * Add a CSS class name to an element
 *
 * @borrows dom:addElClass as videojs.addClass
 * @deprecated Use videojs.dom.addClass() instead
 */

/**
 * Remove a CSS class name from an element
 *
 * @borrows dom:removeElClass as videojs.removeClass
 * @deprecated Use videojs.dom.removeClass() instead
 */

/**
 * Adds or removes a CSS class name on an element depending on an optional
 * condition or the presence/absence of the class name.
 *
 * @borrows dom:toggleElClass as videojs.toggleClass
 * @deprecated Use videojs.dom.toggleClass() instead
 */

/**
 * Apply attributes to an HTML element.
 *
 * @borrows dom:setElAttributes as videojs.setAttribute
 * @deprecated Use videojs.dom.setAttributes() instead
 */

/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributes are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 *
 * @borrows dom:getElAttributes as videojs.getAttributes
 * @deprecated Use videojs.dom.getAttributes() instead
 */

/**
 * Empties the contents of an element.
 *
 * @borrows dom:emptyEl as videojs.emptyEl
 * @deprecated Use videojs.dom.emptyEl() instead
 */

/**
 * Normalizes and appends content to an element.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * - String
 *   Normalized into a text node.
 *
 * - Element, TextNode
 *   Passed through.
 *
 * - Array
 *   A one-dimensional array of strings, elements, nodes, or functions (which
 *   return single strings, elements, or nodes).
 *
 * - Function
 *   If the sole argument, is expected to produce a string, element,
 *   node, or array.
 *
 * @borrows dom:appendContents as videojs.appendContet
 * @deprecated Use videojs.dom.appendContent() instead
 */

/**
 * Normalizes and inserts content into an element; this is identical to
 * `appendContent()`, except it empties the element first.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * - String
 *   Normalized into a text node.
 *
 * - Element, TextNode
 *   Passed through.
 *
 * - Array
 *   A one-dimensional array of strings, elements, nodes, or functions (which
 *   return single strings, elements, or nodes).
 *
 * - Function
 *   If the sole argument, is expected to produce a string, element,
 *   node, or array.
 *
 * @borrows dom:insertContent as videojs.insertContent
 * @deprecated Use videojs.dom.insertContent() instead
 */
['isEl', 'isTextNode', 'createEl', 'hasClass', 'addClass', 'removeClass', 'toggleClass', 'setAttributes', 'getAttributes', 'emptyEl', 'appendContent', 'insertContent'].forEach(function (k) {
  videojs[k] = function () {
    log$1.warn('videojs.' + k + '() is deprecated; use videojs.dom.' + k + '() instead');
    return Dom[k].apply(null, arguments);
  };
});

/**
 * A safe getComputedStyle with an IE8 fallback.
 *
 * This is because in Firefox, if the player is loaded in an iframe with `display:none`,
 * then `getComputedStyle` returns `null`, so, we do a null-check to make sure
 * that the player doesn't break in these cases.
 * See https://bugzilla.mozilla.org/show_bug.cgi?id=548397 for more details.
 *
 * @borrows computed-style:computedStyle as videojs.computedStyle
 */
videojs.computedStyle = computedStyle;

/**
 * Export the Dom utilities for use in external plugins
 * and Tech's
 */
videojs.dom = Dom;

/**
 * Export the Url utilities for use in external plugins
 * and Tech's
 */
videojs.url = Url;

module.exports = videojs;

},{"global/document":41,"global/window":42,"safe-json-parse/tuple":45,"tsml":47,"videojs-vtt.js":49,"xhr":53}],49:[function(require,module,exports){
/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Default exports for Node. Export the extended versions of VTTCue and
// VTTRegion in Node since we likely want the capability to convert back and
// forth between JSON. If we don't then it's not that big of a deal since we're
// off browser.

var window = require('global/window');

var vttjs = module.exports = {
  WebVTT: require("./vtt.js"),
  VTTCue: require("./vttcue.js"),
  VTTRegion: require("./vttregion.js")
};

window.vttjs = vttjs;
window.WebVTT = vttjs.WebVTT;

var cueShim = vttjs.VTTCue;
var regionShim = vttjs.VTTRegion;
var nativeVTTCue = window.VTTCue;
var nativeVTTRegion = window.VTTRegion;

vttjs.shim = function() {
  window.VTTCue = cueShim;
  window.VTTRegion = regionShim;
};

vttjs.restore = function() {
  window.VTTCue = nativeVTTCue;
  window.VTTRegion = nativeVTTRegion;
};

if (!window.VTTCue) {
  vttjs.shim();
}

},{"./vtt.js":50,"./vttcue.js":51,"./vttregion.js":52,"global/window":42}],50:[function(require,module,exports){
/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
var _objCreate = Object.create || (function() {
  function F() {}
  return function(o) {
    if (arguments.length !== 1) {
      throw new Error('Object.create shim only accepts one parameter.');
    }
    F.prototype = o;
    return new F();
  };
})();

// Creates a new ParserError object from an errorData object. The errorData
// object should have default code and message properties. The default message
// property can be overriden by passing in a message parameter.
// See ParsingError.Errors below for acceptable errors.
function ParsingError(errorData, message) {
  this.name = "ParsingError";
  this.code = errorData.code;
  this.message = message || errorData.message;
}
ParsingError.prototype = _objCreate(Error.prototype);
ParsingError.prototype.constructor = ParsingError;

// ParsingError metadata for acceptable ParsingErrors.
ParsingError.Errors = {
  BadSignature: {
    code: 0,
    message: "Malformed WebVTT signature."
  },
  BadTimeStamp: {
    code: 1,
    message: "Malformed time stamp."
  }
};

// Try to parse input as a time stamp.
function parseTimeStamp(input) {

  function computeSeconds(h, m, s, f) {
    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
  }

  var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
  if (!m) {
    return null;
  }

  if (m[3]) {
    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
    return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);
  } else if (m[1] > 59) {
    // Timestamp takes the form of [hours]:[minutes].[milliseconds]
    // First position is hours as it's over 59.
    return computeSeconds(m[1], m[2], 0,  m[4]);
  } else {
    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
    return computeSeconds(0, m[1], m[2], m[4]);
  }
}

// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
  this.values = _objCreate(null);
}

Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function(k, v) {
    if (!this.get(k) && v !== "") {
      this.values[k] = v;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }
    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function(k, v) {
    if (/^-?\d+$/.test(v)) { // integer
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function(k, v) {
    var m;
    if ((m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/))) {
      v = parseFloat(v);
      if (v >= 0 && v <= 100) {
        this.set(k, v);
        return true;
      }
    }
    return false;
  }
};

// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== "string") {
      continue;
    }
    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }
    var k = kv[0];
    var v = kv[1];
    callback(k, v);
  }
}

function parseCue(input, cue, regionList) {
  // Remember the original input if we need to throw an error.
  var oInput = input;
  // 4.1 WebVTT timestamp
  function consumeTimeStamp() {
    var ts = parseTimeStamp(input);
    if (ts === null) {
      throw new ParsingError(ParsingError.Errors.BadTimeStamp,
                            "Malformed timestamp: " + oInput);
    }
    // Remove time stamp from input.
    input = input.replace(/^[^\sa-zA-Z-]+/, "");
    return ts;
  }

  // 4.4.2 WebVTT cue settings
  function consumeCueSettings(input, cue) {
    var settings = new Settings();

    parseOptions(input, function (k, v) {
      switch (k) {
      case "region":
        // Find the last region we parsed with the same region id.
        for (var i = regionList.length - 1; i >= 0; i--) {
          if (regionList[i].id === v) {
            settings.set(k, regionList[i].region);
            break;
          }
        }
        break;
      case "vertical":
        settings.alt(k, v, ["rl", "lr"]);
        break;
      case "line":
        var vals = v.split(","),
            vals0 = vals[0];
        settings.integer(k, vals0);
        settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;
        settings.alt(k, vals0, ["auto"]);
        if (vals.length === 2) {
          settings.alt("lineAlign", vals[1], ["start", "middle", "end"]);
        }
        break;
      case "position":
        vals = v.split(",");
        settings.percent(k, vals[0]);
        if (vals.length === 2) {
          settings.alt("positionAlign", vals[1], ["start", "middle", "end"]);
        }
        break;
      case "size":
        settings.percent(k, v);
        break;
      case "align":
        settings.alt(k, v, ["start", "middle", "end", "left", "right"]);
        break;
      }
    }, /:/, /\s/);

    // Apply default values for any missing fields.
    cue.region = settings.get("region", null);
    cue.vertical = settings.get("vertical", "");
    cue.line = settings.get("line", "auto");
    cue.lineAlign = settings.get("lineAlign", "start");
    cue.snapToLines = settings.get("snapToLines", true);
    cue.size = settings.get("size", 100);
    cue.align = settings.get("align", "middle");
    cue.position = settings.get("position", {
      start: 0,
      left: 0,
      middle: 50,
      end: 100,
      right: 100
    }, cue.align);
    cue.positionAlign = settings.get("positionAlign", {
      start: "start",
      left: "start",
      middle: "middle",
      end: "end",
      right: "end"
    }, cue.align);
  }

  function skipWhitespace() {
    input = input.replace(/^\s+/, "");
  }

  // 4.1 WebVTT cue timings.
  skipWhitespace();
  cue.startTime = consumeTimeStamp();   // (1) collect cue start time
  skipWhitespace();
  if (input.substr(0, 3) !== "-->") {     // (3) next characters must match "-->"
    throw new ParsingError(ParsingError.Errors.BadTimeStamp,
                           "Malformed time stamp (time stamps must be separated by '-->'): " +
                           oInput);
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp();     // (5) collect cue end time

  // 4.1 WebVTT cue settings list.
  skipWhitespace();
  consumeCueSettings(input, cue);
}

var ESCAPE = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&lrm;": "\u200e",
  "&rlm;": "\u200f",
  "&nbsp;": "\u00a0"
};

var TAG_NAME = {
  c: "span",
  i: "i",
  b: "b",
  u: "u",
  ruby: "ruby",
  rt: "rt",
  v: "span",
  lang: "span"
};

var TAG_ANNOTATION = {
  v: "title",
  lang: "lang"
};

var NEEDS_PARENT = {
  rt: "ruby"
};

// Parse content into a document fragment.
function parseContent(window, input) {
  function nextToken() {
    // Check for end-of-string.
    if (!input) {
      return null;
    }

    // Consume 'n' characters from the input.
    function consume(result) {
      input = input.substr(result.length);
      return result;
    }

    var m = input.match(/^([^<]*)(<[^>]+>?)?/);
    // If there is some text before the next tag, return it, otherwise return
    // the tag.
    return consume(m[1] ? m[1] : m[2]);
  }

  // Unescape a string 's'.
  function unescape1(e) {
    return ESCAPE[e];
  }
  function unescape(s) {
    while ((m = s.match(/&(amp|lt|gt|lrm|rlm|nbsp);/))) {
      s = s.replace(m[0], unescape1);
    }
    return s;
  }

  function shouldAdd(current, element) {
    return !NEEDS_PARENT[element.localName] ||
           NEEDS_PARENT[element.localName] === current.localName;
  }

  // Create an element for this tag.
  function createElement(type, annotation) {
    var tagName = TAG_NAME[type];
    if (!tagName) {
      return null;
    }
    var element = window.document.createElement(tagName);
    element.localName = tagName;
    var name = TAG_ANNOTATION[type];
    if (name && annotation) {
      element[name] = annotation.trim();
    }
    return element;
  }

  var rootDiv = window.document.createElement("div"),
      current = rootDiv,
      t,
      tagStack = [];

  while ((t = nextToken()) !== null) {
    if (t[0] === '<') {
      if (t[1] === "/") {
        // If the closing tag matches, move back up to the parent node.
        if (tagStack.length &&
            tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {
          tagStack.pop();
          current = current.parentNode;
        }
        // Otherwise just ignore the end tag.
        continue;
      }
      var ts = parseTimeStamp(t.substr(1, t.length - 2));
      var node;
      if (ts) {
        // Timestamps are lead nodes as well.
        node = window.document.createProcessingInstruction("timestamp", ts);
        current.appendChild(node);
        continue;
      }
      var m = t.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
      // If we can't parse the tag, skip to the next tag.
      if (!m) {
        continue;
      }
      // Try to construct an element, and ignore the tag if we couldn't.
      node = createElement(m[1], m[3]);
      if (!node) {
        continue;
      }
      // Determine if the tag should be added based on the context of where it
      // is placed in the cuetext.
      if (!shouldAdd(current, node)) {
        continue;
      }
      // Set the class list (as a list of classes, separated by space).
      if (m[2]) {
        node.className = m[2].substr(1).replace('.', ' ');
      }
      // Append the node to the current node, and enter the scope of the new
      // node.
      tagStack.push(m[1]);
      current.appendChild(node);
      current = node;
      continue;
    }

    // Text nodes are leaf nodes.
    current.appendChild(window.document.createTextNode(unescape(t)));
  }

  return rootDiv;
}

// This is a list of all the Unicode characters that have a strong
// right-to-left category. What this means is that these characters are
// written right-to-left for sure. It was generated by pulling all the strong
// right-to-left characters out of the Unicode data table. That table can
// found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt
var strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6],
 [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d],
 [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6],
 [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5],
 [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815],
 [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858],
 [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f],
 [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c],
 [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1],
 [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc],
 [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808],
 [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855],
 [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f],
 [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13],
 [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58],
 [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72],
 [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f],
 [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32],
 [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42],
 [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f],
 [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59],
 [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62],
 [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77],
 [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b],
 [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];

function isStrongRTLChar(charCode) {
  for (var i = 0; i < strongRTLRanges.length; i++) {
    var currentRange = strongRTLRanges[i];
    if (charCode >= currentRange[0] && charCode <= currentRange[1]) {
      return true;
    }
  }

  return false;
}

function determineBidi(cueDiv) {
  var nodeStack = [],
      text = "",
      charCode;

  if (!cueDiv || !cueDiv.childNodes) {
    return "ltr";
  }

  function pushNodes(nodeStack, node) {
    for (var i = node.childNodes.length - 1; i >= 0; i--) {
      nodeStack.push(node.childNodes[i]);
    }
  }

  function nextTextNode(nodeStack) {
    if (!nodeStack || !nodeStack.length) {
      return null;
    }

    var node = nodeStack.pop(),
        text = node.textContent || node.innerText;
    if (text) {
      // TODO: This should match all unicode type B characters (paragraph
      // separator characters). See issue #115.
      var m = text.match(/^.*(\n|\r)/);
      if (m) {
        nodeStack.length = 0;
        return m[0];
      }
      return text;
    }
    if (node.tagName === "ruby") {
      return nextTextNode(nodeStack);
    }
    if (node.childNodes) {
      pushNodes(nodeStack, node);
      return nextTextNode(nodeStack);
    }
  }

  pushNodes(nodeStack, cueDiv);
  while ((text = nextTextNode(nodeStack))) {
    for (var i = 0; i < text.length; i++) {
      charCode = text.charCodeAt(i);
      if (isStrongRTLChar(charCode)) {
        return "rtl";
      }
    }
  }
  return "ltr";
}

function computeLinePos(cue) {
  if (typeof cue.line === "number" &&
      (cue.snapToLines || (cue.line >= 0 && cue.line <= 100))) {
    return cue.line;
  }
  if (!cue.track || !cue.track.textTrackList ||
      !cue.track.textTrackList.mediaElement) {
    return -1;
  }
  var track = cue.track,
      trackList = track.textTrackList,
      count = 0;
  for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
    if (trackList[i].mode === "showing") {
      count++;
    }
  }
  return ++count * -1;
}

function StyleBox() {
}

// Apply styles to a div. If there is no div passed then it defaults to the
// div on 'this'.
StyleBox.prototype.applyStyles = function(styles, div) {
  div = div || this.div;
  for (var prop in styles) {
    if (styles.hasOwnProperty(prop)) {
      div.style[prop] = styles[prop];
    }
  }
};

StyleBox.prototype.formatStyle = function(val, unit) {
  return val === 0 ? 0 : val + unit;
};

// Constructs the computed display state of the cue (a div). Places the div
// into the overlay which should be a block level element (usually a div).
function CueStyleBox(window, cue, styleOptions) {
  var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);
  var color = "rgba(255, 255, 255, 1)";
  var backgroundColor = "rgba(0, 0, 0, 0.8)";

  if (isIE8) {
    color = "rgb(255, 255, 255)";
    backgroundColor = "rgb(0, 0, 0)";
  }

  StyleBox.call(this);
  this.cue = cue;

  // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will
  // have inline positioning and will function as the cue background box.
  this.cueDiv = parseContent(window, cue.text);
  var styles = {
    color: color,
    backgroundColor: backgroundColor,
    position: "relative",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    display: "inline"
  };

  if (!isIE8) {
    styles.writingMode = cue.vertical === "" ? "horizontal-tb"
                                             : cue.vertical === "lr" ? "vertical-lr"
                                                                     : "vertical-rl";
    styles.unicodeBidi = "plaintext";
  }
  this.applyStyles(styles, this.cueDiv);

  // Create an absolutely positioned div that will be used to position the cue
  // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS
  // mirrors of them except "middle" which is "center" in CSS.
  this.div = window.document.createElement("div");
  styles = {
    textAlign: cue.align === "middle" ? "center" : cue.align,
    font: styleOptions.font,
    whiteSpace: "pre-line",
    position: "absolute"
  };

  if (!isIE8) {
    styles.direction = determineBidi(this.cueDiv);
    styles.writingMode = cue.vertical === "" ? "horizontal-tb"
                                             : cue.vertical === "lr" ? "vertical-lr"
                                                                     : "vertical-rl".
    stylesunicodeBidi =  "plaintext";
  }

  this.applyStyles(styles);

  this.div.appendChild(this.cueDiv);

  // Calculate the distance from the reference edge of the viewport to the text
  // position of the cue box. The reference edge will be resolved later when
  // the box orientation styles are applied.
  var textPos = 0;
  switch (cue.positionAlign) {
  case "start":
    textPos = cue.position;
    break;
  case "middle":
    textPos = cue.position - (cue.size / 2);
    break;
  case "end":
    textPos = cue.position - cue.size;
    break;
  }

  // Horizontal box orientation; textPos is the distance from the left edge of the
  // area to the left edge of the box and cue.size is the distance extending to
  // the right from there.
  if (cue.vertical === "") {
    this.applyStyles({
      left:  this.formatStyle(textPos, "%"),
      width: this.formatStyle(cue.size, "%")
    });
  // Vertical box orientation; textPos is the distance from the top edge of the
  // area to the top edge of the box and cue.size is the height extending
  // downwards from there.
  } else {
    this.applyStyles({
      top: this.formatStyle(textPos, "%"),
      height: this.formatStyle(cue.size, "%")
    });
  }

  this.move = function(box) {
    this.applyStyles({
      top: this.formatStyle(box.top, "px"),
      bottom: this.formatStyle(box.bottom, "px"),
      left: this.formatStyle(box.left, "px"),
      right: this.formatStyle(box.right, "px"),
      height: this.formatStyle(box.height, "px"),
      width: this.formatStyle(box.width, "px")
    });
  };
}
CueStyleBox.prototype = _objCreate(StyleBox.prototype);
CueStyleBox.prototype.constructor = CueStyleBox;

// Represents the co-ordinates of an Element in a way that we can easily
// compute things with such as if it overlaps or intersects with another Element.
// Can initialize it with either a StyleBox or another BoxPosition.
function BoxPosition(obj) {
  var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);

  // Either a BoxPosition was passed in and we need to copy it, or a StyleBox
  // was passed in and we need to copy the results of 'getBoundingClientRect'
  // as the object returned is readonly. All co-ordinate values are in reference
  // to the viewport origin (top left).
  var lh, height, width, top;
  if (obj.div) {
    height = obj.div.offsetHeight;
    width = obj.div.offsetWidth;
    top = obj.div.offsetTop;

    var rects = (rects = obj.div.childNodes) && (rects = rects[0]) &&
                rects.getClientRects && rects.getClientRects();
    obj = obj.div.getBoundingClientRect();
    // In certain cases the outter div will be slightly larger then the sum of
    // the inner div's lines. This could be due to bold text, etc, on some platforms.
    // In this case we should get the average line height and use that. This will
    // result in the desired behaviour.
    lh = rects ? Math.max((rects[0] && rects[0].height) || 0, obj.height / rects.length)
               : 0;

  }
  this.left = obj.left;
  this.right = obj.right;
  this.top = obj.top || top;
  this.height = obj.height || height;
  this.bottom = obj.bottom || (top + (obj.height || height));
  this.width = obj.width || width;
  this.lineHeight = lh !== undefined ? lh : obj.lineHeight;

  if (isIE8 && !this.lineHeight) {
    this.lineHeight = 13;
  }
}

// Move the box along a particular axis. Optionally pass in an amount to move
// the box. If no amount is passed then the default is the line height of the
// box.
BoxPosition.prototype.move = function(axis, toMove) {
  toMove = toMove !== undefined ? toMove : this.lineHeight;
  switch (axis) {
  case "+x":
    this.left += toMove;
    this.right += toMove;
    break;
  case "-x":
    this.left -= toMove;
    this.right -= toMove;
    break;
  case "+y":
    this.top += toMove;
    this.bottom += toMove;
    break;
  case "-y":
    this.top -= toMove;
    this.bottom -= toMove;
    break;
  }
};

// Check if this box overlaps another box, b2.
BoxPosition.prototype.overlaps = function(b2) {
  return this.left < b2.right &&
         this.right > b2.left &&
         this.top < b2.bottom &&
         this.bottom > b2.top;
};

// Check if this box overlaps any other boxes in boxes.
BoxPosition.prototype.overlapsAny = function(boxes) {
  for (var i = 0; i < boxes.length; i++) {
    if (this.overlaps(boxes[i])) {
      return true;
    }
  }
  return false;
};

// Check if this box is within another box.
BoxPosition.prototype.within = function(container) {
  return this.top >= container.top &&
         this.bottom <= container.bottom &&
         this.left >= container.left &&
         this.right <= container.right;
};

// Check if this box is entirely within the container or it is overlapping
// on the edge opposite of the axis direction passed. For example, if "+x" is
// passed and the box is overlapping on the left edge of the container, then
// return true.
BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
  switch (axis) {
  case "+x":
    return this.left < container.left;
  case "-x":
    return this.right > container.right;
  case "+y":
    return this.top < container.top;
  case "-y":
    return this.bottom > container.bottom;
  }
};

// Find the percentage of the area that this box is overlapping with another
// box.
BoxPosition.prototype.intersectPercentage = function(b2) {
  var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),
      y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),
      intersectArea = x * y;
  return intersectArea / (this.height * this.width);
};

// Convert the positions from this box to CSS compatible positions using
// the reference container's positions. This has to be done because this
// box's positions are in reference to the viewport origin, whereas, CSS
// values are in referecne to their respective edges.
BoxPosition.prototype.toCSSCompatValues = function(reference) {
  return {
    top: this.top - reference.top,
    bottom: reference.bottom - this.bottom,
    left: this.left - reference.left,
    right: reference.right - this.right,
    height: this.height,
    width: this.width
  };
};

// Get an object that represents the box's position without anything extra.
// Can pass a StyleBox, HTMLElement, or another BoxPositon.
BoxPosition.getSimpleBoxPosition = function(obj) {
  var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
  var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
  var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;

  obj = obj.div ? obj.div.getBoundingClientRect() :
                obj.tagName ? obj.getBoundingClientRect() : obj;
  var ret = {
    left: obj.left,
    right: obj.right,
    top: obj.top || top,
    height: obj.height || height,
    bottom: obj.bottom || (top + (obj.height || height)),
    width: obj.width || width
  };
  return ret;
};

// Move a StyleBox to its specified, or next best, position. The containerBox
// is the box that contains the StyleBox, such as a div. boxPositions are
// a list of other boxes that the styleBox can't overlap with.
function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {

  // Find the best position for a cue box, b, on the video. The axis parameter
  // is a list of axis, the order of which, it will move the box along. For example:
  // Passing ["+x", "-x"] will move the box first along the x axis in the positive
  // direction. If it doesn't find a good position for it there it will then move
  // it along the x axis in the negative direction.
  function findBestPosition(b, axis) {
    var bestPosition,
        specifiedPosition = new BoxPosition(b),
        percentage = 1; // Highest possible so the first thing we get is better.

    for (var i = 0; i < axis.length; i++) {
      while (b.overlapsOppositeAxis(containerBox, axis[i]) ||
             (b.within(containerBox) && b.overlapsAny(boxPositions))) {
        b.move(axis[i]);
      }
      // We found a spot where we aren't overlapping anything. This is our
      // best position.
      if (b.within(containerBox)) {
        return b;
      }
      var p = b.intersectPercentage(containerBox);
      // If we're outside the container box less then we were on our last try
      // then remember this position as the best position.
      if (percentage > p) {
        bestPosition = new BoxPosition(b);
        percentage = p;
      }
      // Reset the box position to the specified position.
      b = new BoxPosition(specifiedPosition);
    }
    return bestPosition || specifiedPosition;
  }

  var boxPosition = new BoxPosition(styleBox),
      cue = styleBox.cue,
      linePos = computeLinePos(cue),
      axis = [];

  // If we have a line number to align the cue to.
  if (cue.snapToLines) {
    var size;
    switch (cue.vertical) {
    case "":
      axis = [ "+y", "-y" ];
      size = "height";
      break;
    case "rl":
      axis = [ "+x", "-x" ];
      size = "width";
      break;
    case "lr":
      axis = [ "-x", "+x" ];
      size = "width";
      break;
    }

    var step = boxPosition.lineHeight,
        position = step * Math.round(linePos),
        maxPosition = containerBox[size] + step,
        initialAxis = axis[0];

    // If the specified intial position is greater then the max position then
    // clamp the box to the amount of steps it would take for the box to
    // reach the max position.
    if (Math.abs(position) > maxPosition) {
      position = position < 0 ? -1 : 1;
      position *= Math.ceil(maxPosition / step) * step;
    }

    // If computed line position returns negative then line numbers are
    // relative to the bottom of the video instead of the top. Therefore, we
    // need to increase our initial position by the length or width of the
    // video, depending on the writing direction, and reverse our axis directions.
    if (linePos < 0) {
      position += cue.vertical === "" ? containerBox.height : containerBox.width;
      axis = axis.reverse();
    }

    // Move the box to the specified position. This may not be its best
    // position.
    boxPosition.move(initialAxis, position);

  } else {
    // If we have a percentage line value for the cue.
    var calculatedPercentage = (boxPosition.lineHeight / containerBox.height) * 100;

    switch (cue.lineAlign) {
    case "middle":
      linePos -= (calculatedPercentage / 2);
      break;
    case "end":
      linePos -= calculatedPercentage;
      break;
    }

    // Apply initial line position to the cue box.
    switch (cue.vertical) {
    case "":
      styleBox.applyStyles({
        top: styleBox.formatStyle(linePos, "%")
      });
      break;
    case "rl":
      styleBox.applyStyles({
        left: styleBox.formatStyle(linePos, "%")
      });
      break;
    case "lr":
      styleBox.applyStyles({
        right: styleBox.formatStyle(linePos, "%")
      });
      break;
    }

    axis = [ "+y", "-x", "+x", "-y" ];

    // Get the box position again after we've applied the specified positioning
    // to it.
    boxPosition = new BoxPosition(styleBox);
  }

  var bestPosition = findBestPosition(boxPosition, axis);
  styleBox.move(bestPosition.toCSSCompatValues(containerBox));
}

function WebVTT() {
  // Nothing
}

// Helper to allow strings to be decoded instead of the default binary utf8 data.
WebVTT.StringDecoder = function() {
  return {
    decode: function(data) {
      if (!data) {
        return "";
      }
      if (typeof data !== "string") {
        throw new Error("Error - expected string data.");
      }
      return decodeURIComponent(encodeURIComponent(data));
    }
  };
};

WebVTT.convertCueToDOMTree = function(window, cuetext) {
  if (!window || !cuetext) {
    return null;
  }
  return parseContent(window, cuetext);
};

var FONT_SIZE_PERCENT = 0.05;
var FONT_STYLE = "sans-serif";
var CUE_BACKGROUND_PADDING = "1.5%";

// Runs the processing model over the cues and regions passed to it.
// @param overlay A block level element (usually a div) that the computed cues
//                and regions will be placed into.
WebVTT.processCues = function(window, cues, overlay) {
  if (!window || !cues || !overlay) {
    return null;
  }

  // Remove all previous children.
  while (overlay.firstChild) {
    overlay.removeChild(overlay.firstChild);
  }

  var paddedOverlay = window.document.createElement("div");
  paddedOverlay.style.position = "absolute";
  paddedOverlay.style.left = "0";
  paddedOverlay.style.right = "0";
  paddedOverlay.style.top = "0";
  paddedOverlay.style.bottom = "0";
  paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
  overlay.appendChild(paddedOverlay);

  // Determine if we need to compute the display states of the cues. This could
  // be the case if a cue's state has been changed since the last computation or
  // if it has not been computed yet.
  function shouldCompute(cues) {
    for (var i = 0; i < cues.length; i++) {
      if (cues[i].hasBeenReset || !cues[i].displayState) {
        return true;
      }
    }
    return false;
  }

  // We don't need to recompute the cues' display states. Just reuse them.
  if (!shouldCompute(cues)) {
    for (var i = 0; i < cues.length; i++) {
      paddedOverlay.appendChild(cues[i].displayState);
    }
    return;
  }

  var boxPositions = [],
      containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),
      fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
  var styleOptions = {
    font: fontSize + "px " + FONT_STYLE
  };

  (function() {
    var styleBox, cue;

    for (var i = 0; i < cues.length; i++) {
      cue = cues[i];

      // Compute the intial position and styles of the cue div.
      styleBox = new CueStyleBox(window, cue, styleOptions);
      paddedOverlay.appendChild(styleBox.div);

      // Move the cue div to it's correct line position.
      moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);

      // Remember the computed div so that we don't have to recompute it later
      // if we don't have too.
      cue.displayState = styleBox.div;

      boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
    }
  })();
};

WebVTT.Parser = function(window, vttjs, decoder) {
  if (!decoder) {
    decoder = vttjs;
    vttjs = {};
  }
  if (!vttjs) {
    vttjs = {};
  }

  this.window = window;
  this.vttjs = vttjs;
  this.state = "INITIAL";
  this.buffer = "";
  this.decoder = decoder || new TextDecoder("utf8");
  this.regionList = [];
};

WebVTT.Parser.prototype = {
  // If the error is a ParsingError then report it to the consumer if
  // possible. If it's not a ParsingError then throw it like normal.
  reportOrThrowError: function(e) {
    if (e instanceof ParsingError) {
      this.onparsingerror && this.onparsingerror(e);
    } else {
      throw e;
    }
  },
  parse: function (data) {
    var self = this;

    // If there is no data then we won't decode it, but will just try to parse
    // whatever is in buffer already. This may occur in circumstances, for
    // example when flush() is called.
    if (data) {
      // Try to decode the data that we received.
      self.buffer += self.decoder.decode(data, {stream: true});
    }

    function collectNextLine() {
      var buffer = self.buffer;
      var pos = 0;
      while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
        ++pos;
      }
      var line = buffer.substr(0, pos);
      // Advance the buffer early in case we fail below.
      if (buffer[pos] === '\r') {
        ++pos;
      }
      if (buffer[pos] === '\n') {
        ++pos;
      }
      self.buffer = buffer.substr(pos);
      return line;
    }

    // 3.4 WebVTT region and WebVTT region settings syntax
    function parseRegion(input) {
      var settings = new Settings();

      parseOptions(input, function (k, v) {
        switch (k) {
        case "id":
          settings.set(k, v);
          break;
        case "width":
          settings.percent(k, v);
          break;
        case "lines":
          settings.integer(k, v);
          break;
        case "regionanchor":
        case "viewportanchor":
          var xy = v.split(',');
          if (xy.length !== 2) {
            break;
          }
          // We have to make sure both x and y parse, so use a temporary
          // settings object here.
          var anchor = new Settings();
          anchor.percent("x", xy[0]);
          anchor.percent("y", xy[1]);
          if (!anchor.has("x") || !anchor.has("y")) {
            break;
          }
          settings.set(k + "X", anchor.get("x"));
          settings.set(k + "Y", anchor.get("y"));
          break;
        case "scroll":
          settings.alt(k, v, ["up"]);
          break;
        }
      }, /=/, /\s/);

      // Create the region, using default values for any values that were not
      // specified.
      if (settings.has("id")) {
        var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();
        region.width = settings.get("width", 100);
        region.lines = settings.get("lines", 3);
        region.regionAnchorX = settings.get("regionanchorX", 0);
        region.regionAnchorY = settings.get("regionanchorY", 100);
        region.viewportAnchorX = settings.get("viewportanchorX", 0);
        region.viewportAnchorY = settings.get("viewportanchorY", 100);
        region.scroll = settings.get("scroll", "");
        // Register the region.
        self.onregion && self.onregion(region);
        // Remember the VTTRegion for later in case we parse any VTTCues that
        // reference it.
        self.regionList.push({
          id: settings.get("id"),
          region: region
        });
      }
    }

    // draft-pantos-http-live-streaming-20
    // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5
    // 3.5 WebVTT
    function parseTimestampMap(input) {
      var settings = new Settings();

      parseOptions(input, function(k, v) {
        switch(k) {
        case "MPEGT":
          settings.integer(k + 'S', v);
          break;
        case "LOCA":
          settings.set(k + 'L', parseTimeStamp(v));
          break;
        }
      }, /[^\d]:/, /,/);

      self.ontimestampmap && self.ontimestampmap({
        "MPEGTS": settings.get("MPEGTS"),
        "LOCAL": settings.get("LOCAL")
      });
    }

    // 3.2 WebVTT metadata header syntax
    function parseHeader(input) {
      if (input.match(/X-TIMESTAMP-MAP/)) {
        // This line contains HLS X-TIMESTAMP-MAP metadata
        parseOptions(input, function(k, v) {
          switch(k) {
          case "X-TIMESTAMP-MAP":
            parseTimestampMap(v);
            break;
          }
        }, /=/);
      } else {
        parseOptions(input, function (k, v) {
          switch (k) {
          case "Region":
            // 3.3 WebVTT region metadata header syntax
            parseRegion(v);
            break;
          }
        }, /:/);
      }

    }

    // 5.1 WebVTT file parsing.
    try {
      var line;
      if (self.state === "INITIAL") {
        // We can't start parsing until we have the first line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        line = collectNextLine();

        var m = line.match(/^WEBVTT([ \t].*)?$/);
        if (!m || !m[0]) {
          throw new ParsingError(ParsingError.Errors.BadSignature);
        }

        self.state = "HEADER";
      }

      var alreadyCollectedLine = false;
      while (self.buffer) {
        // We can't parse a line until we have the full line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }

        switch (self.state) {
        case "HEADER":
          // 13-18 - Allow a header (metadata) under the WEBVTT line.
          if (/:/.test(line)) {
            parseHeader(line);
          } else if (!line) {
            // An empty line terminates the header and starts the body (cues).
            self.state = "ID";
          }
          continue;
        case "NOTE":
          // Ignore NOTE blocks.
          if (!line) {
            self.state = "ID";
          }
          continue;
        case "ID":
          // Check for the start of NOTE blocks.
          if (/^NOTE($|[ \t])/.test(line)) {
            self.state = "NOTE";
            break;
          }
          // 19-29 - Allow any number of line terminators, then initialize new cue values.
          if (!line) {
            continue;
          }
          self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, "");
          self.state = "CUE";
          // 30-39 - Check if self line contains an optional identifier or timing data.
          if (line.indexOf("-->") === -1) {
            self.cue.id = line;
            continue;
          }
          // Process line as start of a cue.
          /*falls through*/
        case "CUE":
          // 40 - Collect cue timings and settings.
          try {
            parseCue(line, self.cue, self.regionList);
          } catch (e) {
            self.reportOrThrowError(e);
            // In case of an error ignore rest of the cue.
            self.cue = null;
            self.state = "BADCUE";
            continue;
          }
          self.state = "CUETEXT";
          continue;
        case "CUETEXT":
          var hasSubstring = line.indexOf("-->") !== -1;
          // 34 - If we have an empty line then report the cue.
          // 35 - If we have the special substring '-->' then report the cue,
          // but do not collect the line as we need to process the current
          // one as a new cue.
          if (!line || hasSubstring && (alreadyCollectedLine = true)) {
            // We are done parsing self cue.
            self.oncue && self.oncue(self.cue);
            self.cue = null;
            self.state = "ID";
            continue;
          }
          if (self.cue.text) {
            self.cue.text += "\n";
          }
          self.cue.text += line;
          continue;
        case "BADCUE": // BADCUE
          // 54-62 - Collect and discard the remaining cue.
          if (!line) {
            self.state = "ID";
          }
          continue;
        }
      }
    } catch (e) {
      self.reportOrThrowError(e);

      // If we are currently parsing a cue, report what we have.
      if (self.state === "CUETEXT" && self.cue && self.oncue) {
        self.oncue(self.cue);
      }
      self.cue = null;
      // Enter BADWEBVTT state if header was not parsed correctly otherwise
      // another exception occurred so enter BADCUE state.
      self.state = self.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
    }
    return this;
  },
  flush: function () {
    var self = this;
    try {
      // Finish decoding the stream.
      self.buffer += self.decoder.decode();
      // Synthesize the end of the current cue or region.
      if (self.cue || self.state === "HEADER") {
        self.buffer += "\n\n";
        self.parse();
      }
      // If we've flushed, parsed, and we're still on the INITIAL state then
      // that means we don't have enough of the stream to parse the first
      // line.
      if (self.state === "INITIAL") {
        throw new ParsingError(ParsingError.Errors.BadSignature);
      }
    } catch(e) {
      self.reportOrThrowError(e);
    }
    self.onflush && self.onflush();
    return this;
  }
};

module.exports = WebVTT;

},{}],51:[function(require,module,exports){
/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var autoKeyword = "auto";
var directionSetting = {
  "": true,
  "lr": true,
  "rl": true
};
var alignSetting = {
  "start": true,
  "middle": true,
  "end": true,
  "left": true,
  "right": true
};

function findDirectionSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var dir = directionSetting[value.toLowerCase()];
  return dir ? value.toLowerCase() : false;
}

function findAlignSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var align = alignSetting[value.toLowerCase()];
  return align ? value.toLowerCase() : false;
}

function extend(obj) {
  var i = 1;
  for (; i < arguments.length; i++) {
    var cobj = arguments[i];
    for (var p in cobj) {
      obj[p] = cobj[p];
    }
  }

  return obj;
}

function VTTCue(startTime, endTime, text) {
  var cue = this;
  var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);
  var baseObj = {};

  if (isIE8) {
    cue = document.createElement('custom');
  } else {
    baseObj.enumerable = true;
  }

  /**
   * Shim implementation specific properties. These properties are not in
   * the spec.
   */

  // Lets us know when the VTTCue's data has changed in such a way that we need
  // to recompute its display state. This lets us compute its display state
  // lazily.
  cue.hasBeenReset = false;

  /**
   * VTTCue and TextTrackCue properties
   * http://dev.w3.org/html5/webvtt/#vttcue-interface
   */

  var _id = "";
  var _pauseOnExit = false;
  var _startTime = startTime;
  var _endTime = endTime;
  var _text = text;
  var _region = null;
  var _vertical = "";
  var _snapToLines = true;
  var _line = "auto";
  var _lineAlign = "start";
  var _position = 50;
  var _positionAlign = "middle";
  var _size = 50;
  var _align = "middle";

  Object.defineProperty(cue,
    "id", extend({}, baseObj, {
      get: function() {
        return _id;
      },
      set: function(value) {
        _id = "" + value;
      }
    }));

  Object.defineProperty(cue,
    "pauseOnExit", extend({}, baseObj, {
      get: function() {
        return _pauseOnExit;
      },
      set: function(value) {
        _pauseOnExit = !!value;
      }
    }));

  Object.defineProperty(cue,
    "startTime", extend({}, baseObj, {
      get: function() {
        return _startTime;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("Start time must be set to a number.");
        }
        _startTime = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "endTime", extend({}, baseObj, {
      get: function() {
        return _endTime;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("End time must be set to a number.");
        }
        _endTime = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "text", extend({}, baseObj, {
      get: function() {
        return _text;
      },
      set: function(value) {
        _text = "" + value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "region", extend({}, baseObj, {
      get: function() {
        return _region;
      },
      set: function(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "vertical", extend({}, baseObj, {
      get: function() {
        return _vertical;
      },
      set: function(value) {
        var setting = findDirectionSetting(value);
        // Have to check for false because the setting an be an empty string.
        if (setting === false) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "snapToLines", extend({}, baseObj, {
      get: function() {
        return _snapToLines;
      },
      set: function(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "line", extend({}, baseObj, {
      get: function() {
        return _line;
      },
      set: function(value) {
        if (typeof value !== "number" && value !== autoKeyword) {
          throw new SyntaxError("An invalid number or illegal string was specified.");
        }
        _line = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "lineAlign", extend({}, baseObj, {
      get: function() {
        return _lineAlign;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "position", extend({}, baseObj, {
      get: function() {
        return _position;
      },
      set: function(value) {
        if (value < 0 || value > 100) {
          throw new Error("Position must be between 0 and 100.");
        }
        _position = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "positionAlign", extend({}, baseObj, {
      get: function() {
        return _positionAlign;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "size", extend({}, baseObj, {
      get: function() {
        return _size;
      },
      set: function(value) {
        if (value < 0 || value > 100) {
          throw new Error("Size must be between 0 and 100.");
        }
        _size = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "align", extend({}, baseObj, {
      get: function() {
        return _align;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _align = setting;
        this.hasBeenReset = true;
      }
    }));

  /**
   * Other <track> spec defined properties
   */

  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
  cue.displayState = undefined;

  if (isIE8) {
    return cue;
  }
}

/**
 * VTTCue methods
 */

VTTCue.prototype.getCueAsHTML = function() {
  // Assume WebVTT.convertCueToDOMTree is on the global.
  return WebVTT.convertCueToDOMTree(window, this.text);
};

module.exports = VTTCue;

},{}],52:[function(require,module,exports){
/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var scrollSetting = {
  "": true,
  "up": true
};

function findScrollSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var scroll = scrollSetting[value.toLowerCase()];
  return scroll ? value.toLowerCase() : false;
}

function isValidPercentValue(value) {
  return typeof value === "number" && (value >= 0 && value <= 100);
}

// VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface
function VTTRegion() {
  var _width = 100;
  var _lines = 3;
  var _regionAnchorX = 0;
  var _regionAnchorY = 100;
  var _viewportAnchorX = 0;
  var _viewportAnchorY = 100;
  var _scroll = "";

  Object.defineProperties(this, {
    "width": {
      enumerable: true,
      get: function() {
        return _width;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("Width must be between 0 and 100.");
        }
        _width = value;
      }
    },
    "lines": {
      enumerable: true,
      get: function() {
        return _lines;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("Lines must be set to a number.");
        }
        _lines = value;
      }
    },
    "regionAnchorY": {
      enumerable: true,
      get: function() {
        return _regionAnchorY;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("RegionAnchorX must be between 0 and 100.");
        }
        _regionAnchorY = value;
      }
    },
    "regionAnchorX": {
      enumerable: true,
      get: function() {
        return _regionAnchorX;
      },
      set: function(value) {
        if(!isValidPercentValue(value)) {
          throw new Error("RegionAnchorY must be between 0 and 100.");
        }
        _regionAnchorX = value;
      }
    },
    "viewportAnchorY": {
      enumerable: true,
      get: function() {
        return _viewportAnchorY;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("ViewportAnchorY must be between 0 and 100.");
        }
        _viewportAnchorY = value;
      }
    },
    "viewportAnchorX": {
      enumerable: true,
      get: function() {
        return _viewportAnchorX;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("ViewportAnchorX must be between 0 and 100.");
        }
        _viewportAnchorX = value;
      }
    },
    "scroll": {
      enumerable: true,
      get: function() {
        return _scroll;
      },
      set: function(value) {
        var setting = findScrollSetting(value);
        // Have to check for false as an empty string is a legal value.
        if (setting === false) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _scroll = setting;
      }
    }
  });
}

module.exports = VTTRegion;

},{}],53:[function(require,module,exports){
"use strict";
var window = require("global/window")
var isFunction = require("is-function")
var parseHeaders = require("parse-headers")
var xtend = require("xtend")

module.exports = createXHR
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback)
        options.method = method.toUpperCase()
        return _createXHR(options)
    }
})

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i])
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri

    if (isFunction(options)) {
        callback = options
        if (typeof uri === "string") {
            params = {uri:uri}
        }
    } else {
        params = xtend(options, {uri: uri})
    }

    params.callback = callback
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback)
    return _createXHR(options)
}

function _createXHR(options) {
    if(typeof options.callback === "undefined"){
        throw new Error("callback argument missing")
    }

    var called = false
    var callback = function cbOnce(err, response, body){
        if(!called){
            called = true
            options.callback(err, response, body)
        }
    }

    function readystatechange() {
        if (xhr.readyState === 4) {
            setTimeout(loadFunc, 0)
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else {
            body = xhr.responseText || getXml(xhr)
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
        }
        evt.statusCode = 0
        return callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status
        clearTimeout(timeoutTimer)
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status)
        }
        var response = failureResponse
        var err = null

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        return callback(err, response, response.body)
    }

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest()
        }else{
            xhr = new createXHR.XMLHttpRequest()
        }
    }

    var key
    var aborted
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer
    var failureResponse = {
        body: undefined,
        headers: {},
        statusCode: 0,
        method: method,
        url: uri,
        rawRequest: xhr
    }

    if ("json" in options && options.json !== false) {
        isJson = true
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
            body = JSON.stringify(options.json === true ? body : options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.onabort = function(){
        aborted = true;
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync, options.username, options.password)
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            if (aborted) return
            aborted = true//IE9 may still call readystatechange
            xhr.abort("timeout")
            var e = new Error("XMLHttpRequest timeout")
            e.code = "ETIMEDOUT"
            errorFunc(e)
        }, options.timeout )
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.
    xhr.send(body || null)

    return xhr


}

function getXml(xhr) {
    if (xhr.responseType === "document") {
        return xhr.responseXML
    }
    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"
    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
        return xhr.responseXML
    }

    return null
}

function noop() {}

},{"global/window":42,"is-function":43,"parse-headers":44,"xtend":54}],54:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.videojs = require('video.js');
videojs = videojs.default || videojs;
exports.default = {
  name: 'video-player',
  props: {
    options: {
      type: Object,
      required: true
    },
    start: {
      type: Number,
      default: function _default() {
        return 0;
      }
    },
    playsinline: {
      type: Boolean,
      default: function _default() {
        return false;
      }
    },
    customEventName: {
      type: String,
      default: function _default() {
        return 'statechanged';
      }
    }
  },
  mounted: function mounted() {
    if (!this.player) {
      this.initialize();
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.player) {
      this.dispose();
    }
  },
  methods: {
    initialize: function initialize() {

      // init
      var self = this;
      this.player = null;

      // videojs options
      var videoOptions = (0, _assign2.default)({
        autoplay: false,
        controls: true,
        preload: 'auto',
        fluid: false,
        muted: false,
        width: '100%',
        height: '360',
        language: 'en',
        controlBar: {
          remainingTimeDisplay: false,
          playToggle: {},
          progressControl: {},
          fullscreenToggle: {},
          volumeMenuButton: {
            inline: false,
            vertical: true
          }
        },
        techOrder: ['html5'],
        plugins: {}
      }, this.options);

      // check sources
      /*
      if (!videoOptions.sources || !videoOptions.sources.length) {
        console.warn('Missing required option: "sources".')
        return false
      }
      */

      // ios fullscreen
      var playsinline = this.playsinline;
      if (playsinline) {
        this.$el.children[0].setAttribute('playsinline', playsinline);
        this.$el.children[0].setAttribute('webkit-playsinline', playsinline);
      }

      // emit event
      var emitPlayerState = function emitPlayerState(event, value) {
        if (event) {
          self.$emit(event, self.player);
        }
        if (value) {
          var values = {};
          values[event] = value;
          self.$emit(self.customEventName, values);
        }
      };

      // videoOptions
      // console.log(videoOptions)

      // avoid error "VIDEOJS: ERROR: Unable to find plugin: __ob__"
      if (videoOptions.plugins) {
        delete videoOptions.plugins.__ob__;
      }
      this.player = videojs(this.$el.children[0], videoOptions, function () {
        var _this = this;

        // player readied
        self.$emit('ready', self.player);

        // events
        ['loadeddata', 'canplay', 'canplaythrough', 'play', 'pause', 'waiting', 'playing', 'ended'].forEach(function (event) {
          _this.on(event, function () {
            emitPlayerState(event, true);
          });
        });

        this.on('timeupdate', function () {
          emitPlayerState('timeupdate', this.currentTime());
        });
      });
    },
    dispose: function dispose() {
      if (this.player && videojs) {
        this.player.pause && this.player.pause();
        videojs(this.$el.children[0]).dispose();
        if (!this.$el.children.length) {
          var video = document.createElement('video');
          video.className = 'video-js';
          this.$el.appendChild(video);
        }
        this.player = null;
      }
    }
  },
  watch: {
    options: {
      deep: true,
      handler: function handler(options, oldOptions) {
        this.dispose();
        if (options && options.sources && options.sources.length) {
          this.initialize();
        }
      }
    }
  }
};
if (module.exports.__esModule) module.exports = module.exports.default
;(typeof module.exports === "function"? module.exports.options: module.exports).template = "<div class=video-player><video class=video-js></video></div>"

},{"babel-runtime/core-js/object/assign":2,"video.js":48}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9fYnJvd3Nlci1wYWNrQDYuMC4yQGJyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImluZGV4LmpzIiwibm9kZV9tb2R1bGVzL19iYWJlbC1ydW50aW1lQDYuMjUuMEBiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9fYnJvd3Nlci1yZXNvbHZlQDEuMTEuMkBicm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjBAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuMEBjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwibm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS4wQGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL19mb3ItZWFjaEAwLjMuMkBmb3ItZWFjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9fZ2xvYmFsQDQuMy4yQGdsb2JhbC9ub2RlX21vZHVsZXMvX3ZpZGVvLmpzQDYuMi40QHZpZGVvLmpzL25vZGVfbW9kdWxlcy9nbG9iYWwvZG9jdW1lbnQuanMiLCJub2RlX21vZHVsZXMvX2dsb2JhbEA0LjMuMkBnbG9iYWwvbm9kZV9tb2R1bGVzL192aWRlby5qc0A2LjIuNEB2aWRlby5qcy9ub2RlX21vZHVsZXMvZ2xvYmFsL3dpbmRvdy5qcyIsIm5vZGVfbW9kdWxlcy9faXMtZnVuY3Rpb25AMS4wLjFAaXMtZnVuY3Rpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvX3BhcnNlLWhlYWRlcnNAMi4wLjFAcGFyc2UtaGVhZGVycy9wYXJzZS1oZWFkZXJzLmpzIiwibm9kZV9tb2R1bGVzL19zYWZlLWpzb24tcGFyc2VANC4wLjBAc2FmZS1qc29uLXBhcnNlL3R1cGxlLmpzIiwibm9kZV9tb2R1bGVzL190cmltQDAuMC4xQHRyaW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvX3RzbWxAMS4wLjFAdHNtbC90c21sLmpzIiwibm9kZV9tb2R1bGVzL192aWRlby5qc0A2LjIuNEB2aWRlby5qcy9kaXN0L3ZpZGVvLmNqcy5qcyIsIm5vZGVfbW9kdWxlcy9fdmlkZW9qcy12dHQuanNAMC4xMi40QHZpZGVvanMtdnR0LmpzL2xpYi9icm93c2VyLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL192aWRlb2pzLXZ0dC5qc0AwLjEyLjRAdmlkZW9qcy12dHQuanMvbGliL3Z0dC5qcyIsIm5vZGVfbW9kdWxlcy9fdmlkZW9qcy12dHQuanNAMC4xMi40QHZpZGVvanMtdnR0LmpzL2xpYi92dHRjdWUuanMiLCJub2RlX21vZHVsZXMvX3ZpZGVvanMtdnR0LmpzQDAuMTIuNEB2aWRlb2pzLXZ0dC5qcy9saWIvdnR0cmVnaW9uLmpzIiwibm9kZV9tb2R1bGVzL194aHJAMi40LjBAeGhyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL194dGVuZEA0LjAuMUB4dGVuZC9pbW11dGFibGUuanMiLCJzcmMvcGxheWVyLnZ1ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvN3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2p6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiIC8qKlxuICpcbiAqIFZ1ZS1WaWRlby1QbGF5ZXJcbiAqIEFkYXB0ZWQgZnJvbSBWaWRlb2pzIChodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcylcbiAqXG4gKi9cblxud2luZG93LnZpZGVvanMgPSByZXF1aXJlKCd2aWRlby5qcycpXG52aWRlb2pzID0gdmlkZW9qcy5kZWZhdWx0IHx8IHZpZGVvanNcbnZhciBwbGF5ZXJDb21wb25lbnQgPSByZXF1aXJlKCcuL3NyYy9wbGF5ZXIudnVlJylcbnBsYXllckNvbXBvbmVudCA9IHBsYXllckNvbXBvbmVudC5kZWZhdWx0IHx8IHBsYXllckNvbXBvbmVudFxuXG52YXIgdmlkZW9QbGF5ZXIgPSB7XG4gIHZpZGVvanM6IHZpZGVvanMsXG4gIHZpZGVvUGxheWVyOiBwbGF5ZXJDb21wb25lbnQsXG4gIGluc3RhbGw6IGZ1bmN0aW9uKFZ1ZSkge1xuICAgIFZ1ZS5jb21wb25lbnQocGxheWVyQ29tcG9uZW50Lm5hbWUsIHBsYXllckNvbXBvbmVudClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZpZGVvUGxheWVyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuMCcgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIElTX1dSQVAgPSB0eXBlICYgJGV4cG9ydC5XO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV07XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIga2V5LCBvd24sIG91dDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAob3duICYmIGtleSBpbiBleHBvcnRzKSBjb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uIChDKSB7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQykge1xuICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEMoKTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYgKElTX1BST1RPKSB7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYgKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0pIGhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcbiIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJykgfSk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxuZnVuY3Rpb24gZm9yRWFjaChsaXN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXNGdW5jdGlvbihpdGVyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXNcbiAgICB9XG4gICAgXG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobGlzdCkgPT09ICdbb2JqZWN0IEFycmF5XScpXG4gICAgICAgIGZvckVhY2hBcnJheShsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbiAgICBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIGZvckVhY2hTdHJpbmcobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZVxuICAgICAgICBmb3JFYWNoT2JqZWN0KGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBpKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVtpXSwgaSwgYXJyYXkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTdHJpbmcoc3RyaW5nLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmplY3Rba10sIGssIG9iamVjdClcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsInZhciB0b3BMZXZlbCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDpcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9XG52YXIgbWluRG9jID0gcmVxdWlyZSgnbWluLWRvY3VtZW50Jyk7XG5cbnZhciBkb2NjeTtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkb2NjeSA9IGRvY3VtZW50O1xufSBlbHNlIHtcbiAgICBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J107XG5cbiAgICBpZiAoIWRvY2N5KSB7XG4gICAgICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXSA9IG1pbkRvYztcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG9jY3k7XG4iLCJ2YXIgd2luO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbiA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbiA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgIHdpbiA9IHNlbGY7XG59IGVsc2Uge1xuICAgIHdpbiA9IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdpbjtcbiIsIm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvblxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKGZuKSB7XG4gIHZhciBzdHJpbmcgPSB0b1N0cmluZy5jYWxsKGZuKVxuICByZXR1cm4gc3RyaW5nID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8XG4gICAgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiBzdHJpbmcgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB8fFxuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAvLyBJRTggYW5kIGJlbG93XG4gICAgIChmbiA9PT0gd2luZG93LnNldFRpbWVvdXQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuYWxlcnQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuY29uZmlybSB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5wcm9tcHQpKVxufTtcbiIsInZhciB0cmltID0gcmVxdWlyZSgndHJpbScpXG4gICwgZm9yRWFjaCA9IHJlcXVpcmUoJ2Zvci1lYWNoJylcbiAgLCBpc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gIGlmICghaGVhZGVycylcbiAgICByZXR1cm4ge31cblxuICB2YXIgcmVzdWx0ID0ge31cblxuICBmb3JFYWNoKFxuICAgICAgdHJpbShoZWFkZXJzKS5zcGxpdCgnXFxuJylcbiAgICAsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcm93LmluZGV4T2YoJzonKVxuICAgICAgICAgICwga2V5ID0gdHJpbShyb3cuc2xpY2UoMCwgaW5kZXgpKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgLCB2YWx1ZSA9IHRyaW0ocm93LnNsaWNlKGluZGV4ICsgMSkpXG5cbiAgICAgICAgaWYgKHR5cGVvZihyZXN1bHRba2V5XSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZVxuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IFsgcmVzdWx0W2tleV0sIHZhbHVlIF1cbiAgICAgICAgfVxuICAgICAgfVxuICApXG5cbiAgcmV0dXJuIHJlc3VsdFxufSIsIm1vZHVsZS5leHBvcnRzID0gU2FmZVBhcnNlVHVwbGVcblxuZnVuY3Rpb24gU2FmZVBhcnNlVHVwbGUob2JqLCByZXZpdmVyKSB7XG4gICAgdmFyIGpzb25cbiAgICB2YXIgZXJyb3IgPSBudWxsXG5cbiAgICB0cnkge1xuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShvYmosIHJldml2ZXIpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9yID0gZXJyXG4gICAgfVxuXG4gICAgcmV0dXJuIFtlcnJvciwganNvbl1cbn1cbiIsIlxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHJpbTtcblxuZnVuY3Rpb24gdHJpbShzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTtcbn1cblxuZXhwb3J0cy5sZWZ0ID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKTtcbn07XG5cbmV4cG9ydHMucmlnaHQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xccyokLywgJycpO1xufTtcbiIsImZ1bmN0aW9uIGNsZWFuIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1xcblxccj9cXHMqL2csICcnKVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHNtbCAoc2EpIHtcbiAgdmFyIHMgPSAnJ1xuICAgICwgaSA9IDBcblxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICBzICs9IGNsZWFuKHNhW2ldKSArIChhcmd1bWVudHNbaSArIDFdIHx8ICcnKVxuXG4gIHJldHVybiBzXG59IiwiLyoqXG4gKiBAbGljZW5zZVxuICogVmlkZW8uanMgNi4yLjQgPGh0dHA6Ly92aWRlb2pzLmNvbS8+XG4gKiBDb3B5cmlnaHQgQnJpZ2h0Y292ZSwgSW5jLiA8aHR0cHM6Ly93d3cuYnJpZ2h0Y292ZS5jb20vPlxuICogQXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wXG4gKiA8aHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvYmxvYi9tYXN0ZXIvTElDRU5TRT5cbiAqXG4gKiBJbmNsdWRlcyB2dHQuanMgPGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3Z0dC5qcz5cbiAqIEF2YWlsYWJsZSB1bmRlciBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMFxuICogPGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3Z0dC5qcy9ibG9iL21hc3Rlci9MSUNFTlNFPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciB3aW5kb3cgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpKTtcbnZhciBkb2N1bWVudCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdnbG9iYWwvZG9jdW1lbnQnKSk7XG52YXIgdHNtbCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd0c21sJykpO1xudmFyIHNhZmVQYXJzZVR1cGxlID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3NhZmUtanNvbi1wYXJzZS90dXBsZScpKTtcbnZhciB4aHIgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgneGhyJykpO1xudmFyIHZ0dCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd2aWRlb2pzLXZ0dC5qcycpKTtcblxudmFyIHZlcnNpb24gPSBcIjYuMi40XCI7XG5cbi8qKlxuICogQGZpbGUgYnJvd3Nlci5qc1xuICogQG1vZHVsZSBicm93c2VyXG4gKi9cbnZhciBVU0VSX0FHRU5UID0gd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbnZhciB3ZWJraXRWZXJzaW9uTWFwID0gL0FwcGxlV2ViS2l0XFwvKFtcXGQuXSspL2kuZXhlYyhVU0VSX0FHRU5UKTtcbnZhciBhcHBsZVdlYmtpdFZlcnNpb24gPSB3ZWJraXRWZXJzaW9uTWFwID8gcGFyc2VGbG9hdCh3ZWJraXRWZXJzaW9uTWFwLnBvcCgpKSA6IG51bGw7XG5cbi8qXG4gKiBEZXZpY2UgaXMgYW4gaVBob25lXG4gKlxuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAY29uc3RhbnRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBJU19JUEFEID0gL2lQYWQvaS50ZXN0KFVTRVJfQUdFTlQpO1xuXG4vLyBUaGUgRmFjZWJvb2sgYXBwJ3MgVUlXZWJWaWV3IGlkZW50aWZpZXMgYXMgYm90aCBhbiBpUGhvbmUgYW5kIGlQYWQsIHNvXG4vLyB0byBpZGVudGlmeSBpUGhvbmVzLCB3ZSBuZWVkIHRvIGV4Y2x1ZGUgaVBhZHMuXG4vLyBodHRwOi8vYXJ0c3kuZ2l0aHViLmlvL2Jsb2cvMjAxMi8xMC8xOC90aGUtcGVyaWxzLW9mLWlvcy11c2VyLWFnZW50LXNuaWZmaW5nL1xudmFyIElTX0lQSE9ORSA9IC9pUGhvbmUvaS50ZXN0KFVTRVJfQUdFTlQpICYmICFJU19JUEFEO1xudmFyIElTX0lQT0QgPSAvaVBvZC9pLnRlc3QoVVNFUl9BR0VOVCk7XG52YXIgSVNfSU9TID0gSVNfSVBIT05FIHx8IElTX0lQQUQgfHwgSVNfSVBPRDtcblxudmFyIElPU19WRVJTSU9OID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWF0Y2ggPSBVU0VSX0FHRU5ULm1hdGNoKC9PUyAoXFxkKylfL2kpO1xuXG4gIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkge1xuICAgIHJldHVybiBtYXRjaFsxXTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0oKTtcblxudmFyIElTX0FORFJPSUQgPSAvQW5kcm9pZC9pLnRlc3QoVVNFUl9BR0VOVCk7XG52YXIgQU5EUk9JRF9WRVJTSU9OID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaGlzIG1hdGNoZXMgQW5kcm9pZCBNYWpvci5NaW5vci5QYXRjaCB2ZXJzaW9uc1xuICAvLyBBTkRST0lEX1ZFUlNJT04gaXMgTWFqb3IuTWlub3IgYXMgYSBOdW1iZXIsIGlmIE1pbm9yIGlzbid0IGF2YWlsYWJsZSwgdGhlbiBvbmx5IE1ham9yIGlzIHJldHVybmVkXG4gIHZhciBtYXRjaCA9IFVTRVJfQUdFTlQubWF0Y2goL0FuZHJvaWQgKFxcZCspKD86XFwuKFxcZCspKT8oPzpcXC4oXFxkKykpKi9pKTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWFqb3IgPSBtYXRjaFsxXSAmJiBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIG1pbm9yID0gbWF0Y2hbMl0gJiYgcGFyc2VGbG9hdChtYXRjaFsyXSk7XG5cbiAgaWYgKG1ham9yICYmIG1pbm9yKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMV0gKyAnLicgKyBtYXRjaFsyXSk7XG4gIH0gZWxzZSBpZiAobWFqb3IpIHtcbiAgICByZXR1cm4gbWFqb3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KCk7XG5cbi8vIE9sZCBBbmRyb2lkIGlzIGRlZmluZWQgYXMgVmVyc2lvbiBvbGRlciB0aGFuIDIuMywgYW5kIHJlcXVpcmluZyBhIHdlYmtpdCB2ZXJzaW9uIG9mIHRoZSBhbmRyb2lkIGJyb3dzZXJcbnZhciBJU19PTERfQU5EUk9JRCA9IElTX0FORFJPSUQgJiYgL3dlYmtpdC9pLnRlc3QoVVNFUl9BR0VOVCkgJiYgQU5EUk9JRF9WRVJTSU9OIDwgMi4zO1xudmFyIElTX05BVElWRV9BTkRST0lEID0gSVNfQU5EUk9JRCAmJiBBTkRST0lEX1ZFUlNJT04gPCA1ICYmIGFwcGxlV2Via2l0VmVyc2lvbiA8IDUzNztcblxudmFyIElTX0ZJUkVGT1ggPSAvRmlyZWZveC9pLnRlc3QoVVNFUl9BR0VOVCk7XG52YXIgSVNfRURHRSA9IC9FZGdlL2kudGVzdChVU0VSX0FHRU5UKTtcbnZhciBJU19DSFJPTUUgPSAhSVNfRURHRSAmJiAvQ2hyb21lL2kudGVzdChVU0VSX0FHRU5UKTtcbnZhciBDSFJPTUVfVkVSU0lPTiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1hdGNoID0gVVNFUl9BR0VOVC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG5cbiAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB9XG4gIHJldHVybiBudWxsO1xufSgpO1xudmFyIElTX0lFOCA9IC9NU0lFXFxzOFxcLjAvLnRlc3QoVVNFUl9BR0VOVCk7XG52YXIgSUVfVkVSU0lPTiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlc3VsdCA9IC9NU0lFXFxzKFxcZCspXFwuXFxkLy5leGVjKFVTRVJfQUdFTlQpO1xuICB2YXIgdmVyc2lvbiA9IHJlc3VsdCAmJiBwYXJzZUZsb2F0KHJlc3VsdFsxXSk7XG5cbiAgaWYgKCF2ZXJzaW9uICYmIC9UcmlkZW50XFwvNy4wL2kudGVzdChVU0VSX0FHRU5UKSAmJiAvcnY6MTEuMC8udGVzdChVU0VSX0FHRU5UKSkge1xuICAgIC8vIElFIDExIGhhcyBhIGRpZmZlcmVudCB1c2VyIGFnZW50IHN0cmluZyB0aGFuIG90aGVyIElFIHZlcnNpb25zXG4gICAgdmVyc2lvbiA9IDExLjA7XG4gIH1cblxuICByZXR1cm4gdmVyc2lvbjtcbn0oKTtcblxudmFyIElTX1NBRkFSSSA9IC9TYWZhcmkvaS50ZXN0KFVTRVJfQUdFTlQpICYmICFJU19DSFJPTUUgJiYgIUlTX0FORFJPSUQgJiYgIUlTX0VER0U7XG52YXIgSVNfQU5ZX1NBRkFSSSA9IElTX1NBRkFSSSB8fCBJU19JT1M7XG5cbnZhciBUT1VDSF9FTkFCTEVEID0gaXNSZWFsKCkgJiYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiB3aW5kb3cuZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaCk7XG5cbnZhciBCQUNLR1JPVU5EX1NJWkVfU1VQUE9SVEVEID0gaXNSZWFsKCkgJiYgJ2JhY2tncm91bmRTaXplJyBpbiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKS5zdHlsZTtcblxudmFyIGJyb3dzZXIgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0SVNfSVBBRDogSVNfSVBBRCxcblx0SVNfSVBIT05FOiBJU19JUEhPTkUsXG5cdElTX0lQT0Q6IElTX0lQT0QsXG5cdElTX0lPUzogSVNfSU9TLFxuXHRJT1NfVkVSU0lPTjogSU9TX1ZFUlNJT04sXG5cdElTX0FORFJPSUQ6IElTX0FORFJPSUQsXG5cdEFORFJPSURfVkVSU0lPTjogQU5EUk9JRF9WRVJTSU9OLFxuXHRJU19PTERfQU5EUk9JRDogSVNfT0xEX0FORFJPSUQsXG5cdElTX05BVElWRV9BTkRST0lEOiBJU19OQVRJVkVfQU5EUk9JRCxcblx0SVNfRklSRUZPWDogSVNfRklSRUZPWCxcblx0SVNfRURHRTogSVNfRURHRSxcblx0SVNfQ0hST01FOiBJU19DSFJPTUUsXG5cdENIUk9NRV9WRVJTSU9OOiBDSFJPTUVfVkVSU0lPTixcblx0SVNfSUU4OiBJU19JRTgsXG5cdElFX1ZFUlNJT046IElFX1ZFUlNJT04sXG5cdElTX1NBRkFSSTogSVNfU0FGQVJJLFxuXHRJU19BTllfU0FGQVJJOiBJU19BTllfU0FGQVJJLFxuXHRUT1VDSF9FTkFCTEVEOiBUT1VDSF9FTkFCTEVELFxuXHRCQUNLR1JPVU5EX1NJWkVfU1VQUE9SVEVEOiBCQUNLR1JPVU5EX1NJWkVfU1VQUE9SVEVEXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UgPSBmdW5jdGlvbiAoc3RyaW5ncywgcmF3KSB7XG4gIHN0cmluZ3MucmF3ID0gcmF3O1xuICByZXR1cm4gc3RyaW5ncztcbn07XG5cbi8qKlxuICogQGZpbGUgb2JqLmpzXG4gKiBAbW9kdWxlIG9ialxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9iajpFYWNoQ2FsbGJhY2tcbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogICAgICAgIFRoZSBjdXJyZW50IGtleSBmb3IgdGhlIG9iamVjdCB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogICAgICAgIFRoZSBjdXJyZW50IGtleS12YWx1ZSBmb3Igb2JqZWN0IHRoYXQgaXMgYmVpbmcgaXRlcmF0ZWQgb3ZlclxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9iajpSZWR1Y2VDYWxsYmFja1xuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFjY3VtXG4gKiAgICAgICAgVGhlIHZhbHVlIHRoYXQgaXMgYWNjdW11bGF0aW5nIG92ZXIgdGhlIHJlZHVjZSBsb29wLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiAgICAgICAgVGhlIGN1cnJlbnQga2V5IGZvciB0aGUgb2JqZWN0IHRoYXQgaXMgYmVpbmcgaXRlcmF0ZWQgb3Zlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiAgICAgICAgVGhlIGN1cnJlbnQga2V5LXZhbHVlIGZvciBvYmplY3QgdGhhdCBpcyBiZWluZyBpdGVyYXRlZCBvdmVyXG4gKlxuICogQHJldHVybiB7TWl4ZWR9XG4gKiAgICAgICAgIFRoZSBuZXcgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogR2V0IHRoZSBrZXlzIG9mIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogICAgICAgIFRoZSBPYmplY3QgdG8gZ2V0IHRoZSBrZXlzIGZyb21cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX1cbiAqICAgICAgICAgQW4gYXJyYXkgb2YgdGhlIGtleXMgZnJvbSB0aGUgb2JqZWN0LiBSZXR1cm5zIGFuIGVtcHR5IGFycmF5IGlmIHRoZVxuICogICAgICAgICBvYmplY3QgcGFzc2VkIGluIHdhcyBpbnZhbGlkIG9yIGhhZCBubyBrZXlzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBrZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgPyBPYmplY3Qua2V5cyhvYmplY3QpIDogW107XG59O1xuXG4vKipcbiAqIEFycmF5LWxpa2UgaXRlcmF0aW9uIGZvciBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqICAgICAgICBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3ZlclxuICpcbiAqIEBwYXJhbSB7b2JqOkVhY2hDYWxsYmFja30gZm5cbiAqICAgICAgICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGZvciBlYWNoIGtleSBpbiB0aGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBlYWNoKG9iamVjdCwgZm4pIHtcbiAga2V5cyhvYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBmbihvYmplY3Rba2V5XSwga2V5KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQXJyYXktbGlrZSByZWR1Y2UgZm9yIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogICAgICAgIFRoZSBPYmplY3QgdGhhdCB5b3Ugd2FudCB0byByZWR1Y2UuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqICAgICAgICAgQSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZm9yIGVhY2gga2V5IGluIHRoZSBvYmplY3QuIEl0XG4gKiAgICAgICAgIHJlY2VpdmVzIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBhbmQgdGhlIHBlci1pdGVyYXRpb24gdmFsdWUgYW5kIGtleVxuICogICAgICAgICBhcyBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gW2luaXRpYWwgPSAwXVxuICogICAgICAgIFN0YXJ0aW5nIHZhbHVlXG4gKlxuICogQHJldHVybiB7TWl4ZWR9XG4gKiAgICAgICAgIFRoZSBmaW5hbCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcmVkdWNlKG9iamVjdCwgZm4pIHtcbiAgdmFyIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG5cbiAgcmV0dXJuIGtleXMob2JqZWN0KS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtLCBrZXkpIHtcbiAgICByZXR1cm4gZm4oYWNjdW0sIG9iamVjdFtrZXldLCBrZXkpO1xuICB9LCBpbml0aWFsKTtcbn1cblxuLyoqXG4gKiBPYmplY3QuYXNzaWduLXN0eWxlIG9iamVjdCBzaGFsbG93IG1lcmdlL2V4dGVuZC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtICB7T2JqZWN0fSAuLi5zb3VyY2VzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc291cmNlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoT2JqZWN0LmFzc2lnbikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgW3RhcmdldF0uY29uY2F0KHNvdXJjZXMpKTtcbiAgfVxuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlYWNoKHNvdXJjZSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgdmFsdWUgaXMgYW4gb2JqZWN0IG9mIGFueSBraW5kIC0gaW5jbHVkaW5nIERPTSBub2RlcyxcbiAqIGFycmF5cywgcmVndWxhciBleHByZXNzaW9ucywgZXRjLiBOb3QgZnVuY3Rpb25zLCB0aG91Z2guXG4gKlxuICogVGhpcyBhdm9pZHMgdGhlIGdvdGNoYSB3aGVyZSB1c2luZyBgdHlwZW9mYCBvbiBhIGBudWxsYCB2YWx1ZVxuICogcmVzdWx0cyBpbiBgJ29iamVjdCdgLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgYXBwZWFycyB0byBiZSBhIFwicGxhaW5cIiBvYmplY3QgLSB0aGF0IGlzLCBhXG4gKiBkaXJlY3QgaW5zdGFuY2Ugb2YgYE9iamVjdGAuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufVxuXG4vKipcbiAqIEBmaWxlIGxvZy5qc1xuICogQG1vZHVsZSBsb2dcbiAqL1xudmFyIGxvZyA9IHZvaWQgMDtcblxuLy8gVGhpcyBpcyB0aGUgcHJpdmF0ZSB0cmFja2luZyB2YXJpYWJsZSBmb3IgbG9nZ2luZyBsZXZlbC5cbnZhciBsZXZlbCA9ICdhbGwnO1xuXG4vLyBUaGlzIGlzIHRoZSBwcml2YXRlIHRyYWNraW5nIHZhcmlhYmxlIGZvciB0aGUgbG9nZ2luZyBoaXN0b3J5LlxudmFyIGhpc3RvcnkgPSBbXTtcblxuLyoqXG4gKiBMb2cgbWVzc2FnZXMgdG8gdGhlIGNvbnNvbGUgYW5kIGhpc3RvcnkgYmFzZWQgb24gdGhlIHR5cGUgb2YgbWVzc2FnZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGNvbnNvbGUgbWV0aG9kIHRvIHVzZS5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJnc1xuICogICAgICAgICBUaGUgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byB0aGUgbWF0Y2hpbmcgY29uc29sZSBtZXRob2QuXG4gKlxuICogQHBhcmFtICB7Ym9vbGVhbn0gW3N0cmluZ2lmeV1cbiAqICAgICAgICAgQnkgZGVmYXVsdCwgb25seSBvbGQgSUVzIHNob3VsZCBnZXQgY29uc29sZSBhcmd1bWVudCBzdHJpbmdpZmljYXRpb24sXG4gKiAgICAgICAgIGJ1dCB0aGlzIGlzIGV4cG9zZWQgYXMgYSBwYXJhbWV0ZXIgdG8gZmFjaWxpdGF0ZSB0ZXN0aW5nLlxuICovXG52YXIgbG9nQnlUeXBlID0gZnVuY3Rpb24gbG9nQnlUeXBlKHR5cGUsIGFyZ3MpIHtcbiAgdmFyIHN0cmluZ2lmeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogISFJRV9WRVJTSU9OICYmIElFX1ZFUlNJT04gPCAxMTtcblxuICB2YXIgbHZsID0gbG9nLmxldmVsc1tsZXZlbF07XG4gIHZhciBsdmxSZWdFeHAgPSBuZXcgUmVnRXhwKCdeKCcgKyBsdmwgKyAnKSQnKTtcblxuICBpZiAodHlwZSAhPT0gJ2xvZycpIHtcblxuICAgIC8vIEFkZCB0aGUgdHlwZSB0byB0aGUgZnJvbnQgb2YgdGhlIG1lc3NhZ2Ugd2hlbiBpdCdzIG5vdCBcImxvZ1wiLlxuICAgIGFyZ3MudW5zaGlmdCh0eXBlLnRvVXBwZXJDYXNlKCkgKyAnOicpO1xuICB9XG5cbiAgLy8gQWRkIGEgY2xvbmUgb2YgdGhlIGFyZ3MgYXQgdGhpcyBwb2ludCB0byBoaXN0b3J5LlxuICBpZiAoaGlzdG9yeSkge1xuICAgIGhpc3RvcnkucHVzaChbXS5jb25jYXQoYXJncykpO1xuICB9XG5cbiAgLy8gQWRkIGNvbnNvbGUgcHJlZml4IGFmdGVyIGFkZGluZyB0byBoaXN0b3J5LlxuICBhcmdzLnVuc2hpZnQoJ1ZJREVPSlM6Jyk7XG5cbiAgLy8gSWYgdGhlcmUncyBubyBjb25zb2xlIHRoZW4gZG9uJ3QgdHJ5IHRvIG91dHB1dCBtZXNzYWdlcywgYnV0IHRoZXkgd2lsbFxuICAvLyBzdGlsbCBiZSBzdG9yZWQgaW4gaGlzdG9yeS5cbiAgLy9cbiAgLy8gV2FzIHNldHRpbmcgdGhlc2Ugb25jZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24sIGJ1dCBjb250YWluaW5nIHRoZW1cbiAgLy8gaW4gdGhlIGZ1bmN0aW9uIG1ha2VzIGl0IGVhc2llciB0byB0ZXN0IGNhc2VzIHdoZXJlIGNvbnNvbGUgZG9lc24ndCBleGlzdFxuICAvLyB3aGVuIHRoZSBtb2R1bGUgaXMgZXhlY3V0ZWQuXG4gIHZhciBmbiA9IHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlW3R5cGVdO1xuXG4gIC8vIEJhaWwgb3V0IGlmIHRoZXJlJ3Mgbm8gY29uc29sZSBvciBpZiB0aGlzIHR5cGUgaXMgbm90IGFsbG93ZWQgYnkgdGhlXG4gIC8vIGN1cnJlbnQgbG9nZ2luZyBsZXZlbC5cbiAgaWYgKCFmbiB8fCAhbHZsIHx8ICFsdmxSZWdFeHAudGVzdCh0eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElFcyBwcmV2aW91cyB0byAxMSBsb2cgb2JqZWN0cyB1c2VsZXNzbHkgYXMgXCJbb2JqZWN0IE9iamVjdF1cIjsgc28sIEpTT05pZnlcbiAgLy8gb2JqZWN0cyBhbmQgYXJyYXlzIGZvciB0aG9zZSBsZXNzLWNhcGFibGUgYnJvd3NlcnMuXG4gIGlmIChzdHJpbmdpZnkpIHtcbiAgICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgIGlmIChpc09iamVjdChhKSB8fCBBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhhKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDYXN0IHRvIHN0cmluZyBiZWZvcmUgam9pbmluZywgc28gd2UgZ2V0IG51bGwgYW5kIHVuZGVmaW5lZCBleHBsaWNpdGx5XG4gICAgICAvLyBpbmNsdWRlZCBpbiBvdXRwdXQgKGFzIHdlIHdvdWxkIGluIGEgbW9kZXJuIGNvbnNvbGUpLlxuICAgICAgcmV0dXJuIFN0cmluZyhhKTtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cblxuICAvLyBPbGQgSUUgdmVyc2lvbnMgZG8gbm90IGFsbG93IC5hcHBseSgpIGZvciBjb25zb2xlIG1ldGhvZHMgKHRoZXkgYXJlXG4gIC8vIHJlcG9ydGVkIGFzIG9iamVjdHMgcmF0aGVyIHRoYW4gZnVuY3Rpb25zKS5cbiAgaWYgKCFmbi5hcHBseSkge1xuICAgIGZuKGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIGZuW0FycmF5LmlzQXJyYXkoYXJncykgPyAnYXBwbHknIDogJ2NhbGwnXSh3aW5kb3cuY29uc29sZSwgYXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogTG9ncyBwbGFpbiBkZWJ1ZyBtZXNzYWdlcy4gU2ltaWxhciB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtICAgIHtNaXhlZFtdfSBhcmdzXG4gKiAgICAgICAgICAgT25lIG9yIG1vcmUgbWVzc2FnZXMgb3Igb2JqZWN0cyB0aGF0IHNob3VsZCBiZSBsb2dnZWQuXG4gKi9cbmxvZyA9IGZ1bmN0aW9uIGxvZygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgbG9nQnlUeXBlKCdsb2cnLCBhcmdzKTtcbn07XG5cbi8qKlxuICogRW51bWVyYXRpb24gb2YgYXZhaWxhYmxlIGxvZ2dpbmcgbGV2ZWxzLCB3aGVyZSB0aGUga2V5cyBhcmUgdGhlIGxldmVsIG5hbWVzXG4gKiBhbmQgdGhlIHZhbHVlcyBhcmUgYHxgLXNlcGFyYXRlZCBzdHJpbmdzIGNvbnRhaW5pbmcgbG9nZ2luZyBtZXRob2RzIGFsbG93ZWRcbiAqIGluIHRoYXQgbG9nZ2luZyBsZXZlbC4gVGhlc2Ugc3RyaW5ncyBhcmUgdXNlZCB0byBjcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb25cbiAqIG1hdGNoaW5nIHRoZSBmdW5jdGlvbiBuYW1lIGJlaW5nIGNhbGxlZC5cbiAqXG4gKiBMZXZlbHMgcHJvdmlkZWQgYnkgdmlkZW8uanMgYXJlOlxuICpcbiAqIC0gYG9mZmA6IE1hdGNoZXMgbm8gY2FsbHMuIEFueSB2YWx1ZSB0aGF0IGNhbiBiZSBjYXN0IHRvIGBmYWxzZWAgd2lsbCBoYXZlXG4gKiAgIHRoaXMgZWZmZWN0LiBUaGUgbW9zdCByZXN0cmljdGl2ZS5cbiAqIC0gYGFsbGAgKGRlZmF1bHQpOiBNYXRjaGVzIG9ubHkgVmlkZW8uanMtcHJvdmlkZWQgZnVuY3Rpb25zIChgbG9nYCxcbiAqICAgYGxvZy53YXJuYCwgYW5kIGBsb2cuZXJyb3JgKS5cbiAqIC0gYHdhcm5gOiBNYXRjaGVzIGBsb2cud2FybmAgYW5kIGBsb2cuZXJyb3JgIGNhbGxzLlxuICogLSBgZXJyb3JgOiBNYXRjaGVzIG9ubHkgYGxvZy5lcnJvcmAgY2FsbHMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xubG9nLmxldmVscyA9IHtcbiAgYWxsOiAnbG9nfHdhcm58ZXJyb3InLFxuICBlcnJvcjogJ2Vycm9yJyxcbiAgb2ZmOiAnJyxcbiAgd2FybjogJ3dhcm58ZXJyb3InLFxuICBERUZBVUxUOiBsZXZlbFxufTtcblxuLyoqXG4gKiBHZXQgb3Igc2V0IHRoZSBjdXJyZW50IGxvZ2dpbmcgbGV2ZWwuIElmIGEgc3RyaW5nIG1hdGNoaW5nIGEga2V5IGZyb21cbiAqIHtAbGluayBsb2cubGV2ZWxzfSBpcyBwcm92aWRlZCwgYWN0cyBhcyBhIHNldHRlci4gUmVnYXJkbGVzcyBvZiBhcmd1bWVudCxcbiAqIHJldHVybnMgdGhlIGN1cnJlbnQgbG9nZ2luZyBsZXZlbC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IFtsdmxdXG4gKiAgICAgICAgIFBhc3MgdG8gc2V0IGEgbmV3IGxvZ2dpbmcgbGV2ZWwuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgY3VycmVudCBsb2dnaW5nIGxldmVsLlxuICovXG5sb2cubGV2ZWwgPSBmdW5jdGlvbiAobHZsKSB7XG4gIGlmICh0eXBlb2YgbHZsID09PSAnc3RyaW5nJykge1xuICAgIGlmICghbG9nLmxldmVscy5oYXNPd25Qcm9wZXJ0eShsdmwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGx2bCArICdcIiBpbiBub3QgYSB2YWxpZCBsb2cgbGV2ZWwnKTtcbiAgICB9XG4gICAgbGV2ZWwgPSBsdmw7XG4gIH1cbiAgcmV0dXJuIGxldmVsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgZXZlcnl0aGluZyB0aGF0IGhhcyBiZWVuIGxvZ2dlZCB0byB0aGUgaGlzdG9yeS5cbiAqXG4gKiBUaGlzIGFycmF5IGlzIGEgc2hhbGxvdyBjbG9uZSBvZiB0aGUgaW50ZXJuYWwgaGlzdG9yeSByZWNvcmQuIEhvd2V2ZXIsIGl0c1xuICogY29udGVudHMgYXJlIF9ub3RfIGNsb25lZDsgc28sIG11dGF0aW5nIG9iamVjdHMgaW5zaWRlIHRoaXMgYXJyYXkgd2lsbFxuICogbXV0YXRlIHRoZW0gaW4gaGlzdG9yeS5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xubG9nLmhpc3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBoaXN0b3J5ID8gW10uY29uY2F0KGhpc3RvcnkpIDogW107XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgaW50ZXJuYWwgaGlzdG9yeSB0cmFja2luZywgYnV0IGRvZXMgbm90IHByZXZlbnQgZnVydGhlciBoaXN0b3J5XG4gKiB0cmFja2luZy5cbiAqL1xubG9nLmhpc3RvcnkuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChoaXN0b3J5KSB7XG4gICAgaGlzdG9yeS5sZW5ndGggPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIERpc2FibGUgaGlzdG9yeSB0cmFja2luZyBpZiBpdCBpcyBjdXJyZW50bHkgZW5hYmxlZC5cbiAqL1xubG9nLmhpc3RvcnkuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGhpc3RvcnkgIT09IG51bGwpIHtcbiAgICBoaXN0b3J5Lmxlbmd0aCA9IDA7XG4gICAgaGlzdG9yeSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogRW5hYmxlIGhpc3RvcnkgdHJhY2tpbmcgaWYgaXQgaXMgY3VycmVudGx5IGRpc2FibGVkLlxuICovXG5sb2cuaGlzdG9yeS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChoaXN0b3J5ID09PSBudWxsKSB7XG4gICAgaGlzdG9yeSA9IFtdO1xuICB9XG59O1xuXG4vKipcbiAqIExvZ3MgZXJyb3IgbWVzc2FnZXMuIFNpbWlsYXIgdG8gYGNvbnNvbGUuZXJyb3JgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWRbXX0gYXJnc1xuICogICAgICAgIE9uZSBvciBtb3JlIG1lc3NhZ2VzIG9yIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgbG9nZ2VkIGFzIGFuIGVycm9yXG4gKi9cbmxvZy5lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICByZXR1cm4gbG9nQnlUeXBlKCdlcnJvcicsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBMb2dzIHdhcm5pbmcgbWVzc2FnZXMuIFNpbWlsYXIgdG8gYGNvbnNvbGUud2FybmAuXG4gKlxuICogQHBhcmFtIHtNaXhlZFtdfSBhcmdzXG4gKiAgICAgICAgT25lIG9yIG1vcmUgbWVzc2FnZXMgb3Igb2JqZWN0cyB0aGF0IHNob3VsZCBiZSBsb2dnZWQgYXMgYSB3YXJuaW5nLlxuICovXG5sb2cud2FybiA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICByZXR1cm4gbG9nQnlUeXBlKCd3YXJuJywgYXJncyk7XG59O1xuXG52YXIgbG9nJDEgPSBsb2c7XG5cbi8qKlxuICogQGZpbGUgY29tcHV0ZWQtc3R5bGUuanNcbiAqIEBtb2R1bGUgY29tcHV0ZWQtc3R5bGVcbiAqL1xuLyoqXG4gKiBBIHNhZmUgZ2V0Q29tcHV0ZWRTdHlsZSB3aXRoIGFuIElFOCBmYWxsYmFjay5cbiAqXG4gKiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIGluIEZpcmVmb3gsIGlmIHRoZSBwbGF5ZXIgaXMgbG9hZGVkIGluIGFuIGlmcmFtZSB3aXRoXG4gKiBgZGlzcGxheTpub25lYCwgdGhlbiBgZ2V0Q29tcHV0ZWRTdHlsZWAgcmV0dXJucyBgbnVsbGAsIHNvLCB3ZSBkbyBhIG51bGwtY2hlY2sgdG9cbiAqIG1ha2Ugc3VyZSAgdGhhdCB0aGUgcGxheWVyIGRvZXNuJ3QgYnJlYWsgaW4gdGhlc2UgY2FzZXMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIFRoZSBlbGVtZW50IHlvdSB3YW50IHRoZSBjb21wdXRlZCBzdHlsZSBvZlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiAgICAgICAgVGhlIHByb3BlcnR5IG5hbWUgeW91IHdhbnRcbiAqXG4gKiBAc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdFxuICovXG5mdW5jdGlvbiBjb21wdXRlZFN0eWxlKGVsLCBwcm9wKSB7XG4gIGlmICghZWwgfHwgIXByb3ApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGNzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuXG4gICAgcmV0dXJuIGNzID8gY3NbcHJvcF0gOiAnJztcbiAgfVxuXG4gIHJldHVybiBlbC5jdXJyZW50U3R5bGVbcHJvcF0gfHwgJyc7XG59XG5cbnZhciBfdGVtcGxhdGVPYmplY3QgPSB0YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZShbJ1NldHRpbmcgYXR0cmlidXRlcyBpbiB0aGUgc2Vjb25kIGFyZ3VtZW50IG9mIGNyZWF0ZUVsKClcXG4gICAgICAgICAgICAgICAgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIHRoZSB0aGlyZCBhcmd1bWVudCBpbnN0ZWFkLlxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbCh0eXBlLCBwcm9wZXJ0aWVzLCBhdHRyaWJ1dGVzKS4gQXR0ZW1wdGluZyB0byBzZXQgJywgJyB0byAnLCAnLiddLCBbJ1NldHRpbmcgYXR0cmlidXRlcyBpbiB0aGUgc2Vjb25kIGFyZ3VtZW50IG9mIGNyZWF0ZUVsKClcXG4gICAgICAgICAgICAgICAgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIHRoZSB0aGlyZCBhcmd1bWVudCBpbnN0ZWFkLlxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbCh0eXBlLCBwcm9wZXJ0aWVzLCBhdHRyaWJ1dGVzKS4gQXR0ZW1wdGluZyB0byBzZXQgJywgJyB0byAnLCAnLiddKTtcblxuLyoqXG4gKiBAZmlsZSBkb20uanNcbiAqIEBtb2R1bGUgZG9tXG4gKi9cbi8qKlxuICogRGV0ZWN0IGlmIGEgdmFsdWUgaXMgYSBzdHJpbmcgd2l0aCBhbnkgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiAgICAgICAgVGhlIHN0cmluZyB0byBjaGVja1xuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIG5vbi1ibGFua1xuICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICpcbiAqL1xuZnVuY3Rpb24gaXNOb25CbGFua1N0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICYmIC9cXFMvLnRlc3Qoc3RyKTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHBhc3NlZCBzdHJpbmcgaGFzIHdoaXRlc3BhY2UuIFRoaXMgaXMgdXNlZCBieVxuICogY2xhc3MgbWV0aG9kcyB0byBiZSByZWxhdGl2ZWx5IGNvbnNpc3RlbnQgd2l0aCB0aGUgY2xhc3NMaXN0IEFQSS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiAgICAgICAgIFRoZSBzdHJpbmcgdG8gY2hlY2sgZm9yIHdoaXRlc3BhY2UuXG4gKlxuICogQHRocm93cyB7RXJyb3J9XG4gKiAgICAgICAgIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBpcyB3aGl0ZXNwYWNlIGluIHRoZSBzdHJpbmcuXG4gKlxuICovXG5mdW5jdGlvbiB0aHJvd0lmV2hpdGVzcGFjZShzdHIpIHtcbiAgaWYgKC9cXHMvLnRlc3Qoc3RyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xhc3MgaGFzIGlsbGVnYWwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9kdWNlIGEgcmVndWxhciBleHByZXNzaW9uIGZvciBtYXRjaGluZyBhIGNsYXNzTmFtZSB3aXRoaW4gYW4gZWxlbWVudHMgY2xhc3NOYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAqICAgICAgICAgVGhlIGNsYXNzTmFtZSB0byBnZW5lcmF0ZSB0aGUgUmVnRXhwIGZvci5cbiAqXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiAgICAgICAgIFRoZSBSZWdFeHAgdGhhdCB3aWxsIGNoZWNrIGZvciBhIHNwZWNpZmljIGBjbGFzc05hbWVgIGluIGFuIGVsZW1lbnRzXG4gKiAgICAgICAgIGNsYXNzTmFtZS5cbiAqL1xuZnVuY3Rpb24gY2xhc3NSZWdFeHAoY2xhc3NOYW1lKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgY2xhc3NOYW1lICsgJygkfFxcXFxzKScpO1xufVxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGN1cnJlbnQgRE9NIGludGVyZmFjZSBhcHBlYXJzIHRvIGJlIHJlYWwuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNSZWFsKCkge1xuICByZXR1cm4gKFxuXG4gICAgLy8gQm90aCBkb2N1bWVudCBhbmQgd2luZG93IHdpbGwgbmV2ZXIgYmUgdW5kZWZpbmVkIHRoYW5rcyB0byBgZ2xvYmFsYC5cbiAgICBkb2N1bWVudCA9PT0gd2luZG93LmRvY3VtZW50ICYmXG5cbiAgICAvLyBJbiBJRSA8IDksIERPTSBtZXRob2RzIHJldHVybiBcIm9iamVjdFwiIGFzIHRoZWlyIHR5cGUsIHNvIGFsbCB3ZSBjYW5cbiAgICAvLyBjb25maWRlbnRseSBjaGVjayBpcyB0aGF0IGl0IGV4aXN0cy5cbiAgICB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzLCB2aWEgZHVjayB0eXBpbmcsIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUgaXMgYSBET00gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogICAgICAgIFRoZSB0aGluZyB0byBjaGVja1xuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiBpdCBpcyBhIERPTSBlbGVtZW50XG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzRWwodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGZ1bmN0aW9ucyB0byBxdWVyeSB0aGUgRE9NIHVzaW5nIGEgZ2l2ZW4gbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqICAgICAgICAgVGhlIG1ldGhvZCB0byBjcmVhdGUgdGhlIHF1ZXJ5IHdpdGguXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiAgICAgICAgIFRoZSBxdWVyeSBtZXRob2RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUXVlcmllcihtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCkge1xuICAgIGlmICghaXNOb25CbGFua1N0cmluZyhzZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudFttZXRob2RdKG51bGwpO1xuICAgIH1cbiAgICBpZiAoaXNOb25CbGFua1N0cmluZyhjb250ZXh0KSkge1xuICAgICAgY29udGV4dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGV4dCk7XG4gICAgfVxuXG4gICAgdmFyIGN0eCA9IGlzRWwoY29udGV4dCkgPyBjb250ZXh0IDogZG9jdW1lbnQ7XG5cbiAgICByZXR1cm4gY3R4W21ldGhvZF0gJiYgY3R4W21ldGhvZF0oc2VsZWN0b3IpO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZWxlbWVudCBhbmQgYXBwbGllcyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGFnTmFtZT0nZGl2J11cbiAqICAgICAgICAgTmFtZSBvZiB0YWcgdG8gYmUgY3JlYXRlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dXG4gKiAgICAgICAgIEVsZW1lbnQgcHJvcGVydGllcyB0byBiZSBhcHBsaWVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlcz17fV1cbiAqICAgICAgICAgRWxlbWVudCBhdHRyaWJ1dGVzIHRvIGJlIGFwcGxpZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxUZXh0Tm9kZXxBcnJheXxGdW5jdGlvbn0gW2NvbnRlbnRdXG4gKiAgICAgICAgIENvbnRlbnRzIGZvciB0aGUgZWxlbWVudCAoc2VlOiB7QGxpbmsgZG9tOm5vcm1hbGl6ZUNvbnRlbnR9KVxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICB2YXIgdGFnTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ2Rpdic7XG4gIHZhciBwcm9wZXJ0aWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgY29udGVudCA9IGFyZ3VtZW50c1szXTtcblxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgdmFyIHZhbCA9IHByb3BlcnRpZXNbcHJvcE5hbWVdO1xuXG4gICAgLy8gU2VlICMyMTc2XG4gICAgLy8gV2Ugb3JpZ2luYWxseSB3ZXJlIGFjY2VwdGluZyBib3RoIHByb3BlcnRpZXMgYW5kIGF0dHJpYnV0ZXMgaW4gdGhlXG4gICAgLy8gc2FtZSBvYmplY3QsIGJ1dCB0aGF0IGRvZXNuJ3Qgd29yayBzbyB3ZWxsLlxuICAgIGlmIChwcm9wTmFtZS5pbmRleE9mKCdhcmlhLScpICE9PSAtMSB8fCBwcm9wTmFtZSA9PT0gJ3JvbGUnIHx8IHByb3BOYW1lID09PSAndHlwZScpIHtcbiAgICAgIGxvZyQxLndhcm4odHNtbChfdGVtcGxhdGVPYmplY3QsIHByb3BOYW1lLCB2YWwpKTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShwcm9wTmFtZSwgdmFsKTtcblxuICAgICAgLy8gSGFuZGxlIHRleHRDb250ZW50IHNpbmNlIGl0J3Mgbm90IHN1cHBvcnRlZCBldmVyeXdoZXJlIGFuZCB3ZSBoYXZlIGFcbiAgICAgIC8vIG1ldGhvZCBmb3IgaXQuXG4gICAgfSBlbHNlIGlmIChwcm9wTmFtZSA9PT0gJ3RleHRDb250ZW50Jykge1xuICAgICAgdGV4dENvbnRlbnQoZWwsIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsW3Byb3BOYW1lXSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyaWJ1dGVzW2F0dHJOYW1lXSk7XG4gIH0pO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgYXBwZW5kQ29udGVudChlbCwgY29udGVudCk7XG4gIH1cblxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogSW5qZWN0cyB0ZXh0IGludG8gYW4gZWxlbWVudCwgcmVwbGFjaW5nIGFueSBleGlzdGluZyBjb250ZW50cyBlbnRpcmVseS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgVGhlIGVsZW1lbnQgdG8gYWRkIHRleHQgY29udGVudCBpbnRvXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqICAgICAgICBUaGUgdGV4dCBjb250ZW50IHRvIGFkZC5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB3aXRoIGFkZGVkIHRleHQgY29udGVudC5cbiAqL1xuZnVuY3Rpb24gdGV4dENvbnRlbnQoZWwsIHRleHQpIHtcbiAgaWYgKHR5cGVvZiBlbC50ZXh0Q29udGVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbC5pbm5lclRleHQgPSB0ZXh0O1xuICB9IGVsc2Uge1xuICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogSW5zZXJ0IGFuIGVsZW1lbnQgYXMgdGhlIGZpcnN0IGNoaWxkIG5vZGUgb2YgYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gY2hpbGRcbiAqICAgICAgICBFbGVtZW50IHRvIGluc2VydFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50XG4gKiAgICAgICAgRWxlbWVudCB0byBpbnNlcnQgY2hpbGQgaW50b1xuICovXG5mdW5jdGlvbiBwcmVwZW5kVG8oY2hpbGQsIHBhcmVudCkge1xuICBpZiAocGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBwYXJlbnQuZmlyc3RDaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaGFzIGEgQ1NTIGNsYXNzXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgICAgICAgRWxlbWVudCB0byBjaGVja1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvQ2hlY2tcbiAqICAgICAgICBDbGFzcyBuYW1lIHRvIGNoZWNrIGZvclxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgZWxlbWVudCBoYWQgdGhlIGNsYXNzXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogICAgICAgICBUaHJvd3MgYW4gZXJyb3IgaWYgYGNsYXNzVG9DaGVja2AgaGFzIHdoaXRlIHNwYWNlLlxuICovXG5mdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBjbGFzc1RvQ2hlY2spIHtcbiAgdGhyb3dJZldoaXRlc3BhY2UoY2xhc3NUb0NoZWNrKTtcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzVG9DaGVjayk7XG4gIH1cbiAgcmV0dXJuIGNsYXNzUmVnRXhwKGNsYXNzVG9DaGVjaykudGVzdChlbGVtZW50LmNsYXNzTmFtZSk7XG59XG5cbi8qKlxuICogQWRkIGEgQ1NTIGNsYXNzIG5hbWUgdG8gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogICAgICAgIEVsZW1lbnQgdG8gYWRkIGNsYXNzIG5hbWUgdG8uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9BZGRcbiAqICAgICAgICBDbGFzcyBuYW1lIHRvIGFkZC5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZG9tIGVsZW1lbnQgd2l0aCB0aGUgYWRkZWQgY2xhc3MgbmFtZS5cbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NUb0FkZCkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NUb0FkZCk7XG5cbiAgICAvLyBEb24ndCBuZWVkIHRvIGB0aHJvd0lmV2hpdGVzcGFjZWAgaGVyZSBiZWNhdXNlIGBoYXNFbENsYXNzYCB3aWxsIGRvIGl0XG4gICAgLy8gaW4gdGhlIGNhc2Ugb2YgY2xhc3NMaXN0IG5vdCBiZWluZyBzdXBwb3J0ZWQuXG4gIH0gZWxzZSBpZiAoIWhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzVG9BZGQpKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSAoZWxlbWVudC5jbGFzc05hbWUgKyAnICcgKyBjbGFzc1RvQWRkKS50cmltKCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBDU1MgY2xhc3MgbmFtZSBmcm9tIGFuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgICAgICBFbGVtZW50IHRvIHJlbW92ZSBhIGNsYXNzIG5hbWUgZnJvbS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NUb1JlbW92ZVxuICogICAgICAgIENsYXNzIG5hbWUgdG8gcmVtb3ZlXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGRvbSBlbGVtZW50IHdpdGggY2xhc3MgbmFtZSByZW1vdmVkLlxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc1RvUmVtb3ZlKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc1RvUmVtb3ZlKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvd0lmV2hpdGVzcGFjZShjbGFzc1RvUmVtb3ZlKTtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KC9cXHMrLykuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYyAhPT0gY2xhc3NUb1JlbW92ZTtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBUaGUgY2FsbGJhY2sgZGVmaW5pdGlvbiBmb3IgdG9nZ2xlRWxDbGFzcy5cbiAqXG4gKiBAY2FsbGJhY2sgRG9tflByZWRpY2F0ZUNhbGxiYWNrXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgICAgICBUaGUgRE9NIGVsZW1lbnQgb2YgdGhlIENvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NUb1RvZ2dsZVxuICogICAgICAgIFRoZSBgY2xhc3NOYW1lYCB0aGF0IHdhbnRzIHRvIGJlIHRvZ2dsZWRcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cbiAqICAgICAgICAgLSBJZiB0cnVlIHRoZSBgY2xhc3NUb1RvZ2dsZWAgd2lsbCBnZXQgYWRkZWQgdG8gYGVsZW1lbnRgLlxuICogICAgICAgICAtIElmIGZhbHNlIHRoZSBgY2xhc3NUb1RvZ2dsZWAgd2lsbCBnZXQgcmVtb3ZlZCBmcm9tIGBlbGVtZW50YC5cbiAqICAgICAgICAgLSBJZiB1bmRlZmluZWQgdGhpcyBjYWxsYmFjayB3aWxsIGJlIGlnbm9yZWRcbiAqL1xuXG4vKipcbiAqIEFkZHMgb3IgcmVtb3ZlcyBhIENTUyBjbGFzcyBuYW1lIG9uIGFuIGVsZW1lbnQgZGVwZW5kaW5nIG9uIGFuIG9wdGlvbmFsXG4gKiBjb25kaXRpb24gb3IgdGhlIHByZXNlbmNlL2Fic2VuY2Ugb2YgdGhlIGNsYXNzIG5hbWUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiAgICAgICAgVGhlIGVsZW1lbnQgdG8gdG9nZ2xlIGEgY2xhc3MgbmFtZSBvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NUb1RvZ2dsZVxuICogICAgICAgIFRoZSBjbGFzcyB0aGF0IHNob3VsZCBiZSB0b2dnbGVkXG4gKlxuICogQHBhcmFtIHtib29sZWFufFByZWRpY2F0ZUNhbGxiYWNrfSBbcHJlZGljYXRlXVxuICogICAgICAgIFNlZSB0aGUgcmV0dXJuIHZhbHVlIGZvciB7QGxpbmsgRG9tflByZWRpY2F0ZUNhbGxiYWNrfVxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHdpdGggYSBjbGFzcyB0aGF0IGhhcyBiZWVuIHRvZ2dsZWQuXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIGNsYXNzVG9Ub2dnbGUsIHByZWRpY2F0ZSkge1xuXG4gIC8vIFRoaXMgQ0FOTk9UIHVzZSBgY2xhc3NMaXN0YCBpbnRlcm5hbGx5IGJlY2F1c2UgSUUgZG9lcyBub3Qgc3VwcG9ydCB0aGVcbiAgLy8gc2Vjb25kIHBhcmFtZXRlciB0byB0aGUgYGNsYXNzTGlzdC50b2dnbGUoKWAgbWV0aG9kISBXaGljaCBpcyBmaW5lIGJlY2F1c2VcbiAgLy8gYGNsYXNzTGlzdGAgd2lsbCBiZSB1c2VkIGJ5IHRoZSBhZGQvcmVtb3ZlIGZ1bmN0aW9ucy5cbiAgdmFyIGhhcyA9IGhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzVG9Ub2dnbGUpO1xuXG4gIGlmICh0eXBlb2YgcHJlZGljYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJlZGljYXRlID0gcHJlZGljYXRlKGVsZW1lbnQsIGNsYXNzVG9Ub2dnbGUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT09ICdib29sZWFuJykge1xuICAgIHByZWRpY2F0ZSA9ICFoYXM7XG4gIH1cblxuICAvLyBJZiB0aGUgbmVjZXNzYXJ5IGNsYXNzIG9wZXJhdGlvbiBtYXRjaGVzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZVxuICAvLyBlbGVtZW50LCBubyBhY3Rpb24gaXMgcmVxdWlyZWQuXG4gIGlmIChwcmVkaWNhdGUgPT09IGhhcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcmVkaWNhdGUpIHtcbiAgICBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc1RvVG9nZ2xlKTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc1RvVG9nZ2xlKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIEFwcGx5IGF0dHJpYnV0ZXMgdG8gYW4gSFRNTCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBFbGVtZW50IHRvIGFkZCBhdHRyaWJ1dGVzIHRvLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc11cbiAqICAgICAgICBBdHRyaWJ1dGVzIHRvIGJlIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWwsIGF0dHJpYnV0ZXMpIHtcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICB2YXIgYXR0clZhbHVlID0gYXR0cmlidXRlc1thdHRyTmFtZV07XG5cbiAgICBpZiAoYXR0clZhbHVlID09PSBudWxsIHx8IHR5cGVvZiBhdHRyVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IGF0dHJWYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlID09PSB0cnVlID8gJycgOiBhdHRyVmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGFuIGVsZW1lbnQncyBhdHRyaWJ1dGUgdmFsdWVzLCBhcyBkZWZpbmVkIG9uIHRoZSBIVE1MIHRhZ1xuICogQXR0cmlidXRlcyBhcmUgbm90IHRoZSBzYW1lIGFzIHByb3BlcnRpZXMuIFRoZXkncmUgZGVmaW5lZCBvbiB0aGUgdGFnXG4gKiBvciB3aXRoIHNldEF0dHJpYnV0ZSAod2hpY2ggc2hvdWxkbid0IGJlIHVzZWQgd2l0aCBIVE1MKVxuICogVGhpcyB3aWxsIHJldHVybiB0cnVlIG9yIGZhbHNlIGZvciBib29sZWFuIGF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YWdcbiAqICAgICAgICBFbGVtZW50IGZyb20gd2hpY2ggdG8gZ2V0IHRhZyBhdHRyaWJ1dGVzLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgQWxsIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXModGFnKSB7XG4gIHZhciBvYmogPSB7fTtcblxuICAvLyBrbm93biBib29sZWFuIGF0dHJpYnV0ZXNcbiAgLy8gd2UgY2FuIGNoZWNrIGZvciBtYXRjaGluZyBib29sZWFuIHByb3BlcnRpZXMsIGJ1dCBvbGRlciBicm93c2Vyc1xuICAvLyB3b24ndCBrbm93IGFib3V0IEhUTUw1IGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0IHdlIHN0aWxsIHJlYWQgZnJvbVxuICB2YXIga25vd25Cb29sZWFucyA9ICcsJyArICdhdXRvcGxheSxjb250cm9scyxsb29wLG11dGVkLGRlZmF1bHQnICsgJywnO1xuXG4gIGlmICh0YWcgJiYgdGFnLmF0dHJpYnV0ZXMgJiYgdGFnLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBhdHRycyA9IHRhZy5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yICh2YXIgaSA9IGF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYXR0ck5hbWUgPSBhdHRyc1tpXS5uYW1lO1xuICAgICAgdmFyIGF0dHJWYWwgPSBhdHRyc1tpXS52YWx1ZTtcblxuICAgICAgLy8gY2hlY2sgZm9yIGtub3duIGJvb2xlYW5zXG4gICAgICAvLyB0aGUgbWF0Y2hpbmcgZWxlbWVudCBwcm9wZXJ0eSB3aWxsIHJldHVybiBhIHZhbHVlIGZvciB0eXBlb2ZcbiAgICAgIGlmICh0eXBlb2YgdGFnW2F0dHJOYW1lXSA9PT0gJ2Jvb2xlYW4nIHx8IGtub3duQm9vbGVhbnMuaW5kZXhPZignLCcgKyBhdHRyTmFtZSArICcsJykgIT09IC0xKSB7XG4gICAgICAgIC8vIHRoZSB2YWx1ZSBvZiBhbiBpbmNsdWRlZCBib29sZWFuIGF0dHJpYnV0ZSBpcyB0eXBpY2FsbHkgYW4gZW1wdHlcbiAgICAgICAgLy8gc3RyaW5nICgnJykgd2hpY2ggd291bGQgZXF1YWwgZmFsc2UgaWYgd2UganVzdCBjaGVjayBmb3IgYSBmYWxzZSB2YWx1ZS5cbiAgICAgICAgLy8gd2UgYWxzbyBkb24ndCB3YW50IHN1cHBvcnQgYmFkIGNvZGUgbGlrZSBhdXRvcGxheT0nZmFsc2UnXG4gICAgICAgIGF0dHJWYWwgPSBhdHRyVmFsICE9PSBudWxsID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBvYmpbYXR0ck5hbWVdID0gYXR0clZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBBIERPTSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogICAgICAgIEF0dHJpYnV0ZSB0byBnZXQgdGhlIHZhbHVlIG9mXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlXG4gKi9cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZShlbCwgYXR0cmlidXRlKSB7XG4gIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGFuIGVsZW1lbnQncyBhdHRyaWJ1dGVcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgQSBET00gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqICAgICAgICBBdHRyaWJ1dGUgdG8gc2V0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiAgICAgICAgVmFsdWUgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgdG9cbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlKGVsLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gIGVsLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBBIERPTSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogICAgICAgIEF0dHJpYnV0ZSB0byByZW1vdmVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGVsLCBhdHRyaWJ1dGUpIHtcbiAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBibG9jayB0aGUgYWJpbGl0eSB0byBzZWxlY3QgdGV4dCB3aGlsZSBkcmFnZ2luZyBjb250cm9sc1xuICovXG5mdW5jdGlvbiBibG9ja1RleHRTZWxlY3Rpb24oKSB7XG4gIGRvY3VtZW50LmJvZHkuZm9jdXMoKTtcbiAgZG9jdW1lbnQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG5cbi8qKlxuICogVHVybiBvZmYgdGV4dCBzZWxlY3Rpb24gYmxvY2tpbmdcbiAqL1xuZnVuY3Rpb24gdW5ibG9ja1RleHRTZWxlY3Rpb24oKSB7XG4gIGRvY3VtZW50Lm9uc2VsZWN0c3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbi8qKlxuICogSWRlbnRpY2FsIHRvIHRoZSBuYXRpdmUgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgZnVuY3Rpb24sIGJ1dCBlbnN1cmVzIHRoYXRcbiAqIHRoZSBtZXRob2QgaXMgc3VwcG9ydGVkIGF0IGFsbCAoaXQgaXMgaW4gYWxsIGJyb3dzZXJzIHdlIGNsYWltIHRvIHN1cHBvcnQpXG4gKiBhbmQgdGhhdCB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NIGJlZm9yZSBjb250aW51aW5nLlxuICpcbiAqIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBhbHNvIHNoaW1zIHByb3BlcnRpZXMgd2hpY2ggYXJlIG5vdCBwcm92aWRlZCBieSBzb21lXG4gKiBvbGRlciBicm93c2VycyAobmFtZWx5LCBJRTgpLlxuICpcbiAqIEFkZGl0aW9uYWxseSwgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBhZGRpbmcgcHJvcGVydGllcyB0byBhXG4gKiBgQ2xpZW50UmVjdGAvYERPTVJlY3RgIG9iamVjdDsgc28sIHdlIHNoYWxsb3ctY29weSBpdCB3aXRoIHRoZSBzdGFuZGFyZFxuICogcHJvcGVydGllcyAoZXhjZXB0IGB4YCBhbmQgYHlgIHdoaWNoIGFyZSBub3Qgd2lkZWx5IHN1cHBvcnRlZCkuIFRoaXMgaGVscHNcbiAqIGF2b2lkIGltcGxlbWVudGF0aW9ucyB3aGVyZSBrZXlzIGFyZSBub24tZW51bWVyYWJsZS5cbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogICAgICAgICBFbGVtZW50IHdob3NlIGBDbGllbnRSZWN0YCB3ZSB3YW50IHRvIGNhbGN1bGF0ZS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICogICAgICAgICBBbHdheXMgcmV0dXJucyBhIHBsYWluXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbCkge1xuICBpZiAoZWwgJiYgZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgIFsnYm90dG9tJywgJ2hlaWdodCcsICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICd3aWR0aCddLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChyZWN0W2tdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVjdFtrXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghcmVzdWx0LmhlaWdodCkge1xuICAgICAgcmVzdWx0LmhlaWdodCA9IHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZShlbCwgJ2hlaWdodCcpKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlc3VsdC53aWR0aCkge1xuICAgICAgcmVzdWx0LndpZHRoID0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlKGVsLCAnd2lkdGgnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBwb3N0aW9uIG9mIGEgRE9NIGVsZW1lbnQgb24gdGhlIHBhZ2UuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmRvbX5Qb3NpdGlvblxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0XG4gKiAgICAgICAgICAgUGl4ZWxzIHRvIHRoZSBsZWZ0XG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcFxuICogICAgICAgICAgIFBpeGVscyBvbiB0b3BcbiAqL1xuXG4vKipcbiAqIE9mZnNldCBMZWZ0LlxuICogZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHRlY2huaXF1ZSBmcm9tXG4gKiBKb2huIFJlc2lnXG4gKlxuICogQHNlZSBodHRwOi8vZWpvaG4ub3JnL2Jsb2cvZ2V0Ym91bmRpbmdjbGllbnRyZWN0LWlzLWF3ZXNvbWUvXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEVsZW1lbnQgZnJvbSB3aGljaCB0byBnZXQgb2Zmc2V0XG4gKlxuICogQHJldHVybiB7bW9kdWxlOmRvbX5Qb3NpdGlvbn1cbiAqICAgICAgICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBpbi5cbiAqL1xuZnVuY3Rpb24gZmluZFBvc2l0aW9uKGVsKSB7XG4gIHZhciBib3ggPSB2b2lkIDA7XG5cbiAgaWYgKGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgYm94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICBpZiAoIWJveCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgfVxuXG4gIHZhciBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXG4gIHZhciBjbGllbnRMZWZ0ID0gZG9jRWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMDtcbiAgdmFyIHNjcm9sbExlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgYm9keS5zY3JvbGxMZWZ0O1xuICB2YXIgbGVmdCA9IGJveC5sZWZ0ICsgc2Nyb2xsTGVmdCAtIGNsaWVudExlZnQ7XG5cbiAgdmFyIGNsaWVudFRvcCA9IGRvY0VsLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwO1xuICB2YXIgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGJvZHkuc2Nyb2xsVG9wO1xuICB2YXIgdG9wID0gYm94LnRvcCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcDtcblxuICAvLyBBbmRyb2lkIHNvbWV0aW1lcyByZXR1cm5zIHNsaWdodGx5IG9mZiBkZWNpbWFsIHZhbHVlcywgc28gbmVlZCB0byByb3VuZFxuICByZXR1cm4ge1xuICAgIGxlZnQ6IE1hdGgucm91bmQobGVmdCksXG4gICAgdG9wOiBNYXRoLnJvdW5kKHRvcClcbiAgfTtcbn1cblxuLyoqXG4gKiB4IGFuZCB5IGNvb3JkaW5hdGVzIGZvciBhIGRvbSBlbGVtZW50IG9yIG1vdXNlIHBvaW50ZXJcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEb21+Q29vcmRpbmF0ZXNcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0geFxuICogICAgICAgICAgIHggY29vcmRpbmF0ZSBpbiBwaXhlbHNcbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0geVxuICogICAgICAgICAgIHkgY29vcmRpbmF0ZSBpbiBwaXhlbHNcbiAqL1xuXG4vKipcbiAqIEdldCBwb2ludGVyIHBvc2l0aW9uIGluIGVsZW1lbnRcbiAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggeCBhbmQgeSBjb29yZGluYXRlcy5cbiAqIFRoZSBiYXNlIG9uIHRoZSBjb29yZGluYXRlcyBhcmUgdGhlIGJvdHRvbSBsZWZ0IG9mIHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBFbGVtZW50IG9uIHdoaWNoIHRvIGdldCB0aGUgcG9pbnRlciBwb3NpdGlvbiBvblxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gKiAgICAgICAgRXZlbnQgb2JqZWN0XG4gKlxuICogQHJldHVybiB7RG9tfkNvb3JkaW5hdGVzfVxuICogICAgICAgICBBIENvb3JkaW5hdGVzIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBtb3VzZSBwb3NpdGlvbi5cbiAqXG4gKi9cbmZ1bmN0aW9uIGdldFBvaW50ZXJQb3NpdGlvbihlbCwgZXZlbnQpIHtcbiAgdmFyIHBvc2l0aW9uID0ge307XG4gIHZhciBib3ggPSBmaW5kUG9zaXRpb24oZWwpO1xuICB2YXIgYm94VyA9IGVsLm9mZnNldFdpZHRoO1xuICB2YXIgYm94SCA9IGVsLm9mZnNldEhlaWdodDtcblxuICB2YXIgYm94WSA9IGJveC50b3A7XG4gIHZhciBib3hYID0gYm94LmxlZnQ7XG4gIHZhciBwYWdlWSA9IGV2ZW50LnBhZ2VZO1xuICB2YXIgcGFnZVggPSBldmVudC5wYWdlWDtcblxuICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICBwYWdlWCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgIHBhZ2VZID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XG4gIH1cblxuICBwb3NpdGlvbi55ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKGJveFkgLSBwYWdlWSArIGJveEgpIC8gYm94SCkpO1xuICBwb3NpdGlvbi54ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHBhZ2VYIC0gYm94WCkgLyBib3hXKSk7XG5cbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuXG4vKipcbiAqIERldGVybWluZXMsIHZpYSBkdWNrIHR5cGluZywgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIHRleHQgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogICAgICAgIENoZWNrIGlmIHRoaXMgdmFsdWUgaXMgYSB0ZXh0IG5vZGUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIGl0IGlzIGEgdGV4dCBub2RlXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMztcbn1cblxuLyoqXG4gKiBFbXB0aWVzIHRoZSBjb250ZW50cyBvZiBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgZWxlbWVudCB0byBlbXB0eSBjaGlsZHJlbiBmcm9tXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgd2l0aCBubyBjaGlsZHJlblxuICovXG5mdW5jdGlvbiBlbXB0eUVsKGVsKSB7XG4gIHdoaWxlIChlbC5maXJzdENoaWxkKSB7XG4gICAgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgY29udGVudCBmb3IgZXZlbnR1YWwgaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cbiAqXG4gKiBUaGlzIGFsbG93cyBhIHdpZGUgcmFuZ2Ugb2YgY29udGVudCBkZWZpbml0aW9uIG1ldGhvZHMsIGJ1dCBwcm90ZWN0c1xuICogZnJvbSBmYWxsaW5nIGludG8gdGhlIHRyYXAgb2Ygc2ltcGx5IHdyaXRpbmcgdG8gYGlubmVySFRNTGAsIHdoaWNoIGlzXG4gKiBhbiBYU1MgY29uY2Vybi5cbiAqXG4gKiBUaGUgY29udGVudCBmb3IgYW4gZWxlbWVudCBjYW4gYmUgcGFzc2VkIGluIG11bHRpcGxlIHR5cGVzIGFuZFxuICogY29tYmluYXRpb25zLCB3aG9zZSBiZWhhdmlvciBpcyBhcyBmb2xsb3dzOlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8VGV4dE5vZGV8QXJyYXl8RnVuY3Rpb259IGNvbnRlbnRcbiAqICAgICAgICAtIFN0cmluZzogTm9ybWFsaXplZCBpbnRvIGEgdGV4dCBub2RlLlxuICogICAgICAgIC0gRWxlbWVudC9UZXh0Tm9kZTogUGFzc2VkIHRocm91Z2guXG4gKiAgICAgICAgLSBBcnJheTogQSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2Ygc3RyaW5ncywgZWxlbWVudHMsIG5vZGVzLCBvciBmdW5jdGlvbnNcbiAqICAgICAgICAgICh3aGljaCByZXR1cm4gc2luZ2xlIHN0cmluZ3MsIGVsZW1lbnRzLCBvciBub2RlcykuXG4gKiAgICAgICAgLSBGdW5jdGlvbjogSWYgdGhlIHNvbGUgYXJndW1lbnQsIGlzIGV4cGVjdGVkIHRvIHByb2R1Y2UgYSBzdHJpbmcsIGVsZW1lbnQsXG4gKiAgICAgICAgICBub2RlLCBvciBhcnJheSBhcyBkZWZpbmVkIGFib3ZlLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogICAgICAgICBBbGwgb2YgdGhlIGNvbnRlbnQgdGhhdCB3YXMgcGFzc2VkIGluIG5vcm1hbGl6ZWQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnRlbnQoY29udGVudCkge1xuXG4gIC8vIEZpcnN0LCBpbnZva2UgY29udGVudCBpZiBpdCBpcyBhIGZ1bmN0aW9uLiBJZiBpdCBwcm9kdWNlcyBhbiBhcnJheSxcbiAgLy8gdGhhdCBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIG5vcm1hbGl6YXRpb24uXG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnRlbnQgPSBjb250ZW50KCk7XG4gIH1cblxuICAvLyBOZXh0IHVwLCBub3JtYWxpemUgdG8gYW4gYXJyYXksIHNvIG9uZSBvciBtYW55IGl0ZW1zIGNhbiBiZSBub3JtYWxpemVkLFxuICAvLyBmaWx0ZXJlZCwgYW5kIHJldHVybmVkLlxuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICAvLyBGaXJzdCwgaW52b2tlIHZhbHVlIGlmIGl0IGlzIGEgZnVuY3Rpb24gdG8gcHJvZHVjZSBhIG5ldyB2YWx1ZSxcbiAgICAvLyB3aGljaCB3aWxsIGJlIHN1YnNlcXVlbnRseSBub3JtYWxpemVkIHRvIGEgTm9kZSBvZiBzb21lIGtpbmQuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSgpO1xuICAgIH1cblxuICAgIGlmIChpc0VsKHZhbHVlKSB8fCBpc1RleHROb2RlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIC9cXFMvLnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICAgIH1cbiAgfSkuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBhbmQgYXBwZW5kcyBjb250ZW50IHRvIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogICAgICAgIEVsZW1lbnQgdG8gYXBwZW5kIG5vcm1hbGl6ZWQgY29udGVudCB0by5cbiAqXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxUZXh0Tm9kZXxBcnJheXxGdW5jdGlvbn0gY29udGVudFxuICogICAgICAgIFNlZSB0aGUgYGNvbnRlbnRgIGFyZ3VtZW50IG9mIHtAbGluayBkb206bm9ybWFsaXplQ29udGVudH1cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB3aXRoIGFwcGVuZGVkIG5vcm1hbGl6ZWQgY29udGVudC5cbiAqL1xuZnVuY3Rpb24gYXBwZW5kQ29udGVudChlbCwgY29udGVudCkge1xuICBub3JtYWxpemVDb250ZW50KGNvbnRlbnQpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gZWwuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIH0pO1xuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBhbmQgaW5zZXJ0cyBjb250ZW50IGludG8gYW4gZWxlbWVudDsgdGhpcyBpcyBpZGVudGljYWwgdG9cbiAqIGBhcHBlbmRDb250ZW50KClgLCBleGNlcHQgaXQgZW1wdGllcyB0aGUgZWxlbWVudCBmaXJzdC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgRWxlbWVudCB0byBpbnNlcnQgbm9ybWFsaXplZCBjb250ZW50IGludG8uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxUZXh0Tm9kZXxBcnJheXxGdW5jdGlvbn0gY29udGVudFxuICogICAgICAgIFNlZSB0aGUgYGNvbnRlbnRgIGFyZ3VtZW50IG9mIHtAbGluayBkb206bm9ybWFsaXplQ29udGVudH1cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICogICAgICAgICBUaGUgZWxlbWVudCB3aXRoIGluc2VydGVkIG5vcm1hbGl6ZWQgY29udGVudC5cbiAqXG4gKi9cbmZ1bmN0aW9uIGluc2VydENvbnRlbnQoZWwsIGNvbnRlbnQpIHtcbiAgcmV0dXJuIGFwcGVuZENvbnRlbnQoZW1wdHlFbChlbCksIGNvbnRlbnQpO1xufVxuXG4vKipcbiAqIEZpbmRzIGEgc2luZ2xlIERPTSBlbGVtZW50IG1hdGNoaW5nIGBzZWxlY3RvcmAgd2l0aGluIHRoZSBvcHRpb25hbFxuICogYGNvbnRleHRgIG9mIGFub3RoZXIgRE9NIGVsZW1lbnQgKGRlZmF1bHRpbmcgdG8gYGRvY3VtZW50YCkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiAgICAgICAgQSB2YWxpZCBDU1Mgc2VsZWN0b3IsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGBxdWVyeVNlbGVjdG9yYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBbY29udGV4dD1kb2N1bWVudF1cbiAqICAgICAgICBBIERPTSBlbGVtZW50IHdpdGhpbiB3aGljaCB0byBxdWVyeS4gQ2FuIGFsc28gYmUgYSBzZWxlY3RvclxuICogICAgICAgIHN0cmluZyBpbiB3aGljaCBjYXNlIHRoZSBmaXJzdCBtYXRjaGluZyBlbGVtZW50IHdpbGwgYmUgdXNlZFxuICogICAgICAgIGFzIGNvbnRleHQuIElmIG1pc3NpbmcgKG9yIG5vIGVsZW1lbnQgbWF0Y2hlcyBzZWxlY3RvciksIGZhbGxzXG4gKiAgICAgICAgYmFjayB0byBgZG9jdW1lbnRgLlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR8bnVsbH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgZm91bmQgb3IgbnVsbC5cbiAqL1xudmFyICQgPSBjcmVhdGVRdWVyaWVyKCdxdWVyeVNlbGVjdG9yJyk7XG5cbi8qKlxuICogRmluZHMgYSBhbGwgRE9NIGVsZW1lbnRzIG1hdGNoaW5nIGBzZWxlY3RvcmAgd2l0aGluIHRoZSBvcHRpb25hbFxuICogYGNvbnRleHRgIG9mIGFub3RoZXIgRE9NIGVsZW1lbnQgKGRlZmF1bHRpbmcgdG8gYGRvY3VtZW50YCkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiAgICAgICAgICAgQSB2YWxpZCBDU1Mgc2VsZWN0b3IsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGBxdWVyeVNlbGVjdG9yQWxsYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBbY29udGV4dD1kb2N1bWVudF1cbiAqICAgICAgICAgICBBIERPTSBlbGVtZW50IHdpdGhpbiB3aGljaCB0byBxdWVyeS4gQ2FuIGFsc28gYmUgYSBzZWxlY3RvclxuICogICAgICAgICAgIHN0cmluZyBpbiB3aGljaCBjYXNlIHRoZSBmaXJzdCBtYXRjaGluZyBlbGVtZW50IHdpbGwgYmUgdXNlZFxuICogICAgICAgICAgIGFzIGNvbnRleHQuIElmIG1pc3NpbmcgKG9yIG5vIGVsZW1lbnQgbWF0Y2hlcyBzZWxlY3RvciksIGZhbGxzXG4gKiAgICAgICAgICAgYmFjayB0byBgZG9jdW1lbnRgLlxuICpcbiAqIEByZXR1cm4ge05vZGVMaXN0fVxuICogICAgICAgICBBIGVsZW1lbnQgbGlzdCBvZiBlbGVtZW50cyB0aGF0IHdlcmUgZm91bmQuIFdpbGwgYmUgZW1wdHkgaWYgbm9uZSB3ZXJlIGZvdW5kLlxuICpcbiAqL1xudmFyICQkID0gY3JlYXRlUXVlcmllcigncXVlcnlTZWxlY3RvckFsbCcpO1xuXG5cblxudmFyIERvbSA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRpc1JlYWw6IGlzUmVhbCxcblx0aXNFbDogaXNFbCxcblx0Y3JlYXRlRWw6IGNyZWF0ZUVsLFxuXHR0ZXh0Q29udGVudDogdGV4dENvbnRlbnQsXG5cdHByZXBlbmRUbzogcHJlcGVuZFRvLFxuXHRoYXNDbGFzczogaGFzQ2xhc3MsXG5cdGFkZENsYXNzOiBhZGRDbGFzcyxcblx0cmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuXHR0b2dnbGVDbGFzczogdG9nZ2xlQ2xhc3MsXG5cdHNldEF0dHJpYnV0ZXM6IHNldEF0dHJpYnV0ZXMsXG5cdGdldEF0dHJpYnV0ZXM6IGdldEF0dHJpYnV0ZXMsXG5cdGdldEF0dHJpYnV0ZTogZ2V0QXR0cmlidXRlLFxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZSxcblx0cmVtb3ZlQXR0cmlidXRlOiByZW1vdmVBdHRyaWJ1dGUsXG5cdGJsb2NrVGV4dFNlbGVjdGlvbjogYmxvY2tUZXh0U2VsZWN0aW9uLFxuXHR1bmJsb2NrVGV4dFNlbGVjdGlvbjogdW5ibG9ja1RleHRTZWxlY3Rpb24sXG5cdGdldEJvdW5kaW5nQ2xpZW50UmVjdDogZ2V0Qm91bmRpbmdDbGllbnRSZWN0LFxuXHRmaW5kUG9zaXRpb246IGZpbmRQb3NpdGlvbixcblx0Z2V0UG9pbnRlclBvc2l0aW9uOiBnZXRQb2ludGVyUG9zaXRpb24sXG5cdGlzVGV4dE5vZGU6IGlzVGV4dE5vZGUsXG5cdGVtcHR5RWw6IGVtcHR5RWwsXG5cdG5vcm1hbGl6ZUNvbnRlbnQ6IG5vcm1hbGl6ZUNvbnRlbnQsXG5cdGFwcGVuZENvbnRlbnQ6IGFwcGVuZENvbnRlbnQsXG5cdGluc2VydENvbnRlbnQ6IGluc2VydENvbnRlbnQsXG5cdCQ6ICQsXG5cdCQkOiAkJFxufSk7XG5cbi8qKlxuICogQGZpbGUgZ3VpZC5qc1xuICogQG1vZHVsZSBndWlkXG4gKi9cblxuLyoqXG4gKiBVbmlxdWUgSUQgZm9yIGFuIGVsZW1lbnQgb3IgZnVuY3Rpb25cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbnZhciBfZ3VpZCA9IDE7XG5cbi8qKlxuICogR2V0IGEgdW5pcXVlIGF1dG8taW5jcmVtZW50aW5nIElEIGJ5IG51bWJlciB0aGF0IGhhcyBub3QgYmVlbiByZXR1cm5lZCBiZWZvcmUuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBBIG5ldyB1bmlxdWUgSUQuXG4gKi9cbmZ1bmN0aW9uIG5ld0dVSUQoKSB7XG4gIHJldHVybiBfZ3VpZCsrO1xufVxuXG4vKipcbiAqIEBmaWxlIGRvbS1kYXRhLmpzXG4gKiBAbW9kdWxlIGRvbS1kYXRhXG4gKi9cbi8qKlxuICogRWxlbWVudCBEYXRhIFN0b3JlLlxuICpcbiAqIEFsbG93cyBmb3IgYmluZGluZyBkYXRhIHRvIGFuIGVsZW1lbnQgd2l0aG91dCBwdXR0aW5nIGl0IGRpcmVjdGx5IG9uIHRoZVxuICogZWxlbWVudC4gRXguIEV2ZW50IGxpc3RlbmVycyBhcmUgc3RvcmVkIGhlcmUuXG4gKiAoYWxzbyBmcm9tIGpzbmluamEuY29tLCBzbGlnaHRseSBtb2RpZmllZCBhbmQgdXBkYXRlZCBmb3IgY2xvc3VyZSBjb21waWxlcilcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGVsRGF0YSA9IHt9O1xuXG4vKlxuICogVW5pcXVlIGF0dHJpYnV0ZSBuYW1lIHRvIHN0b3JlIGFuIGVsZW1lbnQncyBndWlkIGluXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBjb25zdGFudFxuICogQHByaXZhdGVcbiAqL1xudmFyIGVsSWRBdHRyID0gJ3ZkYXRhJyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNhY2hlIG9iamVjdCB3aGVyZSBkYXRhIGZvciBhbiBlbGVtZW50IGlzIHN0b3JlZFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBFbGVtZW50IHRvIHN0b3JlIGRhdGEgZm9yLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgVGhlIGNhY2hlIG9iamVjdCBmb3IgdGhhdCBlbCB0aGF0IHdhcyBwYXNzZWQgaW4uXG4gKi9cbmZ1bmN0aW9uIGdldERhdGEoZWwpIHtcbiAgdmFyIGlkID0gZWxbZWxJZEF0dHJdO1xuXG4gIGlmICghaWQpIHtcbiAgICBpZCA9IGVsW2VsSWRBdHRyXSA9IG5ld0dVSUQoKTtcbiAgfVxuXG4gIGlmICghZWxEYXRhW2lkXSkge1xuICAgIGVsRGF0YVtpZF0gPSB7fTtcbiAgfVxuXG4gIHJldHVybiBlbERhdGFbaWRdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gZWxlbWVudCBoYXMgY2FjaGVkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgQ2hlY2sgaWYgdGhpcyBlbGVtZW50IGhhcyBjYWNoZWQgZGF0YS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgdGhlIERPTSBlbGVtZW50IGhhcyBjYWNoZWQgZGF0YS5cbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGhhc0RhdGEoZWwpIHtcbiAgdmFyIGlkID0gZWxbZWxJZEF0dHJdO1xuXG4gIGlmICghaWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gISFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlbERhdGFbaWRdKS5sZW5ndGg7XG59XG5cbi8qKlxuICogRGVsZXRlIGRhdGEgZm9yIHRoZSBlbGVtZW50IGZyb20gdGhlIGNhY2hlIGFuZCB0aGUgZ3VpZCBhdHRyIGZyb20gZ2V0RWxlbWVudEJ5SWRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiAgICAgICAgUmVtb3ZlIGNhY2hlZCBkYXRhIGZvciB0aGlzIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZURhdGEoZWwpIHtcbiAgdmFyIGlkID0gZWxbZWxJZEF0dHJdO1xuXG4gIGlmICghaWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIHN0b3JlZCBkYXRhXG4gIGRlbGV0ZSBlbERhdGFbaWRdO1xuXG4gIC8vIFJlbW92ZSB0aGUgZWxJZEF0dHIgcHJvcGVydHkgZnJvbSB0aGUgRE9NIG5vZGVcbiAgdHJ5IHtcbiAgICBkZWxldGUgZWxbZWxJZEF0dHJdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGVsLnJlbW92ZUF0dHJpYnV0ZSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGVsSWRBdHRyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSUUgZG9lc24ndCBhcHBlYXIgdG8gc3VwcG9ydCByZW1vdmVBdHRyaWJ1dGUgb24gdGhlIGRvY3VtZW50IGVsZW1lbnRcbiAgICAgIGVsW2VsSWRBdHRyXSA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGZpbGUgZXZlbnRzLmpzLiBBbiBFdmVudCBTeXN0ZW0gKEpvaG4gUmVzaWcgLSBTZWNyZXRzIG9mIGEgSlMgTmluamEgaHR0cDovL2pzbmluamEuY29tLylcbiAqIChPcmlnaW5hbCBib29rIHZlcnNpb24gd2Fzbid0IGNvbXBsZXRlbHkgdXNhYmxlLCBzbyBmaXhlZCBzb21lIHRoaW5ncyBhbmQgbWFkZSBDbG9zdXJlIENvbXBpbGVyIGNvbXBhdGlibGUpXG4gKiBUaGlzIHNob3VsZCB3b3JrIHZlcnkgc2ltaWxhcmx5IHRvIGpRdWVyeSdzIGV2ZW50cywgaG93ZXZlciBpdCdzIGJhc2VkIG9mZiB0aGUgYm9vayB2ZXJzaW9uIHdoaWNoIGlzbid0IGFzXG4gKiByb2J1c3QgYXMganF1ZXJ5J3MsIHNvIHRoZXJlJ3MgcHJvYmFibHkgc29tZSBkaWZmZXJlbmNlcy5cbiAqXG4gKiBAbW9kdWxlIGV2ZW50c1xuICovXG5cbi8qKlxuICogQ2xlYW4gdXAgdGhlIGxpc3RlbmVyIGNhY2hlIGFuZCBkaXNwYXRjaGVyc1xuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW1cbiAqICAgICAgICBFbGVtZW50IHRvIGNsZWFuIHVwXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICBUeXBlIG9mIGV2ZW50IHRvIGNsZWFuIHVwXG4gKi9cbmZ1bmN0aW9uIF9jbGVhblVwRXZlbnRzKGVsZW0sIHR5cGUpIHtcbiAgdmFyIGRhdGEgPSBnZXREYXRhKGVsZW0pO1xuXG4gIC8vIFJlbW92ZSB0aGUgZXZlbnRzIG9mIGEgcGFydGljdWxhciB0eXBlIGlmIHRoZXJlIGFyZSBub25lIGxlZnRcbiAgaWYgKGRhdGEuaGFuZGxlcnNbdHlwZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIGRhdGEuaGFuZGxlcnNbdHlwZV07XG4gICAgLy8gZGF0YS5oYW5kbGVyc1t0eXBlXSA9IG51bGw7XG4gICAgLy8gU2V0dGluZyB0byBudWxsIHdhcyBjYXVzaW5nIGFuIGVycm9yIHdpdGggZGF0YS5oYW5kbGVyc1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBtZXRhLWhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBkYXRhLmRpc3BhdGNoZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uZGV0YWNoRXZlbnQpIHtcbiAgICAgIGVsZW0uZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGRhdGEuZGlzcGF0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIHRoZSBldmVudHMgb2JqZWN0IGlmIHRoZXJlIGFyZSBubyB0eXBlcyBsZWZ0XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkYXRhLmhhbmRsZXJzKS5sZW5ndGggPD0gMCkge1xuICAgIGRlbGV0ZSBkYXRhLmhhbmRsZXJzO1xuICAgIGRlbGV0ZSBkYXRhLmRpc3BhdGNoZXI7XG4gICAgZGVsZXRlIGRhdGEuZGlzYWJsZWQ7XG4gIH1cblxuICAvLyBGaW5hbGx5IHJlbW92ZSB0aGUgZWxlbWVudCBkYXRhIGlmIHRoZXJlIGlzIG5vIGRhdGEgbGVmdFxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGF0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgcmVtb3ZlRGF0YShlbGVtKTtcbiAgfVxufVxuXG4vKipcbiAqIExvb3BzIHRocm91Z2ggYW4gYXJyYXkgb2YgZXZlbnQgdHlwZXMgYW5kIGNhbGxzIHRoZSByZXF1ZXN0ZWQgbWV0aG9kIGZvciBlYWNoIHR5cGUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqICAgICAgICBUaGUgZXZlbnQgbWV0aG9kIHdlIHdhbnQgdG8gdXNlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW1cbiAqICAgICAgICBFbGVtZW50IG9yIG9iamVjdCB0byBiaW5kIGxpc3RlbmVycyB0b1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgVHlwZSBvZiBldmVudCB0byBiaW5kIHRvLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gY2FsbGJhY2tcbiAqICAgICAgICBFdmVudCBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gX2hhbmRsZU11bHRpcGxlRXZlbnRzKGZuLCBlbGVtLCB0eXBlcywgY2FsbGJhY2spIHtcbiAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIC8vIENhbGwgdGhlIGV2ZW50IG1ldGhvZCBmb3IgZWFjaCBvbmUgb2YgdGhlIHR5cGVzXG4gICAgZm4oZWxlbSwgdHlwZSwgY2FsbGJhY2spO1xuICB9KTtcbn1cblxuLyoqXG4gKiBGaXggYSBuYXRpdmUgZXZlbnQgdG8gaGF2ZSBzdGFuZGFyZCBwcm9wZXJ0eSB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAqICAgICAgICBFdmVudCBvYmplY3QgdG8gZml4LlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgRml4ZWQgZXZlbnQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBmaXhFdmVudChldmVudCkge1xuXG4gIGZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGlmIGZpeGluZyB1cCBpcyBuZWVkZWRcbiAgLy8gVXNlZCB0byBjaGVjayBpZiAhZXZlbnQuc3RvcFByb3BhZ2F0aW9uIGluc3RlYWQgb2YgaXNQcm9wYWdhdGlvblN0b3BwZWRcbiAgLy8gQnV0IG5hdGl2ZSBldmVudHMgcmV0dXJuIHRydWUgZm9yIHN0b3BQcm9wYWdhdGlvbiwgYnV0IGRvbid0IGhhdmVcbiAgLy8gb3RoZXIgZXhwZWN0ZWQgbWV0aG9kcyBsaWtlIGlzUHJvcGFnYXRpb25TdG9wcGVkLiBTZWVtcyB0byBiZSBhIHByb2JsZW1cbiAgLy8gd2l0aCB0aGUgSmF2YXNjcmlwdCBOaW5qYSBjb2RlLiBTbyB3ZSdyZSBqdXN0IG92ZXJyaWRpbmcgYWxsIGV2ZW50cyBub3cuXG4gIGlmICghZXZlbnQgfHwgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKSB7XG4gICAgdmFyIG9sZCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcblxuICAgIGV2ZW50ID0ge307XG4gICAgLy8gQ2xvbmUgdGhlIG9sZCBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gbW9kaWZ5IHRoZSB2YWx1ZXMgZXZlbnQgPSB7fTtcbiAgICAvLyBJRTggRG9lc24ndCBsaWtlIHdoZW4geW91IG1lc3Mgd2l0aCBuYXRpdmUgZXZlbnQgcHJvcGVydGllc1xuICAgIC8vIEZpcmVmb3ggcmV0dXJucyBmYWxzZSBmb3IgZXZlbnQuaGFzT3duUHJvcGVydHkoJ3R5cGUnKSBhbmQgb3RoZXIgcHJvcHNcbiAgICAvLyAgd2hpY2ggbWFrZXMgY29weWluZyBtb3JlIGRpZmZpY3VsdC5cbiAgICAvLyBUT0RPOiBQcm9iYWJseSBiZXN0IHRvIGNyZWF0ZSBhIHdoaXRlbGlzdCBvZiBldmVudCBwcm9wc1xuICAgIGZvciAodmFyIGtleSBpbiBvbGQpIHtcbiAgICAgIC8vIFNhZmFyaSA2LjAuMyB3YXJucyB5b3UgaWYgeW91IHRyeSB0byBjb3B5IGRlcHJlY2F0ZWQgbGF5ZXJYL1lcbiAgICAgIC8vIENocm9tZSB3YXJucyB5b3UgaWYgeW91IHRyeSB0byBjb3B5IGRlcHJlY2F0ZWQga2V5Ym9hcmRFdmVudC5rZXlMb2NhdGlvblxuICAgICAgLy8gYW5kIHdlYmtpdE1vdmVtZW50WC9ZXG4gICAgICBpZiAoa2V5ICE9PSAnbGF5ZXJYJyAmJiBrZXkgIT09ICdsYXllclknICYmIGtleSAhPT0gJ2tleUxvY2F0aW9uJyAmJiBrZXkgIT09ICd3ZWJraXRNb3ZlbWVudFgnICYmIGtleSAhPT0gJ3dlYmtpdE1vdmVtZW50WScpIHtcbiAgICAgICAgLy8gQ2hyb21lIDMyKyB3YXJucyBpZiB5b3UgdHJ5IHRvIGNvcHkgZGVwcmVjYXRlZCByZXR1cm5WYWx1ZSwgYnV0XG4gICAgICAgIC8vIHdlIHN0aWxsIHdhbnQgdG8gaWYgcHJldmVudERlZmF1bHQgaXNuJ3Qgc3VwcG9ydGVkIChJRTgpLlxuICAgICAgICBpZiAoIShrZXkgPT09ICdyZXR1cm5WYWx1ZScgJiYgb2xkLnByZXZlbnREZWZhdWx0KSkge1xuICAgICAgICAgIGV2ZW50W2tleV0gPSBvbGRba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZSBldmVudCBvY2N1cnJlZCBvbiB0aGlzIGVsZW1lbnRcbiAgICBpZiAoIWV2ZW50LnRhcmdldCkge1xuICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgd2hpY2ggb3RoZXIgZWxlbWVudCB0aGUgZXZlbnQgaXMgcmVsYXRlZCB0b1xuICAgIGlmICghZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgZXZlbnQucmVsYXRlZFRhcmdldCA9IGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC50YXJnZXQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBTdG9wIHRoZSBkZWZhdWx0IGJyb3dzZXIgYWN0aW9uXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob2xkLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIG9sZC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgIG9sZC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgIC8vIFN0b3AgdGhlIGV2ZW50IGZyb20gYnViYmxpbmdcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob2xkLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICBvbGQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgb2xkLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgfTtcblxuICAgIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuRmFsc2U7XG5cbiAgICAvLyBTdG9wIHRoZSBldmVudCBmcm9tIGJ1YmJsaW5nIGFuZCBleGVjdXRpbmcgb3RoZXIgaGFuZGxlcnNcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob2xkLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuICAgICAgICBvbGQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuXG4gICAgZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5GYWxzZTtcblxuICAgIC8vIEhhbmRsZSBtb3VzZSBwb3NpdGlvblxuICAgIGlmIChldmVudC5jbGllbnRYICE9PSBudWxsICYmIGV2ZW50LmNsaWVudFggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcblxuICAgICAgZXZlbnQucGFnZVggPSBldmVudC5jbGllbnRYICsgKGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCk7XG4gICAgICBldmVudC5wYWdlWSA9IGV2ZW50LmNsaWVudFkgKyAoZG9jICYmIGRvYy5zY3JvbGxUb3AgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudFRvcCB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wIHx8IDApO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBrZXkgcHJlc3Nlc1xuICAgIGV2ZW50LndoaWNoID0gZXZlbnQuY2hhckNvZGUgfHwgZXZlbnQua2V5Q29kZTtcblxuICAgIC8vIEZpeCBidXR0b24gZm9yIG1vdXNlIGNsaWNrczpcbiAgICAvLyAwID09IGxlZnQ7IDEgPT0gbWlkZGxlOyAyID09IHJpZ2h0XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gbnVsbCAmJiBldmVudC5idXR0b24gIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGRpc2FibGVkIGJlY2F1c2UgaXQgZG9lcyBub3QgcGFzcyB2aWRlb2pzLXN0YW5kYXJkXG4gICAgICAvLyBhbmQuLi4geWlrZXMuXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgZXZlbnQuYnV0dG9uID0gZXZlbnQuYnV0dG9uICYgMSA/IDAgOiBldmVudC5idXR0b24gJiA0ID8gMSA6IGV2ZW50LmJ1dHRvbiAmIDIgPyAyIDogMDtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGZpeGVkLXVwIGluc3RhbmNlXG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzIGFyZSBzdXBwb3J0ZWRcbiAqL1xudmFyIF9zdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgX3N1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZGlzcmVnYXJkXG4gIH1cbn0pKCk7XG5cbi8qKlxuICogVG91Y2ggZXZlbnRzIENocm9tZSBleHBlY3RzIHRvIGJlIHBhc3NpdmVcbiAqL1xudmFyIHBhc3NpdmVFdmVudHMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJ107XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGVsZW1lbnRcbiAqIEl0IHN0b3JlcyB0aGUgaGFuZGxlciBmdW5jdGlvbiBpbiBhIHNlcGFyYXRlIGNhY2hlIG9iamVjdFxuICogYW5kIGFkZHMgYSBnZW5lcmljIGhhbmRsZXIgdG8gdGhlIGVsZW1lbnQncyBldmVudCxcbiAqIGFsb25nIHdpdGggYSB1bmlxdWUgaWQgKGd1aWQpIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW1cbiAqICAgICAgICBFbGVtZW50IG9yIG9iamVjdCB0byBiaW5kIGxpc3RlbmVycyB0b1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlXG4gKiAgICAgICAgVHlwZSBvZiBldmVudCB0byBiaW5kIHRvLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gZm5cbiAqICAgICAgICBFdmVudCBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gb24oZWxlbSwgdHlwZSwgZm4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICByZXR1cm4gX2hhbmRsZU11bHRpcGxlRXZlbnRzKG9uLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cblxuICB2YXIgZGF0YSA9IGdldERhdGEoZWxlbSk7XG5cbiAgLy8gV2UgbmVlZCBhIHBsYWNlIHRvIHN0b3JlIGFsbCBvdXIgaGFuZGxlciBkYXRhXG4gIGlmICghZGF0YS5oYW5kbGVycykge1xuICAgIGRhdGEuaGFuZGxlcnMgPSB7fTtcbiAgfVxuXG4gIGlmICghZGF0YS5oYW5kbGVyc1t0eXBlXSkge1xuICAgIGRhdGEuaGFuZGxlcnNbdHlwZV0gPSBbXTtcbiAgfVxuXG4gIGlmICghZm4uZ3VpZCkge1xuICAgIGZuLmd1aWQgPSBuZXdHVUlEKCk7XG4gIH1cblxuICBkYXRhLmhhbmRsZXJzW3R5cGVdLnB1c2goZm4pO1xuXG4gIGlmICghZGF0YS5kaXNwYXRjaGVyKSB7XG4gICAgZGF0YS5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgZGF0YS5kaXNwYXRjaGVyID0gZnVuY3Rpb24gKGV2ZW50LCBoYXNoKSB7XG5cbiAgICAgIGlmIChkYXRhLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXZlbnQgPSBmaXhFdmVudChldmVudCk7XG5cbiAgICAgIHZhciBoYW5kbGVycyA9IGRhdGEuaGFuZGxlcnNbZXZlbnQudHlwZV07XG5cbiAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAvLyBDb3B5IGhhbmRsZXJzIHNvIGlmIGhhbmRsZXJzIGFyZSBhZGRlZC9yZW1vdmVkIGR1cmluZyB0aGUgcHJvY2VzcyBpdCBkb2Vzbid0IHRocm93IGV2ZXJ5dGhpbmcgb2ZmLlxuICAgICAgICB2YXIgaGFuZGxlcnNDb3B5ID0gaGFuZGxlcnMuc2xpY2UoMCk7XG5cbiAgICAgICAgZm9yICh2YXIgbSA9IDAsIG4gPSBoYW5kbGVyc0NvcHkubGVuZ3RoOyBtIDwgbjsgbSsrKSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBoYW5kbGVyc0NvcHlbbV0uY2FsbChlbGVtLCBldmVudCwgaGFzaCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGxvZyQxLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpZiAoZGF0YS5oYW5kbGVyc1t0eXBlXS5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhbHNlO1xuXG4gICAgICBpZiAoX3N1cHBvcnRzUGFzc2l2ZSAmJiBwYXNzaXZlRXZlbnRzLmluZGV4T2YodHlwZSkgPiAtMSkge1xuICAgICAgICBvcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XG4gICAgICB9XG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZGF0YS5kaXNwYXRjaGVyLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpIHtcbiAgICAgIGVsZW0uYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGRhdGEuZGlzcGF0Y2hlcik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgZnJvbSBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbVxuICogICAgICAgIE9iamVjdCB0byByZW1vdmUgbGlzdGVuZXJzIGZyb20uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt0eXBlXVxuICogICAgICAgIFR5cGUgb2YgbGlzdGVuZXIgdG8gcmVtb3ZlLiBEb24ndCBpbmNsdWRlIHRvIHJlbW92ZSBhbGwgZXZlbnRzIGZyb20gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IFtmbl1cbiAqICAgICAgICBTcGVjaWZpYyBsaXN0ZW5lciB0byByZW1vdmUuIERvbid0IGluY2x1ZGUgdG8gcmVtb3ZlIGxpc3RlbmVycyBmb3IgYW4gZXZlbnRcbiAqICAgICAgICB0eXBlLlxuICovXG5mdW5jdGlvbiBvZmYoZWxlbSwgdHlwZSwgZm4pIHtcbiAgLy8gRG9uJ3Qgd2FudCB0byBhZGQgYSBjYWNoZSBvYmplY3QgdGhyb3VnaCBnZXRFbERhdGEgaWYgbm90IG5lZWRlZFxuICBpZiAoIWhhc0RhdGEoZWxlbSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IGdldERhdGEoZWxlbSk7XG5cbiAgLy8gSWYgbm8gZXZlbnRzIGV4aXN0LCBub3RoaW5nIHRvIHVuYmluZFxuICBpZiAoIWRhdGEuaGFuZGxlcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIHJldHVybiBfaGFuZGxlTXVsdGlwbGVFdmVudHMob2ZmLCBlbGVtLCB0eXBlLCBmbik7XG4gIH1cblxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uXG4gIHZhciByZW1vdmVUeXBlID0gZnVuY3Rpb24gcmVtb3ZlVHlwZSh0KSB7XG4gICAgZGF0YS5oYW5kbGVyc1t0XSA9IFtdO1xuICAgIF9jbGVhblVwRXZlbnRzKGVsZW0sIHQpO1xuICB9O1xuXG4gIC8vIEFyZSB3ZSByZW1vdmluZyBhbGwgYm91bmQgZXZlbnRzP1xuICBpZiAoIXR5cGUpIHtcbiAgICBmb3IgKHZhciB0IGluIGRhdGEuaGFuZGxlcnMpIHtcbiAgICAgIHJlbW92ZVR5cGUodCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBoYW5kbGVycyA9IGRhdGEuaGFuZGxlcnNbdHlwZV07XG5cbiAgLy8gSWYgbm8gaGFuZGxlcnMgZXhpc3QsIG5vdGhpbmcgdG8gdW5iaW5kXG4gIGlmICghaGFuZGxlcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBubyBsaXN0ZW5lciB3YXMgcHJvdmlkZWQsIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciB0eXBlXG4gIGlmICghZm4pIHtcbiAgICByZW1vdmVUeXBlKHR5cGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFdlJ3JlIG9ubHkgcmVtb3ZpbmcgYSBzaW5nbGUgaGFuZGxlclxuICBpZiAoZm4uZ3VpZCkge1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgaGFuZGxlcnMubGVuZ3RoOyBuKyspIHtcbiAgICAgIGlmIChoYW5kbGVyc1tuXS5ndWlkID09PSBmbi5ndWlkKSB7XG4gICAgICAgIGhhbmRsZXJzLnNwbGljZShuLS0sIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jbGVhblVwRXZlbnRzKGVsZW0sIHR5cGUpO1xufVxuXG4vKipcbiAqIFRyaWdnZXIgYW4gZXZlbnQgZm9yIGFuIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXG4gKiAgICAgICAgRWxlbWVudCB0byB0cmlnZ2VyIGFuIGV2ZW50IG9uXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudHxzdHJpbmd9IGV2ZW50XG4gKiAgICAgICAgQSBzdHJpbmcgKHRoZSB0eXBlKSBvciBhbiBldmVudCBvYmplY3Qgd2l0aCBhIHR5cGUgYXR0cmlidXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtoYXNoXVxuICogICAgICAgIGRhdGEgaGFzaCB0byBwYXNzIGFsb25nIHdpdGggdGhlIGV2ZW50XG4gKlxuICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKiAgICAgICAgIC0gUmV0dXJucyB0aGUgb3Bwb3NpdGUgb2YgYGRlZmF1bHRQcmV2ZW50ZWRgIGlmIGRlZmF1bHQgd2FzIHByZXZlbnRlZFxuICogICAgICAgICAtIE90aGVyd2lzZSByZXR1cm5zIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiB0cmlnZ2VyKGVsZW0sIGV2ZW50LCBoYXNoKSB7XG4gIC8vIEZldGNoZXMgZWxlbWVudCBkYXRhIGFuZCBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IChmb3IgYnViYmxpbmcpLlxuICAvLyBEb24ndCB3YW50IHRvIGFkZCBhIGRhdGEgb2JqZWN0IHRvIGNhY2hlIGZvciBldmVyeSBwYXJlbnQsXG4gIC8vIHNvIGNoZWNraW5nIGhhc0VsRGF0YSBmaXJzdC5cbiAgdmFyIGVsZW1EYXRhID0gaGFzRGF0YShlbGVtKSA/IGdldERhdGEoZWxlbSkgOiB7fTtcbiAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSB8fCBlbGVtLm93bmVyRG9jdW1lbnQ7XG4gIC8vIHR5cGUgPSBldmVudC50eXBlIHx8IGV2ZW50LFxuICAvLyBoYW5kbGVyO1xuXG4gIC8vIElmIGFuIGV2ZW50IG5hbWUgd2FzIHBhc3NlZCBhcyBhIHN0cmluZywgY3JlYXRlcyBhbiBldmVudCBvdXQgb2YgaXRcbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBldmVudCA9IHsgdHlwZTogZXZlbnQsIHRhcmdldDogZWxlbSB9O1xuICB9XG4gIC8vIE5vcm1hbGl6ZXMgdGhlIGV2ZW50IHByb3BlcnRpZXMuXG4gIGV2ZW50ID0gZml4RXZlbnQoZXZlbnQpO1xuXG4gIC8vIElmIHRoZSBwYXNzZWQgZWxlbWVudCBoYXMgYSBkaXNwYXRjaGVyLCBleGVjdXRlcyB0aGUgZXN0YWJsaXNoZWQgaGFuZGxlcnMuXG4gIGlmIChlbGVtRGF0YS5kaXNwYXRjaGVyKSB7XG4gICAgZWxlbURhdGEuZGlzcGF0Y2hlci5jYWxsKGVsZW0sIGV2ZW50LCBoYXNoKTtcbiAgfVxuXG4gIC8vIFVubGVzcyBleHBsaWNpdGx5IHN0b3BwZWQgb3IgdGhlIGV2ZW50IGRvZXMgbm90IGJ1YmJsZSAoZS5nLiBtZWRpYSBldmVudHMpXG4gIC8vIHJlY3Vyc2l2ZWx5IGNhbGxzIHRoaXMgZnVuY3Rpb24gdG8gYnViYmxlIHRoZSBldmVudCB1cCB0aGUgRE9NLlxuICBpZiAocGFyZW50ICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICYmIGV2ZW50LmJ1YmJsZXMgPT09IHRydWUpIHtcbiAgICB0cmlnZ2VyLmNhbGwobnVsbCwgcGFyZW50LCBldmVudCwgaGFzaCk7XG5cbiAgICAvLyBJZiBhdCB0aGUgdG9wIG9mIHRoZSBET00sIHRyaWdnZXJzIHRoZSBkZWZhdWx0IGFjdGlvbiB1bmxlc3MgZGlzYWJsZWQuXG4gIH0gZWxzZSBpZiAoIXBhcmVudCAmJiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHZhciB0YXJnZXREYXRhID0gZ2V0RGF0YShldmVudC50YXJnZXQpO1xuXG4gICAgLy8gQ2hlY2tzIGlmIHRoZSB0YXJnZXQgaGFzIGEgZGVmYXVsdCBhY3Rpb24gZm9yIHRoaXMgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnRhcmdldFtldmVudC50eXBlXSkge1xuICAgICAgLy8gVGVtcG9yYXJpbHkgZGlzYWJsZXMgZXZlbnQgZGlzcGF0Y2hpbmcgb24gdGhlIHRhcmdldCBhcyB3ZSBoYXZlIGFscmVhZHkgZXhlY3V0ZWQgdGhlIGhhbmRsZXIuXG4gICAgICB0YXJnZXREYXRhLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIC8vIEV4ZWN1dGVzIHRoZSBkZWZhdWx0IGFjdGlvbi5cbiAgICAgIGlmICh0eXBlb2YgZXZlbnQudGFyZ2V0W2V2ZW50LnR5cGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGV2ZW50LnRhcmdldFtldmVudC50eXBlXSgpO1xuICAgICAgfVxuICAgICAgLy8gUmUtZW5hYmxlcyBldmVudCBkaXNwYXRjaGluZy5cbiAgICAgIHRhcmdldERhdGEuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBJbmZvcm0gdGhlIHRyaWdnZXJlciBpZiB0aGUgZGVmYXVsdCB3YXMgcHJldmVudGVkIGJ5IHJldHVybmluZyBmYWxzZVxuICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5cbi8qKlxuICogVHJpZ2dlciBhIGxpc3RlbmVyIG9ubHkgb25jZSBmb3IgYW4gZXZlbnRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXG4gKiAgICAgICAgRWxlbWVudCBvciBvYmplY3QgdG8gYmluZCB0by5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdHlwZVxuICogICAgICAgIE5hbWUvdHlwZSBvZiBldmVudFxuICpcbiAqIEBwYXJhbSB7RXZlbnR+RXZlbnRMaXN0ZW5lcn0gZm5cbiAqICAgICAgICBFdmVudCBMaXN0ZW5lciBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBvbmUoZWxlbSwgdHlwZSwgZm4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICByZXR1cm4gX2hhbmRsZU11bHRpcGxlRXZlbnRzKG9uZSwgZWxlbSwgdHlwZSwgZm4pO1xuICB9XG4gIHZhciBmdW5jID0gZnVuY3Rpb24gZnVuYygpIHtcbiAgICBvZmYoZWxlbSwgdHlwZSwgZnVuYyk7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBjb3B5IHRoZSBndWlkIHRvIHRoZSBuZXcgZnVuY3Rpb24gc28gaXQgY2FuIHJlbW92ZWQgdXNpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uJ3MgSURcbiAgZnVuYy5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgbmV3R1VJRCgpO1xuICBvbihlbGVtLCB0eXBlLCBmdW5jKTtcbn1cblxudmFyIEV2ZW50cyA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xuXHRmaXhFdmVudDogZml4RXZlbnQsXG5cdG9uOiBvbixcblx0b2ZmOiBvZmYsXG5cdHRyaWdnZXI6IHRyaWdnZXIsXG5cdG9uZTogb25lXG59KTtcblxuLyoqXG4gKiBAZmlsZSBzZXR1cC5qcyAtIEZ1bmN0aW9ucyBmb3Igc2V0dGluZyB1cCBhIHBsYXllciB3aXRob3V0XG4gKiB1c2VyIGludGVyYWN0aW9uIGJhc2VkIG9uIHRoZSBkYXRhLXNldHVwIGBhdHRyaWJ1dGVgIG9mIHRoZSB2aWRlbyB0YWcuXG4gKlxuICogQG1vZHVsZSBzZXR1cFxuICovXG52YXIgX3dpbmRvd0xvYWRlZCA9IGZhbHNlO1xudmFyIHZpZGVvanMkMiA9IHZvaWQgMDtcblxuLyoqXG4gKiBTZXQgdXAgYW55IHRhZ3MgdGhhdCBoYXZlIGEgZGF0YS1zZXR1cCBgYXR0cmlidXRlYCB3aGVuIHRoZSBwbGF5ZXIgaXMgc3RhcnRlZC5cbiAqL1xudmFyIGF1dG9TZXR1cCA9IGZ1bmN0aW9uIGF1dG9TZXR1cCgpIHtcblxuICAvLyBQcm90ZWN0IGFnYWluc3QgYnJlYWthZ2UgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICBpZiAoIWlzUmVhbCgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gT25lIGRheSwgd2hlbiB3ZSBzdG9wIHN1cHBvcnRpbmcgSUU4LCBnbyBiYWNrIHRvIHRoaXMsIGJ1dCBpbiB0aGUgbWVhbnRpbWUuLi4qaGFjayBoYWNrIGhhY2sqXG4gIC8vIHZhciB2aWRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpZGVvJykpO1xuICAvLyB2YXIgYXVkaW9zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2F1ZGlvJykpO1xuICAvLyB2YXIgbWVkaWFFbHMgPSB2aWRzLmNvbmNhdChhdWRpb3MpO1xuXG4gIC8vIEJlY2F1c2UgSUU4IGRvZXNuJ3Qgc3VwcG9ydCBjYWxsaW5nIHNsaWNlIG9uIGEgbm9kZSBsaXN0LCB3ZSBuZWVkIHRvIGxvb3BcbiAgLy8gdGhyb3VnaCBlYWNoIGxpc3Qgb2YgZWxlbWVudHMgdG8gYnVpbGQgdXAgYSBuZXcsIGNvbWJpbmVkIGxpc3Qgb2YgZWxlbWVudHMuXG4gIHZhciB2aWRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpZGVvJyk7XG4gIHZhciBhdWRpb3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYXVkaW8nKTtcbiAgdmFyIG1lZGlhRWxzID0gW107XG5cbiAgaWYgKHZpZHMgJiYgdmlkcy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGUgPSB2aWRzLmxlbmd0aDsgaSA8IGU7IGkrKykge1xuICAgICAgbWVkaWFFbHMucHVzaCh2aWRzW2ldKTtcbiAgICB9XG4gIH1cblxuICBpZiAoYXVkaW9zICYmIGF1ZGlvcy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfZSA9IGF1ZGlvcy5sZW5ndGg7IF9pIDwgX2U7IF9pKyspIHtcbiAgICAgIG1lZGlhRWxzLnB1c2goYXVkaW9zW19pXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgYW55IG1lZGlhIGVsZW1lbnRzIGV4aXN0XG4gIGlmIChtZWRpYUVscyAmJiBtZWRpYUVscy5sZW5ndGggPiAwKSB7XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwLCBfZTIgPSBtZWRpYUVscy5sZW5ndGg7IF9pMiA8IF9lMjsgX2kyKyspIHtcbiAgICAgIHZhciBtZWRpYUVsID0gbWVkaWFFbHNbX2kyXTtcblxuICAgICAgLy8gQ2hlY2sgaWYgZWxlbWVudCBleGlzdHMsIGhhcyBnZXRBdHRyaWJ1dGUgZnVuYy5cbiAgICAgIC8vIElFIHNlZW1zIHRvIGNvbnNpZGVyIHR5cGVvZiBlbC5nZXRBdHRyaWJ1dGUgPT0gJ29iamVjdCcgaW5zdGVhZCBvZlxuICAgICAgLy8gJ2Z1bmN0aW9uJyBsaWtlIGV4cGVjdGVkLCBhdCBsZWFzdCB3aGVuIGxvYWRpbmcgdGhlIHBsYXllciBpbW1lZGlhdGVseS5cbiAgICAgIGlmIChtZWRpYUVsICYmIG1lZGlhRWwuZ2V0QXR0cmlidXRlKSB7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoaXMgcGxheWVyIGhhc24ndCBhbHJlYWR5IGJlZW4gc2V0IHVwLlxuICAgICAgICBpZiAobWVkaWFFbC5wbGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBvcHRpb25zID0gbWVkaWFFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2V0dXAnKTtcblxuICAgICAgICAgIC8vIENoZWNrIGlmIGRhdGEtc2V0dXAgYXR0ciBleGlzdHMuXG4gICAgICAgICAgLy8gV2Ugb25seSBhdXRvLXNldHVwIGlmIHRoZXkndmUgYWRkZWQgdGhlIGRhdGEtc2V0dXAgYXR0ci5cbiAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyB2aWRlby5qcyBpbnN0YW5jZS5cbiAgICAgICAgICAgIHZpZGVvanMkMihtZWRpYUVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBnZXRBdHRyaWJ1dGUgaXNuJ3QgZGVmaW5lZCwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgRE9NLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXV0b1NldHVwVGltZW91dCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gdmlkZW9zIHdlcmUgZm91bmQsIHNvIGtlZXAgbG9vcGluZyB1bmxlc3MgcGFnZSBpcyBmaW5pc2hlZCBsb2FkaW5nLlxuICB9IGVsc2UgaWYgKCFfd2luZG93TG9hZGVkKSB7XG4gICAgYXV0b1NldHVwVGltZW91dCgxKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWl0IHVudGlsIHRoZSBwYWdlIGlzIGxvYWRlZCBiZWZvcmUgcnVubmluZyBhdXRvU2V0dXAuIFRoaXMgd2lsbCBiZSBjYWxsZWQgaW5cbiAqIGF1dG9TZXR1cCBpZiBgaGFzTG9hZGVkYCByZXR1cm5zIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0XG4gKiAgICAgICAgSG93IGxvbmcgdG8gd2FpdCBpbiBtc1xuICpcbiAqIEBwYXJhbSB7bW9kdWxlOnZpZGVvanN9IFt2anNdXG4gKiAgICAgICAgVGhlIHZpZGVvanMgbGlicmFyeSBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBhdXRvU2V0dXBUaW1lb3V0KHdhaXQsIHZqcykge1xuICBpZiAodmpzKSB7XG4gICAgdmlkZW9qcyQyID0gdmpzO1xuICB9XG5cbiAgd2luZG93LnNldFRpbWVvdXQoYXV0b1NldHVwLCB3YWl0KTtcbn1cblxuaWYgKGlzUmVhbCgpICYmIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgX3dpbmRvd0xvYWRlZCA9IHRydWU7XG59IGVsc2Uge1xuICAvKipcbiAgICogTGlzdGVuIGZvciB0aGUgbG9hZCBldmVudCBvbiB3aW5kb3csIGFuZCBzZXQgX3dpbmRvd0xvYWRlZCB0byB0cnVlLlxuICAgKlxuICAgKiBAbGlzdGVucyBsb2FkXG4gICAqL1xuICBvbmUod2luZG93LCAnbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBfd2luZG93TG9hZGVkID0gdHJ1ZTtcbiAgfSk7XG59XG5cbi8qKlxuICogQGZpbGUgc3R5bGVzaGVldC5qc1xuICogQG1vZHVsZSBzdHlsZXNoZWV0XG4gKi9cbi8qKlxuICogQ3JlYXRlIGEgRE9NIHN5bGUgZWxlbWVudCBnaXZlbiBhIGNsYXNzTmFtZSBmb3IgaXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICogICAgICAgIFRoZSBjbGFzc05hbWUgdG8gYWRkIHRvIHRoZSBjcmVhdGVkIHN0eWxlIGVsZW1lbnQuXG4gKlxuICogQHJldHVybiB7RWxlbWVudH1cbiAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAqL1xudmFyIGNyZWF0ZVN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChjbGFzc05hbWUpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICBzdHlsZS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuLyoqXG4gKiBBZGQgdGV4dCB0byBhIERPTSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgRWxlbWVudCB0byBhZGQgdGV4dCBjb250ZW50IHRvLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiAgICAgICAgVGhlIHRleHQgdG8gYWRkIHRvIHRoZSBlbGVtZW50LlxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiBzZXRUZXh0Q29udGVudChlbCwgY29udGVudCkge1xuICBpZiAoZWwuc3R5bGVTaGVldCkge1xuICAgIGVsLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgZWwudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICB9XG59O1xuXG4vKipcbiAqIEBmaWxlIGZuLmpzXG4gKiBAbW9kdWxlIGZuXG4gKi9cbi8qKlxuICogQmluZCAoYS5rLmEgcHJveHkgb3IgQ29udGV4dCkuIEEgc2ltcGxlIG1ldGhvZCBmb3IgY2hhbmdpbmcgdGhlIGNvbnRleHQgb2YgYSBmdW5jdGlvblxuICogSXQgYWxzbyBzdG9yZXMgYSB1bmlxdWUgaWQgb24gdGhlIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBlYXNpbHkgcmVtb3ZlZCBmcm9tIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0XG4gKiAgICAgICAgVGhlIG9iamVjdCB0byBiaW5kIGFzIHNjb3BlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGJlIGJvdW5kIHRvIGEgc2NvcGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFt1aWRdXG4gKiAgICAgICAgQW4gb3B0aW9uYWwgdW5pcXVlIElEIGZvciB0aGUgZnVuY3Rpb24gdG8gYmUgc2V0XG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiAgICAgICAgIFRoZSBuZXcgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGJvdW5kIGludG8gdGhlIGNvbnRleHQgZ2l2ZW5cbiAqL1xudmFyIGJpbmQgPSBmdW5jdGlvbiBiaW5kKGNvbnRleHQsIGZuLCB1aWQpIHtcbiAgLy8gTWFrZSBzdXJlIHRoZSBmdW5jdGlvbiBoYXMgYSB1bmlxdWUgSURcbiAgaWYgKCFmbi5ndWlkKSB7XG4gICAgZm4uZ3VpZCA9IG5ld0dVSUQoKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSB0aGUgbmV3IGZ1bmN0aW9uIHRoYXQgY2hhbmdlcyB0aGUgY29udGV4dFxuICB2YXIgYm91bmQgPSBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBBbGxvdyBmb3IgdGhlIGFiaWxpdHkgdG8gaW5kaXZpZHVhbGl6ZSB0aGlzIGZ1bmN0aW9uXG4gIC8vIE5lZWRlZCBpbiB0aGUgY2FzZSB3aGVyZSBtdWx0aXBsZSBvYmplY3RzIG1pZ2h0IHNoYXJlIHRoZSBzYW1lIHByb3RvdHlwZVxuICAvLyBJRiBib3RoIGl0ZW1zIGFkZCBhbiBldmVudCBsaXN0ZW5lciB3aXRoIHRoZSBzYW1lIGZ1bmN0aW9uLCB0aGVuIHlvdSB0cnkgdG8gcmVtb3ZlIGp1c3Qgb25lXG4gIC8vIGl0IHdpbGwgcmVtb3ZlIGJvdGggYmVjYXVzZSB0aGV5IGJvdGggaGF2ZSB0aGUgc2FtZSBndWlkLlxuICAvLyB3aGVuIHVzaW5nIHRoaXMsIHlvdSBuZWVkIHRvIHVzZSB0aGUgYmluZCBtZXRob2Qgd2hlbiB5b3UgcmVtb3ZlIHRoZSBsaXN0ZW5lciBhcyB3ZWxsLlxuICAvLyBjdXJyZW50bHkgdXNlZCBpbiB0ZXh0IHRyYWNrc1xuICBib3VuZC5ndWlkID0gdWlkID8gdWlkICsgJ18nICsgZm4uZ3VpZCA6IGZuLmd1aWQ7XG5cbiAgcmV0dXJuIGJvdW5kO1xufTtcblxuLyoqXG4gKiBXcmFwcyB0aGUgZ2l2ZW4gZnVuY3Rpb24sIGBmbmAsIHdpdGggYSBuZXcgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZuYFxuICogYXQgbW9zdCBvbmNlIHBlciBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICogICAgICAgICBUaGUgZnVuY3Rpb24gdG8gYmUgdGhyb3R0bGVkLlxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gICB3YWl0XG4gKiAgICAgICAgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGJ5IHdoaWNoIHRvIHRocm90dGxlLlxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG52YXIgdGhyb3R0bGUgPSBmdW5jdGlvbiB0aHJvdHRsZShmbiwgd2FpdCkge1xuICB2YXIgbGFzdCA9IERhdGUubm93KCk7XG5cbiAgdmFyIHRocm90dGxlZCA9IGZ1bmN0aW9uIHRocm90dGxlZCgpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGlmIChub3cgLSBsYXN0ID49IHdhaXQpIHtcbiAgICAgIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgIGxhc3QgPSBub3c7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aHJvdHRsZWQ7XG59O1xuXG4vKipcbiAqIEBmaWxlIHNyYy9qcy9ldmVudC10YXJnZXQuanNcbiAqL1xuLyoqXG4gKiBgRXZlbnRUYXJnZXRgIGlzIGEgY2xhc3MgdGhhdCBjYW4gaGF2ZSB0aGUgc2FtZSBBUEkgYXMgdGhlIERPTSBgRXZlbnRUYXJnZXRgLiBJdFxuICogYWRkcyBzaG9ydGhhbmQgZnVuY3Rpb25zIHRoYXQgd3JhcCBhcm91bmQgbGVuZ3RoeSBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICogdGhlIGBvbmAgZnVuY3Rpb24gaXMgYSB3cmFwcGVyIGFyb3VuZCBgYWRkRXZlbnRMaXN0ZW5lcmAuXG4gKlxuICogQHNlZSBbRXZlbnRUYXJnZXQgU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXR9XG4gKiBAY2xhc3MgRXZlbnRUYXJnZXRcbiAqL1xudmFyIEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7fTtcblxuLyoqXG4gKiBBIEN1c3RvbSBET00gZXZlbnQuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gRXZlbnRUYXJnZXR+RXZlbnRcbiAqIEBzZWUgW1Byb3BlcnRpZXNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudH1cbiAqL1xuXG4vKipcbiAqIEFsbCBldmVudCBsaXN0ZW5lcnMgc2hvdWxkIGZvbGxvdyB0aGUgZm9sbG93aW5nIGZvcm1hdC5cbiAqXG4gKiBAY2FsbGJhY2sgRXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lclxuICogQHRoaXMge0V2ZW50VGFyZ2V0fVxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gKiAgICAgICAgdGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2hhc2hdXG4gKiAgICAgICAgaGFzaCBvZiBkYXRhIHNlbnQgZHVyaW5nIHRoZSBldmVudFxuICovXG5cbi8qKlxuICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgZXZlbnQgbmFtZXMgYXMga2V5cyBhbmQgYm9vbGVhbnMgYXMgdmFsdWVzLlxuICpcbiAqID4gTk9URTogSWYgYW4gZXZlbnQgbmFtZSBpcyBzZXQgdG8gYSB0cnVlIHZhbHVlIGhlcmUge0BsaW5rIEV2ZW50VGFyZ2V0I3RyaWdnZXJ9XG4gKiAgICAgICAgIHdpbGwgaGF2ZSBleHRyYSBmdW5jdGlvbmFsaXR5LiBTZWUgdGhhdCBmdW5jdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcHJvcGVydHkgRXZlbnRUYXJnZXQucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfXG4gKiBAcHJpdmF0ZVxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7fTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudCBsaXN0ZW5lcmAgdG8gYW4gaW5zdGFuY2Ugb2YgYW4gYEV2ZW50VGFyZ2V0YC4gQW4gYGV2ZW50IGxpc3RlbmVyYCBpcyBhXG4gKiBmdW5jdGlvbiB0aGF0IHdpbGwgZ2V0IGNhbGxlZCB3aGVuIGFuIGV2ZW50IHdpdGggYSBjZXJ0YWluIG5hbWUgZ2V0cyB0cmlnZ2VyZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHR5cGVcbiAqICAgICAgICBBbiBldmVudCBuYW1lIG9yIGFuIGFycmF5IG9mIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gZm5cbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIGBFdmVudFRhcmdldGBzXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAvLyBSZW1vdmUgdGhlIGFkZEV2ZW50TGlzdGVuZXIgYWxpYXMgYmVmb3JlIGNhbGxpbmcgRXZlbnRzLm9uXG4gIC8vIHNvIHdlIGRvbid0IGdldCBpbnRvIGFuIGluZmluaXRlIHR5cGUgbG9vcFxuICB2YXIgYWVsID0gdGhpcy5hZGRFdmVudExpc3RlbmVyO1xuXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHt9O1xuICBvbih0aGlzLCB0eXBlLCBmbik7XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGFlbDtcbn07XG5cbi8qKlxuICogQW4gYWxpYXMgb2Yge0BsaW5rIEV2ZW50VGFyZ2V0I29ufS4gQWxsb3dzIGBFdmVudFRhcmdldGAgdG8gbWltaWNcbiAqIHRoZSBzdGFuZGFyZCBET00gQVBJLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHNlZSB7QGxpbmsgRXZlbnRUYXJnZXQjb259XG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLm9uO1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gYGV2ZW50IGxpc3RlbmVyYCBmb3IgYSBzcGVjaWZpYyBldmVudCBmcm9tIGFuIGluc3RhbmNlIG9mIGBFdmVudFRhcmdldGAuXG4gKiBUaGlzIG1ha2VzIGl0IHNvIHRoYXQgdGhlIGBldmVudCBsaXN0ZW5lcmAgd2lsbCBubyBsb25nZXIgZ2V0IGNhbGxlZCB3aGVuIHRoZVxuICogbmFtZWQgZXZlbnQgaGFwcGVucy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdHlwZVxuICogICAgICAgIEFuIGV2ZW50IG5hbWUgb3IgYW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMuXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBmblxuICogICAgICAgIFRoZSBmdW5jdGlvbiB0byByZW1vdmUuXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgb2ZmKHRoaXMsIHR5cGUsIGZuKTtcbn07XG5cbi8qKlxuICogQW4gYWxpYXMgb2Yge0BsaW5rIEV2ZW50VGFyZ2V0I29mZn0uIEFsbG93cyBgRXZlbnRUYXJnZXRgIHRvIG1pbWljXG4gKiB0aGUgc3RhbmRhcmQgRE9NIEFQSS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBzZWUge0BsaW5rIEV2ZW50VGFyZ2V0I29mZn1cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUub2ZmO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhZGQgYW4gYGV2ZW50IGxpc3RlbmVyYCB0aGF0IGdldHMgdHJpZ2dlcmVkIG9ubHkgb25jZS4gQWZ0ZXIgdGhlXG4gKiBmaXJzdCB0cmlnZ2VyIGl0IHdpbGwgZ2V0IHJlbW92ZWQuIFRoaXMgaXMgbGlrZSBhZGRpbmcgYW4gYGV2ZW50IGxpc3RlbmVyYFxuICogd2l0aCB7QGxpbmsgRXZlbnRUYXJnZXQjb259IHRoYXQgY2FsbHMge0BsaW5rIEV2ZW50VGFyZ2V0I29mZn0gb24gaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlXG4gKiAgICAgICAgQW4gZXZlbnQgbmFtZSBvciBhbiBhcnJheSBvZiBldmVudCBuYW1lcy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZuXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIGV2ZW50IG5hbWUuXG4gKi9cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5vbmUgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgLy8gUmVtb3ZlIHRoZSBhZGRFdmVudExpc3RlbmVyIGFsaWFsaW5nIEV2ZW50cy5vblxuICAvLyBzbyB3ZSBkb24ndCBnZXQgaW50byBhbiBpbmZpbml0ZSB0eXBlIGxvb3BcbiAgdmFyIGFlbCA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcjtcblxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgb25lKHRoaXMsIHR5cGUsIGZuKTtcbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyID0gYWVsO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhdXNlcyBhbiBldmVudCB0byBoYXBwZW4uIFRoaXMgd2lsbCB0aGVuIGNhdXNlIGFueSBgZXZlbnQgbGlzdGVuZXJzYFxuICogdGhhdCBhcmUgd2FpdGluZyBmb3IgdGhhdCBldmVudCwgdG8gZ2V0IGNhbGxlZC4gSWYgdGhlcmUgYXJlIG5vIGBldmVudCBsaXN0ZW5lcnNgXG4gKiBmb3IgYW4gZXZlbnQgdGhlbiBub3RoaW5nIHdpbGwgaGFwcGVuLlxuICpcbiAqIElmIHRoZSBuYW1lIG9mIHRoZSBgRXZlbnRgIHRoYXQgaXMgYmVpbmcgdHJpZ2dlcmVkIGlzIGluIGBFdmVudFRhcmdldC5hbGxvd2VkRXZlbnRzX2AuXG4gKiBUcmlnZ2VyIHdpbGwgYWxzbyBjYWxsIHRoZSBgb25gICsgYHVwcGVyY2FzZUV2ZW50TmFtZWAgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqICdjbGljaycgaXMgaW4gYEV2ZW50VGFyZ2V0LmFsbG93ZWRFdmVudHNfYCwgc28sIHRyaWdnZXIgd2lsbCBhdHRlbXB0IHRvIGNhbGxcbiAqIGBvbkNsaWNrYCBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8RXZlbnRUYXJnZXR+RXZlbnR8T2JqZWN0fSBldmVudFxuICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBldmVudCwgYW4gYEV2ZW50YCwgb3IgYW4gb2JqZWN0IHdpdGggYSBrZXkgb2YgdHlwZSBzZXQgdG9cbiAqICAgICAgICBhbiBldmVudCBuYW1lLlxuICovXG5FdmVudFRhcmdldC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgZXZlbnQ7XG5cbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBldmVudCA9IHsgdHlwZTogdHlwZSB9O1xuICB9XG4gIGV2ZW50ID0gZml4RXZlbnQoZXZlbnQpO1xuXG4gIGlmICh0aGlzLmFsbG93ZWRFdmVudHNfW3R5cGVdICYmIHRoaXNbJ29uJyArIHR5cGVdKSB7XG4gICAgdGhpc1snb24nICsgdHlwZV0oZXZlbnQpO1xuICB9XG5cbiAgdHJpZ2dlcih0aGlzLCBldmVudCk7XG59O1xuXG4vKipcbiAqIEFuIGFsaWFzIG9mIHtAbGluayBFdmVudFRhcmdldCN0cmlnZ2VyfS4gQWxsb3dzIGBFdmVudFRhcmdldGAgdG8gbWltaWNcbiAqIHRoZSBzdGFuZGFyZCBET00gQVBJLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHNlZSB7QGxpbmsgRXZlbnRUYXJnZXQjdHJpZ2dlcn1cbiAqL1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBFdmVudFRhcmdldC5wcm90b3R5cGUudHJpZ2dlcjtcblxuLyoqXG4gKiBAZmlsZSBtaXhpbnMvZXZlbnRlZC5qc1xuICogQG1vZHVsZSBldmVudGVkXG4gKi9cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaGFzIGhhZCB0aGUgZXZlbnRlZCBtaXhpbiBhcHBsaWVkLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0XG4gKiAgICAgICAgIEFuIG9iamVjdCB0byB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgYXBwZWFycyB0byBiZSBldmVudGVkLlxuICovXG52YXIgaXNFdmVudGVkID0gZnVuY3Rpb24gaXNFdmVudGVkKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgRXZlbnRUYXJnZXQgfHwgISFvYmplY3QuZXZlbnRCdXNFbF8gJiYgWydvbicsICdvbmUnLCAnb2ZmJywgJ3RyaWdnZXInXS5ldmVyeShmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0W2tdID09PSAnZnVuY3Rpb24nO1xuICB9KTtcbn07XG5cbi8qKlxuICogV2hldGhlciBhIHZhbHVlIGlzIGEgdmFsaWQgZXZlbnQgdHlwZSAtIG5vbi1lbXB0eSBzdHJpbmcgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge3N0cmluZ3xBcnJheX0gdHlwZVxuICogICAgICAgICBUaGUgdHlwZSB2YWx1ZSB0byB0ZXN0LlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSB0eXBlIGlzIGEgdmFsaWQgZXZlbnQgdHlwZS5cbiAqL1xudmFyIGlzVmFsaWRFdmVudFR5cGUgPSBmdW5jdGlvbiBpc1ZhbGlkRXZlbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBUaGUgcmVnZXggaGVyZSB2ZXJpZmllcyB0aGF0IHRoZSBgdHlwZWAgY29udGFpbnMgYXQgbGVhc3Qgb25lIG5vbi1cbiAgICAvLyB3aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgJiYgL1xcUy8udGVzdCh0eXBlKSB8fCBBcnJheS5pc0FycmF5KHR5cGUpICYmICEhdHlwZS5sZW5ndGhcbiAgKTtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGEgdmFsdWUgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGEgdmFsaWQgZXZlbnQgdGFyZ2V0LiBUaHJvd3MgaWYgbm90LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqICAgICAgICAgSWYgdGhlIHRhcmdldCBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSB2YWxpZCBldmVudCB0YXJnZXQuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAqICAgICAgICAgVGhlIG9iamVjdCB0byB0ZXN0LlxuICovXG52YXIgdmFsaWRhdGVUYXJnZXQgPSBmdW5jdGlvbiB2YWxpZGF0ZVRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKCF0YXJnZXQubm9kZU5hbWUgJiYgIWlzRXZlbnRlZCh0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhcmdldDsgbXVzdCBiZSBhIERPTSBub2RlIG9yIGV2ZW50ZWQgb2JqZWN0LicpO1xuICB9XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBhIHZhbHVlIHRvIGRldGVybWluZSBpZiBpdCBpcyBhIHZhbGlkIGV2ZW50IHRhcmdldC4gVGhyb3dzIGlmIG5vdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHRocm93cyB7RXJyb3J9XG4gKiAgICAgICAgIElmIHRoZSB0eXBlIGRvZXMgbm90IGFwcGVhciB0byBiZSBhIHZhbGlkIGV2ZW50IHR5cGUuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfEFycmF5fSB0eXBlXG4gKiAgICAgICAgIFRoZSB0eXBlIHRvIHRlc3QuXG4gKi9cbnZhciB2YWxpZGF0ZUV2ZW50VHlwZSA9IGZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRUeXBlKHR5cGUpIHtcbiAgaWYgKCFpc1ZhbGlkRXZlbnRUeXBlKHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGV2ZW50IHR5cGU7IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIG9yIGFycmF5LicpO1xuICB9XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBhIHZhbHVlIHRvIGRldGVybWluZSBpZiBpdCBpcyBhIHZhbGlkIGxpc3RlbmVyLiBUaHJvd3MgaWYgbm90LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqICAgICAgICAgSWYgdGhlIGxpc3RlbmVyIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICogICAgICAgICBUaGUgbGlzdGVuZXIgdG8gdGVzdC5cbiAqL1xudmFyIHZhbGlkYXRlTGlzdGVuZXIgPSBmdW5jdGlvbiB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdGVuZXI7IG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBhcmd1bWVudHMgZ2l2ZW4gdG8gYG9uKClgIG9yIGBvbmUoKWAsIHZhbGlkYXRlcyB0aGVtLCBhbmRcbiAqIG5vcm1hbGl6ZXMgdGhlbSBpbnRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7T2JqZWN0fSBzZWxmXG4gKiAgICAgICAgIFRoZSBldmVudGVkIG9iamVjdCBvbiB3aGljaCBgb24oKWAgb3IgYG9uZSgpYCB3YXMgY2FsbGVkLiBUaGlzXG4gKiAgICAgICAgIG9iamVjdCB3aWxsIGJlIGJvdW5kIGFzIHRoZSBgdGhpc2AgdmFsdWUgZm9yIHRoZSBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJnc1xuICogICAgICAgICBBbiBhcnJheSBvZiBhcmd1bWVudHMgcGFzc2VkIHRvIGBvbigpYCBvciBgb25lKClgLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdXNlZnVsIHZhbHVlcyBmb3IgYG9uKClgIG9yIGBvbmUoKWAgY2FsbHMuXG4gKi9cbnZhciBub3JtYWxpemVMaXN0ZW5BcmdzID0gZnVuY3Rpb24gbm9ybWFsaXplTGlzdGVuQXJncyhzZWxmLCBhcmdzKSB7XG5cbiAgLy8gSWYgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgaXMgbGVzcyB0aGFuIDMsIHRoZSB0YXJnZXQgaXMgYWx3YXlzIHRoZVxuICAvLyBldmVudGVkIG9iamVjdCBpdHNlbGYuXG4gIHZhciBpc1RhcmdldGluZ1NlbGYgPSBhcmdzLmxlbmd0aCA8IDMgfHwgYXJnc1swXSA9PT0gc2VsZiB8fCBhcmdzWzBdID09PSBzZWxmLmV2ZW50QnVzRWxfO1xuICB2YXIgdGFyZ2V0ID0gdm9pZCAwO1xuICB2YXIgdHlwZSA9IHZvaWQgMDtcbiAgdmFyIGxpc3RlbmVyID0gdm9pZCAwO1xuXG4gIGlmIChpc1RhcmdldGluZ1NlbGYpIHtcbiAgICB0YXJnZXQgPSBzZWxmLmV2ZW50QnVzRWxfO1xuXG4gICAgLy8gRGVhbCB3aXRoIGNhc2VzIHdoZXJlIHdlIGdvdCAzIGFyZ3VtZW50cywgYnV0IHdlIGFyZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyB0aGUgZXZlbnRlZCBvYmplY3QgaXRzZWxmLlxuICAgIGlmIChhcmdzLmxlbmd0aCA+PSAzKSB7XG4gICAgICBhcmdzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgdHlwZSA9IGFyZ3NbMF07XG4gICAgbGlzdGVuZXIgPSBhcmdzWzFdO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IGFyZ3NbMF07XG4gICAgdHlwZSA9IGFyZ3NbMV07XG4gICAgbGlzdGVuZXIgPSBhcmdzWzJdO1xuICB9XG5cbiAgdmFsaWRhdGVUYXJnZXQodGFyZ2V0KTtcbiAgdmFsaWRhdGVFdmVudFR5cGUodHlwZSk7XG4gIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGxpc3RlbmVyID0gYmluZChzZWxmLCBsaXN0ZW5lcik7XG5cbiAgcmV0dXJuIHsgaXNUYXJnZXRpbmdTZWxmOiBpc1RhcmdldGluZ1NlbGYsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbn07XG5cbi8qKlxuICogQWRkcyB0aGUgbGlzdGVuZXIgdG8gdGhlIGV2ZW50IHR5cGUocykgb24gdGhlIHRhcmdldCwgbm9ybWFsaXppbmcgZm9yXG4gKiB0aGUgdHlwZSBvZiB0YXJnZXQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge0VsZW1lbnR8T2JqZWN0fSB0YXJnZXRcbiAqICAgICAgICAgQSBET00gbm9kZSBvciBldmVudGVkIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG1ldGhvZFxuICogICAgICAgICBUaGUgZXZlbnQgYmluZGluZyBtZXRob2QgdG8gdXNlIChcIm9uXCIgb3IgXCJvbmVcIikuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfEFycmF5fSB0eXBlXG4gKiAgICAgICAgIE9uZSBvciBtb3JlIGV2ZW50IHR5cGUocykuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gKiAgICAgICAgIEEgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKi9cbnZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBtZXRob2QsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhbGlkYXRlVGFyZ2V0KHRhcmdldCk7XG5cbiAgaWYgKHRhcmdldC5ub2RlTmFtZSkge1xuICAgIEV2ZW50c1ttZXRob2RdKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFttZXRob2RdKHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb250YWlucyBtZXRob2RzIHRoYXQgcHJvdmlkZSBldmVudCBjYXBhYmlsaXRlcyB0byBhbiBvYmplY3Qgd2hpY2ggaXMgcGFzc2VkXG4gKiB0byB7QGxpbmsgbW9kdWxlOmV2ZW50ZWR8ZXZlbnRlZH0uXG4gKlxuICogQG1peGluIEV2ZW50ZWRNaXhpblxuICovXG52YXIgRXZlbnRlZE1peGluID0ge1xuXG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciB0byBhbiBldmVudCAob3IgZXZlbnRzKSBvbiB0aGlzIG9iamVjdCBvciBhbm90aGVyIGV2ZW50ZWRcbiAgICogb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8RWxlbWVudHxPYmplY3R9IHRhcmdldE9yVHlwZVxuICAgKiAgICAgICAgIElmIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXksIGl0IHJlcHJlc2VudHMgdGhlIGV2ZW50IHR5cGUocylcbiAgICogICAgICAgICB0aGF0IHdpbGwgdHJpZ2dlciB0aGUgbGlzdGVuZXIuXG4gICAqXG4gICAqICAgICAgICAgQW5vdGhlciBldmVudGVkIG9iamVjdCBjYW4gYmUgcGFzc2VkIGhlcmUgaW5zdGVhZCwgd2hpY2ggd2lsbFxuICAgKiAgICAgICAgIGNhdXNlIHRoZSBsaXN0ZW5lciB0byBsaXN0ZW4gZm9yIGV2ZW50cyBvbiBfdGhhdF8gb2JqZWN0LlxuICAgKlxuICAgKiAgICAgICAgIEluIGVpdGhlciBjYXNlLCB0aGUgbGlzdGVuZXIncyBgdGhpc2AgdmFsdWUgd2lsbCBiZSBib3VuZCB0b1xuICAgKiAgICAgICAgIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8RnVuY3Rpb259IHR5cGVPckxpc3RlbmVyXG4gICAqICAgICAgICAgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBhIHN0cmluZyBvciBhcnJheSwgdGhpcyBzaG91bGQgYmUgdGhlXG4gICAqICAgICAgICAgbGlzdGVuZXIgZnVuY3Rpb24uIE90aGVyd2lzZSwgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSBvZiBldmVudFxuICAgKiAgICAgICAgIHR5cGUocykuXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbbGlzdGVuZXJdXG4gICAqICAgICAgICAgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LCB0aGlzIHdpbGwgYmVcbiAgICogICAgICAgICB0aGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gICAqL1xuICBvbjogZnVuY3Rpb24gb24kJDEoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBfbm9ybWFsaXplTGlzdGVuQXJncyA9IG5vcm1hbGl6ZUxpc3RlbkFyZ3ModGhpcywgYXJncyksXG4gICAgICAgIGlzVGFyZ2V0aW5nU2VsZiA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzLmlzVGFyZ2V0aW5nU2VsZixcbiAgICAgICAgdGFyZ2V0ID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MudGFyZ2V0LFxuICAgICAgICB0eXBlID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MudHlwZSxcbiAgICAgICAgbGlzdGVuZXIgPSBfbm9ybWFsaXplTGlzdGVuQXJncy5saXN0ZW5lcjtcblxuICAgIGxpc3Rlbih0YXJnZXQsICdvbicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICAgIC8vIElmIHRoaXMgb2JqZWN0IGlzIGxpc3RlbmluZyB0byBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LlxuICAgIGlmICghaXNUYXJnZXRpbmdTZWxmKSB7XG5cbiAgICAgIC8vIElmIHRoaXMgb2JqZWN0IGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgICAgdmFyIHJlbW92ZUxpc3RlbmVyT25EaXNwb3NlID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJPbkRpc3Bvc2UoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5vZmYodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICB9O1xuXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgZnVuY3Rpb24gSUQgYXMgdGhlIGxpc3RlbmVyIHNvIHdlIGNhbiByZW1vdmUgaXQgbGF0ZXIgaXRcbiAgICAgIC8vIHVzaW5nIHRoZSBJRCBvZiB0aGUgb3JpZ2luYWwgbGlzdGVuZXIuXG4gICAgICByZW1vdmVMaXN0ZW5lck9uRGlzcG9zZS5ndWlkID0gbGlzdGVuZXIuZ3VpZDtcblxuICAgICAgLy8gQWRkIGEgbGlzdGVuZXIgdG8gdGhlIHRhcmdldCdzIGRpc3Bvc2UgZXZlbnQgYXMgd2VsbC4gVGhpcyBlbnN1cmVzXG4gICAgICAvLyB0aGF0IGlmIHRoZSB0YXJnZXQgaXMgZGlzcG9zZWQgQkVGT1JFIHRoaXMgb2JqZWN0LCB3ZSByZW1vdmUgdGhlXG4gICAgICAvLyByZW1vdmFsIGxpc3RlbmVyIHRoYXQgd2FzIGp1c3QgYWRkZWQuIE90aGVyd2lzZSwgd2UgY3JlYXRlIGEgbWVtb3J5IGxlYWsuXG4gICAgICB2YXIgcmVtb3ZlUmVtb3Zlck9uVGFyZ2V0RGlzcG9zZSA9IGZ1bmN0aW9uIHJlbW92ZVJlbW92ZXJPblRhcmdldERpc3Bvc2UoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5vZmYoJ2Rpc3Bvc2UnLCByZW1vdmVMaXN0ZW5lck9uRGlzcG9zZSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgZnVuY3Rpb24gSUQgYXMgdGhlIGxpc3RlbmVyIHNvIHdlIGNhbiByZW1vdmUgaXQgbGF0ZXJcbiAgICAgIC8vIGl0IHVzaW5nIHRoZSBJRCBvZiB0aGUgb3JpZ2luYWwgbGlzdGVuZXIuXG4gICAgICByZW1vdmVSZW1vdmVyT25UYXJnZXREaXNwb3NlLmd1aWQgPSBsaXN0ZW5lci5ndWlkO1xuXG4gICAgICBsaXN0ZW4odGhpcywgJ29uJywgJ2Rpc3Bvc2UnLCByZW1vdmVMaXN0ZW5lck9uRGlzcG9zZSk7XG4gICAgICBsaXN0ZW4odGFyZ2V0LCAnb24nLCAnZGlzcG9zZScsIHJlbW92ZVJlbW92ZXJPblRhcmdldERpc3Bvc2UpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBBZGQgYSBsaXN0ZW5lciB0byBhbiBldmVudCAob3IgZXZlbnRzKSBvbiB0aGlzIG9iamVjdCBvciBhbm90aGVyIGV2ZW50ZWRcbiAgICogb2JqZWN0LiBUaGUgbGlzdGVuZXIgd2lsbCBvbmx5IGJlIGNhbGxlZCBvbmNlIGFuZCB0aGVuIHJlbW92ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxFbGVtZW50fE9iamVjdH0gdGFyZ2V0T3JUeXBlXG4gICAqICAgICAgICAgSWYgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSwgaXQgcmVwcmVzZW50cyB0aGUgZXZlbnQgdHlwZShzKVxuICAgKiAgICAgICAgIHRoYXQgd2lsbCB0cmlnZ2VyIHRoZSBsaXN0ZW5lci5cbiAgICpcbiAgICogICAgICAgICBBbm90aGVyIGV2ZW50ZWQgb2JqZWN0IGNhbiBiZSBwYXNzZWQgaGVyZSBpbnN0ZWFkLCB3aGljaCB3aWxsXG4gICAqICAgICAgICAgY2F1c2UgdGhlIGxpc3RlbmVyIHRvIGxpc3RlbiBmb3IgZXZlbnRzIG9uIF90aGF0XyBvYmplY3QuXG4gICAqXG4gICAqICAgICAgICAgSW4gZWl0aGVyIGNhc2UsIHRoZSBsaXN0ZW5lcidzIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIGJvdW5kIHRvXG4gICAqICAgICAgICAgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxGdW5jdGlvbn0gdHlwZU9yTGlzdGVuZXJcbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGEgc3RyaW5nIG9yIGFycmF5LCB0aGlzIHNob3VsZCBiZSB0aGVcbiAgICogICAgICAgICBsaXN0ZW5lciBmdW5jdGlvbi4gT3RoZXJ3aXNlLCB0aGlzIGlzIGEgc3RyaW5nIG9yIGFycmF5IG9mIGV2ZW50XG4gICAqICAgICAgICAgdHlwZShzKS5cbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtsaXN0ZW5lcl1cbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGFub3RoZXIgZXZlbnRlZCBvYmplY3QsIHRoaXMgd2lsbCBiZVxuICAgKiAgICAgICAgIHRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICovXG4gIG9uZTogZnVuY3Rpb24gb25lJCQxKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICB2YXIgX25vcm1hbGl6ZUxpc3RlbkFyZ3MyID0gbm9ybWFsaXplTGlzdGVuQXJncyh0aGlzLCBhcmdzKSxcbiAgICAgICAgaXNUYXJnZXRpbmdTZWxmID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MyLmlzVGFyZ2V0aW5nU2VsZixcbiAgICAgICAgdGFyZ2V0ID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MyLnRhcmdldCxcbiAgICAgICAgdHlwZSA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzMi50eXBlLFxuICAgICAgICBsaXN0ZW5lciA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzMi5saXN0ZW5lcjtcblxuICAgIC8vIFRhcmdldGluZyB0aGlzIGV2ZW50ZWQgb2JqZWN0LlxuXG5cbiAgICBpZiAoaXNUYXJnZXRpbmdTZWxmKSB7XG4gICAgICBsaXN0ZW4odGFyZ2V0LCAnb25lJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gICAgICAvLyBUYXJnZXRpbmcgYW5vdGhlciBldmVudGVkIG9iamVjdC5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGxhcmdzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICBsYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyLm9mZih0YXJnZXQsIHR5cGUsIHdyYXBwZXIpO1xuICAgICAgICBsaXN0ZW5lci5hcHBseShudWxsLCBsYXJncyk7XG4gICAgICB9O1xuXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgZnVuY3Rpb24gSUQgYXMgdGhlIGxpc3RlbmVyIHNvIHdlIGNhbiByZW1vdmUgaXQgbGF0ZXJcbiAgICAgIC8vIGl0IHVzaW5nIHRoZSBJRCBvZiB0aGUgb3JpZ2luYWwgbGlzdGVuZXIuXG4gICAgICB3cmFwcGVyLmd1aWQgPSBsaXN0ZW5lci5ndWlkO1xuICAgICAgbGlzdGVuKHRhcmdldCwgJ29uZScsIHR5cGUsIHdyYXBwZXIpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGxpc3RlbmVyKHMpIGZyb20gZXZlbnQocykgb24gYW4gZXZlbnRlZCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxFbGVtZW50fE9iamVjdH0gW3RhcmdldE9yVHlwZV1cbiAgICogICAgICAgICBJZiB0aGlzIGlzIGEgc3RyaW5nIG9yIGFycmF5LCBpdCByZXByZXNlbnRzIHRoZSBldmVudCB0eXBlKHMpLlxuICAgKlxuICAgKiAgICAgICAgIEFub3RoZXIgZXZlbnRlZCBvYmplY3QgY2FuIGJlIHBhc3NlZCBoZXJlIGluc3RlYWQsIGluIHdoaWNoIGNhc2VcbiAgICogICAgICAgICBBTEwgMyBhcmd1bWVudHMgYXJlIF9yZXF1aXJlZF8uXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxGdW5jdGlvbn0gW3R5cGVPckxpc3RlbmVyXVxuICAgKiAgICAgICAgIElmIHRoZSBmaXJzdCBhcmd1bWVudCB3YXMgYSBzdHJpbmcgb3IgYXJyYXksIHRoaXMgbWF5IGJlIHRoZVxuICAgKiAgICAgICAgIGxpc3RlbmVyIGZ1bmN0aW9uLiBPdGhlcndpc2UsIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXkgb2YgZXZlbnRcbiAgICogICAgICAgICB0eXBlKHMpLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2xpc3RlbmVyXVxuICAgKiAgICAgICAgIElmIHRoZSBmaXJzdCBhcmd1bWVudCB3YXMgYW5vdGhlciBldmVudGVkIG9iamVjdCwgdGhpcyB3aWxsIGJlXG4gICAqICAgICAgICAgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uOyBvdGhlcndpc2UsIF9hbGxfIGxpc3RlbmVycyBib3VuZCB0byB0aGVcbiAgICogICAgICAgICBldmVudCB0eXBlKHMpIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICovXG4gIG9mZjogZnVuY3Rpb24gb2ZmJCQxKHRhcmdldE9yVHlwZSwgdHlwZU9yTGlzdGVuZXIsIGxpc3RlbmVyKSB7XG5cbiAgICAvLyBUYXJnZXRpbmcgdGhpcyBldmVudGVkIG9iamVjdC5cbiAgICBpZiAoIXRhcmdldE9yVHlwZSB8fCBpc1ZhbGlkRXZlbnRUeXBlKHRhcmdldE9yVHlwZSkpIHtcbiAgICAgIG9mZih0aGlzLmV2ZW50QnVzRWxfLCB0YXJnZXRPclR5cGUsIHR5cGVPckxpc3RlbmVyKTtcblxuICAgICAgLy8gVGFyZ2V0aW5nIGFub3RoZXIgZXZlbnRlZCBvYmplY3QuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRPclR5cGU7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVPckxpc3RlbmVyO1xuXG4gICAgICAvLyBGYWlsIGZhc3QgYW5kIGluIGEgbWVhbmluZ2Z1bCB3YXkhXG4gICAgICB2YWxpZGF0ZVRhcmdldCh0YXJnZXQpO1xuICAgICAgdmFsaWRhdGVFdmVudFR5cGUodHlwZSk7XG4gICAgICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgLy8gRW5zdXJlIHRoZXJlJ3MgYXQgbGVhc3QgYSBndWlkLCBldmVuIGlmIHRoZSBmdW5jdGlvbiBoYXNuJ3QgYmVlbiB1c2VkXG4gICAgICBsaXN0ZW5lciA9IGJpbmQodGhpcywgbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZW1vdmUgdGhlIGRpc3Bvc2UgbGlzdGVuZXIgb24gdGhpcyBldmVudGVkIG9iamVjdCwgd2hpY2ggd2FzIGdpdmVuXG4gICAgICAvLyB0aGUgc2FtZSBndWlkIGFzIHRoZSBldmVudCBsaXN0ZW5lciBpbiBvbigpLlxuICAgICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnLCBsaXN0ZW5lcik7XG5cbiAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUpIHtcbiAgICAgICAgb2ZmKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBvZmYodGFyZ2V0LCAnZGlzcG9zZScsIGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNFdmVudGVkKHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0Lm9mZih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIHRhcmdldC5vZmYoJ2Rpc3Bvc2UnLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEZpcmUgYW4gZXZlbnQgb24gdGhpcyBldmVudGVkIG9iamVjdCwgY2F1c2luZyBpdHMgbGlzdGVuZXJzIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ3xPYmplY3R9IGV2ZW50XG4gICAqICAgICAgICAgIEFuIGV2ZW50IHR5cGUgb3IgYW4gb2JqZWN0IHdpdGggYSB0eXBlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSBbaGFzaF1cbiAgICogICAgICAgICAgQW4gYWRkaXRpb25hbCBvYmplY3QgdG8gcGFzcyBhbG9uZyB0byBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiAgICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgZGVmYXVsdCBiZWhhdmlvciB3YXMgcHJldmVudGVkLlxuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlciQkMShldmVudCwgaGFzaCkge1xuICAgIHJldHVybiB0cmlnZ2VyKHRoaXMuZXZlbnRCdXNFbF8sIGV2ZW50LCBoYXNoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIHtAbGluayBtb2R1bGU6ZXZlbnRlZH5FdmVudGVkTWl4aW58RXZlbnRlZE1peGlufSB0byBhIHRhcmdldCBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAqICAgICAgICAgVGhlIG9iamVjdCB0byB3aGljaCB0byBhZGQgZXZlbnQgbWV0aG9kcy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICogICAgICAgICBPcHRpb25zIGZvciBjdXN0b21pemluZyB0aGUgbWl4aW4gYmVoYXZpb3IuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBbb3B0aW9ucy5ldmVudEJ1c0tleV1cbiAqICAgICAgICAgQnkgZGVmYXVsdCwgYWRkcyBhIGBldmVudEJ1c0VsX2AgRE9NIGVsZW1lbnQgdG8gdGhlIHRhcmdldCBvYmplY3QsXG4gKiAgICAgICAgIHdoaWNoIGlzIHVzZWQgYXMgYW4gZXZlbnQgYnVzLiBJZiB0aGUgdGFyZ2V0IG9iamVjdCBhbHJlYWR5IGhhcyBhXG4gKiAgICAgICAgIERPTSBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHVzZWQsIHBhc3MgaXRzIGtleSBoZXJlLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqICAgICAgICAgVGhlIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV2ZW50ZWQodGFyZ2V0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIGV2ZW50QnVzS2V5ID0gb3B0aW9ucy5ldmVudEJ1c0tleTtcblxuICAvLyBTZXQgb3IgY3JlYXRlIHRoZSBldmVudEJ1c0VsXy5cblxuICBpZiAoZXZlbnRCdXNLZXkpIHtcbiAgICBpZiAoIXRhcmdldFtldmVudEJ1c0tleV0ubm9kZU5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGV2ZW50QnVzS2V5IFwiJyArIGV2ZW50QnVzS2V5ICsgJ1wiIGRvZXMgbm90IHJlZmVyIHRvIGFuIGVsZW1lbnQuJyk7XG4gICAgfVxuICAgIHRhcmdldC5ldmVudEJ1c0VsXyA9IHRhcmdldFtldmVudEJ1c0tleV07XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LmV2ZW50QnVzRWxfID0gY3JlYXRlRWwoJ3NwYW4nLCB7IGNsYXNzTmFtZTogJ3Zqcy1ldmVudC1idXMnIH0pO1xuICB9XG5cbiAgYXNzaWduKHRhcmdldCwgRXZlbnRlZE1peGluKTtcblxuICAvLyBXaGVuIGFueSBldmVudGVkIG9iamVjdCBpcyBkaXNwb3NlZCwgaXQgcmVtb3ZlcyBhbGwgaXRzIGxpc3RlbmVycy5cbiAgdGFyZ2V0Lm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0YXJnZXQub2ZmKCk7XG4gIH0pO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQGZpbGUgbWl4aW5zL3N0YXRlZnVsLmpzXG4gKiBAbW9kdWxlIHN0YXRlZnVsXG4gKi9cbi8qKlxuICogQ29udGFpbnMgbWV0aG9kcyB0aGF0IHByb3ZpZGUgc3RhdGVmdWxuZXNzIHRvIGFuIG9iamVjdCB3aGljaCBpcyBwYXNzZWRcbiAqIHRvIHtAbGluayBtb2R1bGU6c3RhdGVmdWx9LlxuICpcbiAqIEBtaXhpbiBTdGF0ZWZ1bE1peGluXG4gKi9cbnZhciBTdGF0ZWZ1bE1peGluID0ge1xuXG4gIC8qKlxuICAgKiBBIGhhc2ggY29udGFpbmluZyBhcmJpdHJhcnkga2V5cyBhbmQgdmFsdWVzIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2ZcbiAgICogdGhlIG9iamVjdC5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRlOiB7fSxcblxuICAvKipcbiAgICogU2V0IHRoZSBzdGF0ZSBvZiBhbiBvYmplY3QgYnkgbXV0YXRpbmcgaXRzXG4gICAqIHtAbGluayBtb2R1bGU6c3RhdGVmdWx+U3RhdGVmdWxNaXhpbi5zdGF0ZXxzdGF0ZX0gb2JqZWN0IGluIHBsYWNlLlxuICAgKlxuICAgKiBAZmlyZXMgICBtb2R1bGU6c3RhdGVmdWx+U3RhdGVmdWxNaXhpbiNzdGF0ZWNoYW5nZWRcbiAgICogQHBhcmFtICAge09iamVjdHxGdW5jdGlvbn0gc3RhdGVVcGRhdGVzXG4gICAqICAgICAgICAgIEEgbmV3IHNldCBvZiBwcm9wZXJ0aWVzIHRvIHNoYWxsb3ctbWVyZ2UgaW50byB0aGUgcGx1Z2luIHN0YXRlLlxuICAgKiAgICAgICAgICBDYW4gYmUgYSBwbGFpbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBwbGFpbiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBjaGFuZ2VzIHRoYXQgb2NjdXJyZWQuIElmIG5vIGNoYW5nZXNcbiAgICogICAgICAgICAgb2NjdXJyZWQsIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBzZXRTdGF0ZTogZnVuY3Rpb24gc2V0U3RhdGUoc3RhdGVVcGRhdGVzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIFN1cHBvcnQgcHJvdmlkaW5nIHRoZSBgc3RhdGVVcGRhdGVzYCBzdGF0ZSBhcyBhIGZ1bmN0aW9uLlxuICAgIGlmICh0eXBlb2Ygc3RhdGVVcGRhdGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZVVwZGF0ZXMgPSBzdGF0ZVVwZGF0ZXMoKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhbmdlcyA9IHZvaWQgMDtcblxuICAgIGVhY2goc3RhdGVVcGRhdGVzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYW5nZSBpZiB0aGUgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gd2hhdCdzIGluIHRoZVxuICAgICAgLy8gY3VycmVudCBzdGF0ZS5cbiAgICAgIGlmIChfdGhpcy5zdGF0ZVtrZXldICE9PSB2YWx1ZSkge1xuICAgICAgICBjaGFuZ2VzID0gY2hhbmdlcyB8fCB7fTtcbiAgICAgICAgY2hhbmdlc1trZXldID0ge1xuICAgICAgICAgIGZyb206IF90aGlzLnN0YXRlW2tleV0sXG4gICAgICAgICAgdG86IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnN0YXRlW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIC8vIE9ubHkgdHJpZ2dlciBcInN0YXRlY2hhbmdlXCIgaWYgdGhlcmUgd2VyZSBjaGFuZ2VzIEFORCB3ZSBoYXZlIGEgdHJpZ2dlclxuICAgIC8vIGZ1bmN0aW9uLiBUaGlzIGFsbG93cyB1cyB0byBub3QgcmVxdWlyZSB0aGF0IHRoZSB0YXJnZXQgb2JqZWN0IGJlIGFuXG4gICAgLy8gZXZlbnRlZCBvYmplY3QuXG4gICAgaWYgKGNoYW5nZXMgJiYgaXNFdmVudGVkKHRoaXMpKSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogQW4gZXZlbnQgdHJpZ2dlcmVkIG9uIGFuIG9iamVjdCB0aGF0IGlzIGJvdGhcbiAgICAgICAqIHtAbGluayBtb2R1bGU6c3RhdGVmdWx8c3RhdGVmdWx9IGFuZCB7QGxpbmsgbW9kdWxlOmV2ZW50ZWR8ZXZlbnRlZH1cbiAgICAgICAqIGluZGljYXRpbmcgdGhhdCBpdHMgc3RhdGUgaGFzIGNoYW5nZWQuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50ICAgIG1vZHVsZTpzdGF0ZWZ1bH5TdGF0ZWZ1bE1peGluI3N0YXRlY2hhbmdlZFxuICAgICAgICogQHR5cGUgICAgIHtPYmplY3R9XG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gY2hhbmdlc1xuICAgICAgICogICAgICAgICAgIEEgaGFzaCBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBjaGFuZ2VkIGFuZFxuICAgICAgICogICAgICAgICAgIHRoZSB2YWx1ZXMgdGhleSB3ZXJlIGNoYW5nZWQgYGZyb21gIGFuZCBgdG9gLlxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoe1xuICAgICAgICBjaGFuZ2VzOiBjaGFuZ2VzLFxuICAgICAgICB0eXBlOiAnc3RhdGVjaGFuZ2VkJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZXM7XG4gIH1cbn07XG5cbi8qKlxuICogQXBwbGllcyB7QGxpbmsgbW9kdWxlOnN0YXRlZnVsflN0YXRlZnVsTWl4aW58U3RhdGVmdWxNaXhpbn0gdG8gYSB0YXJnZXRcbiAqIG9iamVjdC5cbiAqXG4gKiBJZiB0aGUgdGFyZ2V0IG9iamVjdCBpcyB7QGxpbmsgbW9kdWxlOmV2ZW50ZWR8ZXZlbnRlZH0gYW5kIGhhcyBhXG4gKiBgaGFuZGxlU3RhdGVDaGFuZ2VkYCBtZXRob2QsIHRoYXQgbWV0aG9kIHdpbGwgYmUgYXV0b21hdGljYWxseSBib3VuZCB0byB0aGVcbiAqIGBzdGF0ZWNoYW5nZWRgIGV2ZW50IG9uIGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0gICB7T2JqZWN0fSB0YXJnZXRcbiAqICAgICAgICAgIFRoZSBvYmplY3QgdG8gYmUgbWFkZSBzdGF0ZWZ1bC5cbiAqXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBbZGVmYXVsdFN0YXRlXVxuICogICAgICAgICAgQSBkZWZhdWx0IHNldCBvZiBwcm9wZXJ0aWVzIHRvIHBvcHVsYXRlIHRoZSBuZXdseS1zdGF0ZWZ1bCBvYmplY3Qnc1xuICogICAgICAgICAgYHN0YXRlYCBwcm9wZXJ0eS5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogICAgICAgICAgUmV0dXJucyB0aGUgYHRhcmdldGAuXG4gKi9cbmZ1bmN0aW9uIHN0YXRlZnVsKHRhcmdldCwgZGVmYXVsdFN0YXRlKSB7XG4gIGFzc2lnbih0YXJnZXQsIFN0YXRlZnVsTWl4aW4pO1xuXG4gIC8vIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgbWl4aW5nLWluIGJlY2F1c2Ugd2UgbmVlZCB0byByZXBsYWNlIHRoZSBgc3RhdGVgXG4gIC8vIGFkZGVkIGluIHRoYXQgc3RlcC5cbiAgdGFyZ2V0LnN0YXRlID0gYXNzaWduKHt9LCB0YXJnZXQuc3RhdGUsIGRlZmF1bHRTdGF0ZSk7XG5cbiAgLy8gQXV0by1iaW5kIHRoZSBgaGFuZGxlU3RhdGVDaGFuZ2VkYCBtZXRob2Qgb2YgdGhlIHRhcmdldCBvYmplY3QgaWYgaXQgZXhpc3RzLlxuICBpZiAodHlwZW9mIHRhcmdldC5oYW5kbGVTdGF0ZUNoYW5nZWQgPT09ICdmdW5jdGlvbicgJiYgaXNFdmVudGVkKHRhcmdldCkpIHtcbiAgICB0YXJnZXQub24oJ3N0YXRlY2hhbmdlZCcsIHRhcmdldC5oYW5kbGVTdGF0ZUNoYW5nZWQpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBAZmlsZSB0by10aXRsZS1jYXNlLmpzXG4gKiBAbW9kdWxlIHRvLXRpdGxlLWNhc2VcbiAqL1xuXG4vKipcbiAqIFVwcGVyY2FzZSB0aGUgZmlyc3QgbGV0dGVyIG9mIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqICAgICAgICBTdHJpbmcgdG8gYmUgdXBwZXJjYXNlZFxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIHN0cmluZyB3aXRoIGFuIHVwcGVyY2FzZWQgZmlyc3QgbGV0dGVyXG4gKi9cbmZ1bmN0aW9uIHRvVGl0bGVDYXNlKHN0cmluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn1cblxuLyoqXG4gKiBDb21wYXJlcyB0aGUgVGl0bGVDYXNlIHZlcnNpb25zIG9mIHRoZSB0d28gc3RyaW5ncyBmb3IgZXF1YWxpdHkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cjFcbiAqICAgICAgICBUaGUgZmlyc3Qgc3RyaW5nIHRvIGNvbXBhcmVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyMlxuICogICAgICAgIFRoZSBzZWNvbmQgc3RyaW5nIHRvIGNvbXBhcmVcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICBXaGV0aGVyIHRoZSBUaXRsZUNhc2UgdmVyc2lvbnMgb2YgdGhlIHN0cmluZ3MgYXJlIGVxdWFsXG4gKi9cbmZ1bmN0aW9uIHRpdGxlQ2FzZUVxdWFscyhzdHIxLCBzdHIyKSB7XG4gIHJldHVybiB0b1RpdGxlQ2FzZShzdHIxKSA9PT0gdG9UaXRsZUNhc2Uoc3RyMik7XG59XG5cbi8qKlxuICogQGZpbGUgbWVyZ2Utb3B0aW9ucy5qc1xuICogQG1vZHVsZSBtZXJnZS1vcHRpb25zXG4gKi9cbi8qKlxuICogRGVlcC1tZXJnZSBvbmUgb3IgbW9yZSBvcHRpb25zIG9iamVjdHMsIHJlY3Vyc2l2ZWx5IG1lcmdpbmcgKipvbmx5KiogcGxhaW5cbiAqIG9iamVjdCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSAgIHtPYmplY3RbXX0gc291cmNlc1xuICogICAgICAgICAgT25lIG9yIG1vcmUgb2JqZWN0cyB0byBtZXJnZSBpbnRvIGEgbmV3IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogICAgICAgICAgQSBuZXcgb2JqZWN0IHRoYXQgaXMgdGhlIG1lcmdlZCByZXN1bHQgb2YgYWxsIHNvdXJjZXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucygpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc291cmNlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlYWNoKHNvdXJjZSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICghaXNQbGFpbih2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzUGxhaW4ocmVzdWx0W2tleV0pKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0ge307XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2VPcHRpb25zKHJlc3VsdFtrZXldLCB2YWx1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUGxheWVyIENvbXBvbmVudCAtIEJhc2UgY2xhc3MgZm9yIGFsbCBVSSBvYmplY3RzXG4gKlxuICogQGZpbGUgY29tcG9uZW50LmpzXG4gKi9cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIFVJIENvbXBvbmVudHMuXG4gKiBDb21wb25lbnRzIGFyZSBVSSBvYmplY3RzIHdoaWNoIHJlcHJlc2VudCBib3RoIGEgamF2YXNjcmlwdCBvYmplY3QgYW5kIGFuIGVsZW1lbnRcbiAqIGluIHRoZSBET00uIFRoZXkgY2FuIGJlIGNoaWxkcmVuIG9mIG90aGVyIGNvbXBvbmVudHMsIGFuZCBjYW4gaGF2ZVxuICogY2hpbGRyZW4gdGhlbXNlbHZlcy5cbiAqXG4gKiBDb21wb25lbnRzIGNhbiBhbHNvIHVzZSBtZXRob2RzIGZyb20ge0BsaW5rIEV2ZW50VGFyZ2V0fVxuICovXG5cbnZhciBDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZWFkeS4gRG9lcyBub3QgaGF2ZSBhbnlcbiAgICogcGFyYW10ZXJzIGFuZCBhbnkgY2FsbGJhY2sgdmFsdWUgd2lsbCBiZSBpZ25vcmVkLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgQ29tcG9uZW50flJlYWR5Q2FsbGJhY2tcbiAgICogQHRoaXMgQ29tcG9uZW50XG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBbb3B0aW9ucy5jaGlsZHJlbl1cbiAgICogICAgICAgIEFuIGFycmF5IG9mIGNoaWxkcmVuIG9iamVjdHMgdG8gaW50aWFsaXplIHRoaXMgY29tcG9uZW50IHdpdGguIENoaWxkcmVuIG9iamVjdHMgaGF2ZVxuICAgKiAgICAgICAgYSBuYW1lIHByb3BlcnR5IHRoYXQgd2lsbCBiZSB1c2VkIGlmIG1vcmUgdGhhbiBvbmUgY29tcG9uZW50IG9mIHRoZSBzYW1lIHR5cGUgbmVlZHMgdG8gYmVcbiAgICogICAgICAgIGFkZGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gICAqICAgICAgICBGdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIGBDb21wb25lbnRgIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gQ29tcG9uZW50KHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wb25lbnQpO1xuXG5cbiAgICAvLyBUaGUgY29tcG9uZW50IG1pZ2h0IGJlIHRoZSBwbGF5ZXIgaXRzZWxmIGFuZCB3ZSBjYW4ndCBwYXNzIGB0aGlzYCB0byBzdXBlclxuICAgIGlmICghcGxheWVyICYmIHRoaXMucGxheSkge1xuICAgICAgdGhpcy5wbGF5ZXJfID0gcGxheWVyID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBsYXllcl8gPSBwbGF5ZXI7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBhIGNvcHkgb2YgcHJvdG90eXBlLm9wdGlvbnNfIHRvIHByb3RlY3QgYWdhaW5zdCBvdmVycmlkaW5nIGRlZmF1bHRzXG4gICAgdGhpcy5vcHRpb25zXyA9IG1lcmdlT3B0aW9ucyh7fSwgdGhpcy5vcHRpb25zXyk7XG5cbiAgICAvLyBVcGRhdGVkIG9wdGlvbnMgd2l0aCBzdXBwbGllZCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uc18gPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zXywgb3B0aW9ucyk7XG5cbiAgICAvLyBHZXQgSUQgZnJvbSBvcHRpb25zIG9yIG9wdGlvbnMgZWxlbWVudCBpZiBvbmUgaXMgc3VwcGxpZWRcbiAgICB0aGlzLmlkXyA9IG9wdGlvbnMuaWQgfHwgb3B0aW9ucy5lbCAmJiBvcHRpb25zLmVsLmlkO1xuXG4gICAgLy8gSWYgdGhlcmUgd2FzIG5vIElEIGZyb20gdGhlIG9wdGlvbnMsIGdlbmVyYXRlIG9uZVxuICAgIGlmICghdGhpcy5pZF8pIHtcbiAgICAgIC8vIERvbid0IHJlcXVpcmUgdGhlIHBsYXllciBJRCBmdW5jdGlvbiBpbiB0aGUgY2FzZSBvZiBtb2NrIHBsYXllcnNcbiAgICAgIHZhciBpZCA9IHBsYXllciAmJiBwbGF5ZXIuaWQgJiYgcGxheWVyLmlkKCkgfHwgJ25vX3BsYXllcic7XG5cbiAgICAgIHRoaXMuaWRfID0gaWQgKyAnX2NvbXBvbmVudF8nICsgbmV3R1VJRCgpO1xuICAgIH1cblxuICAgIHRoaXMubmFtZV8gPSBvcHRpb25zLm5hbWUgfHwgbnVsbDtcblxuICAgIC8vIENyZWF0ZSBlbGVtZW50IGlmIG9uZSB3YXNuJ3QgcHJvdmlkZWQgaW4gb3B0aW9uc1xuICAgIGlmIChvcHRpb25zLmVsKSB7XG4gICAgICB0aGlzLmVsXyA9IG9wdGlvbnMuZWw7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmNyZWF0ZUVsICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5lbF8gPSB0aGlzLmNyZWF0ZUVsKCk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSB0aGlzIGFuIGV2ZW50ZWQgb2JqZWN0IGFuZCB1c2UgYGVsX2AsIGlmIGF2YWlsYWJsZSwgYXMgaXRzIGV2ZW50IGJ1c1xuICAgIGV2ZW50ZWQodGhpcywgeyBldmVudEJ1c0tleTogdGhpcy5lbF8gPyAnZWxfJyA6IG51bGwgfSk7XG4gICAgc3RhdGVmdWwodGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0U3RhdGUpO1xuXG4gICAgdGhpcy5jaGlsZHJlbl8gPSBbXTtcbiAgICB0aGlzLmNoaWxkSW5kZXhfID0ge307XG4gICAgdGhpcy5jaGlsZE5hbWVJbmRleF8gPSB7fTtcblxuICAgIC8vIEFkZCBhbnkgY2hpbGQgY29tcG9uZW50cyBpbiBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMuaW5pdENoaWxkcmVuICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5pbml0Q2hpbGRyZW4oKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlYWR5KHJlYWR5KTtcbiAgICAvLyBEb24ndCB3YW50IHRvIHRyaWdnZXIgcmVhZHkgaGVyZSBvciBpdCB3aWxsIGJlZm9yZSBpbml0IGlzIGFjdHVhbGx5XG4gICAgLy8gZmluaXNoZWQgZm9yIGFsbCBjaGlsZHJlbiB0aGF0IHJ1biB0aGlzIGNvbnN0cnVjdG9yXG5cbiAgICBpZiAob3B0aW9ucy5yZXBvcnRUb3VjaEFjdGl2aXR5ICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5lbmFibGVUb3VjaEFjdGl2aXR5KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2Ugb2YgdGhlIGBDb21wb25lbnRgIGFuZCBhbGwgY2hpbGQgY29tcG9uZW50cy5cbiAgICpcbiAgICogQGZpcmVzIENvbXBvbmVudCNkaXNwb3NlXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgYENvbXBvbmVudGAgaXMgZGlzcG9zZWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgQ29tcG9uZW50I2Rpc3Bvc2VcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtidWJibGVzPWZhbHNlXVxuICAgICAqICAgICAgICAgICBzZXQgdG8gZmFsc2Ugc28gdGhhdCB0aGUgY2xvc2UgZXZlbnQgZG9lcyBub3RcbiAgICAgKiAgICAgICAgICAgYnViYmxlIHVwXG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ2Rpc3Bvc2UnLCBidWJibGVzOiBmYWxzZSB9KTtcblxuICAgIC8vIERpc3Bvc2UgYWxsIGNoaWxkcmVuLlxuICAgIGlmICh0aGlzLmNoaWxkcmVuXykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuY2hpbGRyZW5fLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuX1tpXS5kaXNwb3NlKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbl9baV0uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlIGNoaWxkIHJlZmVyZW5jZXNcbiAgICB0aGlzLmNoaWxkcmVuXyA9IG51bGw7XG4gICAgdGhpcy5jaGlsZEluZGV4XyA9IG51bGw7XG4gICAgdGhpcy5jaGlsZE5hbWVJbmRleF8gPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuZWxfKSB7XG4gICAgICAvLyBSZW1vdmUgZWxlbWVudCBmcm9tIERPTVxuICAgICAgaWYgKHRoaXMuZWxfLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5lbF8ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsXyk7XG4gICAgICB9XG5cbiAgICAgIHJlbW92ZURhdGEodGhpcy5lbF8pO1xuICAgICAgdGhpcy5lbF8gPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB7QGxpbmsgUGxheWVyfSB0aGF0IHRoZSBgQ29tcG9uZW50YCBoYXMgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEByZXR1cm4ge1BsYXllcn1cbiAgICogICAgICAgICBUaGUgcGxheWVyIHRoYXQgdGhpcyBgQ29tcG9uZW50YCBoYXMgYXR0YWNoZWQgdG8uXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5wbGF5ZXIgPSBmdW5jdGlvbiBwbGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyXztcbiAgfTtcblxuICAvKipcbiAgICogRGVlcCBtZXJnZSBvZiBvcHRpb25zIG9iamVjdHMgd2l0aCBuZXcgb3B0aW9ucy5cbiAgICogPiBOb3RlOiBXaGVuIGJvdGggYG9iamAgYW5kIGBvcHRpb25zYCBjb250YWluIHByb3BlcnRpZXMgd2hvc2UgdmFsdWVzIGFyZSBvYmplY3RzLlxuICAgKiAgICAgICAgIFRoZSB0d28gcHJvcGVydGllcyBnZXQgbWVyZ2VkIHVzaW5nIHtAbGluayBtb2R1bGU6bWVyZ2VPcHRpb25zfVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqICAgICAgICBUaGUgb2JqZWN0IHRoYXQgY29udGFpbnMgbmV3IG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBBIG5ldyBvYmplY3Qgb2YgYHRoaXMub3B0aW9uc19gIGFuZCBgb2JqYCBtZXJnZWQgdG9nZXRoZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUub3B0aW9ucyA9IGZ1bmN0aW9uIG9wdGlvbnMob2JqKSB7XG4gICAgbG9nJDEud2FybigndGhpcy5vcHRpb25zKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSBtb3ZlZCB0byB0aGUgY29uc3RydWN0b3IgaW4gNi4wJyk7XG5cbiAgICBpZiAoIW9iaikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc187XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zXyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnNfLCBvYmopO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGBDb21wb25lbnRgcyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBET00gZWxlbWVudCBmb3IgdGhpcyBgQ29tcG9uZW50YC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmVsID0gZnVuY3Rpb24gZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgcyBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0YWdOYW1lXVxuICAgKiAgICAgICAgRWxlbWVudCdzIERPTSBub2RlIHR5cGUuIGUuZy4gJ2RpdidcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBzZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKHRhZ05hbWUsIHByb3BlcnRpZXMsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gY3JlYXRlRWwodGFnTmFtZSwgcHJvcGVydGllcywgYXR0cmlidXRlcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvY2FsaXplIGEgc3RyaW5nIGdpdmVuIHRoZSBzdHJpbmcgaW4gZW5nbGlzaC5cbiAgICpcbiAgICogSWYgdG9rZW5zIGFyZSBwcm92aWRlZCwgaXQnbGwgdHJ5IGFuZCBydW4gYSBzaW1wbGUgdG9rZW4gcmVwbGFjZW1lbnQgb24gdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICogVGhlIHRva2VucyBpdCBsb29va3MgZm9yIGxvb2sgbGlrZSBgezF9YCB3aXRoIHRoZSBpbmRleCBiZWluZyAxLWluZGV4ZWQgaW50byB0aGUgdG9rZW5zIGFycmF5LlxuICAgKlxuICAgKiBJZiBhIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBpdCdsbCB1c2UgdGhhdCBvdmVyIGBzdHJpbmdgLFxuICAgKiBpZiBhIHZhbHVlIGlzbid0IGZvdW5kIGluIHByb3ZpZGVkIGxhbmd1YWdlIGZpbGVzLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBoYXZlIGEgZGVzY3JpcHRpdmUga2V5IGZvciB0b2tlbiByZXBsYWNlbWVudFxuICAgKiBidXQgaGF2ZSBhIHN1Y2NpbmN0IGxvY2FsaXplZCBzdHJpbmcgYW5kIG5vdCByZXF1aXJlIGBlbi5qc29uYCB0byBiZSBpbmNsdWRlZC5cbiAgICpcbiAgICogQ3VycmVudGx5LCBpdCBpcyB1c2VkIGZvciB0aGUgcHJvZ3Jlc3MgYmFyIHRpbWluZy5cbiAgICogYGBganNcbiAgICoge1xuICAgKiAgIFwicHJvZ3Jlc3MgYmFyIHRpbWluZzogY3VycmVudFRpbWU9ezF9IGR1cmF0aW9uPXsyfVwiOiBcInsxfSBvZiB7Mn1cIlxuICAgKiB9XG4gICAqIGBgYFxuICAgKiBJdCBpcyB0aGVuIHVzZWQgbGlrZSBzbzpcbiAgICogYGBganNcbiAgICogdGhpcy5sb2NhbGl6ZSgncHJvZ3Jlc3MgYmFyIHRpbWluZzogY3VycmVudFRpbWU9ezF9IGR1cmF0aW9uezJ9JyxcbiAgICogICAgICAgICAgICAgICBbdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCksIHRoaXMucGxheWVyXy5kdXJhdGlvbigpXSxcbiAgICogICAgICAgICAgICAgICAnezF9IG9mIHsyfScpO1xuICAgKiBgYGBcbiAgICpcbiAgICogV2hpY2ggb3V0cHV0cyBzb21ldGhpbmcgbGlrZTogYDAxOjIzIG9mIDI0OjU2YC5cbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKiAgICAgICAgVGhlIHN0cmluZyB0byBsb2NhbGl6ZSBhbmQgdGhlIGtleSB0byBsb29rdXAgaW4gdGhlIGxhbmd1YWdlIGZpbGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbdG9rZW5zXVxuICAgKiAgICAgICAgSWYgdGhlIGN1cnJlbnQgaXRlbSBoYXMgdG9rZW4gcmVwbGFjZW1lbnRzLCBwcm92aWRlIHRoZSB0b2tlbnMgaGVyZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0VmFsdWVdXG4gICAqICAgICAgICBEZWZhdWx0cyB0byBgc3RyaW5nYC4gQ2FuIGJlIGEgZGVmYXVsdCB2YWx1ZSB0byB1c2UgZm9yIHRva2VuIHJlcGxhY2VtZW50XG4gICAqICAgICAgICBpZiB0aGUgbG9va3VwIGtleSBpcyBuZWVkZWQgdG8gYmUgc2VwYXJhdGUuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgbG9jYWxpemVkIHN0cmluZyBvciBpZiBubyBsb2NhbGl6YXRpb24gZXhpc3RzIHRoZSBlbmdsaXNoIHN0cmluZy5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmxvY2FsaXplID0gZnVuY3Rpb24gbG9jYWxpemUoc3RyaW5nLCB0b2tlbnMpIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBzdHJpbmc7XG5cbiAgICB2YXIgY29kZSA9IHRoaXMucGxheWVyXy5sYW5ndWFnZSAmJiB0aGlzLnBsYXllcl8ubGFuZ3VhZ2UoKTtcbiAgICB2YXIgbGFuZ3VhZ2VzID0gdGhpcy5wbGF5ZXJfLmxhbmd1YWdlcyAmJiB0aGlzLnBsYXllcl8ubGFuZ3VhZ2VzKCk7XG4gICAgdmFyIGxhbmd1YWdlID0gbGFuZ3VhZ2VzICYmIGxhbmd1YWdlc1tjb2RlXTtcbiAgICB2YXIgcHJpbWFyeUNvZGUgPSBjb2RlICYmIGNvZGUuc3BsaXQoJy0nKVswXTtcbiAgICB2YXIgcHJpbWFyeUxhbmcgPSBsYW5ndWFnZXMgJiYgbGFuZ3VhZ2VzW3ByaW1hcnlDb2RlXTtcblxuICAgIHZhciBsb2NhbGl6ZWRTdHJpbmcgPSBkZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAobGFuZ3VhZ2UgJiYgbGFuZ3VhZ2Vbc3RyaW5nXSkge1xuICAgICAgbG9jYWxpemVkU3RyaW5nID0gbGFuZ3VhZ2Vbc3RyaW5nXTtcbiAgICB9IGVsc2UgaWYgKHByaW1hcnlMYW5nICYmIHByaW1hcnlMYW5nW3N0cmluZ10pIHtcbiAgICAgIGxvY2FsaXplZFN0cmluZyA9IHByaW1hcnlMYW5nW3N0cmluZ107XG4gICAgfVxuXG4gICAgaWYgKHRva2Vucykge1xuICAgICAgbG9jYWxpemVkU3RyaW5nID0gbG9jYWxpemVkU3RyaW5nLnJlcGxhY2UoL1xceyhcXGQrKVxcfS9nLCBmdW5jdGlvbiAobWF0Y2gsIGluZGV4KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRva2Vuc1tpbmRleCAtIDFdO1xuICAgICAgICB2YXIgcmV0ID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXQgPSBtYXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYWxpemVkU3RyaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGBDb21wb25lbnRgcyBET00gZWxlbWVudC4gVGhpcyBpcyB3aGVyZSBjaGlsZHJlbiBnZXQgaW5zZXJ0ZWQuXG4gICAqIFRoaXMgd2lsbCB1c3VhbGx5IGJlIHRoZSB0aGUgc2FtZSBhcyB0aGUgZWxlbWVudCByZXR1cm5lZCBpbiB7QGxpbmsgQ29tcG9uZW50I2VsfS5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgY29udGVudCBlbGVtZW50IGZvciB0aGlzIGBDb21wb25lbnRgLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY29udGVudEVsID0gZnVuY3Rpb24gY29udGVudEVsKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRFbF8gfHwgdGhpcy5lbF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGlzIGBDb21wb25lbnRgcyBJRFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGlkIG9mIHRoaXMgYENvbXBvbmVudGBcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGBDb21wb25lbnRgcyBuYW1lLiBUaGUgbmFtZSBnZXRzIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSBgQ29tcG9uZW50YFxuICAgKiBhbmQgaXMgc2V0IGR1cmluZyByZWdpc3RyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgbmFtZSBvZiB0aGlzIGBDb21wb25lbnRgLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiBhcnJheSBvZiBhbGwgY2hpbGQgY29tcG9uZW50c1xuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogICAgICAgICBUaGUgY2hpbGRyZW5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24gY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZCBgQ29tcG9uZW50YCB3aXRoIHRoZSBnaXZlbiBgaWRgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICogICAgICAgIFRoZSBpZCBvZiB0aGUgY2hpbGQgYENvbXBvbmVudGAgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIFRoZSBjaGlsZCBgQ29tcG9uZW50YCB3aXRoIHRoZSBnaXZlbiBgaWRgIG9yIHVuZGVmaW5lZC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmdldENoaWxkQnlJZCA9IGZ1bmN0aW9uIGdldENoaWxkQnlJZChpZCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkSW5kZXhfW2lkXTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2hpbGQgYENvbXBvbmVudGAgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGNoaWxkIGBDb21wb25lbnRgIHRvIGdldC5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fHVuZGVmaW5lZH1cbiAgICogICAgICAgICBUaGUgY2hpbGQgYENvbXBvbmVudGAgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgIG9yIHVuZGVmaW5lZC5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24gZ2V0Q2hpbGQobmFtZSkge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5hbWUgPSB0b1RpdGxlQ2FzZShuYW1lKTtcblxuICAgIHJldHVybiB0aGlzLmNoaWxkTmFtZUluZGV4X1tuYW1lXTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2hpbGQgYENvbXBvbmVudGAgaW5zaWRlIHRoZSBjdXJyZW50IGBDb21wb25lbnRgLlxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xDb21wb25lbnR9IGNoaWxkXG4gICAqICAgICAgICBUaGUgbmFtZSBvciBpbnN0YW5jZSBvZiBhIGNoaWxkIHRvIGFkZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBvcHRpb25zIHRoYXQgd2lsbCBnZXQgcGFzc2VkIHRvIGNoaWxkcmVuIG9mXG4gICAqICAgICAgICB0aGUgY2hpbGQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9dGhpcy5jaGlsZHJlbl8ubGVuZ3RoXVxuICAgKiAgICAgICAgVGhlIGluZGV4IHRvIGF0dGVtcHQgdG8gYWRkIGEgY2hpbGQgaW50by5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiAgICAgICAgIFRoZSBgQ29tcG9uZW50YCB0aGF0IGdldHMgYWRkZWQgYXMgYSBjaGlsZC4gV2hlbiB1c2luZyBhIHN0cmluZyB0aGVcbiAgICogICAgICAgICBgQ29tcG9uZW50YCB3aWxsIGdldCBjcmVhdGVkIGJ5IHRoaXMgcHJvY2Vzcy5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmNoaWxkcmVuXy5sZW5ndGg7XG5cbiAgICB2YXIgY29tcG9uZW50ID0gdm9pZCAwO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gdm9pZCAwO1xuXG4gICAgLy8gSWYgY2hpbGQgaXMgYSBzdHJpbmcsIGNyZWF0ZSBjb21wb25lbnQgd2l0aCBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0b1RpdGxlQ2FzZShjaGlsZCk7XG5cbiAgICAgIHZhciBjb21wb25lbnRDbGFzc05hbWUgPSBvcHRpb25zLmNvbXBvbmVudENsYXNzIHx8IGNvbXBvbmVudE5hbWU7XG5cbiAgICAgIC8vIFNldCBuYW1lIHRocm91Z2ggb3B0aW9uc1xuICAgICAgb3B0aW9ucy5uYW1lID0gY29tcG9uZW50TmFtZTtcblxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IG9iamVjdCAmIGVsZW1lbnQgZm9yIHRoaXMgY29udHJvbHMgc2V0XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIC5wbGF5ZXJfLCB0aGlzIGlzIGEgcGxheWVyXG4gICAgICB2YXIgQ29tcG9uZW50Q2xhc3MgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KGNvbXBvbmVudENsYXNzTmFtZSk7XG5cbiAgICAgIGlmICghQ29tcG9uZW50Q2xhc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wb25lbnQgJyArIGNvbXBvbmVudENsYXNzTmFtZSArICcgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgIH1cblxuICAgICAgLy8gZGF0YSBzdG9yZWQgZGlyZWN0bHkgb24gdGhlIHZpZGVvanMgb2JqZWN0IG1heSBiZVxuICAgICAgLy8gbWlzaWRlbnRpZmllZCBhcyBhIGNvbXBvbmVudCB0byByZXRhaW5cbiAgICAgIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdpdGggNC54LiBjaGVjayB0byBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBjb21wb25lbnQgY2xhc3MgY2FuIGJlIGluc3RhbnRpYXRlZC5cbiAgICAgIGlmICh0eXBlb2YgQ29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnRDbGFzcyh0aGlzLnBsYXllcl8gfHwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIGNoaWxkIGlzIGEgY29tcG9uZW50IGluc3RhbmNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudCA9IGNoaWxkO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRyZW5fLnNwbGljZShpbmRleCwgMCwgY29tcG9uZW50KTtcblxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50LmlkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmNoaWxkSW5kZXhfW2NvbXBvbmVudC5pZCgpXSA9IGNvbXBvbmVudDtcbiAgICB9XG5cbiAgICAvLyBJZiBhIG5hbWUgd2Fzbid0IHVzZWQgdG8gY3JlYXRlIHRoZSBjb21wb25lbnQsIGNoZWNrIGlmIHdlIGNhbiB1c2UgdGhlXG4gICAgLy8gbmFtZSBmdW5jdGlvbiBvZiB0aGUgY29tcG9uZW50XG4gICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgY29tcG9uZW50Lm5hbWUgJiYgdG9UaXRsZUNhc2UoY29tcG9uZW50Lm5hbWUoKSk7XG5cbiAgICBpZiAoY29tcG9uZW50TmFtZSkge1xuICAgICAgdGhpcy5jaGlsZE5hbWVJbmRleF9bY29tcG9uZW50TmFtZV0gPSBjb21wb25lbnQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBVSSBvYmplY3QncyBlbGVtZW50IHRvIHRoZSBjb250YWluZXIgZGl2IChib3gpXG4gICAgLy8gSGF2aW5nIGFuIGVsZW1lbnQgaXMgbm90IHJlcXVpcmVkXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQuZWwgPT09ICdmdW5jdGlvbicgJiYgY29tcG9uZW50LmVsKCkpIHtcbiAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpcy5jb250ZW50RWwoKS5jaGlsZHJlbjtcbiAgICAgIHZhciByZWZOb2RlID0gY2hpbGROb2Rlc1tpbmRleF0gfHwgbnVsbDtcblxuICAgICAgdGhpcy5jb250ZW50RWwoKS5pbnNlcnRCZWZvcmUoY29tcG9uZW50LmVsKCksIHJlZk5vZGUpO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBzbyBpdCBjYW4gc3RvcmVkIG9uIHBhcmVudCBvYmplY3QgaWYgZGVzaXJlZC5cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjaGlsZCBgQ29tcG9uZW50YCBmcm9tIHRoaXMgYENvbXBvbmVudGBzIGxpc3Qgb2YgY2hpbGRyZW4uIEFsc28gcmVtb3Zlc1xuICAgKiB0aGUgY2hpbGQgYENvbXBvbmVudGBzIGVsZW1lbnQgZnJvbSB0aGlzIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gY29tcG9uZW50XG4gICAqICAgICAgICBUaGUgY2hpbGQgYENvbXBvbmVudGAgdG8gcmVtb3ZlLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZChjb21wb25lbnQpIHtcbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbXBvbmVudCA9IHRoaXMuZ2V0Q2hpbGQoY29tcG9uZW50KTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbXBvbmVudCB8fCAhdGhpcy5jaGlsZHJlbl8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRGb3VuZCA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IHRoaXMuY2hpbGRyZW5fLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbl9baV0gPT09IGNvbXBvbmVudCkge1xuICAgICAgICBjaGlsZEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbl8uc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkRm91bmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNoaWxkSW5kZXhfW2NvbXBvbmVudC5pZCgpXSA9IG51bGw7XG4gICAgdGhpcy5jaGlsZE5hbWVJbmRleF9bY29tcG9uZW50Lm5hbWUoKV0gPSBudWxsO1xuXG4gICAgdmFyIGNvbXBFbCA9IGNvbXBvbmVudC5lbCgpO1xuXG4gICAgaWYgKGNvbXBFbCAmJiBjb21wRWwucGFyZW50Tm9kZSA9PT0gdGhpcy5jb250ZW50RWwoKSkge1xuICAgICAgdGhpcy5jb250ZW50RWwoKS5yZW1vdmVDaGlsZChjb21wb25lbnQuZWwoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYW5kIGluaXRpYWxpemUgZGVmYXVsdCBjaGlsZCBgQ29tcG9uZW50YHMgYmFzZWQgdXBvbiBvcHRpb25zLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaW5pdENoaWxkcmVuID0gZnVuY3Rpb24gaW5pdENoaWxkcmVuKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLm9wdGlvbnNfLmNoaWxkcmVuO1xuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAvLyBgdGhpc2AgaXMgYHBhcmVudGBcbiAgICAgIHZhciBwYXJlbnRPcHRpb25zID0gdGhpcy5vcHRpb25zXztcblxuICAgICAgdmFyIGhhbmRsZUFkZCA9IGZ1bmN0aW9uIGhhbmRsZUFkZChjaGlsZCkge1xuICAgICAgICB2YXIgbmFtZSA9IGNoaWxkLm5hbWU7XG4gICAgICAgIHZhciBvcHRzID0gY2hpbGQub3B0cztcblxuICAgICAgICAvLyBBbGxvdyBvcHRpb25zIGZvciBjaGlsZHJlbiB0byBiZSBzZXQgYXQgdGhlIHBhcmVudCBvcHRpb25zXG4gICAgICAgIC8vIGUuZy4gdmlkZW9qcyhpZCwgeyBjb250cm9sQmFyOiBmYWxzZSB9KTtcbiAgICAgICAgLy8gaW5zdGVhZCBvZiB2aWRlb2pzKGlkLCB7IGNoaWxkcmVuOiB7IGNvbnRyb2xCYXI6IGZhbHNlIH0pO1xuICAgICAgICBpZiAocGFyZW50T3B0aW9uc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3B0cyA9IHBhcmVudE9wdGlvbnNbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGxvdyBmb3IgZGlzYWJsaW5nIGRlZmF1bHQgY29tcG9uZW50c1xuICAgICAgICAvLyBlLmcuIG9wdGlvbnNbJ2NoaWxkcmVuJ11bJ3Bvc3RlckltYWdlJ10gPSBmYWxzZVxuICAgICAgICBpZiAob3B0cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGxvdyBvcHRpb25zIHRvIGJlIHBhc3NlZCBhcyBhIHNpbXBsZSBib29sZWFuIGlmIG5vIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgLy8gaXMgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAob3B0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGFsc28gd2FudCB0byBwYXNzIHRoZSBvcmlnaW5hbCBwbGF5ZXIgb3B0aW9uc1xuICAgICAgICAvLyB0byBlYWNoIGNvbXBvbmVudCBhcyB3ZWxsIHNvIHRoZXkgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAvLyByZWFjaCBiYWNrIGludG8gdGhlIHBsYXllciBmb3Igb3B0aW9ucyBsYXRlci5cbiAgICAgICAgb3B0cy5wbGF5ZXJPcHRpb25zID0gX3RoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucztcblxuICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCB0aGUgY2hpbGQgY29tcG9uZW50LlxuICAgICAgICAvLyBBZGQgYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBjaGlsZCBieSBuYW1lIG9uIHRoZSBwYXJlbnQgaW5zdGFuY2UuXG4gICAgICAgIC8vIElmIHR3byBvZiB0aGUgc2FtZSBjb21wb25lbnQgYXJlIHVzZWQsIGRpZmZlcmVudCBuYW1lcyBzaG91bGQgYmUgc3VwcGxpZWRcbiAgICAgICAgLy8gZm9yIGVhY2hcbiAgICAgICAgdmFyIG5ld0NoaWxkID0gX3RoaXMuYWRkQ2hpbGQobmFtZSwgb3B0cyk7XG5cbiAgICAgICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICAgICAgX3RoaXNbbmFtZV0gPSBuZXdDaGlsZDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gQWxsb3cgZm9yIGFuIGFycmF5IG9mIGNoaWxkcmVuIGRldGFpbHMgdG8gcGFzc2VkIGluIHRoZSBvcHRpb25zXG4gICAgICB2YXIgd29ya2luZ0NoaWxkcmVuID0gdm9pZCAwO1xuICAgICAgdmFyIFRlY2ggPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KCdUZWNoJyk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICB3b3JraW5nQ2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmtpbmdDaGlsZHJlbiA9IE9iamVjdC5rZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cblxuICAgICAgd29ya2luZ0NoaWxkcmVuXG4gICAgICAvLyBjaGlsZHJlbiB0aGF0IGFyZSBpbiB0aGlzLm9wdGlvbnNfIGJ1dCBhbHNvIGluIHdvcmtpbmdDaGlsZHJlbiAgd291bGRcbiAgICAgIC8vIGdpdmUgdXMgZXh0cmEgY2hpbGRyZW4gd2UgZG8gbm90IHdhbnQuIFNvLCB3ZSB3YW50IHRvIGZpbHRlciB0aGVtIG91dC5cbiAgICAgIC5jb25jYXQoT2JqZWN0LmtleXModGhpcy5vcHRpb25zXykuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gIXdvcmtpbmdDaGlsZHJlbi5zb21lKGZ1bmN0aW9uICh3Y2hpbGQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gd2NoaWxkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2hpbGQgPT09IHdjaGlsZC5uYW1lO1xuICAgICAgICB9KTtcbiAgICAgIH0pKS5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZhciBuYW1lID0gdm9pZCAwO1xuICAgICAgICB2YXIgb3B0cyA9IHZvaWQgMDtcblxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG5hbWUgPSBjaGlsZDtcbiAgICAgICAgICBvcHRzID0gY2hpbGRyZW5bbmFtZV0gfHwgX3RoaXMub3B0aW9uc19bbmFtZV0gfHwge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IGNoaWxkLm5hbWU7XG4gICAgICAgICAgb3B0cyA9IGNoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgb3B0czogb3B0cyB9O1xuICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAvLyB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IGNoaWxkLm5hbWUgaXNuJ3QgaW4gdGhlIHRlY2hPcmRlciBzaW5jZVxuICAgICAgICAvLyB0ZWNocyBhcmUgcmVnaXN0ZXJkIGFzIENvbXBvbmVudHMgYnV0IGNhbid0IGFyZW4ndCBjb21wYXRpYmxlXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvMjc3MlxuICAgICAgICB2YXIgYyA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoY2hpbGQub3B0cy5jb21wb25lbnRDbGFzcyB8fCB0b1RpdGxlQ2FzZShjaGlsZC5uYW1lKSk7XG5cbiAgICAgICAgcmV0dXJuIGMgJiYgIVRlY2guaXNUZWNoKGMpO1xuICAgICAgfSkuZm9yRWFjaChoYW5kbGVBZGQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBjbGFzcyBuYW1lLiBTaG91bGQgYmUgb3ZlcnJpZGVuIGJ5IHN1Yi1jb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBjbGFzcyBuYW1lIGZvciB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICAvLyBDaGlsZCBjbGFzc2VzIGNhbiBpbmNsdWRlIGEgZnVuY3Rpb24gdGhhdCBkb2VzOlxuICAgIC8vIHJldHVybiAnQ0xBU1MgTkFNRScgKyB0aGlzLl9zdXBlcigpO1xuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogQmluZCBhIGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByZWFkeSBzdGF0ZS5cbiAgICogRGlmZmVyZW50IGZyb20gZXZlbnQgbGlzdGVuZXJzIGluIHRoYXQgaWYgdGhlIHJlYWR5IGV2ZW50IGhhcyBhbHJlYWR5IGhhcHBlbmVkXG4gICAqIGl0IHdpbGwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gaW1tZWRpYXRlbHkuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogICAgICAgICBSZXR1cm5zIGl0c2VsZjsgbWV0aG9kIGNhbiBiZSBjaGFpbmVkLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbiByZWFkeShmbikge1xuICAgIHZhciBzeW5jID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIGlmIChmbikge1xuICAgICAgaWYgKHRoaXMuaXNSZWFkeV8pIHtcbiAgICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgICBmbi5jYWxsKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENhbGwgdGhlIGZ1bmN0aW9uIGFzeW5jaHJvbm91c2x5IGJ5IGRlZmF1bHQgZm9yIGNvbnNpc3RlbmN5XG4gICAgICAgICAgdGhpcy5zZXRUaW1lb3V0KGZuLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWFkeVF1ZXVlXyA9IHRoaXMucmVhZHlRdWV1ZV8gfHwgW107XG4gICAgICAgIHRoaXMucmVhZHlRdWV1ZV8ucHVzaChmbik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGFsbCB0aGUgcmVhZHkgbGlzdGVuZXJzIGZvciB0aGlzIGBDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmlyZXMgQ29tcG9uZW50I3JlYWR5XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyUmVhZHkgPSBmdW5jdGlvbiB0cmlnZ2VyUmVhZHkoKSB7XG4gICAgdGhpcy5pc1JlYWR5XyA9IHRydWU7XG5cbiAgICAvLyBFbnN1cmUgcmVhZHkgaXMgdHJpZ2dlcmQgYXN5bmNocm9ub3VzbHlcbiAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlYWR5UXVldWUgPSB0aGlzLnJlYWR5UXVldWVfO1xuXG4gICAgICAvLyBSZXNldCBSZWFkeSBRdWV1ZVxuICAgICAgdGhpcy5yZWFkeVF1ZXVlXyA9IFtdO1xuXG4gICAgICBpZiAocmVhZHlRdWV1ZSAmJiByZWFkeVF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVhZHlRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIGZuLmNhbGwodGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyBmb3IgdXNpbmcgZXZlbnQgbGlzdGVuZXJzIGFsc29cbiAgICAgIC8qKlxuICAgICAgICogVHJpZ2dlcmVkIHdoZW4gYSBgQ29tcG9uZW50YCBpcyByZWFkeS5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgQ29tcG9uZW50I3JlYWR5XG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcigncmVhZHknKTtcbiAgICB9LCAxKTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCBhIHNpbmdsZSBET00gZWxlbWVudCBtYXRjaGluZyBhIGBzZWxlY3RvcmAuIFRoaXMgY2FuIGJlIHdpdGhpbiB0aGUgYENvbXBvbmVudGBzXG4gICAqIGBjb250ZW50RWwoKWAgb3IgYW5vdGhlciBjdXN0b20gY29udGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqICAgICAgICBBIHZhbGlkIENTUyBzZWxlY3Rvciwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYHF1ZXJ5U2VsZWN0b3JgLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBbY29udGV4dD10aGlzLmNvbnRlbnRFbCgpXVxuICAgKiAgICAgICAgQSBET00gZWxlbWVudCB3aXRoaW4gd2hpY2ggdG8gcXVlcnkuIENhbiBhbHNvIGJlIGEgc2VsZWN0b3Igc3RyaW5nIGluXG4gICAqICAgICAgICB3aGljaCBjYXNlIHRoZSBmaXJzdCBtYXRjaGluZyBlbGVtZW50IHdpbGwgZ2V0IHVzZWQgYXMgY29udGV4dC4gSWZcbiAgICogICAgICAgIG1pc3NpbmcgYHRoaXMuY29udGVudEVsKClgIGdldHMgdXNlZC4gSWYgIGB0aGlzLmNvbnRlbnRFbCgpYCByZXR1cm5zXG4gICAqICAgICAgICBub3RoaW5nIGl0IGZhbGxzIGJhY2sgdG8gYGRvY3VtZW50YC5cbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudHxudWxsfVxuICAgKiAgICAgICAgIHRoZSBkb20gZWxlbWVudCB0aGF0IHdhcyBmb3VuZCwgb3IgbnVsbFxuICAgKlxuICAgKiBAc2VlIFtJbmZvcm1hdGlvbiBvbiBDU1MgU2VsZWN0b3JzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9DU1MvR2V0dGluZ19TdGFydGVkL1NlbGVjdG9ycylcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLiQgPSBmdW5jdGlvbiAkJCQxKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuICQoc2VsZWN0b3IsIGNvbnRleHQgfHwgdGhpcy5jb250ZW50RWwoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBET00gZWxlbWVudCBtYXRjaGluZyBhIGBzZWxlY3RvcmAuIFRoaXMgY2FuIGJlIHdpdGhpbiB0aGUgYENvbXBvbmVudGBzXG4gICAqIGBjb250ZW50RWwoKWAgb3IgYW5vdGhlciBjdXN0b20gY29udGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqICAgICAgICBBIHZhbGlkIENTUyBzZWxlY3Rvciwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYHF1ZXJ5U2VsZWN0b3JBbGxgLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBbY29udGV4dD10aGlzLmNvbnRlbnRFbCgpXVxuICAgKiAgICAgICAgQSBET00gZWxlbWVudCB3aXRoaW4gd2hpY2ggdG8gcXVlcnkuIENhbiBhbHNvIGJlIGEgc2VsZWN0b3Igc3RyaW5nIGluXG4gICAqICAgICAgICB3aGljaCBjYXNlIHRoZSBmaXJzdCBtYXRjaGluZyBlbGVtZW50IHdpbGwgZ2V0IHVzZWQgYXMgY29udGV4dC4gSWZcbiAgICogICAgICAgIG1pc3NpbmcgYHRoaXMuY29udGVudEVsKClgIGdldHMgdXNlZC4gSWYgIGB0aGlzLmNvbnRlbnRFbCgpYCByZXR1cm5zXG4gICAqICAgICAgICBub3RoaW5nIGl0IGZhbGxzIGJhY2sgdG8gYGRvY3VtZW50YC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZUxpc3R9XG4gICAqICAgICAgICAgYSBsaXN0IG9mIGRvbSBlbGVtZW50cyB0aGF0IHdlcmUgZm91bmRcbiAgICpcbiAgICogQHNlZSBbSW5mb3JtYXRpb24gb24gQ1NTIFNlbGVjdG9yc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvQ1NTL0dldHRpbmdfU3RhcnRlZC9TZWxlY3RvcnMpXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS4kJCA9IGZ1bmN0aW9uICQkJCQxKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuICQkKHNlbGVjdG9yLCBjb250ZXh0IHx8IHRoaXMuY29udGVudEVsKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGNvbXBvbmVudCdzIGVsZW1lbnQgaGFzIGEgQ1NTIGNsYXNzIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvQ2hlY2tcbiAgICogICAgICAgIENTUyBjbGFzcyBuYW1lIHRvIGNoZWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgYENvbXBvbmVudGAgaGFzIHRoZSBjbGFzcy5cbiAgICogICAgICAgICAtIEZhbHNlIGlmIHRoZSBgQ29tcG9uZW50YCBkb2VzIG5vdCBoYXZlIHRoZSBjbGFzc2BcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmhhc0NsYXNzID0gZnVuY3Rpb24gaGFzQ2xhc3MkJDEoY2xhc3NUb0NoZWNrKSB7XG4gICAgcmV0dXJuIGhhc0NsYXNzKHRoaXMuZWxfLCBjbGFzc1RvQ2hlY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBDU1MgY2xhc3MgbmFtZSB0byB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvQWRkXG4gICAqICAgICAgICBDU1MgY2xhc3MgbmFtZSB0byBhZGRcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3MkJDEoY2xhc3NUb0FkZCkge1xuICAgIGFkZENsYXNzKHRoaXMuZWxfLCBjbGFzc1RvQWRkKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgQ1NTIGNsYXNzIG5hbWUgZnJvbSB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvUmVtb3ZlXG4gICAqICAgICAgICBDU1MgY2xhc3MgbmFtZSB0byByZW1vdmVcbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3MkJDEoY2xhc3NUb1JlbW92ZSkge1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxfLCBjbGFzc1RvUmVtb3ZlKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIG9yIHJlbW92ZSBhIENTUyBjbGFzcyBuYW1lIGZyb20gdGhlIGNvbXBvbmVudCdzIGVsZW1lbnQuXG4gICAqIC0gYGNsYXNzVG9Ub2dnbGVgIGdldHMgYWRkZWQgd2hlbiB7QGxpbmsgQ29tcG9uZW50I2hhc0NsYXNzfSB3b3VsZCByZXR1cm4gZmFsc2UuXG4gICAqIC0gYGNsYXNzVG9Ub2dnbGVgIGdldHMgcmVtb3ZlZCB3aGVuIHtAbGluayBDb21wb25lbnQjaGFzQ2xhc3N9IHdvdWxkIHJldHVybiB0cnVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNsYXNzVG9Ub2dnbGVcbiAgICogICAgICAgICBUaGUgY2xhc3MgdG8gYWRkIG9yIHJlbW92ZSBiYXNlZCBvbiAoQGxpbmsgQ29tcG9uZW50I2hhc0NsYXNzfVxuICAgKlxuICAgKiBAcGFyYW0gIHtib29sZWFufERvbX5wcmVkaWNhdGV9IFtwcmVkaWNhdGVdXG4gICAqICAgICAgICAgQW4ge0BsaW5rIERvbX5wcmVkaWNhdGV9IGZ1bmN0aW9uIG9yIGEgYm9vbGVhblxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUudG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiB0b2dnbGVDbGFzcyQkMShjbGFzc1RvVG9nZ2xlLCBwcmVkaWNhdGUpIHtcbiAgICB0b2dnbGVDbGFzcyh0aGlzLmVsXywgY2xhc3NUb1RvZ2dsZSwgcHJlZGljYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2hvdyB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQgaWYgaXQgaXMgaGlkZGVuIGJ5IHJlbW92aW5nIHRoZVxuICAgKiAndmpzLWhpZGRlbicgY2xhc3MgbmFtZSBmcm9tIGl0LlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudCBpZiBpdCBpcyBjdXJyZW50bHkgc2hvd2luZyBieSBhZGRpbmcgdGhlXG4gICAqICd2anMtaGlkZGVuYCBjbGFzcyBuYW1lIHRvIGl0LlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2NrIGEgYENvbXBvbmVudGBzIGVsZW1lbnQgaW4gaXRzIHZpc2libGUgc3RhdGUgYnkgYWRkaW5nIHRoZSAndmpzLWxvY2stc2hvd2luZydcbiAgICogY2xhc3MgbmFtZSB0byBpdC4gVXNlZCBkdXJpbmcgZmFkZUluL2ZhZGVPdXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5sb2NrU2hvd2luZyA9IGZ1bmN0aW9uIGxvY2tTaG93aW5nKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1sb2NrLXNob3dpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5sb2NrIGEgYENvbXBvbmVudGBzIGVsZW1lbnQgZnJvbSBpdHMgdmlzaWJsZSBzdGF0ZSBieSByZW1vdmluZyB0aGUgJ3Zqcy1sb2NrLXNob3dpbmcnXG4gICAqIGNsYXNzIG5hbWUgZnJvbSBpdC4gVXNlZCBkdXJpbmcgZmFkZUluL2ZhZGVPdXQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS51bmxvY2tTaG93aW5nID0gZnVuY3Rpb24gdW5sb2NrU2hvd2luZygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtbG9jay1zaG93aW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICAgKiAgICAgICAgTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGdldCB0aGUgdmFsdWUgZnJvbS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gICAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSB0aGF0IHdhcyBhc2tlZCBmb3IuXG4gICAqICAgICAgICAgLSBDYW4gYmUgYW4gZW1wdHkgc3RyaW5nIG9uIHNvbWUgYnJvd3NlcnMgaWYgdGhlIGF0dHJpYnV0ZSBkb2VzIG5vdCBleGlzdFxuICAgKiAgICAgICAgICAgb3IgaGFzIG5vIHZhbHVlXG4gICAqICAgICAgICAgLSBNb3N0IGJyb3dzZXJzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIGF0dGlidXRlIGRvZXMgbm90IGV4aXN0IG9yIGhhc1xuICAgKiAgICAgICAgICAgbm8gdmFsdWUuXG4gICAqXG4gICAqIEBzZWUgW0RPTSBBUElde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEF0dHJpYnV0ZX1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZSQkMShhdHRyaWJ1dGUpIHtcbiAgICByZXR1cm4gZ2V0QXR0cmlidXRlKHRoaXMuZWxfLCBhdHRyaWJ1dGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiB0aGUgYENvbXBvbmVudGAncyBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAgICogICAgICAgIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICAgVmFsdWUgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgdG8uXG4gICAqXG4gICAqIEBzZWUgW0RPTSBBUElde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L3NldEF0dHJpYnV0ZX1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZSQkMShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgc2V0QXR0cmlidXRlKHRoaXMuZWxfLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICAgKiAgICAgICAgTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHJlbW92ZS5cbiAgICpcbiAgICogQHNlZSBbRE9NIEFQSV17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvcmVtb3ZlQXR0cmlidXRlfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlJCQxKGF0dHJpYnV0ZSkge1xuICAgIHJlbW92ZUF0dHJpYnV0ZSh0aGlzLmVsXywgYXR0cmlidXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgd2lkdGggb2YgdGhlIGNvbXBvbmVudCBiYXNlZCB1cG9uIHRoZSBDU1Mgc3R5bGVzLlxuICAgKiBTZWUge0BsaW5rIENvbXBvbmVudCNkaW1lbnNpb259IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtudW1dXG4gICAqICAgICAgICBUaGUgd2lkdGggdGhhdCB5b3Ugd2FudCB0byBzZXQgcG9zdGZpeGVkIHdpdGggJyUnLCAncHgnIG9yIG5vdGhpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBMaXN0ZW5lcnNdXG4gICAqICAgICAgICBTa2lwIHRoZSBjb21wb25lbnRyZXNpemUgZXZlbnQgdHJpZ2dlclxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSB3aWR0aCB3aGVuIGdldHRpbmcsIHplcm8gaWYgdGhlcmUgaXMgbm8gd2lkdGguIENhbiBiZSBhIHN0cmluZ1xuICAgKiAgICAgICAgICAgcG9zdHBpeGVkIHdpdGggJyUnIG9yICdweCcuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uIHdpZHRoKG51bSwgc2tpcExpc3RlbmVycykge1xuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbignd2lkdGgnLCBudW0sIHNraXBMaXN0ZW5lcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBoZWlnaHQgb2YgdGhlIGNvbXBvbmVudCBiYXNlZCB1cG9uIHRoZSBDU1Mgc3R5bGVzLlxuICAgKiBTZWUge0BsaW5rIENvbXBvbmVudCNkaW1lbnNpb259IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtudW1dXG4gICAqICAgICAgICBUaGUgaGVpZ2h0IHRoYXQgeW91IHdhbnQgdG8gc2V0IHBvc3RmaXhlZCB3aXRoICclJywgJ3B4JyBvciBub3RoaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwTGlzdGVuZXJzXVxuICAgKiAgICAgICAgU2tpcCB0aGUgY29tcG9uZW50cmVzaXplIGV2ZW50IHRyaWdnZXJcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfHN0cmluZ31cbiAgICogICAgICAgICBUaGUgd2lkdGggd2hlbiBnZXR0aW5nLCB6ZXJvIGlmIHRoZXJlIGlzIG5vIHdpZHRoLiBDYW4gYmUgYSBzdHJpbmdcbiAgICogICAgICAgICBwb3N0cGl4ZWQgd2l0aCAnJScgb3IgJ3B4Jy5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uIGhlaWdodChudW0sIHNraXBMaXN0ZW5lcnMpIHtcbiAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24oJ2hlaWdodCcsIG51bSwgc2tpcExpc3RlbmVycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBib3RoIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBgQ29tcG9uZW50YCBlbGVtZW50IGF0IHRoZSBzYW1lIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcnxzdHJpbmd9IHdpZHRoXG4gICAqICAgICAgICAgV2lkdGggdG8gc2V0IHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudCB0by5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfHN0cmluZ30gaGVpZ2h0XG4gICAqICAgICAgICAgSGVpZ2h0IHRvIHNldCB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQgdG8uXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5kaW1lbnNpb25zID0gZnVuY3Rpb24gZGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgLy8gU2tpcCBjb21wb25lbnRyZXNpemUgbGlzdGVuZXJzIG9uIHdpZHRoIGZvciBvcHRpbWl6YXRpb25cbiAgICB0aGlzLndpZHRoKHdpZHRoLCB0cnVlKTtcbiAgICB0aGlzLmhlaWdodChoZWlnaHQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHdpZHRoIG9yIGhlaWdodCBvZiB0aGUgYENvbXBvbmVudGAgZWxlbWVudC4gVGhpcyBpcyB0aGUgc2hhcmVkIGNvZGVcbiAgICogZm9yIHRoZSB7QGxpbmsgQ29tcG9uZW50I3dpZHRofSBhbmQge0BsaW5rIENvbXBvbmVudCNoZWlnaHR9LlxuICAgKlxuICAgKiBUaGluZ3MgdG8ga25vdzpcbiAgICogLSBJZiB0aGUgd2lkdGggb3IgaGVpZ2h0IGluIGFuIG51bWJlciB0aGlzIHdpbGwgcmV0dXJuIHRoZSBudW1iZXIgcG9zdGZpeGVkIHdpdGggJ3B4Jy5cbiAgICogLSBJZiB0aGUgd2lkdGgvaGVpZ2h0IGlzIGEgcGVyY2VudCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBwZXJjZW50IHBvc3RmaXhlZCB3aXRoICclJ1xuICAgKiAtIEhpZGRlbiBlbGVtZW50cyBoYXZlIGEgd2lkdGggb2YgMCB3aXRoIGB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZWAuIFRoaXMgZnVuY3Rpb25cbiAgICogICBkZWZhdWx0cyB0byB0aGUgYENvbXBvbmVudGBzIGBzdHlsZS53aWR0aGAgYW5kIGZhbGxzIGJhY2sgdG8gYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cbiAgICogICBTZWUgW3RoaXNde0BsaW5rIGh0dHA6Ly93d3cuZm9saW90ZWsuY29tL2RldmJsb2cvZ2V0dGluZy10aGUtd2lkdGgtb2YtYS1oaWRkZW4tZWxlbWVudC13aXRoLWpxdWVyeS11c2luZy13aWR0aC99XG4gICAqICAgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAgICogLSBJZiB5b3Ugd2FudCB0aGUgY29tcHV0ZWQgc3R5bGUgb2YgdGhlIGNvbXBvbmVudCwgdXNlIHtAbGluayBDb21wb25lbnQjY3VycmVudFdpZHRofVxuICAgKiAgIGFuZCB7QGxpbmsge0NvbXBvbmVudCNjdXJyZW50SGVpZ2h0fVxuICAgKlxuICAgKiBAZmlyZXMgQ29tcG9uZW50I2NvbXBvbmVudHJlc2l6ZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gd2lkdGhPckhlaWdodFxuICAgOCAgICAgICAgJ3dpZHRoJyBvciAnaGVpZ2h0J1xuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ8c3RyaW5nfSBbbnVtXVxuICAgOCAgICAgICAgIE5ldyBkaW1lbnNpb25cbiAgICpcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW3NraXBMaXN0ZW5lcnNdXG4gICAqICAgICAgICAgU2tpcCBjb21wb25lbnRyZXNpemUgZXZlbnQgdHJpZ2dlclxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGRpbWVuc2lvbiB3aGVuIGdldHRpbmcgb3IgMCBpZiB1bnNldFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gZGltZW5zaW9uKHdpZHRoT3JIZWlnaHQsIG51bSwgc2tpcExpc3RlbmVycykge1xuICAgIGlmIChudW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gU2V0IHRvIHplcm8gaWYgbnVsbCBvciBsaXRlcmFsbHkgTmFOIChOYU4gIT09IE5hTilcbiAgICAgIGlmIChudW0gPT09IG51bGwgfHwgbnVtICE9PSBudW0pIHtcbiAgICAgICAgbnVtID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdXNpbmcgY3NzIHdpZHRoL2hlaWdodCAoJSBvciBweCkgYW5kIGFkanVzdFxuICAgICAgaWYgKCgnJyArIG51bSkuaW5kZXhPZignJScpICE9PSAtMSB8fCAoJycgKyBudW0pLmluZGV4T2YoJ3B4JykgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdID0gbnVtO1xuICAgICAgfSBlbHNlIGlmIChudW0gPT09ICdhdXRvJykge1xuICAgICAgICB0aGlzLmVsXy5zdHlsZVt3aWR0aE9ySGVpZ2h0XSA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbF8uc3R5bGVbd2lkdGhPckhlaWdodF0gPSBudW0gKyAncHgnO1xuICAgICAgfVxuXG4gICAgICAvLyBza2lwTGlzdGVuZXJzIGFsbG93cyB1cyB0byBhdm9pZCB0cmlnZ2VyaW5nIHRoZSByZXNpemUgZXZlbnQgd2hlbiBzZXR0aW5nIGJvdGggd2lkdGggYW5kIGhlaWdodFxuICAgICAgaWYgKCFza2lwTGlzdGVuZXJzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZXNpemVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgQ29tcG9uZW50I2NvbXBvbmVudHJlc2l6ZVxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NvbXBvbmVudHJlc2l6ZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTm90IHNldHRpbmcgYSB2YWx1ZSwgc28gZ2V0dGluZyBpdFxuICAgIC8vIE1ha2Ugc3VyZSBlbGVtZW50IGV4aXN0c1xuICAgIGlmICghdGhpcy5lbF8pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIEdldCBkaW1lbnNpb24gdmFsdWUgZnJvbSBzdHlsZVxuICAgIHZhciB2YWwgPSB0aGlzLmVsXy5zdHlsZVt3aWR0aE9ySGVpZ2h0XTtcbiAgICB2YXIgcHhJbmRleCA9IHZhbC5pbmRleE9mKCdweCcpO1xuXG4gICAgaWYgKHB4SW5kZXggIT09IC0xKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIHBpeGVsIHZhbHVlIHdpdGggbm8gJ3B4J1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbC5zbGljZSgwLCBweEluZGV4KSwgMTApO1xuICAgIH1cblxuICAgIC8vIE5vIHB4IHNvIHVzaW5nICUgb3Igbm8gc3R5bGUgd2FzIHNldCwgc28gZmFsbGluZyBiYWNrIHRvIG9mZnNldFdpZHRoL2hlaWdodFxuICAgIC8vIElmIGNvbXBvbmVudCBoYXMgZGlzcGxheTpub25lLCBvZmZzZXQgd2lsbCByZXR1cm4gMFxuICAgIC8vIFRPRE86IGhhbmRsZSBkaXNwbGF5Om5vbmUgYW5kIG5vIGRpbWVuc2lvbiBzdHlsZSB1c2luZyBweFxuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmVsX1snb2Zmc2V0JyArIHRvVGl0bGVDYXNlKHdpZHRoT3JIZWlnaHQpXSwgMTApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHdpZHRoIG9yIHRoZSBoZWlnaHQgb2YgdGhlIGBDb21wb25lbnRgIGVsZW1lbnRzIGNvbXB1dGVkIHN0eWxlLiBVc2VzXG4gICAqIGB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB3aWR0aE9ySGVpZ2h0XG4gICAqICAgICAgICBBIHN0cmluZyBjb250YWluaW5nICd3aWR0aCcgb3IgJ2hlaWdodCcuIFdoaWNoZXZlciBvbmUgeW91IHdhbnQgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGRpbWVuc2lvbiB0aGF0IGdldHMgYXNrZWQgZm9yIG9yIDAgaWYgbm90aGluZyB3YXMgc2V0XG4gICAqICAgICAgICAgZm9yIHRoYXQgZGltZW5zaW9uLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY3VycmVudERpbWVuc2lvbiA9IGZ1bmN0aW9uIGN1cnJlbnREaW1lbnNpb24od2lkdGhPckhlaWdodCkge1xuICAgIHZhciBjb21wdXRlZFdpZHRoT3JIZWlnaHQgPSAwO1xuXG4gICAgaWYgKHdpZHRoT3JIZWlnaHQgIT09ICd3aWR0aCcgJiYgd2lkdGhPckhlaWdodCAhPT0gJ2hlaWdodCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudERpbWVuc2lvbiBvbmx5IGFjY2VwdHMgd2lkdGggb3IgaGVpZ2h0IHZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsXyk7XG5cbiAgICAgIGNvbXB1dGVkV2lkdGhPckhlaWdodCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSh3aWR0aE9ySGVpZ2h0KSB8fCBjb21wdXRlZFN0eWxlW3dpZHRoT3JIZWlnaHRdO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSAncHgnIGZyb20gdmFyaWFibGUgYW5kIHBhcnNlIGFzIGludGVnZXJcbiAgICBjb21wdXRlZFdpZHRoT3JIZWlnaHQgPSBwYXJzZUZsb2F0KGNvbXB1dGVkV2lkdGhPckhlaWdodCk7XG5cbiAgICAvLyBpZiB0aGUgY29tcHV0ZWQgdmFsdWUgaXMgc3RpbGwgMCwgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBicm93c2VyIGlzIGx5aW5nXG4gICAgLy8gYW5kIHdlIHdhbnQgdG8gY2hlY2sgdGhlIG9mZnNldCB2YWx1ZXMuXG4gICAgLy8gVGhpcyBjb2RlIGFsc28gcnVucyBvbiBJRTggYW5kIHdoZXJldmVyIGdldENvbXB1dGVkU3R5bGUgZG9lc24ndCBleGlzdC5cbiAgICBpZiAoY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID09PSAwKSB7XG4gICAgICB2YXIgcnVsZSA9ICdvZmZzZXQnICsgdG9UaXRsZUNhc2Uod2lkdGhPckhlaWdodCk7XG5cbiAgICAgIGNvbXB1dGVkV2lkdGhPckhlaWdodCA9IHRoaXMuZWxfW3J1bGVdO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wdXRlZFdpZHRoT3JIZWlnaHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHdpZHRoIGFuZCBoZWlnaHQgdmFsdWVzIG9mIHRoZSBgQ29tcG9uZW50YHNcbiAgICogY29tcHV0ZWQgc3R5bGUuIFVzZXMgYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cbiAgICpcbiAgICogQHR5cGVkZWYge09iamVjdH0gQ29tcG9uZW50fkRpbWVuc2lvbk9iamVjdFxuICAgKlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGhcbiAgICogICAgICAgICAgIFRoZSB3aWR0aCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLlxuICAgKlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0XG4gICAqICAgICAgICAgICBUaGUgaGVpZ2h0IG9mIHRoZSBgQ29tcG9uZW50YHMgY29tcHV0ZWQgc3R5bGUuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZXQgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgb2YgdGhlIGBDb21wb25lbnRgc1xuICAgKiBjb21wdXRlZCBzdHlsZS5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fkRpbWVuc2lvbk9iamVjdH1cbiAgICogICAgICAgICBUaGUgZGltZW5zaW9ucyBvZiB0aGUgY29tcG9uZW50cyBlbGVtZW50XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jdXJyZW50RGltZW5zaW9ucyA9IGZ1bmN0aW9uIGN1cnJlbnREaW1lbnNpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdGhpcy5jdXJyZW50RGltZW5zaW9uKCd3aWR0aCcpLFxuICAgICAgaGVpZ2h0OiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ2hlaWdodCcpXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB3aWR0aCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLiBVc2VzIGB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gd2lkdGhcbiAgICogICAgICAgICAgIFRoZSB3aWR0aCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY3VycmVudFdpZHRoID0gZnVuY3Rpb24gY3VycmVudFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ3dpZHRoJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSBgQ29tcG9uZW50YHMgY29tcHV0ZWQgc3R5bGUuIFVzZXMgYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBoZWlnaHRcbiAgICogICAgICAgICAgIFRoZSBoZWlnaHQgb2YgdGhlIGBDb21wb25lbnRgcyBjb21wdXRlZCBzdHlsZS5cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmN1cnJlbnRIZWlnaHQgPSBmdW5jdGlvbiBjdXJyZW50SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ2hlaWdodCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZvY3VzIHRvIHRoaXMgY29tcG9uZW50XG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIHRoaXMuZWxfLmZvY3VzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZm9jdXMgZnJvbSB0aGlzIGNvbXBvbmVudFxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgdGhpcy5lbF8uYmx1cigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbWl0IGEgJ3RhcCcgZXZlbnRzIHdoZW4gdG91Y2ggZXZlbnQgc3VwcG9ydCBnZXRzIGRldGVjdGVkLiBUaGlzIGdldHMgdXNlZCB0b1xuICAgKiBzdXBwb3J0IHRvZ2dsaW5nIHRoZSBjb250cm9scyB0aHJvdWdoIGEgdGFwIG9uIHRoZSB2aWRlby4gVGhleSBnZXQgZW5hYmxlZFxuICAgKiBiZWNhdXNlIGV2ZXJ5IHN1Yi1jb21wb25lbnQgd291bGQgaGF2ZSBleHRyYSBvdmVyaGVhZCBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmaXJlcyBDb21wb25lbnQjdGFwXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaHN0YXJ0XG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaG1vdmVcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNobGVhdmVcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoY2FuY2VsXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaGVuZFxuICAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmVtaXRUYXBFdmVudHMgPSBmdW5jdGlvbiBlbWl0VGFwRXZlbnRzKCkge1xuICAgIC8vIFRyYWNrIHRoZSBzdGFydCB0aW1lIHNvIHdlIGNhbiBkZXRlcm1pbmUgaG93IGxvbmcgdGhlIHRvdWNoIGxhc3RlZFxuICAgIHZhciB0b3VjaFN0YXJ0ID0gMDtcbiAgICB2YXIgZmlyc3RUb3VjaCA9IG51bGw7XG5cbiAgICAvLyBNYXhpbXVtIG1vdmVtZW50IGFsbG93ZWQgZHVyaW5nIGEgdG91Y2ggZXZlbnQgdG8gc3RpbGwgYmUgY29uc2lkZXJlZCBhIHRhcFxuICAgIC8vIE90aGVyIHBvcHVsYXIgbGlicyB1c2UgYW55d2hlcmUgZnJvbSAyIChoYW1tZXIuanMpIHRvIDE1LFxuICAgIC8vIHNvIDEwIHNlZW1zIGxpa2UgYSBuaWNlLCByb3VuZCBudW1iZXIuXG4gICAgdmFyIHRhcE1vdmVtZW50VGhyZXNob2xkID0gMTA7XG5cbiAgICAvLyBUaGUgbWF4aW11bSBsZW5ndGggYSB0b3VjaCBjYW4gYmUgd2hpbGUgc3RpbGwgYmVpbmcgY29uc2lkZXJlZCBhIHRhcFxuICAgIHZhciB0b3VjaFRpbWVUaHJlc2hvbGQgPSAyMDA7XG5cbiAgICB2YXIgY291bGRCZVRhcCA9IHZvaWQgMDtcblxuICAgIHRoaXMub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgZmluZ2VyLCBkb24ndCBjb25zaWRlciB0cmVhdGluZyB0aGlzIGFzIGEgY2xpY2tcbiAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBDb3B5IHBhZ2VYL3BhZ2VZIGZyb20gdGhlIG9iamVjdFxuICAgICAgICBmaXJzdFRvdWNoID0ge1xuICAgICAgICAgIHBhZ2VYOiBldmVudC50b3VjaGVzWzBdLnBhZ2VYLFxuICAgICAgICAgIHBhZ2VZOiBldmVudC50b3VjaGVzWzBdLnBhZ2VZXG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlY29yZCBzdGFydCB0aW1lIHNvIHdlIGNhbiBkZXRlY3QgYSB0YXAgdnMuIFwidG91Y2ggYW5kIGhvbGRcIlxuICAgICAgICB0b3VjaFN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIC8vIFJlc2V0IGNvdWxkQmVUYXAgdHJhY2tpbmdcbiAgICAgICAgY291bGRCZVRhcCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgZmluZ2VyLCBkb24ndCBjb25zaWRlciB0cmVhdGluZyB0aGlzIGFzIGEgY2xpY2tcbiAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY291bGRCZVRhcCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdFRvdWNoKSB7XG4gICAgICAgIC8vIFNvbWUgZGV2aWNlcyB3aWxsIHRocm93IHRvdWNobW92ZXMgZm9yIGFsbCBidXQgdGhlIHNsaWdodGVzdCBvZiB0YXBzLlxuICAgICAgICAvLyBTbywgaWYgd2UgbW92ZWQgb25seSBhIHNtYWxsIGRpc3RhbmNlLCB0aGlzIGNvdWxkIHN0aWxsIGJlIGEgdGFwXG4gICAgICAgIHZhciB4ZGlmZiA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBmaXJzdFRvdWNoLnBhZ2VYO1xuICAgICAgICB2YXIgeWRpZmYgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZmlyc3RUb3VjaC5wYWdlWTtcbiAgICAgICAgdmFyIHRvdWNoRGlzdGFuY2UgPSBNYXRoLnNxcnQoeGRpZmYgKiB4ZGlmZiArIHlkaWZmICogeWRpZmYpO1xuXG4gICAgICAgIGlmICh0b3VjaERpc3RhbmNlID4gdGFwTW92ZW1lbnRUaHJlc2hvbGQpIHtcbiAgICAgICAgICBjb3VsZEJlVGFwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBub1RhcCA9IGZ1bmN0aW9uIG5vVGFwKCkge1xuICAgICAgY291bGRCZVRhcCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBMaXN0ZW4gdG8gdGhlIG9yaWdpbmFsIHRhcmdldC4gaHR0cDovL3lvdXR1LmJlL0R1amZwWE9LVXA4P3Q9MTNtOHNcbiAgICB0aGlzLm9uKCd0b3VjaGxlYXZlJywgbm9UYXApO1xuICAgIHRoaXMub24oJ3RvdWNoY2FuY2VsJywgbm9UYXApO1xuXG4gICAgLy8gV2hlbiB0aGUgdG91Y2ggZW5kcywgbWVhc3VyZSBob3cgbG9uZyBpdCB0b29rIGFuZCB0cmlnZ2VyIHRoZSBhcHByb3ByaWF0ZVxuICAgIC8vIGV2ZW50XG4gICAgdGhpcy5vbigndG91Y2hlbmQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGZpcnN0VG91Y2ggPSBudWxsO1xuICAgICAgLy8gUHJvY2VlZCBvbmx5IGlmIHRoZSB0b3VjaG1vdmUvbGVhdmUvY2FuY2VsIGV2ZW50IGRpZG4ndCBoYXBwZW5cbiAgICAgIGlmIChjb3VsZEJlVGFwID09PSB0cnVlKSB7XG4gICAgICAgIC8vIE1lYXN1cmUgaG93IGxvbmcgdGhlIHRvdWNoIGxhc3RlZFxuICAgICAgICB2YXIgdG91Y2hUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0b3VjaFN0YXJ0O1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdG91Y2ggd2FzIGxlc3MgdGhhbiB0aGUgdGhyZXNob2xkIHRvIGJlIGNvbnNpZGVyZWQgYSB0YXBcbiAgICAgICAgaWYgKHRvdWNoVGltZSA8IHRvdWNoVGltZVRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIERvbid0IGxldCBicm93c2VyIHR1cm4gdGhpcyBpbnRvIGEgY2xpY2tcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgYENvbXBvbmVudGAgaXMgdGFwcGVkLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGV2ZW50IENvbXBvbmVudCN0YXBcbiAgICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd0YXAnKTtcbiAgICAgICAgICAvLyBJdCBtYXkgYmUgZ29vZCB0byBjb3B5IHRoZSB0b3VjaGVuZCBldmVudCBvYmplY3QgYW5kIGNoYW5nZSB0aGVcbiAgICAgICAgICAvLyB0eXBlIHRvIHRhcCwgaWYgdGhlIG90aGVyIGV2ZW50IHByb3BlcnRpZXMgYXJlbid0IGV4YWN0IGFmdGVyXG4gICAgICAgICAgLy8gRXZlbnRzLmZpeEV2ZW50IHJ1bnMgKGUuZy4gZXZlbnQudGFyZ2V0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gcmVwb3J0cyB1c2VyIGFjdGl2aXR5IHdoZW5ldmVyIHRvdWNoIGV2ZW50cyBoYXBwZW4uIFRoaXMgY2FuIGdldFxuICAgKiB0dXJuZWQgb2ZmIGJ5IGFueSBzdWItY29tcG9uZW50cyB0aGF0IHdhbnRzIHRvdWNoIGV2ZW50cyB0byBhY3QgYW5vdGhlciB3YXkuXG4gICAqXG4gICAqIFJlcG9ydCB1c2VyIHRvdWNoIGFjdGl2aXR5IHdoZW4gdG91Y2ggZXZlbnRzIG9jY3VyLiBVc2VyIGFjdGl2aXR5IGdldHMgdXNlZCB0b1xuICAgKiBkZXRlcm1pbmUgd2hlbiBjb250cm9scyBzaG91bGQgc2hvdy9oaWRlLiBJdCBpcyBzaW1wbGUgd2hlbiBpdCBjb21lcyB0byBtb3VzZVxuICAgKiBldmVudHMsIGJlY2F1c2UgYW55IG1vdXNlIGV2ZW50IHNob3VsZCBzaG93IHRoZSBjb250cm9scy4gU28gd2UgY2FwdHVyZSBtb3VzZVxuICAgKiBldmVudHMgdGhhdCBidWJibGUgdXAgdG8gdGhlIHBsYXllciBhbmQgcmVwb3J0IGFjdGl2aXR5IHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgKiBXaXRoIHRvdWNoIGV2ZW50cyBpdCBpc24ndCBhcyBlYXN5IGFzIGB0b3VjaHN0YXJ0YCBhbmQgYHRvdWNoZW5kYCB0b2dnbGUgcGxheWVyXG4gICAqIGNvbnRyb2xzLiBTbyB0b3VjaCBldmVudHMgY2FuJ3QgaGVscCB1cyBhdCB0aGUgcGxheWVyIGxldmVsIGVpdGhlci5cbiAgICpcbiAgICogVXNlciBhY3Rpdml0eSBnZXRzIGNoZWNrZWQgYXN5bmNocm9ub3VzbHkuIFNvIHdoYXQgY291bGQgaGFwcGVuIGlzIGEgdGFwIGV2ZW50XG4gICAqIG9uIHRoZSB2aWRlbyB0dXJucyB0aGUgY29udHJvbHMgb2ZmLiBUaGVuIHRoZSBgdG91Y2hlbmRgIGV2ZW50IGJ1YmJsZXMgdXAgdG9cbiAgICogdGhlIHBsYXllci4gV2hpY2gsIGlmIGl0IHJlcG9ydGVkIHVzZXIgYWN0aXZpdHksIHdvdWxkIHR1cm4gdGhlIGNvbnRyb2xzIHJpZ2h0XG4gICAqIGJhY2sgb24uIFdlIGFsc28gZG9uJ3Qgd2FudCB0byBjb21wbGV0ZWx5IGJsb2NrIHRvdWNoIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHVwLlxuICAgKiBGdXJ0aGVybW9yZSBhIGB0b3VjaG1vdmVgIGV2ZW50IGFuZCBhbnl0aGluZyBvdGhlciB0aGFuIGEgdGFwLCBzaG91bGQgbm90IHR1cm5cbiAgICogY29udHJvbHMgYmFjayBvbi5cbiAgICpcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoc3RhcnRcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNobW92ZVxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hlbmRcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoY2FuY2VsXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5lbmFibGVUb3VjaEFjdGl2aXR5ID0gZnVuY3Rpb24gZW5hYmxlVG91Y2hBY3Rpdml0eSgpIHtcbiAgICAvLyBEb24ndCBjb250aW51ZSBpZiB0aGUgcm9vdCBwbGF5ZXIgZG9lc24ndCBzdXBwb3J0IHJlcG9ydGluZyB1c2VyIGFjdGl2aXR5XG4gICAgaWYgKCF0aGlzLnBsYXllcigpIHx8ICF0aGlzLnBsYXllcigpLnJlcG9ydFVzZXJBY3Rpdml0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGxpc3RlbmVyIGZvciByZXBvcnRpbmcgdGhhdCB0aGUgdXNlciBpcyBhY3RpdmVcbiAgICB2YXIgcmVwb3J0ID0gYmluZCh0aGlzLnBsYXllcigpLCB0aGlzLnBsYXllcigpLnJlcG9ydFVzZXJBY3Rpdml0eSk7XG5cbiAgICB2YXIgdG91Y2hIb2xkaW5nID0gdm9pZCAwO1xuXG4gICAgdGhpcy5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlcG9ydCgpO1xuICAgICAgLy8gRm9yIGFzIGxvbmcgYXMgdGhlIHRoZXkgYXJlIHRvdWNoaW5nIHRoZSBkZXZpY2Ugb3IgaGF2ZSB0aGVpciBtb3VzZSBkb3duLFxuICAgICAgLy8gd2UgY29uc2lkZXIgdGhlbSBhY3RpdmUgZXZlbiBpZiB0aGV5J3JlIG5vdCBtb3ZpbmcgdGhlaXIgZmluZ2VyIG9yIG1vdXNlLlxuICAgICAgLy8gU28gd2Ugd2FudCB0byBjb250aW51ZSB0byB1cGRhdGUgdGhhdCB0aGV5IGFyZSBhY3RpdmVcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCh0b3VjaEhvbGRpbmcpO1xuICAgICAgLy8gcmVwb3J0IGF0IHRoZSBzYW1lIGludGVydmFsIGFzIGFjdGl2aXR5Q2hlY2tcbiAgICAgIHRvdWNoSG9sZGluZyA9IHRoaXMuc2V0SW50ZXJ2YWwocmVwb3J0LCAyNTApO1xuICAgIH0pO1xuXG4gICAgdmFyIHRvdWNoRW5kID0gZnVuY3Rpb24gdG91Y2hFbmQoZXZlbnQpIHtcbiAgICAgIHJlcG9ydCgpO1xuICAgICAgLy8gc3RvcCB0aGUgaW50ZXJ2YWwgdGhhdCBtYWludGFpbnMgYWN0aXZpdHkgaWYgdGhlIHRvdWNoIGlzIGhvbGRpbmdcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCh0b3VjaEhvbGRpbmcpO1xuICAgIH07XG5cbiAgICB0aGlzLm9uKCd0b3VjaG1vdmUnLCByZXBvcnQpO1xuICAgIHRoaXMub24oJ3RvdWNoZW5kJywgdG91Y2hFbmQpO1xuICAgIHRoaXMub24oJ3RvdWNoY2FuY2VsJywgdG91Y2hFbmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGNhbGxiYWNrIHRoYXQgaGFzIG5vIHBhcmFtZXRlcnMgYW5kIGlzIGJvdW5kIGludG8gYENvbXBvbmVudGBzIGNvbnRleHQuXG4gICAqXG4gICAqIEBjYWxsYmFjayBDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrXG4gICAqIEB0aGlzIENvbXBvbmVudFxuICAgKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcnVucyBhZnRlciBhbiBgeGAgbWlsbGlzZWNvbmQgdGltZW91dC4gVGhpcyBmdW5jdGlvbiBpcyBhXG4gICAqIHdyYXBwZXIgYXJvdW5kIGB3aW5kb3cuc2V0VGltZW91dGAuIFRoZXJlIGFyZSBhIGZldyByZWFzb25zIHRvIHVzZSB0aGlzIG9uZVxuICAgKiBpbnN0ZWFkIHRob3VnaDpcbiAgICogMS4gSXQgZ2V0cyBjbGVhcmVkIHZpYSAge0BsaW5rIENvbXBvbmVudCNjbGVhclRpbWVvdXR9IHdoZW5cbiAgICogICAge0BsaW5rIENvbXBvbmVudCNkaXNwb3NlfSBnZXRzIGNhbGxlZC5cbiAgICogMi4gVGhlIGZ1bmN0aW9uIGNhbGxiYWNrIHdpbGwgZ2V0cyB0dXJuZWQgaW50byBhIHtAbGluayBDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrfVxuICAgKlxuICAgKiA+IE5vdGU6IFlvdSBjYW4gdXNlIGB3aW5kb3cuY2xlYXJUaW1lb3V0YCBvbiB0aGUgaWQgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbi4gVGhpc1xuICAgKiAgICAgICAgIHdpbGwgY2F1c2UgaXRzIGRpc3Bvc2UgbGlzdGVuZXIgbm90IHRvIGdldCBjbGVhbmVkIHVwISBQbGVhc2UgdXNlXG4gICAqICAgICAgICAge0BsaW5rIENvbXBvbmVudCNjbGVhclRpbWVvdXR9IG9yIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0uXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fkdlbmVyaWNDYWxsYmFja30gZm5cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgcnVuIGFmdGVyIGB0aW1lb3V0YC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAgICogICAgICAgIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGJlZm9yZSBleGVjdXRpbmcgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFJldHVybnMgYSB0aW1lb3V0IElEIHRoYXQgZ2V0cyB1c2VkIHRvIGlkZW50aWZ5IHRoZSB0aW1lb3V0LiBJdCBjYW4gYWxzb1xuICAgKiAgICAgICAgIGdldCB1c2VkIGluIHtAbGluayBDb21wb25lbnQjY2xlYXJUaW1lb3V0fSB0byBjbGVhciB0aGUgdGltZW91dCB0aGF0XG4gICAqICAgICAgICAgd2FzIHNldC5cbiAgICpcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I2Rpc3Bvc2VcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd1RpbWVycy9zZXRUaW1lb3V0fVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uIHNldFRpbWVvdXQoZm4sIHRpbWVvdXQpIHtcbiAgICBmbiA9IGJpbmQodGhpcywgZm4pO1xuXG4gICAgdmFyIHRpbWVvdXRJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZuLCB0aW1lb3V0KTtcbiAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge1xuICAgICAgdGhpcy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9O1xuXG4gICAgZGlzcG9zZUZuLmd1aWQgPSAndmpzLXRpbWVvdXQtJyArIHRpbWVvdXRJZDtcblxuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgcmV0dXJuIHRpbWVvdXRJZDtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXJzIGEgdGltZW91dCB0aGF0IGdldHMgY3JlYXRlZCB2aWEgYHdpbmRvdy5zZXRUaW1lb3V0YCBvclxuICAgKiB7QGxpbmsgQ29tcG9uZW50I3NldFRpbWVvdXR9LiBJZiB5b3Ugc2V0IGEgdGltZW91dCB2aWEge0BsaW5rIENvbXBvbmVudCNzZXRUaW1lb3V0fVxuICAgKiB1c2UgdGhpcyBmdW5jdGlvbiBpbnN0ZWFkIG9mIGB3aW5kb3cuY2xlYXJUaW1vdXRgLiBJZiB5b3UgZG9uJ3QgeW91ciBkaXNwb3NlXG4gICAqIGxpc3RlbmVyIHdpbGwgbm90IGdldCBjbGVhbmVkIHVwIHVudGlsIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0hXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0SWRcbiAgICogICAgICAgIFRoZSBpZCBvZiB0aGUgdGltZW91dCB0byBjbGVhci4gVGhlIHJldHVybiB2YWx1ZSBvZlxuICAgKiAgICAgICAge0BsaW5rIENvbXBvbmVudCNzZXRUaW1lb3V0fSBvciBgd2luZG93LnNldFRpbWVvdXRgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgUmV0dXJucyB0aGUgdGltZW91dCBpZCB0aGF0IHdhcyBjbGVhcmVkLlxuICAgKlxuICAgKiBAc2VlIFtTaW1pbGFyIHRvXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93VGltZXJzL2NsZWFyVGltZW91dH1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpIHtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cbiAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge307XG5cbiAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtdGltZW91dC0nICsgdGltZW91dElkO1xuXG4gICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgcmV0dXJuIHRpbWVvdXRJZDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyBydW4gZXZlcnkgYHhgIG1pbGxpc2Vjb25kcy4gVGhpcyBmdW5jdGlvbiBpcyBhIHdyYXBwZXJcbiAgICogYXJvdW5kIGB3aW5kb3cuc2V0SW50ZXJ2YWxgLiBUaGVyZSBhcmUgYSBmZXcgcmVhc29ucyB0byB1c2UgdGhpcyBvbmUgaW5zdGVhZCB0aG91Z2guXG4gICAqIDEuIEl0IGdldHMgY2xlYXJlZCB2aWEgIHtAbGluayBDb21wb25lbnQjY2xlYXJJbnRlcnZhbH0gd2hlblxuICAgKiAgICB7QGxpbmsgQ29tcG9uZW50I2Rpc3Bvc2V9IGdldHMgY2FsbGVkLlxuICAgKiAyLiBUaGUgZnVuY3Rpb24gY2FsbGJhY2sgd2lsbCBiZSBhIHtAbGluayBDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrfVxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9IGZuXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gcnVuIGV2ZXJ5IGB4YCBzZWNvbmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWxcbiAgICogICAgICAgIEV4ZWN1dGUgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBldmVyeSBgeGAgbWlsbGlzZWNvbmRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgUmV0dXJucyBhbiBpZCB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IHRoZSBpbnRlcnZhbC4gSXQgY2FuIGFsc28gYmUgYmUgdXNlZCBpblxuICAgKiAgICAgICAgIHtAbGluayBDb21wb25lbnQjY2xlYXJJbnRlcnZhbH0gdG8gY2xlYXIgdGhlIGludGVydmFsLlxuICAgKlxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjZGlzcG9zZVxuICAgKiBAc2VlIFtTaW1pbGFyIHRvXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93VGltZXJzL3NldEludGVydmFsfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiBzZXRJbnRlcnZhbChmbiwgaW50ZXJ2YWwpIHtcbiAgICBmbiA9IGJpbmQodGhpcywgZm4pO1xuXG4gICAgdmFyIGludGVydmFsSWQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZm4sIGludGVydmFsKTtcblxuICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7XG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgfTtcblxuICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy1pbnRlcnZhbC0nICsgaW50ZXJ2YWxJZDtcblxuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgcmV0dXJuIGludGVydmFsSWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbiBpbnRlcnZhbCB0aGF0IGdldHMgY3JlYXRlZCB2aWEgYHdpbmRvdy5zZXRJbnRlcnZhbGAgb3JcbiAgICoge0BsaW5rIENvbXBvbmVudCNzZXRJbnRlcnZhbH0uIElmIHlvdSBzZXQgYW4gaW50ZXZhbCB2aWEge0BsaW5rIENvbXBvbmVudCNzZXRJbnRlcnZhbH1cbiAgICogdXNlIHRoaXMgZnVuY3Rpb24gaW5zdGVhZCBvZiBgd2luZG93LmNsZWFySW50ZXJ2YWxgLiBJZiB5b3UgZG9uJ3QgeW91ciBkaXNwb3NlXG4gICAqIGxpc3RlbmVyIHdpbGwgbm90IGdldCBjbGVhbmVkIHVwIHVudGlsIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0hXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbElkXG4gICAqICAgICAgICBUaGUgaWQgb2YgdGhlIGludGVydmFsIHRvIGNsZWFyLiBUaGUgcmV0dXJuIHZhbHVlIG9mXG4gICAqICAgICAgICB7QGxpbmsgQ29tcG9uZW50I3NldEludGVydmFsfSBvciBgd2luZG93LnNldEludGVydmFsYC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFJldHVybnMgdGhlIGludGVydmFsIGlkIHRoYXQgd2FzIGNsZWFyZWQuXG4gICAqXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dUaW1lcnMvY2xlYXJJbnRlcnZhbH1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiBjbGVhckludGVydmFsKGludGVydmFsSWQpIHtcbiAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcblxuICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7fTtcblxuICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy1pbnRlcnZhbC0nICsgaW50ZXJ2YWxJZDtcblxuICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgIHJldHVybiBpbnRlcnZhbElkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBRdWV1ZXMgdXAgYSBjYWxsYmFjayB0byBiZSBwYXNzZWQgdG8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChyQUYpLCBidXRcbiAgICogd2l0aCBhIGZldyBleHRyYSBib251c2VzOlxuICAgKlxuICAgKiAtIFN1cHBvcnRzIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgckFGIGJ5IGZhbGxpbmcgYmFjayB0b1xuICAgKiAgIHtAbGluayBDb21wb25lbnQjc2V0VGltZW91dH0uXG4gICAqXG4gICAqIC0gVGhlIGNhbGxiYWNrIGlzIHR1cm5lZCBpbnRvIGEge0BsaW5rIENvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9IChpLmUuXG4gICAqICAgYm91bmQgdG8gdGhlIGNvbXBvbmVudCkuXG4gICAqXG4gICAqIC0gQXV0b21hdGljIGNhbmNlbGxhdGlvbiBvZiB0aGUgckFGIGNhbGxiYWNrIGlzIGhhbmRsZWQgaWYgdGhlIGNvbXBvbmVudFxuICAgKiAgIGlzIGRpc3Bvc2VkIGJlZm9yZSBpdCBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge0NvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9IGZuXG4gICAqICAgICAgICAgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgYm91bmQgdG8gdGhpcyBjb21wb25lbnQgYW5kIGV4ZWN1dGVkIGp1c3RcbiAgICogICAgICAgICBiZWZvcmUgdGhlIGJyb3dzZXIncyBuZXh0IHJlcGFpbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIGFuIHJBRiBJRCB0aGF0IGdldHMgdXNlZCB0byBpZGVudGlmeSB0aGUgdGltZW91dC4gSXQgY2FuXG4gICAqICAgICAgICAgYWxzbyBiZSB1c2VkIGluIHtAbGluayBDb21wb25lbnQjY2FuY2VsQW5pbWF0aW9uRnJhbWV9IHRvIGNhbmNlbFxuICAgKiAgICAgICAgIHRoZSBhbmltYXRpb24gZnJhbWUgY2FsbGJhY2suXG4gICAqXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCNkaXNwb3NlXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cvcmVxdWVzdEFuaW1hdGlvbkZyYW1lfVxuICAgKi9cblxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5zdXBwb3J0c1JhZl8pIHtcbiAgICAgIGZuID0gYmluZCh0aGlzLCBmbik7XG5cbiAgICAgIHZhciBpZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgdmFyIGRpc3Bvc2VGbiA9IGZ1bmN0aW9uIGRpc3Bvc2VGbigpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICB9O1xuXG4gICAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtcmFmLScgKyBpZDtcbiAgICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xuXG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgLy8gRmFsbCBiYWNrIHRvIHVzaW5nIGEgdGltZXIuXG4gICAgcmV0dXJuIHRoaXMuc2V0VGltZW91dChmbiwgMTAwMCAvIDYwKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FuY2VscyBhIHF1ZXVlZCBjYWxsYmFjayBwYXNzZWQgdG8ge0BsaW5rIENvbXBvbmVudCNyZXF1ZXN0QW5pbWF0aW9uRnJhbWV9XG4gICAqIChyQUYpLlxuICAgKlxuICAgKiBJZiB5b3UgcXVldWUgYW4gckFGIGNhbGxiYWNrIHZpYSB7QGxpbmsgQ29tcG9uZW50I3JlcXVlc3RBbmltYXRpb25GcmFtZX0sXG4gICAqIHVzZSB0aGlzIGZ1bmN0aW9uIGluc3RlYWQgb2YgYHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZWAuIElmIHlvdSBkb24ndCxcbiAgICogeW91ciBkaXNwb3NlIGxpc3RlbmVyIHdpbGwgbm90IGdldCBjbGVhbmVkIHVwIHVudGlsIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0hXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpZFxuICAgKiAgICAgICAgVGhlIHJBRiBJRCB0byBjbGVhci4gVGhlIHJldHVybiB2YWx1ZSBvZiB7QGxpbmsgQ29tcG9uZW50I3JlcXVlc3RBbmltYXRpb25GcmFtZX0uXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBSZXR1cm5zIHRoZSByQUYgSUQgdGhhdCB3YXMgY2xlYXJlZC5cbiAgICpcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy9jYW5jZWxBbmltYXRpb25GcmFtZX1cbiAgICovXG5cblxuICBDb21wb25lbnQucHJvdG90eXBlLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpIHtcbiAgICBpZiAodGhpcy5zdXBwb3J0c1JhZl8pIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG5cbiAgICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7fTtcblxuICAgICAgZGlzcG9zZUZuLmd1aWQgPSAndmpzLXJhZi0nICsgaWQ7XG5cbiAgICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcblxuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIC8vIEZhbGwgYmFjayB0byB1c2luZyBhIHRpbWVyLlxuICAgIHJldHVybiB0aGlzLmNsZWFyVGltZW91dChpZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgYENvbXBvbmVudGAgd2l0aCBgdmlkZW9qc2AgZ2l2ZW4gdGhlIG5hbWUgYW5kIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqID4gTk9URToge0BsaW5rIFRlY2h9cyBzaG91bGQgbm90IGJlIHJlZ2lzdGVyZWQgYXMgYSBgQ29tcG9uZW50YC4ge0BsaW5rIFRlY2h9c1xuICAgKiAgICAgICAgIHNob3VsZCBiZSByZWdpc3RlcmVkIHVzaW5nIHtAbGluayBUZWNoLnJlZ2lzdGVyVGVjaH0gb3JcbiAgICogICAgICAgICB7QGxpbmsgdmlkZW9qczp2aWRlb2pzLnJlZ2lzdGVyVGVjaH0uXG4gICAqXG4gICAqID4gTk9URTogVGhpcyBmdW5jdGlvbiBjYW4gYWxzbyBiZSBzZWVuIG9uIHZpZGVvanMgYXNcbiAgICogICAgICAgICB7QGxpbmsgdmlkZW9qczp2aWRlb2pzLnJlZ2lzdGVyQ29tcG9uZW50fS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBgQ29tcG9uZW50YCB0byByZWdpc3Rlci5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR9IENvbXBvbmVudFRvUmVnaXN0ZXJcbiAgICogICAgICAgIFRoZSBgQ29tcG9uZW50YCBjbGFzcyB0byByZWdpc3Rlci5cbiAgICpcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxuICAgKiAgICAgICAgIFRoZSBgQ29tcG9uZW50YCB0aGF0IHdhcyByZWdpc3RlcmVkLlxuICAgKi9cblxuXG4gIENvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCA9IGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50KG5hbWUsIENvbXBvbmVudFRvUmVnaXN0ZXIpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8ICFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY29tcG9uZW50IG5hbWUsIFwiJyArIG5hbWUgKyAnXCI7IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLicpO1xuICAgIH1cblxuICAgIHZhciBUZWNoID0gQ29tcG9uZW50LmdldENvbXBvbmVudCgnVGVjaCcpO1xuXG4gICAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgdGhpcyBjaGVjayBpcyBvbmx5IGRvbmUgaWYgVGVjaCBoYXMgYmVlbiByZWdpc3RlcmVkLlxuICAgIHZhciBpc1RlY2ggPSBUZWNoICYmIFRlY2guaXNUZWNoKENvbXBvbmVudFRvUmVnaXN0ZXIpO1xuICAgIHZhciBpc0NvbXAgPSBDb21wb25lbnQgPT09IENvbXBvbmVudFRvUmVnaXN0ZXIgfHwgQ29tcG9uZW50LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKENvbXBvbmVudFRvUmVnaXN0ZXIucHJvdG90eXBlKTtcblxuICAgIGlmIChpc1RlY2ggfHwgIWlzQ29tcCkge1xuICAgICAgdmFyIHJlYXNvbiA9IHZvaWQgMDtcblxuICAgICAgaWYgKGlzVGVjaCkge1xuICAgICAgICByZWFzb24gPSAndGVjaHMgbXVzdCBiZSByZWdpc3RlcmVkIHVzaW5nIFRlY2gucmVnaXN0ZXJUZWNoKCknO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVhc29uID0gJ211c3QgYmUgYSBDb21wb25lbnQgc3ViY2xhc3MnO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgY29tcG9uZW50LCBcIicgKyBuYW1lICsgJ1wiOyAnICsgcmVhc29uICsgJy4nKTtcbiAgICB9XG5cbiAgICBuYW1lID0gdG9UaXRsZUNhc2UobmFtZSk7XG5cbiAgICBpZiAoIUNvbXBvbmVudC5jb21wb25lbnRzXykge1xuICAgICAgQ29tcG9uZW50LmNvbXBvbmVudHNfID0ge307XG4gICAgfVxuXG4gICAgdmFyIFBsYXllciA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoJ1BsYXllcicpO1xuXG4gICAgaWYgKG5hbWUgPT09ICdQbGF5ZXInICYmIFBsYXllciAmJiBQbGF5ZXIucGxheWVycykge1xuICAgICAgdmFyIHBsYXllcnMgPSBQbGF5ZXIucGxheWVycztcbiAgICAgIHZhciBwbGF5ZXJOYW1lcyA9IE9iamVjdC5rZXlzKHBsYXllcnMpO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIHBsYXllcnMgdGhhdCB3ZXJlIGRpc3Bvc2VkLCB0aGVuIHRoZWlyIG5hbWUgd2lsbCBzdGlsbCBiZVxuICAgICAgLy8gaW4gUGxheWVycy5wbGF5ZXJzLiBTbywgd2UgbXVzdCBsb29wIHRocm91Z2ggYW5kIHZlcmlmeSB0aGF0IHRoZSB2YWx1ZVxuICAgICAgLy8gZm9yIGVhY2ggaXRlbSBpcyBub3QgbnVsbC4gVGhpcyBhbGxvd3MgcmVnaXN0cmF0aW9uIG9mIHRoZSBQbGF5ZXIgY29tcG9uZW50XG4gICAgICAvLyBhZnRlciBhbGwgcGxheWVycyBoYXZlIGJlZW4gZGlzcG9zZWQgb3IgYmVmb3JlIGFueSB3ZXJlIGNyZWF0ZWQuXG4gICAgICBpZiAocGxheWVycyAmJiBwbGF5ZXJOYW1lcy5sZW5ndGggPiAwICYmIHBsYXllck5hbWVzLm1hcChmdW5jdGlvbiAocG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHBsYXllcnNbcG5hbWVdO1xuICAgICAgfSkuZXZlcnkoQm9vbGVhbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IHJlZ2lzdGVyIFBsYXllciBjb21wb25lbnQgYWZ0ZXIgcGxheWVyIGhhcyBiZWVuIGNyZWF0ZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQ29tcG9uZW50LmNvbXBvbmVudHNfW25hbWVdID0gQ29tcG9uZW50VG9SZWdpc3RlcjtcblxuICAgIHJldHVybiBDb21wb25lbnRUb1JlZ2lzdGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBgQ29tcG9uZW50YCBiYXNlZCBvbiB0aGUgbmFtZSBpdCB3YXMgcmVnaXN0ZXJlZCB3aXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiAgICAgICAgVGhlIE5hbWUgb2YgdGhlIGNvbXBvbmVudCB0byBnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogICAgICAgICBUaGUgYENvbXBvbmVudGAgdGhhdCBnb3QgcmVnaXN0ZXJlZCB1bmRlciB0aGUgZ2l2ZW4gbmFtZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW4gYHZpZGVvanNgIDYgdGhpcyB3aWxsIG5vdCByZXR1cm4gYENvbXBvbmVudGBzIHRoYXQgd2VyZSBub3RcbiAgICogICAgICAgICAgICAgcmVnaXN0ZXJlZCB1c2luZyB7QGxpbmsgQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50fS4gQ3VycmVudGx5IHdlXG4gICAqICAgICAgICAgICAgIGNoZWNrIHRoZSBnbG9iYWwgYHZpZGVvanNgIG9iamVjdCBmb3IgYSBgQ29tcG9uZW50YCBuYW1lIGFuZFxuICAgKiAgICAgICAgICAgICByZXR1cm4gdGhhdCBpZiBpdCBleGlzdHMuXG4gICAqL1xuXG5cbiAgQ29tcG9uZW50LmdldENvbXBvbmVudCA9IGZ1bmN0aW9uIGdldENvbXBvbmVudChuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmFtZSA9IHRvVGl0bGVDYXNlKG5hbWUpO1xuXG4gICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzXyAmJiBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV0pIHtcbiAgICAgIHJldHVybiBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV07XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDb21wb25lbnQ7XG59KCk7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhpcyBjb21wb25lbnQgc3VwcG9ydHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gKlxuICogVGhpcyBpcyBleHBvc2VkIHByaW1hcmlseSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLnN1cHBvcnRzUmFmXyA9IHR5cGVvZiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbic7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ29tcG9uZW50JywgQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAZmlsZSB0aW1lLXJhbmdlcy5qc1xuICogQG1vZHVsZSB0aW1lLXJhbmdlc1xuICovXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdGltZSBmb3IgdGhlIHNwZWNpZmllZCBpbmRleCBhdCB0aGUgc3RhcnQgb3IgZW5kXG4gKiBvZiBhIFRpbWVSYW5nZSBvYmplY3QuXG4gKlxuICogQGZ1bmN0aW9uIHRpbWUtcmFuZ2VzOmluZGV4RnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PTBdXG4gKiAgICAgICAgVGhlIHJhbmdlIG51bWJlciB0byByZXR1cm4gdGhlIHRpbWUgZm9yLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHRpbWUgdGhhdCBvZmZzZXQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAqXG4gKiBAZGVwcmljYXRlZCBpbmRleCBtdXN0IGJlIHNldCB0byBhIHZhbHVlLCBpbiB0aGUgZnV0dXJlIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqL1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHJhbmdlcyBvZiB0aW1lIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gVGltZVJhbmdlXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlbmd0aFxuICogICAgICAgICAgIFRoZSBudW1iZXIgb2YgdGltZSByYW5nZXMgcmVwcmVzZW50ZWQgYnkgdGhpcyBPYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge3RpbWUtcmFuZ2VzOmluZGV4RnVuY3Rpb259IHN0YXJ0XG4gKiAgICAgICAgICAgUmV0dXJucyB0aGUgdGltZSBvZmZzZXQgYXQgd2hpY2ggYSBzcGVjaWZpZWQgdGltZSByYW5nZSBiZWdpbnMuXG4gKlxuICogQHByb3BlcnR5IHt0aW1lLXJhbmdlczppbmRleEZ1bmN0aW9ufSBlbmRcbiAqICAgICAgICAgICBSZXR1cm5zIHRoZSB0aW1lIG9mZnNldCBhdCB3aGljaCBhIHNwZWNpZmllZCB0aW1lIHJhbmdlIGJlZ2lucy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UaW1lUmFuZ2VzXG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiBhbnkgb2YgdGhlIHRpbWUgcmFuZ2VzIGFyZSBvdmVyIHRoZSBtYXhpbXVtIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcbiAqICAgICAgICBUaGUgZnVuY3Rpb24gbmFtZSB0byB1c2UgZm9yIGxvZ2dpbmdcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqICAgICAgICBUaGUgaW5kZXggdG8gY2hlY2tcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4SW5kZXhcbiAqICAgICAgICBUaGUgbWF4aW11bSBwb3NzaWJsZSBpbmRleFxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgdGltZVJhbmdlcyBwcm92aWRlZCBhcmUgb3ZlciB0aGUgbWF4SW5kZXhcbiAqL1xuZnVuY3Rpb24gcmFuZ2VDaGVjayhmbk5hbWUsIGluZGV4LCBtYXhJbmRleCkge1xuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJyB8fCBpbmRleCA8IDAgfHwgaW5kZXggPiBtYXhJbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGV4ZWN1dGUgXFwnJyArIGZuTmFtZSArICdcXCcgb24gXFwnVGltZVJhbmdlc1xcJzogVGhlIGluZGV4IHByb3ZpZGVkICgnICsgaW5kZXggKyAnKSBpcyBub24tbnVtZXJpYyBvciBvdXQgb2YgYm91bmRzICgwLScgKyBtYXhJbmRleCArICcpLicpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW55IG9mIHRoZSB0aW1lIHJhbmdlcyBhcmUgb3ZlciB0aGUgbWF4aW11bSBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIG5hbWUgdG8gdXNlIGZvciBsb2dnaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlSW5kZXhcbiAqICAgICAgICBUaGUgcHJvcHJldHkgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBnZXQgdGhlIHRpbWUuIHNob3VsZCBiZSAnc3RhcnQnIG9yICdlbmQnXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcmFuZ2VzXG4gKiAgICAgICAgQW4gYXJyYXkgb2YgdGltZSByYW5nZXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBbcmFuZ2VJbmRleD0wXVxuICogICAgICAgIFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoIGF0XG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdGltZSB0aGF0IG9mZnNldCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICpcbiAqXG4gKiBAZGVwcmljYXRlZCByYW5nZUluZGV4IG11c3QgYmUgc2V0IHRvIGEgdmFsdWUsIGluIHRoZSBmdXR1cmUgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yLlxuICogQHRocm93cyB7RXJyb3J9IGlmIHJhbmdlSW5kZXggaXMgbW9yZSB0aGFuIHRoZSBsZW5ndGggb2YgcmFuZ2VzXG4gKi9cbmZ1bmN0aW9uIGdldFJhbmdlKGZuTmFtZSwgdmFsdWVJbmRleCwgcmFuZ2VzLCByYW5nZUluZGV4KSB7XG4gIHJhbmdlQ2hlY2soZm5OYW1lLCByYW5nZUluZGV4LCByYW5nZXMubGVuZ3RoIC0gMSk7XG4gIHJldHVybiByYW5nZXNbcmFuZ2VJbmRleF1bdmFsdWVJbmRleF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgdGltZSByYW5nZSBvYmplY3QgZ2l2ZW50IHJhbmdlcyBvZiB0aW1lLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IFtyYW5nZXNdXG4gKiAgICAgICAgQW4gYXJyYXkgb2YgdGltZSByYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVSYW5nZXNPYmoocmFuZ2VzKSB7XG4gIGlmIChyYW5nZXMgPT09IHVuZGVmaW5lZCB8fCByYW5nZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlbmd0aDogMCxcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIFRpbWVSYW5nZXMgb2JqZWN0IGlzIGVtcHR5Jyk7XG4gICAgICB9LFxuICAgICAgZW5kOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBUaW1lUmFuZ2VzIG9iamVjdCBpcyBlbXB0eScpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsZW5ndGg6IHJhbmdlcy5sZW5ndGgsXG4gICAgc3RhcnQ6IGdldFJhbmdlLmJpbmQobnVsbCwgJ3N0YXJ0JywgMCwgcmFuZ2VzKSxcbiAgICBlbmQ6IGdldFJhbmdlLmJpbmQobnVsbCwgJ2VuZCcsIDEsIHJhbmdlcylcbiAgfTtcbn1cblxuLyoqXG4gKiBTaG91bGQgY3JlYXRlIGEgZmFrZSBgVGltZVJhbmdlYCBvYmplY3Qgd2hpY2ggbWltaWNzIGFuIEhUTUw1IHRpbWUgcmFuZ2UgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ8QXJyYXl9IHN0YXJ0XG4gKiAgICAgICAgVGhlIHN0YXJ0IG9mIGEgc2luZ2xlIHJhbmdlIG9yIGFuIGFycmF5IG9mIHJhbmdlc1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAqICAgICAgICBUaGUgZW5kIG9mIGEgc2luZ2xlIHJhbmdlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVSYW5nZXMoc3RhcnQsIGVuZCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdGFydCkpIHtcbiAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlc09iaihzdGFydCk7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzT2JqKCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXNPYmooW1tzdGFydCwgZW5kXV0pO1xufVxuXG4vKipcbiAqIEBmaWxlIGJ1ZmZlci5qc1xuICogQG1vZHVsZSBidWZmZXJcbiAqL1xuLyoqXG4gKiBDb21wdXRlIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBtZWRpYSB0aGF0IGhhcyBiZWVuIGJ1ZmZlcmVkLlxuICpcbiAqIEBwYXJhbSB7VGltZVJhbmdlfSBidWZmZXJlZFxuICogICAgICAgIFRoZSBjdXJyZW50IGBUaW1lUmFuZ2VgIG9iamVjdCByZXByZXNlbnRpbmcgYnVmZmVyZWQgdGltZSByYW5nZXNcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cbiAqICAgICAgICBUb3RhbCBkdXJhdGlvbiBvZiB0aGUgbWVkaWFcbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFBlcmNlbnQgYnVmZmVyZWQgb2YgdGhlIHRvdGFsIGR1cmF0aW9uIGluIGRlY2ltYWwgZm9ybS5cbiAqL1xuZnVuY3Rpb24gYnVmZmVyZWRQZXJjZW50KGJ1ZmZlcmVkLCBkdXJhdGlvbikge1xuICB2YXIgYnVmZmVyZWREdXJhdGlvbiA9IDA7XG4gIHZhciBzdGFydCA9IHZvaWQgMDtcbiAgdmFyIGVuZCA9IHZvaWQgMDtcblxuICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoIWJ1ZmZlcmVkIHx8ICFidWZmZXJlZC5sZW5ndGgpIHtcbiAgICBidWZmZXJlZCA9IGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgc3RhcnQgPSBidWZmZXJlZC5zdGFydChpKTtcbiAgICBlbmQgPSBidWZmZXJlZC5lbmQoaSk7XG5cbiAgICAvLyBidWZmZXJlZCBlbmQgY2FuIGJlIGJpZ2dlciB0aGFuIGR1cmF0aW9uIGJ5IGEgdmVyeSBzbWFsbCBmcmFjdGlvblxuICAgIGlmIChlbmQgPiBkdXJhdGlvbikge1xuICAgICAgZW5kID0gZHVyYXRpb247XG4gICAgfVxuXG4gICAgYnVmZmVyZWREdXJhdGlvbiArPSBlbmQgLSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiBidWZmZXJlZER1cmF0aW9uIC8gZHVyYXRpb247XG59XG5cbi8qKlxuICogQGZpbGUgZnVsbHNjcmVlbi1hcGkuanNcbiAqIEBtb2R1bGUgZnVsbHNjcmVlbi1hcGlcbiAqIEBwcml2YXRlXG4gKi9cbi8qKlxuICogU3RvcmUgdGhlIGJyb3dzZXItc3BlY2lmaWMgbWV0aG9kcyBmb3IgdGhlIGZ1bGxzY3JlZW4gQVBJLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc2VlIFtTcGVjaWZpY2F0aW9uXXtAbGluayBodHRwczovL2Z1bGxzY3JlZW4uc3BlYy53aGF0d2cub3JnfVxuICogQHNlZSBbTWFwIEFwcHJvYWNoIEZyb20gU2NyZWVuZnVsbC5qc117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9zY3JlZW5mdWxsLmpzfVxuICovXG52YXIgRnVsbHNjcmVlbkFwaSA9IHt9O1xuXG4vLyBicm93c2VyIEFQSSBtZXRob2RzXG52YXIgYXBpTWFwID0gW1sncmVxdWVzdEZ1bGxzY3JlZW4nLCAnZXhpdEZ1bGxzY3JlZW4nLCAnZnVsbHNjcmVlbkVsZW1lbnQnLCAnZnVsbHNjcmVlbkVuYWJsZWQnLCAnZnVsbHNjcmVlbmNoYW5nZScsICdmdWxsc2NyZWVuZXJyb3InXSxcbi8vIFdlYktpdFxuWyd3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbicsICd3ZWJraXRFeGl0RnVsbHNjcmVlbicsICd3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCcsICd3ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCcsICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgJ3dlYmtpdGZ1bGxzY3JlZW5lcnJvciddLFxuLy8gT2xkIFdlYktpdCAoU2FmYXJpIDUuMSlcblsnd2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4nLCAnd2Via2l0Q2FuY2VsRnVsbFNjcmVlbicsICd3ZWJraXRDdXJyZW50RnVsbFNjcmVlbkVsZW1lbnQnLCAnd2Via2l0Q2FuY2VsRnVsbFNjcmVlbicsICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgJ3dlYmtpdGZ1bGxzY3JlZW5lcnJvciddLFxuLy8gTW96aWxsYVxuWydtb3pSZXF1ZXN0RnVsbFNjcmVlbicsICdtb3pDYW5jZWxGdWxsU2NyZWVuJywgJ21vekZ1bGxTY3JlZW5FbGVtZW50JywgJ21vekZ1bGxTY3JlZW5FbmFibGVkJywgJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLCAnbW96ZnVsbHNjcmVlbmVycm9yJ10sXG4vLyBNaWNyb3NvZnRcblsnbXNSZXF1ZXN0RnVsbHNjcmVlbicsICdtc0V4aXRGdWxsc2NyZWVuJywgJ21zRnVsbHNjcmVlbkVsZW1lbnQnLCAnbXNGdWxsc2NyZWVuRW5hYmxlZCcsICdNU0Z1bGxzY3JlZW5DaGFuZ2UnLCAnTVNGdWxsc2NyZWVuRXJyb3InXV07XG5cbnZhciBzcGVjQXBpID0gYXBpTWFwWzBdO1xudmFyIGJyb3dzZXJBcGkgPSB2b2lkIDA7XG5cbi8vIGRldGVybWluZSB0aGUgc3VwcG9ydGVkIHNldCBvZiBmdW5jdGlvbnNcbmZvciAodmFyIGkgPSAwOyBpIDwgYXBpTWFwLmxlbmd0aDsgaSsrKSB7XG4gIC8vIGNoZWNrIGZvciBleGl0RnVsbHNjcmVlbiBmdW5jdGlvblxuICBpZiAoYXBpTWFwW2ldWzFdIGluIGRvY3VtZW50KSB7XG4gICAgYnJvd3NlckFwaSA9IGFwaU1hcFtpXTtcbiAgICBicmVhaztcbiAgfVxufVxuXG4vLyBtYXAgdGhlIGJyb3dzZXIgQVBJIG5hbWVzIHRvIHRoZSBzcGVjIEFQSSBuYW1lc1xuaWYgKGJyb3dzZXJBcGkpIHtcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJyb3dzZXJBcGkubGVuZ3RoOyBfaSsrKSB7XG4gICAgRnVsbHNjcmVlbkFwaVtzcGVjQXBpW19pXV0gPSBicm93c2VyQXBpW19pXTtcbiAgfVxufVxuXG4vKipcbiAqIEBmaWxlIG1lZGlhLWVycm9yLmpzXG4gKi9cbi8qKlxuICogQSBDdXN0b20gYE1lZGlhRXJyb3JgIGNsYXNzIHdoaWNoIG1pbWljcyB0aGUgc3RhbmRhcmQgSFRNTDUgYE1lZGlhRXJyb3JgIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xPYmplY3R8TWVkaWFFcnJvcn0gdmFsdWVcbiAqICAgICAgICBUaGlzIGNhbiBiZSBvZiBtdWx0aXBsZSB0eXBlczpcbiAqICAgICAgICAtIG51bWJlcjogc2hvdWxkIGJlIGEgc3RhbmRhcmQgZXJyb3IgY29kZVxuICogICAgICAgIC0gc3RyaW5nOiBhbiBlcnJvciBtZXNzYWdlICh0aGUgY29kZSB3aWxsIGJlIDApXG4gKiAgICAgICAgLSBPYmplY3Q6IGFyYml0cmFyeSBwcm9wZXJ0aWVzXG4gKiAgICAgICAgLSBgTWVkaWFFcnJvcmAgKG5hdGl2ZSk6IHVzZWQgdG8gcG9wdWxhdGUgYSB2aWRlby5qcyBgTWVkaWFFcnJvcmAgb2JqZWN0XG4gKiAgICAgICAgLSBgTWVkaWFFcnJvcmAgKHZpZGVvLmpzKTogd2lsbCByZXR1cm4gaXRzZWxmIGlmIGl0J3MgYWxyZWFkeSBhXG4gKiAgICAgICAgICB2aWRlby5qcyBgTWVkaWFFcnJvcmAgb2JqZWN0LlxuICpcbiAqIEBzZWUgW01lZGlhRXJyb3IgU3BlY117QGxpbmsgaHR0cHM6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMtYXV0aG9yLXZpZXcvdmlkZW8uaHRtbCNtZWRpYWVycm9yfVxuICogQHNlZSBbRW5jcnlwdGVkIE1lZGlhRXJyb3IgU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtZW5jcnlwdGVkLW1lZGlhLTIwMTMwNTEwLyNlcnJvci1jb2Rlc31cbiAqXG4gKiBAY2xhc3MgTWVkaWFFcnJvclxuICovXG5mdW5jdGlvbiBNZWRpYUVycm9yKHZhbHVlKSB7XG5cbiAgLy8gQWxsb3cgcmVkdW5kYW50IGNhbGxzIHRvIHRoaXMgY29uc3RydWN0b3IgdG8gYXZvaWQgaGF2aW5nIGBpbnN0YW5jZW9mYFxuICAvLyBjaGVja3MgcGVwcGVyZWQgYXJvdW5kIHRoZSBjb2RlLlxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNZWRpYUVycm9yKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLmNvZGUgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZGVmYXVsdCBjb2RlIGlzIHplcm8sIHNvIHRoaXMgaXMgYSBjdXN0b20gZXJyb3JcbiAgICB0aGlzLm1lc3NhZ2UgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcblxuICAgIC8vIFdlIGFzc2lnbiB0aGUgYGNvZGVgIHByb3BlcnR5IG1hbnVhbGx5IGJlY2F1c2UgbmF0aXZlIGBNZWRpYUVycm9yYCBvYmplY3RzXG4gICAgLy8gZG8gbm90IGV4cG9zZSBpdCBhcyBhbiBvd24vZW51bWVyYWJsZSBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0LlxuICAgIGlmICh0eXBlb2YgdmFsdWUuY29kZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuY29kZSA9IHZhbHVlLmNvZGU7XG4gICAgfVxuXG4gICAgYXNzaWduKHRoaXMsIHZhbHVlKTtcbiAgfVxuXG4gIGlmICghdGhpcy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gTWVkaWFFcnJvci5kZWZhdWx0TWVzc2FnZXNbdGhpcy5jb2RlXSB8fCAnJztcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBlcnJvciBjb2RlIHRoYXQgcmVmZXJzIHR3byBvbmUgb2YgdGhlIGRlZmluZWQgYE1lZGlhRXJyb3JgIHR5cGVzXG4gKlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuTWVkaWFFcnJvci5wcm90b3R5cGUuY29kZSA9IDA7XG5cbi8qKlxuICogQW4gb3B0aW9uYWwgbWVzc2FnZSB0aGF0IHRvIHNob3cgd2l0aCB0aGUgZXJyb3IuIE1lc3NhZ2UgaXMgbm90IHBhcnQgb2YgdGhlIEhUTUw1XG4gKiB2aWRlbyBzcGVjIGJ1dCBhbGxvd3MgZm9yIG1vcmUgaW5mb3JtYXRpdmUgY3VzdG9tIGVycm9ycy5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5NZWRpYUVycm9yLnByb3RvdHlwZS5tZXNzYWdlID0gJyc7XG5cbi8qKlxuICogQW4gb3B0aW9uYWwgc3RhdHVzIGNvZGUgdGhhdCBjYW4gYmUgc2V0IGJ5IHBsdWdpbnMgdG8gYWxsb3cgZXZlbiBtb3JlIGRldGFpbCBhYm91dFxuICogdGhlIGVycm9yLiBGb3IgZXhhbXBsZSBhIHBsdWdpbiBtaWdodCBwcm92aWRlIGEgc3BlY2lmaWMgSFRUUCBzdGF0dXMgY29kZSBhbmQgYW5cbiAqIGVycm9yIG1lc3NhZ2UgZm9yIHRoYXQgY29kZS4gVGhlbiB3aGVuIHRoZSBwbHVnaW4gZ2V0cyB0aGF0IGVycm9yIHRoaXMgY2xhc3Mgd2lsbFxuICoga25vdyBob3cgdG8gZGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIGZvciBpdC4gVGhpcyBhbGxvd3MgYSBjdXN0b20gbWVzc2FnZSB0byBzaG93XG4gKiB1cCBvbiB0aGUgYFBsYXllcmAgZXJyb3Igb3ZlcmxheS5cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbk1lZGlhRXJyb3IucHJvdG90eXBlLnN0YXR1cyA9IG51bGw7XG5cbi8qKlxuICogRXJyb3JzIGluZGV4ZWQgYnkgdGhlIFczQyBzdGFuZGFyZC4gVGhlIG9yZGVyICoqQ0FOTk9UIENIQU5HRSoqISBTZWUgdGhlXG4gKiBzcGVjaWZpY2F0aW9uIGxpc3RlZCB1bmRlciB7QGxpbmsgTWVkaWFFcnJvcn0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGVudW0ge2FycmF5fVxuICogQHJlYWRvbmx5XG4gKiBAcHJvcGVydHkge3N0cmluZ30gMCAtIE1FRElBX0VSUl9DVVNUT01cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAxIC0gTUVESUFfRVJSX0NVU1RPTVxuICogQHByb3BlcnR5IHtzdHJpbmd9IDIgLSBNRURJQV9FUlJfQUJPUlRFRFxuICogQHByb3BlcnR5IHtzdHJpbmd9IDMgLSBNRURJQV9FUlJfTkVUV09SS1xuICogQHByb3BlcnR5IHtzdHJpbmd9IDQgLSBNRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURURcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSA1IC0gTUVESUFfRVJSX0VOQ1JZUFRFRFxuICovXG5NZWRpYUVycm9yLmVycm9yVHlwZXMgPSBbJ01FRElBX0VSUl9DVVNUT00nLCAnTUVESUFfRVJSX0FCT1JURUQnLCAnTUVESUFfRVJSX05FVFdPUksnLCAnTUVESUFfRVJSX0RFQ09ERScsICdNRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURUQnLCAnTUVESUFfRVJSX0VOQ1JZUFRFRCddO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGBNZWRpYUVycm9yYCBtZXNzYWdlcyBiYXNlZCBvbiB0aGUge0BsaW5rIE1lZGlhRXJyb3IuZXJyb3JUeXBlc30uXG4gKlxuICogQHR5cGUge0FycmF5fVxuICogQGNvbnN0YW50XG4gKi9cbk1lZGlhRXJyb3IuZGVmYXVsdE1lc3NhZ2VzID0ge1xuICAxOiAnWW91IGFib3J0ZWQgdGhlIG1lZGlhIHBsYXliYWNrJyxcbiAgMjogJ0EgbmV0d29yayBlcnJvciBjYXVzZWQgdGhlIG1lZGlhIGRvd25sb2FkIHRvIGZhaWwgcGFydC13YXkuJyxcbiAgMzogJ1RoZSBtZWRpYSBwbGF5YmFjayB3YXMgYWJvcnRlZCBkdWUgdG8gYSBjb3JydXB0aW9uIHByb2JsZW0gb3IgYmVjYXVzZSB0aGUgbWVkaWEgdXNlZCBmZWF0dXJlcyB5b3VyIGJyb3dzZXIgZGlkIG5vdCBzdXBwb3J0LicsXG4gIDQ6ICdUaGUgbWVkaWEgY291bGQgbm90IGJlIGxvYWRlZCwgZWl0aGVyIGJlY2F1c2UgdGhlIHNlcnZlciBvciBuZXR3b3JrIGZhaWxlZCBvciBiZWNhdXNlIHRoZSBmb3JtYXQgaXMgbm90IHN1cHBvcnRlZC4nLFxuICA1OiAnVGhlIG1lZGlhIGlzIGVuY3J5cHRlZCBhbmQgd2UgZG8gbm90IGhhdmUgdGhlIGtleXMgdG8gZGVjcnlwdCBpdC4nXG59O1xuXG4vLyBBZGQgdHlwZXMgYXMgcHJvcGVydGllcyBvbiBNZWRpYUVycm9yXG4vLyBlLmcuIE1lZGlhRXJyb3IuTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEID0gNDtcbmZvciAodmFyIGVyck51bSA9IDA7IGVyck51bSA8IE1lZGlhRXJyb3IuZXJyb3JUeXBlcy5sZW5ndGg7IGVyck51bSsrKSB7XG4gIE1lZGlhRXJyb3JbTWVkaWFFcnJvci5lcnJvclR5cGVzW2Vyck51bV1dID0gZXJyTnVtO1xuICAvLyB2YWx1ZXMgc2hvdWxkIGJlIGFjY2Vzc2libGUgb24gYm90aCB0aGUgY2xhc3MgYW5kIGluc3RhbmNlXG4gIE1lZGlhRXJyb3IucHJvdG90eXBlW01lZGlhRXJyb3IuZXJyb3JUeXBlc1tlcnJOdW1dXSA9IGVyck51bTtcbn1cblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWxpc3QtY29udmVydGVyLmpzIFV0aWxpdGllcyBmb3IgY2FwdHVyaW5nIHRleHQgdHJhY2sgc3RhdGUgYW5kXG4gKiByZS1jcmVhdGluZyB0cmFja3MgYmFzZWQgb24gYSBjYXB0dXJlLlxuICpcbiAqIEBtb2R1bGUgdGV4dC10cmFjay1saXN0LWNvbnZlcnRlclxuICovXG5cbi8qKlxuICogRXhhbWluZSBhIHNpbmdsZSB7QGxpbmsgVGV4dFRyYWNrfSBhbmQgcmV0dXJuIGEgSlNPTi1jb21wYXRpYmxlIGphdmFzY3JpcHQgb2JqZWN0IHRoYXRcbiAqIHJlcHJlc2VudHMgdGhlIHtAbGluayBUZXh0VHJhY2t9J3Mgc3RhdGUuXG4gKlxuICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gKiAgICAgICAgVGhlIHRleHQgdHJhY2sgdG8gcXVlcnkuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBBIHNlcmlhbGl6YWJsZSBqYXZhc2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBUZXh0VHJhY2suXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdHJhY2tUb0pzb25fID0gZnVuY3Rpb24gdHJhY2tUb0pzb25fKHRyYWNrKSB7XG4gIHZhciByZXQgPSBbJ2tpbmQnLCAnbGFiZWwnLCAnbGFuZ3VhZ2UnLCAnaWQnLCAnaW5CYW5kTWV0YWRhdGFUcmFja0Rpc3BhdGNoVHlwZScsICdtb2RlJywgJ3NyYyddLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwcm9wLCBpKSB7XG5cbiAgICBpZiAodHJhY2tbcHJvcF0pIHtcbiAgICAgIGFjY1twcm9wXSA9IHRyYWNrW3Byb3BdO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHtcbiAgICBjdWVzOiB0cmFjay5jdWVzICYmIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh0cmFjay5jdWVzLCBmdW5jdGlvbiAoY3VlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydFRpbWU6IGN1ZS5zdGFydFRpbWUsXG4gICAgICAgIGVuZFRpbWU6IGN1ZS5lbmRUaW1lLFxuICAgICAgICB0ZXh0OiBjdWUudGV4dCxcbiAgICAgICAgaWQ6IGN1ZS5pZFxuICAgICAgfTtcbiAgICB9KVxuICB9KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBFeGFtaW5lIGEge0BsaW5rIFRlY2h9IGFuZCByZXR1cm4gYSBKU09OLWNvbXBhdGlibGUgamF2YXNjcmlwdCBhcnJheSB0aGF0IHJlcHJlc2VudHMgdGhlXG4gKiBzdGF0ZSBvZiBhbGwge0BsaW5rIFRleHRUcmFja31zIGN1cnJlbnRseSBjb25maWd1cmVkLiBUaGUgcmV0dXJuIGFycmF5IGlzIGNvbXBhdGlibGUgd2l0aFxuICoge0BsaW5rIHRleHQtdHJhY2stbGlzdC1jb252ZXJ0ZXI6anNvblRvVGV4dFRyYWNrc30uXG4gKlxuICogQHBhcmFtIHtUZWNofSB0ZWNoXG4gKiAgICAgICAgVGhlIHRlY2ggb2JqZWN0IHRvIHF1ZXJ5XG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiAgICAgICAgIEEgc2VyaWFsaXphYmxlIGphdmFzY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHtAbGluayBUZWNofXNcbiAqICAgICAgICAge0BsaW5rIFRleHRUcmFja0xpc3R9LlxuICovXG52YXIgdGV4dFRyYWNrc1RvSnNvbiA9IGZ1bmN0aW9uIHRleHRUcmFja3NUb0pzb24odGVjaCkge1xuXG4gIHZhciB0cmFja0VscyA9IHRlY2guJCQoJ3RyYWNrJyk7XG5cbiAgdmFyIHRyYWNrT2JqcyA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh0cmFja0VscywgZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC50cmFjaztcbiAgfSk7XG4gIHZhciB0cmFja3MgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwodHJhY2tFbHMsIGZ1bmN0aW9uICh0cmFja0VsKSB7XG4gICAgdmFyIGpzb24gPSB0cmFja1RvSnNvbl8odHJhY2tFbC50cmFjayk7XG5cbiAgICBpZiAodHJhY2tFbC5zcmMpIHtcbiAgICAgIGpzb24uc3JjID0gdHJhY2tFbC5zcmM7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xuICB9KTtcblxuICByZXR1cm4gdHJhY2tzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwodGVjaC50ZXh0VHJhY2tzKCksIGZ1bmN0aW9uICh0cmFjaykge1xuICAgIHJldHVybiB0cmFja09ianMuaW5kZXhPZih0cmFjaykgPT09IC0xO1xuICB9KS5tYXAodHJhY2tUb0pzb25fKSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHNldCBvZiByZW1vdGUge0BsaW5rIFRleHRUcmFja31zIG9uIGEge0BsaW5rIFRlY2h9IGJhc2VkIG9uIGFuIGFycmF5IG9mIGphdmFzY3JpcHRcbiAqIG9iamVjdCB7QGxpbmsgVGV4dFRyYWNrfSByZXByZXNlbnRhdGlvbnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0ganNvblxuICogICAgICAgIEFuIGFycmF5IG9mIGBUZXh0VHJhY2tgIHJlcHJlc2VudGF0aW9uIG9iamVjdHMsIGxpa2UgdGhvc2UgdGhhdCB3b3VsZCBiZVxuICogICAgICAgIHByb2R1Y2VkIGJ5IGB0ZXh0VHJhY2tzVG9Kc29uYC5cbiAqXG4gKiBAcGFyYW0ge1RlY2h9IHRlY2hcbiAqICAgICAgICBUaGUgYFRlY2hgIHRvIGNyZWF0ZSB0aGUgYFRleHRUcmFja2BzIG9uLlxuICovXG52YXIganNvblRvVGV4dFRyYWNrcyA9IGZ1bmN0aW9uIGpzb25Ub1RleHRUcmFja3MoanNvbiwgdGVjaCkge1xuICBqc29uLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgdmFyIGFkZGVkVHJhY2sgPSB0ZWNoLmFkZFJlbW90ZVRleHRUcmFjayh0cmFjaykudHJhY2s7XG5cbiAgICBpZiAoIXRyYWNrLnNyYyAmJiB0cmFjay5jdWVzKSB7XG4gICAgICB0cmFjay5jdWVzLmZvckVhY2goZnVuY3Rpb24gKGN1ZSkge1xuICAgICAgICByZXR1cm4gYWRkZWRUcmFjay5hZGRDdWUoY3VlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRlY2gudGV4dFRyYWNrcygpO1xufTtcblxudmFyIHRleHRUcmFja0NvbnZlcnRlciA9IHsgdGV4dFRyYWNrc1RvSnNvbjogdGV4dFRyYWNrc1RvSnNvbiwganNvblRvVGV4dFRyYWNrczoganNvblRvVGV4dFRyYWNrcywgdHJhY2tUb0pzb25fOiB0cmFja1RvSnNvbl8gfTtcblxuLyoqXG4gKiBAZmlsZSBtb2RhbC1kaWFsb2cuanNcbiAqL1xudmFyIE1PREFMX0NMQVNTX05BTUUgPSAndmpzLW1vZGFsLWRpYWxvZyc7XG52YXIgRVNDID0gMjc7XG5cbi8qKlxuICogVGhlIGBNb2RhbERpYWxvZ2AgZGlzcGxheXMgb3ZlciB0aGUgdmlkZW8gYW5kIGl0cyBjb250cm9scywgd2hpY2ggYmxvY2tzXG4gKiBpbnRlcmFjdGlvbiB3aXRoIHRoZSBwbGF5ZXIgdW50aWwgaXQgaXMgY2xvc2VkLlxuICpcbiAqIE1vZGFsIGRpYWxvZ3MgaW5jbHVkZSBhIFwiQ2xvc2VcIiBidXR0b24gYW5kIHdpbGwgY2xvc2Ugd2hlbiB0aGF0IGJ1dHRvblxuICogaXMgYWN0aXZhdGVkIC0gb3Igd2hlbiBFU0MgaXMgcHJlc3NlZCBhbnl3aGVyZS5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTW9kYWxEaWFsb2cgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhNb2RhbERpYWxvZywgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtNaXhlZH0gW29wdGlvbnMuY29udGVudD11bmRlZmluZWRdXG4gICAqICAgICAgICBQcm92aWRlIGN1c3RvbWl6ZWQgY29udGVudCBmb3IgdGhpcyBtb2RhbC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlc2NyaXB0aW9uXVxuICAgKiAgICAgICAgQSB0ZXh0IGRlc2NyaXB0aW9uIGZvciB0aGUgbW9kYWwsIHByaW1hcmlseSBmb3IgYWNjZXNzaWJpbGl0eS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5maWxsQWx3YXlzPWZhbHNlXVxuICAgKiAgICAgICAgTm9ybWFsbHksIG1vZGFscyBhcmUgYXV0b21hdGljYWxseSBmaWxsZWQgb25seSB0aGUgZmlyc3QgdGltZVxuICAgKiAgICAgICAgdGhleSBvcGVuLiBUaGlzIHRlbGxzIHRoZSBtb2RhbCB0byByZWZyZXNoIGl0cyBjb250ZW50XG4gICAqICAgICAgICBldmVyeSB0aW1lIGl0IG9wZW5zLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWxdXG4gICAqICAgICAgICBBIHRleHQgbGFiZWwgZm9yIHRoZSBtb2RhbCwgcHJpbWFyaWx5IGZvciBhY2Nlc3NpYmlsaXR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRlbXBvcmFyeT10cnVlXVxuICAgKiAgICAgICAgSWYgYHRydWVgLCB0aGUgbW9kYWwgY2FuIG9ubHkgYmUgb3BlbmVkIG9uY2U7IGl0IHdpbGwgYmVcbiAgICogICAgICAgIGRpc3Bvc2VkIGFzIHNvb24gYXMgaXQncyBjbG9zZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudW5jbG9zZWFibGU9ZmFsc2VdXG4gICAqICAgICAgICBJZiBgdHJ1ZWAsIHRoZSB1c2VyIHdpbGwgbm90IGJlIGFibGUgdG8gY2xvc2UgdGhlIG1vZGFsXG4gICAqICAgICAgICB0aHJvdWdoIHRoZSBVSSBpbiB0aGUgbm9ybWFsIHdheXMuIFByb2dyYW1tYXRpYyBjbG9zaW5nIGlzXG4gICAqICAgICAgICBzdGlsbCBwb3NzaWJsZS5cbiAgICovXG4gIGZ1bmN0aW9uIE1vZGFsRGlhbG9nKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZGFsRGlhbG9nKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub3BlbmVkXyA9IF90aGlzLmhhc0JlZW5PcGVuZWRfID0gX3RoaXMuaGFzQmVlbkZpbGxlZF8gPSBmYWxzZTtcblxuICAgIF90aGlzLmNsb3NlYWJsZSghX3RoaXMub3B0aW9uc18udW5jbG9zZWFibGUpO1xuICAgIF90aGlzLmNvbnRlbnQoX3RoaXMub3B0aW9uc18uY29udGVudCk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGNvbnRlbnRFbCBpcyBkZWZpbmVkIEFGVEVSIGFueSBjaGlsZHJlbiBhcmUgaW5pdGlhbGl6ZWRcbiAgICAvLyBiZWNhdXNlIHdlIG9ubHkgd2FudCB0aGUgY29udGVudHMgb2YgdGhlIG1vZGFsIGluIHRoZSBjb250ZW50RWxcbiAgICAvLyAobm90IHRoZSBVSSBlbGVtZW50cyBsaWtlIHRoZSBjbG9zZSBidXR0b24pLlxuICAgIF90aGlzLmNvbnRlbnRFbF8gPSBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiBNT0RBTF9DTEFTU19OQU1FICsgJy1jb250ZW50J1xuICAgIH0sIHtcbiAgICAgIHJvbGU6ICdkb2N1bWVudCdcbiAgICB9KTtcblxuICAgIF90aGlzLmRlc2NFbF8gPSBjcmVhdGVFbCgncCcsIHtcbiAgICAgIGNsYXNzTmFtZTogTU9EQUxfQ0xBU1NfTkFNRSArICctZGVzY3JpcHRpb24gdmpzLWNvbnRyb2wtdGV4dCcsXG4gICAgICBpZDogX3RoaXMuZWwoKS5nZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKVxuICAgIH0pO1xuXG4gICAgdGV4dENvbnRlbnQoX3RoaXMuZGVzY0VsXywgX3RoaXMuZGVzY3JpcHRpb24oKSk7XG4gICAgX3RoaXMuZWxfLmFwcGVuZENoaWxkKF90aGlzLmRlc2NFbF8pO1xuICAgIF90aGlzLmVsXy5hcHBlbmRDaGlsZChfdGhpcy5jb250ZW50RWxfKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgTW9kYWxEaWFsb2dgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgRE9NIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKCksXG4gICAgICB0YWJJbmRleDogLTFcbiAgICB9LCB7XG4gICAgICAnYXJpYS1kZXNjcmliZWRieSc6IHRoaXMuaWQoKSArICdfZGVzY3JpcHRpb24nLFxuICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnLFxuICAgICAgJ2FyaWEtbGFiZWwnOiB0aGlzLmxhYmVsKCksXG4gICAgICAncm9sZSc6ICdkaWFsb2cnXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuIE1PREFMX0NMQVNTX05BTUUgKyAnIHZqcy1oaWRkZW4gJyArIF9Db21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlcyBga2V5ZG93bmAgZXZlbnRzIG9uIHRoZSBkb2N1bWVudCwgbG9va2luZyBmb3IgRVNDLCB3aGljaCBjbG9zZXNcbiAgICogdGhlIG1vZGFsLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBlXG4gICAqICAgICAgICBUaGUga2V5cHJlc3MgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudC5cbiAgICpcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGUpIHtcbiAgICBpZiAoZS53aGljaCA9PT0gRVNDICYmIHRoaXMuY2xvc2VhYmxlKCkpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhYmVsIHN0cmluZyBmb3IgdGhpcyBtb2RhbC4gUHJpbWFyaWx5IHVzZWQgZm9yIGFjY2Vzc2liaWxpdHkuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICB0aGUgbG9jYWxpemVkIG9yIHJhdyBsYWJlbCBvZiB0aGlzIG1vZGFsLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uIGxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubGFiZWwgfHwgJ01vZGFsIFdpbmRvdycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNjcmlwdGlvbiBzdHJpbmcgZm9yIHRoaXMgbW9kYWwuIFByaW1hcmlseSB1c2VkIGZvclxuICAgKiBhY2Nlc3NpYmlsaXR5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGxvY2FsaXplZCBvciByYXcgZGVzY3JpcHRpb24gb2YgdGhpcyBtb2RhbC5cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuZGVzY3JpcHRpb24gPSBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICB2YXIgZGVzYyA9IHRoaXMub3B0aW9uc18uZGVzY3JpcHRpb24gfHwgdGhpcy5sb2NhbGl6ZSgnVGhpcyBpcyBhIG1vZGFsIHdpbmRvdy4nKTtcblxuICAgIC8vIEFwcGVuZCBhIHVuaXZlcnNhbCBjbG9zZWFiaWxpdHkgbWVzc2FnZSBpZiB0aGUgbW9kYWwgaXMgY2xvc2VhYmxlLlxuICAgIGlmICh0aGlzLmNsb3NlYWJsZSgpKSB7XG4gICAgICBkZXNjICs9ICcgJyArIHRoaXMubG9jYWxpemUoJ1RoaXMgbW9kYWwgY2FuIGJlIGNsb3NlZCBieSBwcmVzc2luZyB0aGUgRXNjYXBlIGtleSBvciBhY3RpdmF0aW5nIHRoZSBjbG9zZSBidXR0b24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2M7XG4gIH07XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBtb2RhbC5cbiAgICpcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsb3BlblxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjbW9kYWxvcGVuXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiBvcGVuKCkge1xuICAgIGlmICghdGhpcy5vcGVuZWRfKSB7XG4gICAgICB2YXIgcGxheWVyID0gdGhpcy5wbGF5ZXIoKTtcblxuICAgICAgLyoqXG4gICAgICAgICogRmlyZWQganVzdCBiZWZvcmUgYSBgTW9kYWxEaWFsb2dgIGlzIG9wZW5lZC5cbiAgICAgICAgKlxuICAgICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbG9wZW5cbiAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZW1vZGFsb3BlbicpO1xuICAgICAgdGhpcy5vcGVuZWRfID0gdHJ1ZTtcblxuICAgICAgLy8gRmlsbCBjb250ZW50IGlmIHRoZSBtb2RhbCBoYXMgbmV2ZXIgb3BlbmVkIGJlZm9yZSBhbmRcbiAgICAgIC8vIG5ldmVyIGJlZW4gZmlsbGVkLlxuICAgICAgaWYgKHRoaXMub3B0aW9uc18uZmlsbEFsd2F5cyB8fCAhdGhpcy5oYXNCZWVuT3BlbmVkXyAmJiAhdGhpcy5oYXNCZWVuRmlsbGVkXykge1xuICAgICAgICB0aGlzLmZpbGwoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHBsYXllciB3YXMgcGxheWluZywgcGF1c2UgaXQgYW5kIHRha2Ugbm90ZSBvZiBpdHMgcHJldmlvdXNseVxuICAgICAgLy8gcGxheWluZyBzdGF0ZS5cbiAgICAgIHRoaXMud2FzUGxheWluZ18gPSAhcGxheWVyLnBhdXNlZCgpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zXy5wYXVzZU9uT3BlbiAmJiB0aGlzLndhc1BsYXlpbmdfKSB7XG4gICAgICAgIHBsYXllci5wYXVzZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jbG9zZWFibGUoKSkge1xuICAgICAgICB0aGlzLm9uKHRoaXMuZWxfLm93bmVyRG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XG4gICAgICB9XG5cbiAgICAgIHBsYXllci5jb250cm9scyhmYWxzZSk7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICAgIHRoaXMuY29uZGl0aW9uYWxGb2N1c18oKTtcbiAgICAgIHRoaXMuZWwoKS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG5cbiAgICAgIC8qKlxuICAgICAgICAqIEZpcmVkIGp1c3QgYWZ0ZXIgYSBgTW9kYWxEaWFsb2dgIGlzIG9wZW5lZC5cbiAgICAgICAgKlxuICAgICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNtb2RhbG9wZW5cbiAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ21vZGFsb3BlbicpO1xuICAgICAgdGhpcy5oYXNCZWVuT3BlbmVkXyA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJZiB0aGUgYE1vZGFsRGlhbG9nYCBpcyBjdXJyZW50bHkgb3BlbiBvciBjbG9zZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgICBJZiBnaXZlbiwgaXQgd2lsbCBvcGVuIChgdHJ1ZWApIG9yIGNsb3NlIChgZmFsc2VgKSB0aGUgbW9kYWwuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgdGhlIGN1cnJlbnQgb3BlbiBzdGF0ZSBvZiB0aGUgbW9kYWxkaWFsb2dcbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUub3BlbmVkID0gZnVuY3Rpb24gb3BlbmVkKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzW3ZhbHVlID8gJ29wZW4nIDogJ2Nsb3NlJ10oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3BlbmVkXztcbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBtb2RhbCwgZG9lcyBub3RoaW5nIGlmIHRoZSBgTW9kYWxEaWFsb2dgIGlzXG4gICAqIG5vdCBvcGVuLlxuICAgKlxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxjbG9zZVxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjbW9kYWxjbG9zZVxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmICghdGhpcy5vcGVuZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwbGF5ZXIgPSB0aGlzLnBsYXllcigpO1xuXG4gICAgLyoqXG4gICAgICAqIEZpcmVkIGp1c3QgYmVmb3JlIGEgYE1vZGFsRGlhbG9nYCBpcyBjbG9zZWQuXG4gICAgICAqXG4gICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbGNsb3NlXG4gICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdiZWZvcmVtb2RhbGNsb3NlJyk7XG4gICAgdGhpcy5vcGVuZWRfID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy53YXNQbGF5aW5nXyAmJiB0aGlzLm9wdGlvbnNfLnBhdXNlT25PcGVuKSB7XG4gICAgICBwbGF5ZXIucGxheSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNsb3NlYWJsZSgpKSB7XG4gICAgICB0aGlzLm9mZih0aGlzLmVsXy5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIGJpbmQodGhpcywgdGhpcy5oYW5kbGVLZXlQcmVzcykpO1xuICAgIH1cblxuICAgIHBsYXllci5jb250cm9scyh0cnVlKTtcbiAgICB0aGlzLmhpZGUoKTtcbiAgICB0aGlzLmVsKCkuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICAvKipcbiAgICAgICogRmlyZWQganVzdCBhZnRlciBhIGBNb2RhbERpYWxvZ2AgaXMgY2xvc2VkLlxuICAgICAgKlxuICAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjbW9kYWxjbG9zZVxuICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignbW9kYWxjbG9zZScpO1xuICAgIHRoaXMuY29uZGl0aW9uYWxCbHVyXygpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9uc18udGVtcG9yYXJ5KSB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHRvIHNlZSBpZiB0aGUgYE1vZGFsRGlhbG9nYCBpcyBjbG9zZWFibGUgdmlhIHRoZSBVSS5cbiAgICpcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW3ZhbHVlXVxuICAgKiAgICAgICAgIElmIGdpdmVuIGFzIGEgYm9vbGVhbiwgaXQgd2lsbCBzZXQgdGhlIGBjbG9zZWFibGVgIG9wdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBSZXR1cm5zIHRoZSBmaW5hbCB2YWx1ZSBvZiB0aGUgY2xvc2FibGUgb3B0aW9uLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jbG9zZWFibGUgPSBmdW5jdGlvbiBjbG9zZWFibGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHZhciBjbG9zZWFibGUgPSB0aGlzLmNsb3NlYWJsZV8gPSAhIXZhbHVlO1xuICAgICAgdmFyIGNsb3NlID0gdGhpcy5nZXRDaGlsZCgnY2xvc2VCdXR0b24nKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBiZWluZyBtYWRlIGNsb3NlYWJsZSBhbmQgaGFzIG5vIGNsb3NlIGJ1dHRvbiwgYWRkIG9uZS5cbiAgICAgIGlmIChjbG9zZWFibGUgJiYgIWNsb3NlKSB7XG5cbiAgICAgICAgLy8gVGhlIGNsb3NlIGJ1dHRvbiBzaG91bGQgYmUgYSBjaGlsZCBvZiB0aGUgbW9kYWwgLSBub3QgaXRzXG4gICAgICAgIC8vIGNvbnRlbnQgZWxlbWVudCwgc28gdGVtcG9yYXJpbHkgY2hhbmdlIHRoZSBjb250ZW50IGVsZW1lbnQuXG4gICAgICAgIHZhciB0ZW1wID0gdGhpcy5jb250ZW50RWxfO1xuXG4gICAgICAgIHRoaXMuY29udGVudEVsXyA9IHRoaXMuZWxfO1xuICAgICAgICBjbG9zZSA9IHRoaXMuYWRkQ2hpbGQoJ2Nsb3NlQnV0dG9uJywgeyBjb250cm9sVGV4dDogJ0Nsb3NlIE1vZGFsIERpYWxvZycgfSk7XG4gICAgICAgIHRoaXMuY29udGVudEVsXyA9IHRlbXA7XG4gICAgICAgIHRoaXMub24oY2xvc2UsICdjbG9zZScsIHRoaXMuY2xvc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIGJlaW5nIG1hZGUgdW5jbG9zZWFibGUgYW5kIGhhcyBhIGNsb3NlIGJ1dHRvbiwgcmVtb3ZlIGl0LlxuICAgICAgaWYgKCFjbG9zZWFibGUgJiYgY2xvc2UpIHtcbiAgICAgICAgdGhpcy5vZmYoY2xvc2UsICdjbG9zZScsIHRoaXMuY2xvc2UpO1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGNsb3NlKTtcbiAgICAgICAgY2xvc2UuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9zZWFibGVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaWxsIHRoZSBtb2RhbCdzIGNvbnRlbnQgZWxlbWVudCB3aXRoIHRoZSBtb2RhbCdzIFwiY29udGVudFwiIG9wdGlvbi5cbiAgICogVGhlIGNvbnRlbnQgZWxlbWVudCB3aWxsIGJlIGVtcHRpZWQgYmVmb3JlIHRoaXMgY2hhbmdlIHRha2VzIHBsYWNlLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCgpIHtcbiAgICB0aGlzLmZpbGxXaXRoKHRoaXMuY29udGVudCgpKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlsbCB0aGUgbW9kYWwncyBjb250ZW50IGVsZW1lbnQgd2l0aCBhcmJpdHJhcnkgY29udGVudC5cbiAgICogVGhlIGNvbnRlbnQgZWxlbWVudCB3aWxsIGJlIGVtcHRpZWQgYmVmb3JlIHRoaXMgY2hhbmdlIHRha2VzIHBsYWNlLlxuICAgKlxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxmaWxsXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNtb2RhbGZpbGxcbiAgICpcbiAgICogQHBhcmFtIHtNaXhlZH0gW2NvbnRlbnRdXG4gICAqICAgICAgICBUaGUgc2FtZSBydWxlcyBhcHBseSB0byB0aGlzIGFzIGFwcGx5IHRvIHRoZSBgY29udGVudGAgb3B0aW9uLlxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5maWxsV2l0aCA9IGZ1bmN0aW9uIGZpbGxXaXRoKGNvbnRlbnQpIHtcbiAgICB2YXIgY29udGVudEVsID0gdGhpcy5jb250ZW50RWwoKTtcbiAgICB2YXIgcGFyZW50RWwgPSBjb250ZW50RWwucGFyZW50Tm9kZTtcbiAgICB2YXIgbmV4dFNpYmxpbmdFbCA9IGNvbnRlbnRFbC5uZXh0U2libGluZztcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIGp1c3QgYmVmb3JlIGEgYE1vZGFsRGlhbG9nYCBpcyBmaWxsZWQgd2l0aCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsZmlsbFxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZW1vZGFsZmlsbCcpO1xuICAgIHRoaXMuaGFzQmVlbkZpbGxlZF8gPSB0cnVlO1xuXG4gICAgLy8gRGV0YWNoIHRoZSBjb250ZW50IGVsZW1lbnQgZnJvbSB0aGUgRE9NIGJlZm9yZSBwZXJmb3JtaW5nXG4gICAgLy8gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG1vZGlmeWluZyB0aGUgbGl2ZSBET00gbXVsdGlwbGUgdGltZXMuXG4gICAgcGFyZW50RWwucmVtb3ZlQ2hpbGQoY29udGVudEVsKTtcbiAgICB0aGlzLmVtcHR5KCk7XG4gICAgaW5zZXJ0Q29udGVudChjb250ZW50RWwsIGNvbnRlbnQpO1xuICAgIC8qKlxuICAgICAqIEZpcmVkIGp1c3QgYWZ0ZXIgYSBgTW9kYWxEaWFsb2dgIGlzIGZpbGxlZCB3aXRoIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjbW9kYWxmaWxsXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignbW9kYWxmaWxsJyk7XG5cbiAgICAvLyBSZS1pbmplY3QgdGhlIHJlLWZpbGxlZCBjb250ZW50IGVsZW1lbnQuXG4gICAgaWYgKG5leHRTaWJsaW5nRWwpIHtcbiAgICAgIHBhcmVudEVsLmluc2VydEJlZm9yZShjb250ZW50RWwsIG5leHRTaWJsaW5nRWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChjb250ZW50RWwpO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBjbG9zZSBidXR0b24gaXMgbGFzdCBpbiB0aGUgZGlhbG9nIERPTVxuICAgIHZhciBjbG9zZUJ1dHRvbiA9IHRoaXMuZ2V0Q2hpbGQoJ2Nsb3NlQnV0dG9uJyk7XG5cbiAgICBpZiAoY2xvc2VCdXR0b24pIHtcbiAgICAgIHBhcmVudEVsLmFwcGVuZENoaWxkKGNsb3NlQnV0dG9uLmVsXyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbXB0aWVzIHRoZSBjb250ZW50IGVsZW1lbnQuIFRoaXMgaGFwcGVucyBhbnl0aW1lIHRoZSBtb2RhbCBpcyBmaWxsZWQuXG4gICAqXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNiZWZvcmVtb2RhbGVtcHR5XG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNtb2RhbGVtcHR5XG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgLyoqXG4gICAgICogRmlyZWQganVzdCBiZWZvcmUgYSBgTW9kYWxEaWFsb2dgIGlzIGVtcHRpZWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxlbXB0eVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZW1vZGFsZW1wdHknKTtcbiAgICBlbXB0eUVsKHRoaXMuY29udGVudEVsKCkpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQganVzdCBhZnRlciBhIGBNb2RhbERpYWxvZ2AgaXMgZW1wdGllZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNtb2RhbGVtcHR5XG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignbW9kYWxlbXB0eScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIG1vZGFsIGNvbnRlbnQsIHdoaWNoIGdldHMgbm9ybWFsaXplZCBiZWZvcmUgYmVpbmdcbiAgICogcmVuZGVyZWQgaW50byB0aGUgRE9NLlxuICAgKlxuICAgKiBUaGlzIGRvZXMgbm90IHVwZGF0ZSB0aGUgRE9NIG9yIGZpbGwgdGhlIG1vZGFsLCBidXQgaXQgaXMgY2FsbGVkIGR1cmluZ1xuICAgKiB0aGF0IHByb2Nlc3MuXG4gICAqXG4gICAqIEBwYXJhbSAge01peGVkfSBbdmFsdWVdXG4gICAqICAgICAgICAgSWYgZGVmaW5lZCwgc2V0cyB0aGUgaW50ZXJuYWwgY29udGVudCB2YWx1ZSB0byBiZSB1c2VkIG9uIHRoZVxuICAgKiAgICAgICAgIG5leHQgY2FsbChzKSB0byBgZmlsbGAuIFRoaXMgdmFsdWUgaXMgbm9ybWFsaXplZCBiZWZvcmUgYmVpbmdcbiAgICogICAgICAgICBpbnNlcnRlZC4gVG8gXCJjbGVhclwiIHRoZSBpbnRlcm5hbCBjb250ZW50IHZhbHVlLCBwYXNzIGBudWxsYC5cbiAgICpcbiAgICogQHJldHVybiB7TWl4ZWR9XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgY29udGVudCBvZiB0aGUgbW9kYWwgZGlhbG9nXG4gICAqL1xuXG5cbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiBjb250ZW50KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuY29udGVudF8gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGVudF87XG4gIH07XG5cbiAgLyoqXG4gICAqIGNvbmRpdGlvbmFsbHkgZm9jdXMgdGhlIG1vZGFsIGRpYWxvZyBpZiBmb2N1cyB3YXMgcHJldmlvdXNseSBvbiB0aGUgcGxheWVyLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jb25kaXRpb25hbEZvY3VzXyA9IGZ1bmN0aW9uIGNvbmRpdGlvbmFsRm9jdXNfKCkge1xuICAgIHZhciBhY3RpdmVFbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgdmFyIHBsYXllckVsID0gdGhpcy5wbGF5ZXJfLmVsXztcblxuICAgIHRoaXMucHJldmlvdXNseUFjdGl2ZUVsXyA9IG51bGw7XG5cbiAgICBpZiAocGxheWVyRWwuY29udGFpbnMoYWN0aXZlRWwpIHx8IHBsYXllckVsID09PSBhY3RpdmVFbCkge1xuICAgICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfID0gYWN0aXZlRWw7XG5cbiAgICAgIHRoaXMuZm9jdXMoKTtcblxuICAgICAgdGhpcy5vbihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogY29uZGl0aW9uYWxseSBibHVyIHRoZSBlbGVtZW50IGFuZCByZWZvY3VzIHRoZSBsYXN0IGZvY3VzZWQgZWxlbWVudFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jb25kaXRpb25hbEJsdXJfID0gZnVuY3Rpb24gY29uZGl0aW9uYWxCbHVyXygpIHtcbiAgICBpZiAodGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfKSB7XG4gICAgICB0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8uZm9jdXMoKTtcbiAgICAgIHRoaXMucHJldmlvdXNseUFjdGl2ZUVsXyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5vZmYoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duKTtcbiAgfTtcblxuICAvKipcbiAgICogS2V5ZG93biBoYW5kbGVyLiBBdHRhY2hlZCB3aGVuIG1vZGFsIGlzIGZvY3VzZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAvLyBleGl0IGVhcmx5IGlmIGl0IGlzbid0IGEgdGFiIGtleVxuICAgIGlmIChldmVudC53aGljaCAhPT0gOSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBmb2N1c2FibGVFbHMgPSB0aGlzLmZvY3VzYWJsZUVsc18oKTtcbiAgICB2YXIgYWN0aXZlRWwgPSB0aGlzLmVsXy5xdWVyeVNlbGVjdG9yKCc6Zm9jdXMnKTtcbiAgICB2YXIgZm9jdXNJbmRleCA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9jdXNhYmxlRWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0aXZlRWwgPT09IGZvY3VzYWJsZUVsc1tpXSkge1xuICAgICAgICBmb2N1c0luZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuZWxfKSB7XG4gICAgICBmb2N1c0luZGV4ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgZm9jdXNJbmRleCA9PT0gMCkge1xuICAgICAgZm9jdXNhYmxlRWxzW2ZvY3VzYWJsZUVscy5sZW5ndGggLSAxXS5mb2N1cygpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2UgaWYgKCFldmVudC5zaGlmdEtleSAmJiBmb2N1c0luZGV4ID09PSBmb2N1c2FibGVFbHMubGVuZ3RoIC0gMSkge1xuICAgICAgZm9jdXNhYmxlRWxzWzBdLmZvY3VzKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogZ2V0IGFsbCBmb2N1c2FibGUgZWxlbWVudHNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuZm9jdXNhYmxlRWxzXyA9IGZ1bmN0aW9uIGZvY3VzYWJsZUVsc18oKSB7XG4gICAgdmFyIGFsbENoaWxkcmVuID0gdGhpcy5lbF8ucXVlcnlTZWxlY3RvckFsbCgnKicpO1xuXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChhbGxDaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gKGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxBbmNob3JFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxBcmVhRWxlbWVudCkgJiYgY2hpbGQuaGFzQXR0cmlidXRlKCdocmVmJykgfHwgKGNoaWxkIGluc3RhbmNlb2Ygd2luZG93LkhUTUxJbnB1dEVsZW1lbnQgfHwgY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTFNlbGVjdEVsZW1lbnQgfHwgY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTFRleHRBcmVhRWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MQnV0dG9uRWxlbWVudCkgJiYgIWNoaWxkLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MT2JqZWN0RWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MRW1iZWRFbGVtZW50IHx8IGNoaWxkLmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSAmJiBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgIT09IC0xIHx8IGNoaWxkLmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1vZGFsRGlhbG9nO1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgYE1vZGFsRGlhbG9nYCBkZWZhdWx0IG9wdGlvbnMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Nb2RhbERpYWxvZy5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIHBhdXNlT25PcGVuOiB0cnVlLFxuICB0ZW1wb3Jhcnk6IHRydWVcbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTW9kYWxEaWFsb2cnLCBNb2RhbERpYWxvZyk7XG5cbi8qKlxuICogQGZpbGUgdHJhY2stbGlzdC5qc1xuICovXG4vKipcbiAqIENvbW1vbiBmdW5jdGlvbmFsaXkgYmV0d2VlbiB7QGxpbmsgVGV4dFRyYWNrTGlzdH0sIHtAbGluayBBdWRpb1RyYWNrTGlzdH0sIGFuZFxuICoge0BsaW5rIFZpZGVvVHJhY2tMaXN0fVxuICpcbiAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XG4gKi9cblxudmFyIFRyYWNrTGlzdCA9IGZ1bmN0aW9uIChfRXZlbnRUYXJnZXQpIHtcbiAgaW5oZXJpdHMoVHJhY2tMaXN0LCBfRXZlbnRUYXJnZXQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge1RyYWNrW119IHRyYWNrc1xuICAgKiAgICAgICAgQSBsaXN0IG9mIHRyYWNrcyB0byBpbml0aWFsaXplIHRoZSBsaXN0IHdpdGguXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbbGlzdF1cbiAgICogICAgICAgIFRoZSBjaGlsZCBvYmplY3Qgd2l0aCBpbmhlcml0YW5jZSBkb25lIG1hbnVhbGx5IGZvciBpZTguXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZnVuY3Rpb24gVHJhY2tMaXN0KCkge1xuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuXG4gICAgdmFyIF9yZXQ7XG5cbiAgICB2YXIgbGlzdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFja0xpc3QpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXZlbnRUYXJnZXQuY2FsbCh0aGlzKSk7XG5cbiAgICBpZiAoIWxpc3QpIHtcbiAgICAgIGxpc3QgPSBfdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgaWYgKElTX0lFOCkge1xuICAgICAgICBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gVHJhY2tMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgICBsaXN0W3Byb3BdID0gVHJhY2tMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0LnRyYWNrc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUcmFja0xpc3RcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGxlbmd0aFxuICAgICAqICAgICAgICAgVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGBUcmFja2BzIGluIHRoZSB0aGlzIFRyYWNraXN0LlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnbGVuZ3RoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrc18ubGVuZ3RoO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3QuYWRkVHJhY2sodHJhY2tzW2ldKTtcbiAgICB9XG5cbiAgICAvLyBtdXN0IHJldHVybiB0aGUgb2JqZWN0LCBhcyBmb3IgaWU4IGl0IHdpbGwgbm90IGJlIHRoaXNcbiAgICAvLyBidXQgYSByZWZlcmVuY2UgdG8gYSBkb2N1bWVudCBvYmplY3RcbiAgICByZXR1cm4gX3JldCA9IGxpc3QsIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHtAbGluayBUcmFja30gdG8gdGhlIGBUcmFja0xpc3RgXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUaGUgYXVkaW8sIHZpZGVvLCBvciB0ZXh0IHRyYWNrIHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICpcbiAgICogQGZpcmVzIFRyYWNrTGlzdCNhZGR0cmFja1xuICAgKi9cblxuXG4gIFRyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaykge1xuICAgIHZhciBpbmRleCA9IHRoaXMudHJhY2tzXy5sZW5ndGg7XG5cbiAgICBpZiAoISgnJyArIGluZGV4IGluIHRoaXMpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tzX1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERvIG5vdCBhZGQgZHVwbGljYXRlIHRyYWNrc1xuICAgIGlmICh0aGlzLnRyYWNrc18uaW5kZXhPZih0cmFjaykgPT09IC0xKSB7XG4gICAgICB0aGlzLnRyYWNrc18ucHVzaCh0cmFjayk7XG4gICAgICAvKipcbiAgICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgdHJhY2sgaXMgYWRkZWQgdG8gYSB0cmFjayBsaXN0LlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBUcmFja0xpc3QjYWRkdHJhY2tcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqIEBwcm9wZXJ0eSB7VHJhY2t9IHRyYWNrXG4gICAgICAgKiAgICAgICAgICAgQSByZWZlcmVuY2UgdG8gdHJhY2sgdGhhdCB3YXMgYWRkZWQuXG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcih7XG4gICAgICAgIHRyYWNrOiB0cmFjayxcbiAgICAgICAgdHlwZTogJ2FkZHRyYWNrJ1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB7QGxpbmsgVHJhY2t9IGZyb20gdGhlIGBUcmFja0xpc3RgXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhY2t9IHJ0cmFja1xuICAgKiAgICAgICAgVGhlIGF1ZGlvLCB2aWRlbywgb3IgdGV4dCB0cmFjayB0byByZW1vdmUgZnJvbSB0aGUgbGlzdC5cbiAgICpcbiAgICogQGZpcmVzIFRyYWNrTGlzdCNyZW1vdmV0cmFja1xuICAgKi9cblxuXG4gIFRyYWNrTGlzdC5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhydHJhY2spIHtcbiAgICB2YXIgdHJhY2sgPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGhpc1tpXSA9PT0gcnRyYWNrKSB7XG4gICAgICAgIHRyYWNrID0gdGhpc1tpXTtcbiAgICAgICAgaWYgKHRyYWNrLm9mZikge1xuICAgICAgICAgIHRyYWNrLm9mZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmFja3NfLnNwbGljZShpLCAxKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYSB0cmFjayBpcyByZW1vdmVkIGZyb20gdHJhY2sgbGlzdC5cbiAgICAgKlxuICAgICAqIEBldmVudCBUcmFja0xpc3QjcmVtb3ZldHJhY2tcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICogQHByb3BlcnR5IHtUcmFja30gdHJhY2tcbiAgICAgKiAgICAgICAgICAgQSByZWZlcmVuY2UgdG8gdHJhY2sgdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoe1xuICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgdHlwZTogJ3JlbW92ZXRyYWNrJ1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBUcmFjayBmcm9tIHRoZSBUcmFja0xpc3QgYnkgYSB0cmFja3MgaWRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gdGhlIGlkIG9mIHRoZSB0cmFjayB0byBnZXRcbiAgICogQG1ldGhvZCBnZXRUcmFja0J5SWRcbiAgICogQHJldHVybiB7VHJhY2t9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVHJhY2tMaXN0LnByb3RvdHlwZS5nZXRUcmFja0J5SWQgPSBmdW5jdGlvbiBnZXRUcmFja0J5SWQoaWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRoaXNbaV07XG5cbiAgICAgIGlmICh0cmFjay5pZCA9PT0gaWQpIHtcbiAgICAgICAgcmVzdWx0ID0gdHJhY2s7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFRyYWNrTGlzdDtcbn0oRXZlbnRUYXJnZXQpO1xuXG4vKipcbiAqIFRyaWdnZXJlZCB3aGVuIGEgZGlmZmVyZW50IHRyYWNrIGlzIHNlbGVjdGVkL2VuYWJsZWQuXG4gKlxuICogQGV2ZW50IFRyYWNrTGlzdCNjaGFuZ2VcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuXG4vKipcbiAqIEV2ZW50cyB0aGF0IGNhbiBiZSBjYWxsZWQgd2l0aCBvbiArIGV2ZW50TmFtZS4gU2VlIHtAbGluayBFdmVudEhhbmRsZXJ9LlxuICpcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBUcmFja0xpc3QjYWxsb3dlZEV2ZW50c19cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5UcmFja0xpc3QucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge1xuICBjaGFuZ2U6ICdjaGFuZ2UnLFxuICBhZGR0cmFjazogJ2FkZHRyYWNrJyxcbiAgcmVtb3ZldHJhY2s6ICdyZW1vdmV0cmFjaydcbn07XG5cbi8vIGVtdWxhdGUgYXR0cmlidXRlIEV2ZW50SGFuZGxlciBzdXBwb3J0IHRvIGFsbG93IGZvciBmZWF0dXJlIGRldGVjdGlvblxuZm9yICh2YXIgZXZlbnQgaW4gVHJhY2tMaXN0LnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzXykge1xuICBUcmFja0xpc3QucHJvdG90eXBlWydvbicgKyBldmVudF0gPSBudWxsO1xufVxuXG4vKipcbiAqIEBmaWxlIGF1ZGlvLXRyYWNrLWxpc3QuanNcbiAqL1xuLyoqXG4gKiBBbnl3aGVyZSB3ZSBjYWxsIHRoaXMgZnVuY3Rpb24gd2UgZGl2ZXJnZSBmcm9tIHRoZSBzcGVjXG4gKiBhcyB3ZSBvbmx5IHN1cHBvcnQgb25lIGVuYWJsZWQgYXVkaW90cmFjayBhdCBhIHRpbWVcbiAqXG4gKiBAcGFyYW0ge0F1ZGlvVHJhY2tMaXN0fSBsaXN0XG4gKiAgICAgICAgbGlzdCB0byB3b3JrIG9uXG4gKlxuICogQHBhcmFtIHtBdWRpb1RyYWNrfSB0cmFja1xuICogICAgICAgIFRoZSB0cmFjayB0byBza2lwXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGRpc2FibGVPdGhlcnMgPSBmdW5jdGlvbiBkaXNhYmxlT3RoZXJzKGxpc3QsIHRyYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LmtleXMobGlzdFtpXSkubGVuZ3RoIHx8IHRyYWNrLmlkID09PSBsaXN0W2ldLmlkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gYW5vdGhlciBhdWRpbyB0cmFjayBpcyBlbmFibGVkLCBkaXNhYmxlIGl0XG4gICAgbGlzdFtpXS5lbmFibGVkID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgbGlzdCBvZiB7QGxpbmsgQXVkaW9UcmFja30gZm9yIGEgbWVkaWEgZmlsZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjYXVkaW90cmFja2xpc3R9XG4gKiBAZXh0ZW5kcyBUcmFja0xpc3RcbiAqL1xuXG52YXIgQXVkaW9UcmFja0xpc3QgPSBmdW5jdGlvbiAoX1RyYWNrTGlzdCkge1xuICBpbmhlcml0cyhBdWRpb1RyYWNrTGlzdCwgX1RyYWNrTGlzdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2tbXX0gW3RyYWNrcz1bXV1cbiAgICogICAgICAgIEEgbGlzdCBvZiBgQXVkaW9UcmFja2AgdG8gaW5zdGFudGlhdGUgdGhlIGxpc3Qgd2l0aC5cbiAgICovXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2tMaXN0KCkge1xuICAgIHZhciBfdGhpcywgX3JldDtcblxuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvVHJhY2tMaXN0KTtcblxuICAgIHZhciBsaXN0ID0gdm9pZCAwO1xuXG4gICAgLy8gbWFrZSBzdXJlIG9ubHkgMSB0cmFjayBpcyBlbmFibGVkXG4gICAgLy8gc29ydGVkIGZyb20gbGFzdCBpbmRleCB0byBmaXJzdCBpbmRleFxuICAgIGZvciAodmFyIGkgPSB0cmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0cmFja3NbaV0uZW5hYmxlZCkge1xuICAgICAgICBkaXNhYmxlT3RoZXJzKHRyYWNrcywgdHJhY2tzW2ldKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSUU4IGZvcmNlcyB1cyB0byBpbXBsZW1lbnQgaW5oZXJpdGFuY2Ugb3Vyc2VsdmVzXG4gICAgLy8gYXMgaXQgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QuZGVmaW5lUHJvcGVydHkgcHJvcGVybHlcbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W3Byb3BdID0gVHJhY2tMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gQXVkaW9UcmFja0xpc3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChfcHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbX3Byb3BdID0gQXVkaW9UcmFja0xpc3QucHJvdG90eXBlW19wcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpc3QgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0xpc3QuY2FsbCh0aGlzLCB0cmFja3MsIGxpc3QpKSwgX3RoaXMpO1xuICAgIGxpc3QuY2hhbmdpbmdfID0gZmFsc2U7XG5cbiAgICByZXR1cm4gX3JldCA9IGxpc3QsIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiB7QGxpbmsgQXVkaW9UcmFja30gdG8gdGhlIGBBdWRpb1RyYWNrTGlzdGAuXG4gICAqXG4gICAqIEBwYXJhbSB7QXVkaW9UcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSBBdWRpb1RyYWNrIHRvIGFkZCB0byB0aGUgbGlzdFxuICAgKlxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I2FkZHRyYWNrXG4gICAqL1xuXG5cbiAgQXVkaW9UcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2spIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmICh0cmFjay5lbmFibGVkKSB7XG4gICAgICBkaXNhYmxlT3RoZXJzKHRoaXMsIHRyYWNrKTtcbiAgICB9XG5cbiAgICBfVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrKTtcbiAgICAvLyBuYXRpdmUgdHJhY2tzIGRvbid0IGhhdmUgdGhpc1xuICAgIGlmICghdHJhY2suYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaXN0ZW5zIEF1ZGlvVHJhY2sjZW5hYmxlZGNoYW5nZVxuICAgICAqIEBmaXJlcyBUcmFja0xpc3QjY2hhbmdlXG4gICAgICovXG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5hYmxlZGNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHdoZW4gd2UgYXJlIGRpc2FibGluZyBvdGhlciB0cmFja3MgKHNpbmNlIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1vcmUgdGhhbiBvbmUgdHJhY2sgYXQgYSB0aW1lKSB3ZSB3aWxsIHNldCBjaGFuZ2luZ19cbiAgICAgIC8vIHRvIHRydWUgc28gdGhhdCB3ZSBkb24ndCB0cmlnZ2VyIGFkZGl0aW9uYWwgY2hhbmdlIGV2ZW50c1xuICAgICAgaWYgKF90aGlzMi5jaGFuZ2luZ18pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3RoaXMyLmNoYW5naW5nXyA9IHRydWU7XG4gICAgICBkaXNhYmxlT3RoZXJzKF90aGlzMiwgdHJhY2spO1xuICAgICAgX3RoaXMyLmNoYW5naW5nXyA9IGZhbHNlO1xuICAgICAgX3RoaXMyLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBBdWRpb1RyYWNrTGlzdDtcbn0oVHJhY2tMaXN0KTtcblxuLyoqXG4gKiBAZmlsZSB2aWRlby10cmFjay1saXN0LmpzXG4gKi9cbi8qKlxuICogVW4tc2VsZWN0IGFsbCBvdGhlciB7QGxpbmsgVmlkZW9UcmFja31zIHRoYXQgYXJlIHNlbGVjdGVkLlxuICpcbiAqIEBwYXJhbSB7VmlkZW9UcmFja0xpc3R9IGxpc3RcbiAqICAgICAgICBsaXN0IHRvIHdvcmsgb25cbiAqXG4gKiBAcGFyYW0ge1ZpZGVvVHJhY2t9IHRyYWNrXG4gKiAgICAgICAgVGhlIHRyYWNrIHRvIHNraXBcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZGlzYWJsZU90aGVycyQxID0gZnVuY3Rpb24gZGlzYWJsZU90aGVycyhsaXN0LCB0cmFjaykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIU9iamVjdC5rZXlzKGxpc3RbaV0pLmxlbmd0aCB8fCB0cmFjay5pZCA9PT0gbGlzdFtpXS5pZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIGFub3RoZXIgdmlkZW8gdHJhY2sgaXMgZW5hYmxlZCwgZGlzYWJsZSBpdFxuICAgIGxpc3RbaV0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgY3VycmVudCBsaXN0IG9mIHtAbGluayBWaWRlb1RyYWNrfSBmb3IgYSB2aWRlby5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdmlkZW90cmFja2xpc3R9XG4gKiBAZXh0ZW5kcyBUcmFja0xpc3RcbiAqL1xuXG52YXIgVmlkZW9UcmFja0xpc3QgPSBmdW5jdGlvbiAoX1RyYWNrTGlzdCkge1xuICBpbmhlcml0cyhWaWRlb1RyYWNrTGlzdCwgX1RyYWNrTGlzdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1ZpZGVvVHJhY2tbXX0gW3RyYWNrcz1bXV1cbiAgICogICAgICAgIEEgbGlzdCBvZiBgVmlkZW9UcmFja2AgdG8gaW5zdGFudGlhdGUgdGhlIGxpc3Qgd2l0aC5cbiAgICovXG4gIGZ1bmN0aW9uIFZpZGVvVHJhY2tMaXN0KCkge1xuICAgIHZhciBfdGhpcywgX3JldDtcblxuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZGVvVHJhY2tMaXN0KTtcblxuICAgIHZhciBsaXN0ID0gdm9pZCAwO1xuXG4gICAgLy8gbWFrZSBzdXJlIG9ubHkgMSB0cmFjayBpcyBlbmFibGVkXG4gICAgLy8gc29ydGVkIGZyb20gbGFzdCBpbmRleCB0byBmaXJzdCBpbmRleFxuICAgIGZvciAodmFyIGkgPSB0cmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0cmFja3NbaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgZGlzYWJsZU90aGVycyQxKHRyYWNrcywgdHJhY2tzW2ldKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSUU4IGZvcmNlcyB1cyB0byBpbXBsZW1lbnQgaW5oZXJpdGFuY2Ugb3Vyc2VsdmVzXG4gICAgLy8gYXMgaXQgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QuZGVmaW5lUHJvcGVydHkgcHJvcGVybHlcbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W3Byb3BdID0gVHJhY2tMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gVmlkZW9UcmFja0xpc3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChfcHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbX3Byb3BdID0gVmlkZW9UcmFja0xpc3QucHJvdG90eXBlW19wcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpc3QgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0xpc3QuY2FsbCh0aGlzLCB0cmFja3MsIGxpc3QpKSwgX3RoaXMpO1xuICAgIGxpc3QuY2hhbmdpbmdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IFZpZGVvVHJhY2tMaXN0I3NlbGVjdGVkSW5kZXhcbiAgICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBzZWxlY3RlZCB7QGxpbmsgVmlkZW9UcmFja2B9LlxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnc2VsZWN0ZWRJbmRleCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBpZiAodGhpc1tfaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKCkge31cbiAgICB9KTtcblxuICAgIHJldHVybiBfcmV0ID0gbGlzdCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEge0BsaW5rIFZpZGVvVHJhY2t9IHRvIHRoZSBgVmlkZW9UcmFja0xpc3RgLlxuICAgKlxuICAgKiBAcGFyYW0ge1ZpZGVvVHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUaGUgVmlkZW9UcmFjayB0byBhZGQgdG8gdGhlIGxpc3RcbiAgICpcbiAgICogQGZpcmVzIFRyYWNrTGlzdCNhZGR0cmFja1xuICAgKi9cblxuXG4gIFZpZGVvVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAodHJhY2suc2VsZWN0ZWQpIHtcbiAgICAgIGRpc2FibGVPdGhlcnMkMSh0aGlzLCB0cmFjayk7XG4gICAgfVxuXG4gICAgX1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjayk7XG4gICAgLy8gbmF0aXZlIHRyYWNrcyBkb24ndCBoYXZlIHRoaXNcbiAgICBpZiAoIXRyYWNrLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGlzdGVucyBWaWRlb1RyYWNrI3NlbGVjdGVkY2hhbmdlXG4gICAgICogQGZpcmVzIFRyYWNrTGlzdCNjaGFuZ2VcbiAgICAgKi9cbiAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RlZGNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpczIuY2hhbmdpbmdfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF90aGlzMi5jaGFuZ2luZ18gPSB0cnVlO1xuICAgICAgZGlzYWJsZU90aGVycyQxKF90aGlzMiwgdHJhY2spO1xuICAgICAgX3RoaXMyLmNoYW5naW5nXyA9IGZhbHNlO1xuICAgICAgX3RoaXMyLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBWaWRlb1RyYWNrTGlzdDtcbn0oVHJhY2tMaXN0KTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWxpc3QuanNcbiAqL1xuLyoqXG4gKiBUaGUgY3VycmVudCBsaXN0IG9mIHtAbGluayBUZXh0VHJhY2t9IGZvciBhIG1lZGlhIGZpbGUuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3RleHR0cmFja2xpc3R9XG4gKiBAZXh0ZW5kcyBUcmFja0xpc3RcbiAqL1xuXG52YXIgVGV4dFRyYWNrTGlzdCA9IGZ1bmN0aW9uIChfVHJhY2tMaXN0KSB7XG4gIGluaGVyaXRzKFRleHRUcmFja0xpc3QsIF9UcmFja0xpc3QpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2tbXX0gW3RyYWNrcz1bXV1cbiAgICogICAgICAgIEEgbGlzdCBvZiBgVGV4dFRyYWNrYCB0byBpbnN0YW50aWF0ZSB0aGUgbGlzdCB3aXRoLlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrTGlzdCgpIHtcbiAgICB2YXIgX3RoaXMsIF9yZXQ7XG5cbiAgICB2YXIgdHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tMaXN0KTtcblxuICAgIHZhciBsaXN0ID0gdm9pZCAwO1xuXG4gICAgLy8gSUU4IGZvcmNlcyB1cyB0byBpbXBsZW1lbnQgaW5oZXJpdGFuY2Ugb3Vyc2VsdmVzXG4gICAgLy8gYXMgaXQgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QuZGVmaW5lUHJvcGVydHkgcHJvcGVybHlcbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W3Byb3BdID0gVHJhY2tMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gVGV4dFRyYWNrTGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKF9wcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgbGlzdFtfcHJvcF0gPSBUZXh0VHJhY2tMaXN0LnByb3RvdHlwZVtfcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaXN0ID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhY2tMaXN0LmNhbGwodGhpcywgdHJhY2tzLCBsaXN0KSksIF90aGlzKTtcbiAgICByZXR1cm4gX3JldCA9IGxpc3QsIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHtAbGluayBUZXh0VHJhY2t9IHRvIHRoZSBgVGV4dFRyYWNrTGlzdGBcbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUaGUgdGV4dCB0cmFjayB0byBhZGQgdG8gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBmaXJlcyBUcmFja0xpc3QjYWRkdHJhY2tcbiAgICovXG5cblxuICBUZXh0VHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgX1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjayk7XG5cbiAgICAvKipcbiAgICAgKiBAbGlzdGVucyBUZXh0VHJhY2sjbW9kZWNoYW5nZVxuICAgICAqIEBmaXJlcyBUcmFja0xpc3QjY2hhbmdlXG4gICAgICovXG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIGJpbmQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICB9KSk7XG5cbiAgICB2YXIgbm9uTGFuZ3VhZ2VUZXh0VHJhY2tLaW5kID0gWydtZXRhZGF0YScsICdjaGFwdGVycyddO1xuXG4gICAgaWYgKG5vbkxhbmd1YWdlVGV4dFRyYWNrS2luZC5pbmRleE9mKHRyYWNrLmtpbmQpID09PSAtMSkge1xuICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIGJpbmQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3NlbGVjdGVkbGFuZ3VhZ2VjaGFuZ2UnKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFja0xpc3Q7XG59KFRyYWNrTGlzdCk7XG5cbi8qKlxuICogQGZpbGUgaHRtbC10cmFjay1lbGVtZW50LWxpc3QuanNcbiAqL1xuXG4vKipcbiAqIFRoZSBjdXJyZW50IGxpc3Qgb2Yge0BsaW5rIEh0bWxUcmFja0VsZW1lbnR9cy5cbiAqL1xuXG52YXIgSHRtbFRyYWNrRWxlbWVudExpc3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0h0bWxUcmFja0VsZW1lbnRbXX0gW3RyYWNrcz1bXV1cbiAgICogICAgICAgIEEgbGlzdCBvZiBgSHRtbFRyYWNrRWxlbWVudGAgdG8gaW5zdGFudGlhdGUgdGhlIGxpc3Qgd2l0aC5cbiAgICovXG4gIGZ1bmN0aW9uIEh0bWxUcmFja0VsZW1lbnRMaXN0KCkge1xuICAgIHZhciB0cmFja0VsZW1lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBIdG1sVHJhY2tFbGVtZW50TGlzdCk7XG5cbiAgICB2YXIgbGlzdCA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBIdG1sVHJhY2tFbGVtZW50TGlzdC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBsaXN0W3Byb3BdID0gSHRtbFRyYWNrRWxlbWVudExpc3QucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGlzdC50cmFja0VsZW1lbnRzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIEh0bWxUcmFja0VsZW1lbnRMaXN0XG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBsZW5ndGhcbiAgICAgKiAgICAgICAgIFRoZSBjdXJyZW50IG51bWJlciBvZiBgVHJhY2tgcyBpbiB0aGUgdGhpcyBUcmFja2lzdC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGlzdCwgJ2xlbmd0aCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFja0VsZW1lbnRzXy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdHJhY2tFbGVtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgbGlzdC5hZGRUcmFja0VsZW1lbnRfKHRyYWNrRWxlbWVudHNbaV0pO1xuICAgIH1cblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4ge0BsaW5rIEh0bWxUcmFja0VsZW1lbnR9IHRvIHRoZSBgSHRtbFRyYWNrRWxlbWVudExpc3RgXG4gICAqXG4gICAqIEBwYXJhbSB7SHRtbFRyYWNrRWxlbWVudH0gdHJhY2tFbGVtZW50XG4gICAqICAgICAgICBUaGUgdHJhY2sgZWxlbWVudCB0byBhZGQgdG8gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgSHRtbFRyYWNrRWxlbWVudExpc3QucHJvdG90eXBlLmFkZFRyYWNrRWxlbWVudF8gPSBmdW5jdGlvbiBhZGRUcmFja0VsZW1lbnRfKHRyYWNrRWxlbWVudCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudHJhY2tFbGVtZW50c18ubGVuZ3RoO1xuXG4gICAgaWYgKCEoJycgKyBpbmRleCBpbiB0aGlzKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYWNrRWxlbWVudHNfW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IGFkZCBkdXBsaWNhdGUgZWxlbWVudHNcbiAgICBpZiAodGhpcy50cmFja0VsZW1lbnRzXy5pbmRleE9mKHRyYWNrRWxlbWVudCkgPT09IC0xKSB7XG4gICAgICB0aGlzLnRyYWNrRWxlbWVudHNfLnB1c2godHJhY2tFbGVtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudH0gZnJvbSB0aGUgYEh0bWxUcmFja0VsZW1lbnRMaXN0YCBnaXZlbiBhblxuICAgKiB7QGxpbmsgVGV4dFRyYWNrfS5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBUaGUgdHJhY2sgYXNzb2NpYXRlZCB3aXRoIGEgdHJhY2sgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7SHRtbFRyYWNrRWxlbWVudHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgVGhlIHRyYWNrIGVsZW1lbnQgdGhhdCB3YXMgZm91bmQgb3IgdW5kZWZpbmVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIEh0bWxUcmFja0VsZW1lbnRMaXN0LnByb3RvdHlwZS5nZXRUcmFja0VsZW1lbnRCeVRyYWNrXyA9IGZ1bmN0aW9uIGdldFRyYWNrRWxlbWVudEJ5VHJhY2tfKHRyYWNrKSB7XG4gICAgdmFyIHRyYWNrRWxlbWVudF8gPSB2b2lkIDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy50cmFja0VsZW1lbnRzXy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyYWNrID09PSB0aGlzLnRyYWNrRWxlbWVudHNfW2ldLnRyYWNrKSB7XG4gICAgICAgIHRyYWNrRWxlbWVudF8gPSB0aGlzLnRyYWNrRWxlbWVudHNfW2ldO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cmFja0VsZW1lbnRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudH0gZnJvbSB0aGUgYEh0bWxUcmFja0VsZW1lbnRMaXN0YFxuICAgKlxuICAgKiBAcGFyYW0ge0h0bWxUcmFja0VsZW1lbnR9IHRyYWNrRWxlbWVudFxuICAgKiAgICAgICAgVGhlIHRyYWNrIGVsZW1lbnQgdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgSHRtbFRyYWNrRWxlbWVudExpc3QucHJvdG90eXBlLnJlbW92ZVRyYWNrRWxlbWVudF8gPSBmdW5jdGlvbiByZW1vdmVUcmFja0VsZW1lbnRfKHRyYWNrRWxlbWVudCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnRyYWNrRWxlbWVudHNfLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJhY2tFbGVtZW50ID09PSB0aGlzLnRyYWNrRWxlbWVudHNfW2ldKSB7XG4gICAgICAgIHRoaXMudHJhY2tFbGVtZW50c18uc3BsaWNlKGksIDEpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gSHRtbFRyYWNrRWxlbWVudExpc3Q7XG59KCk7XG5cbi8qKlxuICogQGZpbGUgdGV4dC10cmFjay1jdWUtbGlzdC5qc1xuICovXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHRUcmFja0N1ZUxpc3R+VGV4dFRyYWNrQ3VlXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkXG4gKiAgICAgICAgICAgVGhlIHVuaXF1ZSBpZCBmb3IgdGhpcyB0ZXh0IHRyYWNrIGN1ZVxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGFydFRpbWVcbiAqICAgICAgICAgICBUaGUgc3RhcnQgdGltZSBmb3IgdGhpcyB0ZXh0IHRyYWNrIGN1ZVxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbmRUaW1lXG4gKiAgICAgICAgICAgVGhlIGVuZCB0aW1lIGZvciB0aGlzIHRleHQgdHJhY2sgY3VlXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBwYXVzZU9uRXhpdFxuICogICAgICAgICAgIFBhdXNlIHdoZW4gdGhlIGVuZCB0aW1lIGlzIHJlYWNoZWQgaWYgdHJ1ZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrY3VlfVxuICovXG5cbi8qKlxuICogQSBMaXN0IG9mIFRleHRUcmFja0N1ZXMuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3RleHR0cmFja2N1ZWxpc3R9XG4gKi9cblxudmFyIFRleHRUcmFja0N1ZUxpc3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY3Vlc1xuICAgKiAgICAgICAgQSBsaXN0IG9mIGN1ZXMgdG8gYmUgaW5pdGlhbGl6ZWQgd2l0aFxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrQ3VlTGlzdChjdWVzKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrQ3VlTGlzdCk7XG5cbiAgICB2YXIgbGlzdCA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIGxpc3RbcHJvcF0gPSBUZXh0VHJhY2tDdWVMaXN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlLnNldEN1ZXNfLmNhbGwobGlzdCwgY3Vlcyk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVGV4dFRyYWNrQ3VlTGlzdFxuICAgICAqIEBtZW1iZXIge251bWJlcn0gbGVuZ3RoXG4gICAgICogICAgICAgICBUaGUgY3VycmVudCBudW1iZXIgb2YgYFRleHRUcmFja0N1ZWBzIGluIHRoZSBUZXh0VHJhY2tDdWVMaXN0LlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaXN0LCAnbGVuZ3RoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aF87XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBzZXR0ZXIgZm9yIGN1ZXMgaW4gdGhpcyBsaXN0LiBDcmVhdGVzIGdldHRlcnNcbiAgICogYW4gYW4gaW5kZXggZm9yIHRoZSBjdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjdWVzXG4gICAqICAgICAgICBBbiBhcnJheSBvZiBjdWVzIHRvIHNldFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlLnNldEN1ZXNfID0gZnVuY3Rpb24gc2V0Q3Vlc18oY3Vlcykge1xuICAgIHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbCA9IGN1ZXMubGVuZ3RoO1xuXG4gICAgdGhpcy5jdWVzXyA9IGN1ZXM7XG4gICAgdGhpcy5sZW5ndGhfID0gY3Vlcy5sZW5ndGg7XG5cbiAgICB2YXIgZGVmaW5lUHJvcCA9IGZ1bmN0aW9uIGRlZmluZVByb3AoaW5kZXgpIHtcbiAgICAgIGlmICghKCcnICsgaW5kZXggaW4gdGhpcykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICcnICsgaW5kZXgsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1ZXNfW2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAob2xkTGVuZ3RoIDwgbCkge1xuICAgICAgaSA9IG9sZExlbmd0aDtcblxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgZGVmaW5lUHJvcC5jYWxsKHRoaXMsIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgYFRleHRUcmFja0N1ZWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gdGhlIGBUZXh0VHJhY2tDdWVMaXN0YCBieSBpZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAqICAgICAgICBUaGUgaWQgb2YgdGhlIGN1ZSB0aGF0IHNob3VsZCBiZSBzZWFyY2hlZCBmb3IuXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja0N1ZUxpc3R+VGV4dFRyYWNrQ3VlfG51bGx9XG4gICAqICAgICAgICAgQSBzaW5nbGUgY3VlIG9yIG51bGwgaWYgbm9uZSB3YXMgZm91bmQuXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUuZ2V0Q3VlQnlJZCA9IGZ1bmN0aW9uIGdldEN1ZUJ5SWQoaWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjdWUgPSB0aGlzW2ldO1xuXG4gICAgICBpZiAoY3VlLmlkID09PSBpZCkge1xuICAgICAgICByZXN1bHQgPSBjdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFja0N1ZUxpc3Q7XG59KCk7XG5cbi8qKlxuICogQGZpbGUgdHJhY2sta2luZHMuanNcbiAqL1xuXG4vKipcbiAqIEFsbCBwb3NzaWJsZSBgVmlkZW9UcmFja0tpbmRgc1xuICpcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS12aWRlb3RyYWNrLWtpbmRcbiAqIEB0eXBlZGVmIFZpZGVvVHJhY2t+S2luZFxuICogQGVudW1cbiAqL1xudmFyIFZpZGVvVHJhY2tLaW5kID0ge1xuICBhbHRlcm5hdGl2ZTogJ2FsdGVybmF0aXZlJyxcbiAgY2FwdGlvbnM6ICdjYXB0aW9ucycsXG4gIG1haW46ICdtYWluJyxcbiAgc2lnbjogJ3NpZ24nLFxuICBzdWJ0aXRsZXM6ICdzdWJ0aXRsZXMnLFxuICBjb21tZW50YXJ5OiAnY29tbWVudGFyeSdcbn07XG5cbi8qKlxuICogQWxsIHBvc3NpYmxlIGBBdWRpb1RyYWNrS2luZGBzXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLWF1ZGlvdHJhY2sta2luZFxuICogQHR5cGVkZWYgQXVkaW9UcmFja35LaW5kXG4gKiBAZW51bVxuICovXG52YXIgQXVkaW9UcmFja0tpbmQgPSB7XG4gICdhbHRlcm5hdGl2ZSc6ICdhbHRlcm5hdGl2ZScsXG4gICdkZXNjcmlwdGlvbnMnOiAnZGVzY3JpcHRpb25zJyxcbiAgJ21haW4nOiAnbWFpbicsXG4gICdtYWluLWRlc2MnOiAnbWFpbi1kZXNjJyxcbiAgJ3RyYW5zbGF0aW9uJzogJ3RyYW5zbGF0aW9uJyxcbiAgJ2NvbW1lbnRhcnknOiAnY29tbWVudGFyeSdcbn07XG5cbi8qKlxuICogQWxsIHBvc3NpYmxlIGBUZXh0VHJhY2tLaW5kYHNcbiAqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tdGV4dHRyYWNrLWtpbmRcbiAqIEB0eXBlZGVmIFRleHRUcmFja35LaW5kXG4gKiBAZW51bVxuICovXG52YXIgVGV4dFRyYWNrS2luZCA9IHtcbiAgc3VidGl0bGVzOiAnc3VidGl0bGVzJyxcbiAgY2FwdGlvbnM6ICdjYXB0aW9ucycsXG4gIGRlc2NyaXB0aW9uczogJ2Rlc2NyaXB0aW9ucycsXG4gIGNoYXB0ZXJzOiAnY2hhcHRlcnMnLFxuICBtZXRhZGF0YTogJ21ldGFkYXRhJ1xufTtcblxuLyoqXG4gKiBBbGwgcG9zc2libGUgYFRleHRUcmFja01vZGVgc1xuICpcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3RleHR0cmFja21vZGVcbiAqIEB0eXBlZGVmIFRleHRUcmFja35Nb2RlXG4gKiBAZW51bVxuICovXG52YXIgVGV4dFRyYWNrTW9kZSA9IHtcbiAgZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGhpZGRlbjogJ2hpZGRlbicsXG4gIHNob3dpbmc6ICdzaG93aW5nJ1xufTtcblxuLyoqXG4gKiBAZmlsZSB0cmFjay5qc1xuICovXG4vKipcbiAqIEEgVHJhY2sgY2xhc3MgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciB7QGxpbmsgQXVkaW9UcmFja30sXG4gKiB7QGxpbmsgVmlkZW9UcmFja30sIGFuZCB7QGxpbmsgVGV4dFRyYWNrfS5cbiAqXG4gKiA+IE5vdGU6IFRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5XG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sfVxuICogQGV4dGVuZHMgRXZlbnRUYXJnZXRcbiAqIEBhYnN0cmFjdFxuICovXG5cbnZhciBUcmFjayA9IGZ1bmN0aW9uIChfRXZlbnRUYXJnZXQpIHtcbiAgaW5oZXJpdHMoVHJhY2ssIF9FdmVudFRhcmdldCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmtpbmQ9JyddXG4gICAqICAgICAgICBBIHZhbGlkIGtpbmQgZm9yIHRoZSB0cmFjayB0eXBlIHlvdSBhcmUgY3JlYXRpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZD0ndmpzX3RyYWNrXycgKyBHdWlkLm5ld0dVSUQoKV1cbiAgICogICAgICAgIEEgdW5pcXVlIGlkIGZvciB0aGlzIEF1ZGlvVHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbD0nJ11cbiAgICogICAgICAgIFRoZSBtZW51IGxhYmVsIGZvciB0aGlzIHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2U9JyddXG4gICAqICAgICAgICBBIHZhbGlkIHR3byBjaGFyYWN0ZXIgbGFuZ3VhZ2UgY29kZS5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBmdW5jdGlvbiBUcmFjaygpIHtcbiAgICB2YXIgX3JldDtcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFjayk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudFRhcmdldC5jYWxsKHRoaXMpKTtcblxuICAgIHZhciB0cmFjayA9IF90aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICB0cmFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBUcmFjay5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0cmFja1twcm9wXSA9IFRyYWNrLnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmFja1Byb3BzID0ge1xuICAgICAgaWQ6IG9wdGlvbnMuaWQgfHwgJ3Zqc190cmFja18nICsgbmV3R1VJRCgpLFxuICAgICAga2luZDogb3B0aW9ucy5raW5kIHx8ICcnLFxuICAgICAgbGFiZWw6IG9wdGlvbnMubGFiZWwgfHwgJycsXG4gICAgICBsYW5ndWFnZTogb3B0aW9ucy5sYW5ndWFnZSB8fCAnJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVHJhY2tcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGlkXG4gICAgICogICAgICAgICBUaGUgaWQgb2YgdGhpcyB0cmFjay4gQ2Fubm90IGJlIGNoYW5nZWQgYWZ0ZXIgY3JlYXRpb24uXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUcmFja1xuICAgICAqIEBtZW1iZXIge3N0cmluZ30ga2luZFxuICAgICAqICAgICAgICAgVGhlIGtpbmQgb2YgdHJhY2sgdGhhdCB0aGlzIGlzLiBDYW5ub3QgYmUgY2hhbmdlZCBhZnRlciBjcmVhdGlvbi5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIFRyYWNrXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBsYWJlbFxuICAgICAqICAgICAgICAgVGhlIGxhYmVsIG9mIHRoaXMgdHJhY2suIENhbm5vdCBiZSBjaGFuZ2VkIGFmdGVyIGNyZWF0aW9uLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVHJhY2tcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGxhbmd1YWdlXG4gICAgICogICAgICAgICBUaGUgdHdvIGxldHRlciBsYW5ndWFnZSBjb2RlIGZvciB0aGlzIHRyYWNrLiBDYW5ub3QgYmUgY2hhbmdlZCBhZnRlclxuICAgICAqICAgICAgICAgY3JlYXRpb24uXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRyYWNrLCBrZXksIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWNrUHJvcHNba2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoKSB7fVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGtleSBpbiB0cmFja1Byb3BzKSB7XG4gICAgICBfbG9vcChrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gdHJhY2ssIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgcmV0dXJuIFRyYWNrO1xufShFdmVudFRhcmdldCk7XG5cbi8qKlxuICogQGZpbGUgdXJsLmpzXG4gKiBAbW9kdWxlIHVybFxuICovXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IHVybDpVUkxPYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcHJvdG9jb2xcbiAqICAgICAgICAgICBUaGUgcHJvdG9jb2wgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhvc3RuYW1lXG4gKiAgICAgICAgICAgVGhlIGhvc3RuYW1lIG9mIHRoZSB1cmwgdGhhdCB3YXMgcGFyc2VkLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwb3J0XG4gKiAgICAgICAgICAgVGhlIHBvcnQgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBhdGhuYW1lXG4gKiAgICAgICAgICAgVGhlIHBhdGhuYW1lIG9mIHRoZSB1cmwgdGhhdCB3YXMgcGFyc2VkLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWFyY2hcbiAqICAgICAgICAgICBUaGUgc2VhcmNoIHF1ZXJ5IG9mIHRoZSB1cmwgdGhhdCB3YXMgcGFyc2VkLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBoYXNoXG4gKiAgICAgICAgICAgVGhlIGhhc2ggb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhvc3RcbiAqICAgICAgICAgICBUaGUgaG9zdCBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cbiAqL1xuXG4vKipcbiAqIFJlc29sdmUgYW5kIHBhcnNlIHRoZSBlbGVtZW50cyBvZiBhIFVSTC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHVybFxuICogICAgICAgICBUaGUgdXJsIHRvIHBhcnNlXG4gKlxuICogQHJldHVybiB7dXJsOlVSTE9iamVjdH1cbiAqICAgICAgICAgQW4gb2JqZWN0IG9mIHVybCBkZXRhaWxzXG4gKi9cbnZhciBwYXJzZVVybCA9IGZ1bmN0aW9uIHBhcnNlVXJsKHVybCkge1xuICB2YXIgcHJvcHMgPSBbJ3Byb3RvY29sJywgJ2hvc3RuYW1lJywgJ3BvcnQnLCAncGF0aG5hbWUnLCAnc2VhcmNoJywgJ2hhc2gnLCAnaG9zdCddO1xuXG4gIC8vIGFkZCB0aGUgdXJsIHRvIGFuIGFuY2hvciBhbmQgbGV0IHRoZSBicm93c2VyIHBhcnNlIHRoZSBVUkxcbiAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cbiAgYS5ocmVmID0gdXJsO1xuXG4gIC8vIElFOCAoYW5kIDk/KSBGaXhcbiAgLy8gaWU4IGRvZXNuJ3QgcGFyc2UgdGhlIFVSTCBjb3JyZWN0bHkgdW50aWwgdGhlIGFuY2hvciBpcyBhY3R1YWxseVxuICAvLyBhZGRlZCB0byB0aGUgYm9keSwgYW5kIGFuIGlubmVySFRNTCBpcyBuZWVkZWQgdG8gdHJpZ2dlciB0aGUgcGFyc2luZ1xuICB2YXIgYWRkVG9Cb2R5ID0gYS5ob3N0ID09PSAnJyAmJiBhLnByb3RvY29sICE9PSAnZmlsZTonO1xuICB2YXIgZGl2ID0gdm9pZCAwO1xuXG4gIGlmIChhZGRUb0JvZHkpIHtcbiAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gJzxhIGhyZWY9XCInICsgdXJsICsgJ1wiPjwvYT4nO1xuICAgIGEgPSBkaXYuZmlyc3RDaGlsZDtcbiAgICAvLyBwcmV2ZW50IHRoZSBkaXYgZnJvbSBhZmZlY3RpbmcgbGF5b3V0XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTpub25lOyBwb3NpdGlvbjphYnNvbHV0ZTsnKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gIH1cblxuICAvLyBDb3B5IHRoZSBzcGVjaWZpYyBVUkwgcHJvcGVydGllcyB0byBhIG5ldyBvYmplY3RcbiAgLy8gVGhpcyBpcyBhbHNvIG5lZWRlZCBmb3IgSUU4IGJlY2F1c2UgdGhlIGFuY2hvciBsb3NlcyBpdHNcbiAgLy8gcHJvcGVydGllcyB3aGVuIGl0J3MgcmVtb3ZlZCBmcm9tIHRoZSBkb21cbiAgdmFyIGRldGFpbHMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGV0YWlsc1twcm9wc1tpXV0gPSBhW3Byb3BzW2ldXTtcbiAgfVxuXG4gIC8vIElFOSBhZGRzIHRoZSBwb3J0IHRvIHRoZSBob3N0IHByb3BlcnR5IHVubGlrZSBldmVyeW9uZSBlbHNlLiBJZlxuICAvLyBhIHBvcnQgaWRlbnRpZmllciBpcyBhZGRlZCBmb3Igc3RhbmRhcmQgcG9ydHMsIHN0cmlwIGl0LlxuICBpZiAoZGV0YWlscy5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgIGRldGFpbHMuaG9zdCA9IGRldGFpbHMuaG9zdC5yZXBsYWNlKC86ODAkLywgJycpO1xuICB9XG5cbiAgaWYgKGRldGFpbHMucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgZGV0YWlscy5ob3N0ID0gZGV0YWlscy5ob3N0LnJlcGxhY2UoLzo0NDMkLywgJycpO1xuICB9XG5cbiAgaWYgKGFkZFRvQm9keSkge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgfVxuXG4gIHJldHVybiBkZXRhaWxzO1xufTtcblxuLyoqXG4gKiBHZXQgYWJzb2x1dGUgdmVyc2lvbiBvZiByZWxhdGl2ZSBVUkwuIFVzZWQgdG8gdGVsbCBmbGFzaCBjb3JyZWN0IFVSTC5cbiAqXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB1cmxcbiAqICAgICAgICAgVVJMIHRvIG1ha2UgYWJzb2x1dGVcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIEFic29sdXRlIFVSTFxuICpcbiAqIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NzA4MzIvZ2V0dGluZy1hbi1hYnNvbHV0ZS11cmwtZnJvbS1hLXJlbGF0aXZlLW9uZS1pZTYtaXNzdWVcbiAqL1xudmFyIGdldEFic29sdXRlVVJMID0gZnVuY3Rpb24gZ2V0QWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIENoZWNrIGlmIGFic29sdXRlIFVSTFxuICBpZiAoIXVybC5tYXRjaCgvXmh0dHBzPzpcXC9cXC8vKSkge1xuICAgIC8vIENvbnZlcnQgdG8gYWJzb2x1dGUgVVJMLiBGbGFzaCBob3N0ZWQgb2ZmLXNpdGUgbmVlZHMgYW4gYWJzb2x1dGUgVVJMLlxuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGRpdi5pbm5lckhUTUwgPSAnPGEgaHJlZj1cIicgKyB1cmwgKyAnXCI+eDwvYT4nO1xuICAgIHVybCA9IGRpdi5maXJzdENoaWxkLmhyZWY7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBleHRlbnNpb24gb2YgdGhlIHBhc3NlZCBmaWxlIG5hbWUuIEl0IHdpbGwgcmV0dXJuIGFuIGVtcHR5IHN0cmluZ1xuICogaWYgcGFzc2VkIGFuIGludmFsaWQgcGF0aC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogICAgICAgIFRoZSBmaWxlTmFtZSBwYXRoIGxpa2UgJy9wYXRoL3RvL2ZpbGUubXA0J1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiAgICAgICAgICBUaGUgZXh0ZW5zaW9uIGluIGxvd2VyIGNhc2Ugb3IgYW4gZW1wdHkgc3RyaW5nIGlmIG5vXG4gKiAgICAgICAgICBleHRlbnNpb24gY291bGQgYmUgZm91bmQuXG4gKi9cbnZhciBnZXRGaWxlRXh0ZW5zaW9uID0gZnVuY3Rpb24gZ2V0RmlsZUV4dGVuc2lvbihwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc3BsaXRQYXRoUmUgPSAvXihcXC8/KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rPykoXFwuKFteXFwuXFwvXFw/XSspKSkoPzpbXFwvXSp8W1xcP10uKikkL2k7XG4gICAgdmFyIHBhdGhQYXJ0cyA9IHNwbGl0UGF0aFJlLmV4ZWMocGF0aCk7XG5cbiAgICBpZiAocGF0aFBhcnRzKSB7XG4gICAgICByZXR1cm4gcGF0aFBhcnRzLnBvcCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHVybCBwYXNzZWQgaXMgYSBjcm9zcyBkb21haW4gcmVxdWVzdCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogICAgICAgIFRoZSB1cmwgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgV2hldGhlciBpdCBpcyBhIGNyb3NzIGRvbWFpbiByZXF1ZXN0IG9yIG5vdC5cbiAqL1xudmFyIGlzQ3Jvc3NPcmlnaW4gPSBmdW5jdGlvbiBpc0Nyb3NzT3JpZ2luKHVybCkge1xuICB2YXIgd2luTG9jID0gd2luZG93LmxvY2F0aW9uO1xuICB2YXIgdXJsSW5mbyA9IHBhcnNlVXJsKHVybCk7XG5cbiAgLy8gSUU4IHByb3RvY29sIHJlbGF0aXZlIHVybHMgd2lsbCByZXR1cm4gJzonIGZvciBwcm90b2NvbFxuICB2YXIgc3JjUHJvdG9jb2wgPSB1cmxJbmZvLnByb3RvY29sID09PSAnOicgPyB3aW5Mb2MucHJvdG9jb2wgOiB1cmxJbmZvLnByb3RvY29sO1xuXG4gIC8vIENoZWNrIGlmIHVybCBpcyBmb3IgYW5vdGhlciBkb21haW4vb3JpZ2luXG4gIC8vIElFOCBkb2Vzbid0IGtub3cgbG9jYXRpb24ub3JpZ2luLCBzbyB3ZSB3b24ndCByZWx5IG9uIGl0IGhlcmVcbiAgdmFyIGNyb3NzT3JpZ2luID0gc3JjUHJvdG9jb2wgKyB1cmxJbmZvLmhvc3QgIT09IHdpbkxvYy5wcm90b2NvbCArIHdpbkxvYy5ob3N0O1xuXG4gIHJldHVybiBjcm9zc09yaWdpbjtcbn07XG5cbnZhciBVcmwgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcblx0cGFyc2VVcmw6IHBhcnNlVXJsLFxuXHRnZXRBYnNvbHV0ZVVSTDogZ2V0QWJzb2x1dGVVUkwsXG5cdGdldEZpbGVFeHRlbnNpb246IGdldEZpbGVFeHRlbnNpb24sXG5cdGlzQ3Jvc3NPcmlnaW46IGlzQ3Jvc3NPcmlnaW5cbn0pO1xuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2suanNcbiAqL1xuLyoqXG4gKiBUYWtlcyBhIHdlYnZ0dCBmaWxlIGNvbnRlbnRzIGFuZCBwYXJzZXMgaXQgaW50byBjdWVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNyY0NvbnRlbnRcbiAqICAgICAgICB3ZWJWVFQgZmlsZSBjb250ZW50c1xuICpcbiAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICogICAgICAgIFRleHRUcmFjayB0byBhZGQgY3VlcyB0by4gQ3VlcyBjb21lIGZyb20gdGhlIHNyY0NvbnRlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIHBhcnNlQ3VlcyA9IGZ1bmN0aW9uIHBhcnNlQ3VlcyhzcmNDb250ZW50LCB0cmFjaykge1xuICB2YXIgcGFyc2VyID0gbmV3IHdpbmRvdy5XZWJWVFQuUGFyc2VyKHdpbmRvdywgd2luZG93LnZ0dGpzLCB3aW5kb3cuV2ViVlRULlN0cmluZ0RlY29kZXIoKSk7XG4gIHZhciBlcnJvcnMgPSBbXTtcblxuICBwYXJzZXIub25jdWUgPSBmdW5jdGlvbiAoY3VlKSB7XG4gICAgdHJhY2suYWRkQ3VlKGN1ZSk7XG4gIH07XG5cbiAgcGFyc2VyLm9ucGFyc2luZ2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICB9O1xuXG4gIHBhcnNlci5vbmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHRyYWNrLnRyaWdnZXIoe1xuICAgICAgdHlwZTogJ2xvYWRlZGRhdGEnLFxuICAgICAgdGFyZ2V0OiB0cmFja1xuICAgIH0pO1xuICB9O1xuXG4gIHBhcnNlci5wYXJzZShzcmNDb250ZW50KTtcbiAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmdyb3VwQ29sbGFwc2VkKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5ncm91cENvbGxhcHNlZCgnVGV4dCBUcmFjayBwYXJzaW5nIGVycm9ycyBmb3IgJyArIHRyYWNrLnNyYyk7XG4gICAgfVxuICAgIGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIGxvZyQxLmVycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgICBpZiAod2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUuZ3JvdXBFbmQpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VyLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIExvYWQgYSBgVGV4dFRyYWNrYCBmcm9tIGEgc3BlY2lmZWQgdXJsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNcbiAqICAgICAgICBVcmwgdG8gbG9hZCB0cmFjayBmcm9tLlxuICpcbiAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICogICAgICAgIFRyYWNrIHRvIGFkZCBjdWVzIHRvLiBDb21lcyBmcm9tIHRoZSBjb250ZW50IGF0IHRoZSBlbmQgb2YgYHVybGAuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGxvYWRUcmFjayA9IGZ1bmN0aW9uIGxvYWRUcmFjayhzcmMsIHRyYWNrKSB7XG4gIHZhciBvcHRzID0ge1xuICAgIHVyaTogc3JjXG4gIH07XG4gIHZhciBjcm9zc09yaWdpbiA9IGlzQ3Jvc3NPcmlnaW4oc3JjKTtcblxuICBpZiAoY3Jvc3NPcmlnaW4pIHtcbiAgICBvcHRzLmNvcnMgPSBjcm9zc09yaWdpbjtcbiAgfVxuXG4gIHhocihvcHRzLCBiaW5kKHRoaXMsIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlLCByZXNwb25zZUJvZHkpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gbG9nJDEuZXJyb3IoZXJyLCByZXNwb25zZSk7XG4gICAgfVxuXG4gICAgdHJhY2subG9hZGVkXyA9IHRydWU7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB2dHRqcyBoYXMgbG9hZGVkLCBvdGhlcndpc2UsIHdhaXQgdGlsbCBpdCBmaW5pc2hlZCBsb2FkaW5nXG4gICAgLy8gTk9URTogdGhpcyBpcyBvbmx5IHVzZWQgZm9yIHRoZSBhbHQvdmlkZW8ubm92dHQuanMgYnVpbGRcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5XZWJWVFQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh0cmFjay50ZWNoXykge1xuICAgICAgICB2YXIgbG9hZEhhbmRsZXIgPSBmdW5jdGlvbiBsb2FkSGFuZGxlcigpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VDdWVzKHJlc3BvbnNlQm9keSwgdHJhY2spO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRyYWNrLnRlY2hfLm9uKCd2dHRqc2xvYWRlZCcsIGxvYWRIYW5kbGVyKTtcbiAgICAgICAgdHJhY2sudGVjaF8ub24oJ3Z0dGpzZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbG9nJDEuZXJyb3IoJ3Z0dGpzIGZhaWxlZCB0byBsb2FkLCBzdG9wcGluZyB0cnlpbmcgdG8gcHJvY2VzcyAnICsgdHJhY2suc3JjKTtcbiAgICAgICAgICB0cmFjay50ZWNoXy5vZmYoJ3Z0dGpzbG9hZGVkJywgbG9hZEhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VDdWVzKHJlc3BvbnNlQm9keSwgdHJhY2spO1xuICAgIH1cbiAgfSkpO1xufTtcblxuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGBUZXh0VHJhY2tgLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2t9XG4gKiBAZXh0ZW5kcyBUcmFja1xuICovXG5cbnZhciBUZXh0VHJhY2sgPSBmdW5jdGlvbiAoX1RyYWNrKSB7XG4gIGluaGVyaXRzKFRleHRUcmFjaywgX1RyYWNrKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zPXt9XG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtUZWNofSBvcHRpb25zLnRlY2hcbiAgICogICAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0ZWNoIHRoYXQgb3ducyB0aGlzIFRleHRUcmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t+S2luZH0gW29wdGlvbnMua2luZD0nc3VidGl0bGVzJ11cbiAgICogICAgICAgIEEgdmFsaWQgdGV4dCB0cmFjayBraW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja35Nb2RlfSBbb3B0aW9ucy5tb2RlPSdkaXNhYmxlZCddXG4gICAqICAgICAgICBBIHZhbGlkIHRleHQgdHJhY2sgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkPSd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpXVxuICAgKiAgICAgICAgQSB1bmlxdWUgaWQgZm9yIHRoaXMgVGV4dFRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWw9JyddXG4gICAqICAgICAgICBUaGUgbWVudSBsYWJlbCBmb3IgdGhpcyB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zcmNsYW5nPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuIEFuIGFsdGVybmF0aXZlLCBidXQgZGVwcmlvcml0aXplZFxuICAgKiAgICAgICAgdmVzaW9uIG9mIGBvcHRpb25zLmxhbmd1YWdlYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3JjXVxuICAgKiAgICAgICAgQSB1cmwgdG8gVGV4dFRyYWNrIGN1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVmYXVsdF1cbiAgICogICAgICAgIElmIHRoaXMgdHJhY2sgc2hvdWxkIGRlZmF1bHQgdG8gb24gb3Igb2ZmLlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrKCkge1xuICAgIHZhciBfdGhpcywgX3JldDtcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2spO1xuXG4gICAgaWYgKCFvcHRpb25zLnRlY2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSB0ZWNoIHdhcyBub3QgcHJvdmlkZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHNldHRpbmdzID0gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIGtpbmQ6IFRleHRUcmFja0tpbmRbb3B0aW9ucy5raW5kXSB8fCAnc3VidGl0bGVzJyxcbiAgICAgIGxhbmd1YWdlOiBvcHRpb25zLmxhbmd1YWdlIHx8IG9wdGlvbnMuc3JjbGFuZyB8fCAnJ1xuICAgIH0pO1xuICAgIHZhciBtb2RlID0gVGV4dFRyYWNrTW9kZVtzZXR0aW5ncy5tb2RlXSB8fCAnZGlzYWJsZWQnO1xuICAgIHZhciBkZWZhdWx0XyA9IHNldHRpbmdzWydkZWZhdWx0J107XG5cbiAgICBpZiAoc2V0dGluZ3Mua2luZCA9PT0gJ21ldGFkYXRhJyB8fCBzZXR0aW5ncy5raW5kID09PSAnY2hhcHRlcnMnKSB7XG4gICAgICBtb2RlID0gJ2hpZGRlbic7XG4gICAgfVxuICAgIC8vIG9uIElFOCB0aGlzIHdpbGwgYmUgYSBkb2N1bWVudCBlbGVtZW50XG4gICAgLy8gZm9yIGV2ZXJ5IG90aGVyIGJyb3dzZXIgdGhpcyB3aWxsIGJlIGEgbm9ybWFsIG9iamVjdFxuICAgIHZhciB0dCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrLmNhbGwodGhpcywgc2V0dGluZ3MpKSwgX3RoaXMpO1xuXG4gICAgdHQudGVjaF8gPSBzZXR0aW5ncy50ZWNoO1xuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBUZXh0VHJhY2sucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdHRbcHJvcF0gPSBUZXh0VHJhY2sucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHQuY3Vlc18gPSBbXTtcbiAgICB0dC5hY3RpdmVDdWVzXyA9IFtdO1xuXG4gICAgdmFyIGN1ZXMgPSBuZXcgVGV4dFRyYWNrQ3VlTGlzdCh0dC5jdWVzXyk7XG4gICAgdmFyIGFjdGl2ZUN1ZXMgPSBuZXcgVGV4dFRyYWNrQ3VlTGlzdCh0dC5hY3RpdmVDdWVzXyk7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgdGltZXVwZGF0ZUhhbmRsZXIgPSBiaW5kKHR0LCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIC8vIEFjY2Vzc2luZyB0aGlzLmFjdGl2ZUN1ZXMgZm9yIHRoZSBzaWRlLWVmZmVjdHMgb2YgdXBkYXRpbmcgaXRzZWxmXG4gICAgICAvLyBkdWUgdG8gaXQncyBuYXR1cmUgYXMgYSBnZXR0ZXIgZnVuY3Rpb24uIERvIG5vdCByZW1vdmUgb3IgY3VlcyB3aWxsXG4gICAgICAvLyBzdG9wIHVwZGF0aW5nIVxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgICB0aGlzLmFjdGl2ZUN1ZXM7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjdWVjaGFuZ2UnKTtcbiAgICAgICAgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG1vZGUgIT09ICdkaXNhYmxlZCcpIHtcbiAgICAgIHR0LnRlY2hfLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHQudGVjaF8ub24oJ3RpbWV1cGRhdGUnLCB0aW1ldXBkYXRlSGFuZGxlcik7XG4gICAgICB9LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVGV4dFRyYWNrXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gZGVmYXVsdFxuICAgICAqICAgICAgICAgSWYgdGhpcyB0cmFjayB3YXMgc2V0IHRvIGJlIG9uIG9yIG9mZiBieSBkZWZhdWx0LiBDYW5ub3QgYmUgY2hhbmdlZCBhZnRlclxuICAgICAqICAgICAgICAgY3JlYXRpb24uXG4gICAgICogQGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHQsICdkZWZhdWx0Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0XztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSgpIHt9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVGV4dFRyYWNrXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBtb2RlXG4gICAgICogICAgICAgICBTZXQgdGhlIG1vZGUgb2YgdGhpcyBUZXh0VHJhY2sgdG8gYSB2YWxpZCB7QGxpbmsgVGV4dFRyYWNrfk1vZGV9LiBXaWxsXG4gICAgICogICAgICAgICBub3QgYmUgc2V0IGlmIHNldHRpbmcgdG8gYW4gaW52YWxpZCBtb2RlLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQGZpcmVzIFRleHRUcmFjayNtb2RlY2hhbmdlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnbW9kZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShuZXdNb2RlKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIGlmICghVGV4dFRyYWNrTW9kZVtuZXdNb2RlXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtb2RlID0gbmV3TW9kZTtcbiAgICAgICAgaWYgKG1vZGUgPT09ICdzaG93aW5nJykge1xuXG4gICAgICAgICAgdGhpcy50ZWNoXy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIudGVjaF8ub24oJ3RpbWV1cGRhdGUnLCB0aW1ldXBkYXRlSGFuZGxlcik7XG4gICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGV2ZW50IHRoYXQgZmlyZXMgd2hlbiBtb2RlIGNoYW5nZXMgb24gdGhpcyB0cmFjay4gVGhpcyBhbGxvd3NcbiAgICAgICAgICogdGhlIFRleHRUcmFja0xpc3QgdGhhdCBob2xkcyB0aGlzIHRyYWNrIHRvIGFjdCBhY2NvcmRpbmdseS5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBOb3RlOiBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBzcGVjIVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgVGV4dFRyYWNrI21vZGVjaGFuZ2VcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdtb2RlY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVGV4dFRyYWNrXG4gICAgICogQG1lbWJlciB7VGV4dFRyYWNrQ3VlTGlzdH0gY3Vlc1xuICAgICAqICAgICAgICAgVGhlIHRleHQgdHJhY2sgY3VlIGxpc3QgZm9yIHRoaXMgVGV4dFRyYWNrLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ2N1ZXMnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRlZF8pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjdWVzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKCkge31cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBUZXh0VHJhY2tcbiAgICAgKiBAbWVtYmVyIHtUZXh0VHJhY2tDdWVMaXN0fSBhY3RpdmVDdWVzXG4gICAgICogICAgICAgICBUaGUgbGlzdCB0ZXh0IHRyYWNrIGN1ZXMgdGhhdCBhcmUgY3VycmVudGx5IGFjdGl2ZSBmb3IgdGhpcyBUZXh0VHJhY2suXG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnYWN0aXZlQ3VlcycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVkXykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICBpZiAodGhpcy5jdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVDdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN0ID0gdGhpcy50ZWNoXy5jdXJyZW50VGltZSgpO1xuICAgICAgICB2YXIgYWN0aXZlID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmN1ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1ZSA9IHRoaXMuY3Vlc1tpXTtcblxuICAgICAgICAgIGlmIChjdWUuc3RhcnRUaW1lIDw9IGN0ICYmIGN1ZS5lbmRUaW1lID49IGN0KSB7XG4gICAgICAgICAgICBhY3RpdmUucHVzaChjdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VlLnN0YXJ0VGltZSA9PT0gY3VlLmVuZFRpbWUgJiYgY3VlLnN0YXJ0VGltZSA8PSBjdCAmJiBjdWUuc3RhcnRUaW1lICsgMC41ID49IGN0KSB7XG4gICAgICAgICAgICBhY3RpdmUucHVzaChjdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCAhPT0gdGhpcy5hY3RpdmVDdWVzXy5sZW5ndGgpIHtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYWN0aXZlLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ3Vlc18uaW5kZXhPZihhY3RpdmVbX2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hY3RpdmVDdWVzXyA9IGFjdGl2ZTtcbiAgICAgICAgYWN0aXZlQ3Vlcy5zZXRDdWVzXyh0aGlzLmFjdGl2ZUN1ZXNfKTtcblxuICAgICAgICByZXR1cm4gYWN0aXZlQ3VlcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSgpIHt9XG4gICAgfSk7XG5cbiAgICBpZiAoc2V0dGluZ3Muc3JjKSB7XG4gICAgICB0dC5zcmMgPSBzZXR0aW5ncy5zcmM7XG4gICAgICBsb2FkVHJhY2soc2V0dGluZ3Muc3JjLCB0dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR0LmxvYWRlZF8gPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gdHQsIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGN1ZSB0byB0aGUgaW50ZXJuYWwgbGlzdCBvZiBjdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja35DdWV9IGN1ZVxuICAgKiAgICAgICAgVGhlIGN1ZSB0byBhZGQgdG8gb3VyIGludGVybmFsIGxpc3RcbiAgICovXG5cblxuICBUZXh0VHJhY2sucHJvdG90eXBlLmFkZEN1ZSA9IGZ1bmN0aW9uIGFkZEN1ZShvcmlnaW5hbEN1ZSkge1xuICAgIHZhciBjdWUgPSBvcmlnaW5hbEN1ZTtcblxuICAgIGlmICh3aW5kb3cudnR0anMgJiYgIShvcmlnaW5hbEN1ZSBpbnN0YW5jZW9mIHdpbmRvdy52dHRqcy5WVFRDdWUpKSB7XG4gICAgICBjdWUgPSBuZXcgd2luZG93LnZ0dGpzLlZUVEN1ZShvcmlnaW5hbEN1ZS5zdGFydFRpbWUsIG9yaWdpbmFsQ3VlLmVuZFRpbWUsIG9yaWdpbmFsQ3VlLnRleHQpO1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIG9yaWdpbmFsQ3VlKSB7XG4gICAgICAgIGlmICghKHByb3AgaW4gY3VlKSkge1xuICAgICAgICAgIGN1ZVtwcm9wXSA9IG9yaWdpbmFsQ3VlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGBpZGAgaXMgY29waWVkIG92ZXJcbiAgICAgIGN1ZS5pZCA9IG9yaWdpbmFsQ3VlLmlkO1xuICAgICAgY3VlLm9yaWdpbmFsQ3VlXyA9IG9yaWdpbmFsQ3VlO1xuICAgIH1cblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnRlY2hfLnRleHRUcmFja3MoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJhY2tzW2ldICE9PSB0aGlzKSB7XG4gICAgICAgIHRyYWNrc1tpXS5yZW1vdmVDdWUoY3VlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmN1ZXNfLnB1c2goY3VlKTtcbiAgICB0aGlzLmN1ZXMuc2V0Q3Vlc18odGhpcy5jdWVzXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGN1ZSBmcm9tIG91ciBpbnRlcm5hbCBsaXN0XG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfkN1ZX0gcmVtb3ZlQ3VlXG4gICAqICAgICAgICBUaGUgY3VlIHRvIHJlbW92ZSBmcm9tIG91ciBpbnRlcm5hbCBsaXN0XG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrLnByb3RvdHlwZS5yZW1vdmVDdWUgPSBmdW5jdGlvbiByZW1vdmVDdWUoX3JlbW92ZUN1ZSkge1xuICAgIHZhciBpID0gdGhpcy5jdWVzXy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgY3VlID0gdGhpcy5jdWVzX1tpXTtcblxuICAgICAgaWYgKGN1ZSA9PT0gX3JlbW92ZUN1ZSB8fCBjdWUub3JpZ2luYWxDdWVfICYmIGN1ZS5vcmlnaW5hbEN1ZV8gPT09IF9yZW1vdmVDdWUpIHtcbiAgICAgICAgdGhpcy5jdWVzXy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHRoaXMuY3Vlcy5zZXRDdWVzXyh0aGlzLmN1ZXNfKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUZXh0VHJhY2s7XG59KFRyYWNrKTtcblxuLyoqXG4gKiBjdWVjaGFuZ2UgLSBPbmUgb3IgbW9yZSBjdWVzIGluIHRoZSB0cmFjayBoYXZlIGJlY29tZSBhY3RpdmUgb3Igc3RvcHBlZCBiZWluZyBhY3RpdmUuXG4gKi9cblxuXG5UZXh0VHJhY2sucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge1xuICBjdWVjaGFuZ2U6ICdjdWVjaGFuZ2UnXG59O1xuXG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgYEF1ZGlvVHJhY2tgLiBJZiBpdCBpcyBwYXJ0IG9mIGFuIHtAbGluayBBdWRpb1RyYWNrTGlzdH1cbiAqIG9ubHkgb25lIGBBdWRpb1RyYWNrYCBpbiB0aGUgbGlzdCB3aWxsIGJlIGVuYWJsZWQgYXQgYSB0aW1lLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNhdWRpb3RyYWNrfVxuICogQGV4dGVuZHMgVHJhY2tcbiAqL1xuXG52YXIgQXVkaW9UcmFjayA9IGZ1bmN0aW9uIChfVHJhY2spIHtcbiAgaW5oZXJpdHMoQXVkaW9UcmFjaywgX1RyYWNrKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlc1xuICAgKlxuICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2t+S2luZH0gW29wdGlvbnMua2luZD0nJ11cbiAgICogICAgICAgIEEgdmFsaWQgYXVkaW8gdHJhY2sga2luZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWQ9J3Zqc190cmFja18nICsgR3VpZC5uZXdHVUlEKCldXG4gICAqICAgICAgICBBIHVuaXF1ZSBpZCBmb3IgdGhpcyBBdWRpb1RyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWw9JyddXG4gICAqICAgICAgICBUaGUgbWVudSBsYWJlbCBmb3IgdGhpcyB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlZF1cbiAgICogICAgICAgIElmIHRoaXMgdHJhY2sgaXMgdGhlIG9uZSB0aGF0IGlzIGN1cnJlbnRseSBwbGF5aW5nLiBJZiB0aGlzIHRyYWNrIGlzIHBhcnQgb2ZcbiAgICogICAgICAgIGFuIHtAbGluayBBdWRpb1RyYWNrTGlzdH0sIG9ubHkgb25lIHtAbGluayBBdWRpb1RyYWNrfSB3aWxsIGJlIGVuYWJsZWQuXG4gICAqL1xuICBmdW5jdGlvbiBBdWRpb1RyYWNrKCkge1xuICAgIHZhciBfdGhpcywgX3JldDtcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb1RyYWNrKTtcblxuICAgIHZhciBzZXR0aW5ncyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICBraW5kOiBBdWRpb1RyYWNrS2luZFtvcHRpb25zLmtpbmRdIHx8ICcnXG4gICAgfSk7XG4gICAgLy8gb24gSUU4IHRoaXMgd2lsbCBiZSBhIGRvY3VtZW50IGVsZW1lbnRcbiAgICAvLyBmb3IgZXZlcnkgb3RoZXIgYnJvd3NlciB0aGlzIHdpbGwgYmUgYSBub3JtYWwgb2JqZWN0XG4gICAgdmFyIHRyYWNrID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhY2suY2FsbCh0aGlzLCBzZXR0aW5ncykpLCBfdGhpcyk7XG4gICAgdmFyIGVuYWJsZWQgPSBmYWxzZTtcblxuICAgIGlmIChJU19JRTgpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gQXVkaW9UcmFjay5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0cmFja1twcm9wXSA9IEF1ZGlvVHJhY2sucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJvZiBBdWRpb1RyYWNrXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICAqICAgICAgICAgSWYgdGhpcyBgQXVkaW9UcmFja2AgaXMgZW5hYmxlZCBvciBub3QuIFdoZW4gc2V0dGluZyB0aGlzIHdpbGxcbiAgICAgKiAgICAgICAgIGZpcmUge0BsaW5rIEF1ZGlvVHJhY2sjZW5hYmxlZGNoYW5nZX0gaWYgdGhlIHN0YXRlIG9mIGVuYWJsZWQgaXMgY2hhbmdlZC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBmaXJlcyBWaWRlb1RyYWNrI3NlbGVjdGVkY2hhbmdlXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRyYWNrLCAnZW5hYmxlZCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gZW5hYmxlZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShuZXdFbmFibGVkKSB7XG4gICAgICAgIC8vIGFuIGludmFsaWQgb3IgdW5jaGFuZ2VkIHZhbHVlXG4gICAgICAgIGlmICh0eXBlb2YgbmV3RW5hYmxlZCAhPT0gJ2Jvb2xlYW4nIHx8IG5ld0VuYWJsZWQgPT09IGVuYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZW5hYmxlZCA9IG5ld0VuYWJsZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGV2ZW50IHRoYXQgZmlyZXMgd2hlbiBlbmFibGVkIGNoYW5nZXMgb24gdGhpcyB0cmFjay4gVGhpcyBhbGxvd3NcbiAgICAgICAgICogdGhlIEF1ZGlvVHJhY2tMaXN0IHRoYXQgaG9sZHMgdGhpcyB0cmFjayB0byBhY3QgYWNjb3JkaW5nbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gTm90ZTogVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgc3BlYyEgTmF0aXZlIHRyYWNrcyB3aWxsIGRvXG4gICAgICAgICAqICAgICAgICAgdGhpcyBpbnRlcm5hbGx5IHdpdGhvdXQgYW4gZXZlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBBdWRpb1RyYWNrI2VuYWJsZWRjaGFuZ2VcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdlbmFibGVkY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBpZiB0aGUgdXNlciBzZXRzIHRoaXMgdHJhY2sgdG8gc2VsZWN0ZWQgdGhlblxuICAgIC8vIHNldCBzZWxlY3RlZCB0byB0aGF0IHRydWUgdmFsdWUgb3RoZXJ3aXNlXG4gICAgLy8gd2Uga2VlcCBpdCBmYWxzZVxuICAgIGlmIChzZXR0aW5ncy5lbmFibGVkKSB7XG4gICAgICB0cmFjay5lbmFibGVkID0gc2V0dGluZ3MuZW5hYmxlZDtcbiAgICB9XG4gICAgdHJhY2subG9hZGVkXyA9IHRydWU7XG5cbiAgICByZXR1cm4gX3JldCA9IHRyYWNrLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIHJldHVybiBBdWRpb1RyYWNrO1xufShUcmFjayk7XG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBgVmlkZW9UcmFja2AuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3ZpZGVvdHJhY2t9XG4gKiBAZXh0ZW5kcyBUcmFja1xuICovXG5cbnZhciBWaWRlb1RyYWNrID0gZnVuY3Rpb24gKF9UcmFjaykge1xuICBpbmhlcml0cyhWaWRlb1RyYWNrLCBfVHJhY2spO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5raW5kPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB7QGxpbmsgVmlkZW9UcmFja35LaW5kfVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWQ9J3Zqc190cmFja18nICsgR3VpZC5uZXdHVUlEKCldXG4gICAqICAgICAgICBBIHVuaXF1ZSBpZCBmb3IgdGhpcyBBdWRpb1RyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWw9JyddXG4gICAqICAgICAgICBUaGUgbWVudSBsYWJlbCBmb3IgdGhpcyB0cmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlPScnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VsZWN0ZWRdXG4gICAqICAgICAgICBJZiB0aGlzIHRyYWNrIGlzIHRoZSBvbmUgdGhhdCBpcyBjdXJyZW50bHkgcGxheWluZy5cbiAgICovXG4gIGZ1bmN0aW9uIFZpZGVvVHJhY2soKSB7XG4gICAgdmFyIF90aGlzLCBfcmV0O1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZGVvVHJhY2spO1xuXG4gICAgdmFyIHNldHRpbmdzID0gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIGtpbmQ6IFZpZGVvVHJhY2tLaW5kW29wdGlvbnMua2luZF0gfHwgJydcbiAgICB9KTtcblxuICAgIC8vIG9uIElFOCB0aGlzIHdpbGwgYmUgYSBkb2N1bWVudCBlbGVtZW50XG4gICAgLy8gZm9yIGV2ZXJ5IG90aGVyIGJyb3dzZXIgdGhpcyB3aWxsIGJlIGEgbm9ybWFsIG9iamVjdFxuICAgIHZhciB0cmFjayA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrLmNhbGwodGhpcywgc2V0dGluZ3MpKSwgX3RoaXMpO1xuICAgIHZhciBzZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgaWYgKElTX0lFOCkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBWaWRlb1RyYWNrLnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRyYWNrW3Byb3BdID0gVmlkZW9UcmFjay5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgVmlkZW9UcmFja1xuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogICAgICAgICBJZiB0aGlzIGBWaWRlb1RyYWNrYCBpcyBzZWxlY3RlZCBvciBub3QuIFdoZW4gc2V0dGluZyB0aGlzIHdpbGxcbiAgICAgKiAgICAgICAgIGZpcmUge0BsaW5rIFZpZGVvVHJhY2sjc2VsZWN0ZWRjaGFuZ2V9IGlmIHRoZSBzdGF0ZSBvZiBzZWxlY3RlZCBjaGFuZ2VkLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQGZpcmVzIFZpZGVvVHJhY2sjc2VsZWN0ZWRjaGFuZ2VcbiAgICAgKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2ssICdzZWxlY3RlZCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEobmV3U2VsZWN0ZWQpIHtcbiAgICAgICAgLy8gYW4gaW52YWxpZCBvciB1bmNoYW5nZWQgdmFsdWVcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdTZWxlY3RlZCAhPT0gJ2Jvb2xlYW4nIHx8IG5ld1NlbGVjdGVkID09PSBzZWxlY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3RlZCA9IG5ld1NlbGVjdGVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBldmVudCB0aGF0IGZpcmVzIHdoZW4gc2VsZWN0ZWQgY2hhbmdlcyBvbiB0aGlzIHRyYWNrLiBUaGlzIGFsbG93c1xuICAgICAgICAgKiB0aGUgVmlkZW9UcmFja0xpc3QgdGhhdCBob2xkcyB0aGlzIHRyYWNrIHRvIGFjdCBhY2NvcmRpbmdseS5cbiAgICAgICAgICpcbiAgICAgICAgICogPiBOb3RlOiBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBzcGVjISBOYXRpdmUgdHJhY2tzIHdpbGwgZG9cbiAgICAgICAgICogICAgICAgICB0aGlzIGludGVybmFsbHkgd2l0aG91dCBhbiBldmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFZpZGVvVHJhY2sjc2VsZWN0ZWRjaGFuZ2VcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzZWxlY3RlZGNoYW5nZScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gaWYgdGhlIHVzZXIgc2V0cyB0aGlzIHRyYWNrIHRvIHNlbGVjdGVkIHRoZW5cbiAgICAvLyBzZXQgc2VsZWN0ZWQgdG8gdGhhdCB0cnVlIHZhbHVlIG90aGVyd2lzZVxuICAgIC8vIHdlIGtlZXAgaXQgZmFsc2VcbiAgICBpZiAoc2V0dGluZ3Muc2VsZWN0ZWQpIHtcbiAgICAgIHRyYWNrLnNlbGVjdGVkID0gc2V0dGluZ3Muc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSB0cmFjaywgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICByZXR1cm4gVmlkZW9UcmFjaztcbn0oVHJhY2spO1xuXG4vKipcbiAqIEBmaWxlIGh0bWwtdHJhY2stZWxlbWVudC5qc1xuICovXG5cbi8qKlxuICogQG1lbWJlcm9mIEhUTUxUcmFja0VsZW1lbnRcbiAqIEB0eXBlZGVmIHtIVE1MVHJhY2tFbGVtZW50flJlYWR5U3RhdGV9XG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG52YXIgTk9ORSA9IDA7XG52YXIgTE9BRElORyA9IDE7XG52YXIgTE9BREVEID0gMjtcbnZhciBFUlJPUiA9IDM7XG5cbi8qKlxuICogQSBzaW5nbGUgdHJhY2sgcmVwcmVzZW50ZWQgaW4gdGhlIERPTS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjaHRtbHRyYWNrZWxlbWVudH1cbiAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XG4gKi9cblxudmFyIEhUTUxUcmFja0VsZW1lbnQgPSBmdW5jdGlvbiAoX0V2ZW50VGFyZ2V0KSB7XG4gIGluaGVyaXRzKEhUTUxUcmFja0VsZW1lbnQsIF9FdmVudFRhcmdldCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucz17fVxuICAgKiAgICAgICAgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzXG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH0gb3B0aW9ucy50ZWNoXG4gICAqICAgICAgICBBIHJlZmVyZW5jZSB0byB0aGUgdGVjaCB0aGF0IG93bnMgdGhpcyBIVE1MVHJhY2tFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja35LaW5kfSBbb3B0aW9ucy5raW5kPSdzdWJ0aXRsZXMnXVxuICAgKiAgICAgICAgQSB2YWxpZCB0ZXh0IHRyYWNrIGtpbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfk1vZGV9IFtvcHRpb25zLm1vZGU9J2Rpc2FibGVkJ11cbiAgICogICAgICAgIEEgdmFsaWQgdGV4dCB0cmFjayBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWQ9J3Zqc190cmFja18nICsgR3VpZC5uZXdHVUlEKCldXG4gICAqICAgICAgICBBIHVuaXF1ZSBpZCBmb3IgdGhpcyBUZXh0VHJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbD0nJ11cbiAgICogICAgICAgIFRoZSBtZW51IGxhYmVsIGZvciB0aGlzIHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2U9JyddXG4gICAqICAgICAgICBBIHZhbGlkIHR3byBjaGFyYWN0ZXIgbGFuZ3VhZ2UgY29kZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY2xhbmc9JyddXG4gICAqICAgICAgICBBIHZhbGlkIHR3byBjaGFyYWN0ZXIgbGFuZ3VhZ2UgY29kZS4gQW4gYWx0ZXJuYXRpdmUsIGJ1dCBkZXByaW9yaXRpemVkXG4gICAqICAgICAgICB2ZXNpb24gb2YgYG9wdGlvbnMubGFuZ3VhZ2VgXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zcmNdXG4gICAqICAgICAgICBBIHVybCB0byBUZXh0VHJhY2sgY3Vlcy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kZWZhdWx0XVxuICAgKiAgICAgICAgSWYgdGhpcyB0cmFjayBzaG91bGQgZGVmYXVsdCB0byBvbiBvciBvZmYuXG4gICAqL1xuICBmdW5jdGlvbiBIVE1MVHJhY2tFbGVtZW50KCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBIVE1MVHJhY2tFbGVtZW50KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50VGFyZ2V0LmNhbGwodGhpcykpO1xuXG4gICAgdmFyIHJlYWR5U3RhdGUgPSB2b2lkIDA7XG4gICAgdmFyIHRyYWNrRWxlbWVudCA9IF90aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICB0cmFja0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBIVE1MVHJhY2tFbGVtZW50LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRyYWNrRWxlbWVudFtwcm9wXSA9IEhUTUxUcmFja0VsZW1lbnQucHJvdG90eXBlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRyYWNrID0gbmV3IFRleHRUcmFjayhvcHRpb25zKTtcblxuICAgIHRyYWNrRWxlbWVudC5raW5kID0gdHJhY2sua2luZDtcbiAgICB0cmFja0VsZW1lbnQuc3JjID0gdHJhY2suc3JjO1xuICAgIHRyYWNrRWxlbWVudC5zcmNsYW5nID0gdHJhY2subGFuZ3VhZ2U7XG4gICAgdHJhY2tFbGVtZW50LmxhYmVsID0gdHJhY2subGFiZWw7XG4gICAgdHJhY2tFbGVtZW50WydkZWZhdWx0J10gPSB0cmFja1snZGVmYXVsdCddO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIEhUTUxUcmFja0VsZW1lbnRcbiAgICAgKiBAbWVtYmVyIHtIVE1MVHJhY2tFbGVtZW50flJlYWR5U3RhdGV9IHJlYWR5U3RhdGVcbiAgICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHJlYWR5IHN0YXRlIG9mIHRoZSB0cmFjayBlbGVtZW50LlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cmFja0VsZW1lbnQsICdyZWFkeVN0YXRlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiByZWFkeVN0YXRlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIEhUTUxUcmFja0VsZW1lbnRcbiAgICAgKiBAbWVtYmVyIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAgICogICAgICAgICBUaGUgdW5kZXJseWluZyBUZXh0VHJhY2sgb2JqZWN0LlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqXG4gICAgICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRyYWNrRWxlbWVudCwgJ3RyYWNrJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB0cmFjaztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlYWR5U3RhdGUgPSBOT05FO1xuXG4gICAgLyoqXG4gICAgICogQGxpc3RlbnMgVGV4dFRyYWNrI2xvYWRlZGRhdGFcbiAgICAgKiBAZmlyZXMgSFRNTFRyYWNrRWxlbWVudCNsb2FkXG4gICAgICovXG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlYWR5U3RhdGUgPSBMT0FERUQ7XG5cbiAgICAgIHRyYWNrRWxlbWVudC50cmlnZ2VyKHtcbiAgICAgICAgdHlwZTogJ2xvYWQnLFxuICAgICAgICB0YXJnZXQ6IHRyYWNrRWxlbWVudFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoSVNfSUU4KSB7XG4gICAgICB2YXIgX3JldDtcblxuICAgICAgcmV0dXJuIF9yZXQgPSB0cmFja0VsZW1lbnQsIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gSFRNTFRyYWNrRWxlbWVudDtcbn0oRXZlbnRUYXJnZXQpO1xuXG5IVE1MVHJhY2tFbGVtZW50LnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzXyA9IHtcbiAgbG9hZDogJ2xvYWQnXG59O1xuXG5IVE1MVHJhY2tFbGVtZW50Lk5PTkUgPSBOT05FO1xuSFRNTFRyYWNrRWxlbWVudC5MT0FESU5HID0gTE9BRElORztcbkhUTUxUcmFja0VsZW1lbnQuTE9BREVEID0gTE9BREVEO1xuSFRNTFRyYWNrRWxlbWVudC5FUlJPUiA9IEVSUk9SO1xuXG4vKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGFsbCB0cmFjayBwcm9wZXJ0aWVzIHRoYXQgYXJlIHVzZWQgaW5cbiAqIHBsYXllci5qcywgdGVjaC5qcywgaHRtbDUuanMgYW5kIHBvc3NpYmx5IG90aGVyIHRlY2hzIGluIHRoZSBmdXR1cmUuXG4gKi9cblxudmFyIE5PUk1BTCA9IHtcbiAgYXVkaW86IHtcbiAgICBMaXN0Q2xhc3M6IEF1ZGlvVHJhY2tMaXN0LFxuICAgIFRyYWNrQ2xhc3M6IEF1ZGlvVHJhY2ssXG4gICAgY2FwaXRhbE5hbWU6ICdBdWRpbydcbiAgfSxcbiAgdmlkZW86IHtcbiAgICBMaXN0Q2xhc3M6IFZpZGVvVHJhY2tMaXN0LFxuICAgIFRyYWNrQ2xhc3M6IFZpZGVvVHJhY2ssXG4gICAgY2FwaXRhbE5hbWU6ICdWaWRlbydcbiAgfSxcbiAgdGV4dDoge1xuICAgIExpc3RDbGFzczogVGV4dFRyYWNrTGlzdCxcbiAgICBUcmFja0NsYXNzOiBUZXh0VHJhY2ssXG4gICAgY2FwaXRhbE5hbWU6ICdUZXh0J1xuICB9XG59O1xuXG5PYmplY3Qua2V5cyhOT1JNQUwpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgTk9STUFMW3R5cGVdLmdldHRlck5hbWUgPSB0eXBlICsgJ1RyYWNrcyc7XG4gIE5PUk1BTFt0eXBlXS5wcml2YXRlTmFtZSA9IHR5cGUgKyAnVHJhY2tzXyc7XG59KTtcblxudmFyIFJFTU9URSA9IHtcbiAgcmVtb3RlVGV4dDoge1xuICAgIExpc3RDbGFzczogVGV4dFRyYWNrTGlzdCxcbiAgICBUcmFja0NsYXNzOiBUZXh0VHJhY2ssXG4gICAgY2FwaXRhbE5hbWU6ICdSZW1vdGVUZXh0JyxcbiAgICBnZXR0ZXJOYW1lOiAncmVtb3RlVGV4dFRyYWNrcycsXG4gICAgcHJpdmF0ZU5hbWU6ICdyZW1vdGVUZXh0VHJhY2tzXydcbiAgfSxcbiAgcmVtb3RlVGV4dEVsOiB7XG4gICAgTGlzdENsYXNzOiBIdG1sVHJhY2tFbGVtZW50TGlzdCxcbiAgICBUcmFja0NsYXNzOiBIVE1MVHJhY2tFbGVtZW50LFxuICAgIGNhcGl0YWxOYW1lOiAnUmVtb3RlVGV4dFRyYWNrRWxzJyxcbiAgICBnZXR0ZXJOYW1lOiAncmVtb3RlVGV4dFRyYWNrRWxzJyxcbiAgICBwcml2YXRlTmFtZTogJ3JlbW90ZVRleHRUcmFja0Vsc18nXG4gIH1cbn07XG5cbnZhciBBTEwgPSBtZXJnZU9wdGlvbnMoTk9STUFMLCBSRU1PVEUpO1xuXG5SRU1PVEUubmFtZXMgPSBPYmplY3Qua2V5cyhSRU1PVEUpO1xuTk9STUFMLm5hbWVzID0gT2JqZWN0LmtleXMoTk9STUFMKTtcbkFMTC5uYW1lcyA9IFtdLmNvbmNhdChSRU1PVEUubmFtZXMpLmNvbmNhdChOT1JNQUwubmFtZXMpO1xuXG4vKipcbiAqIEBmaWxlIHRlY2guanNcbiAqL1xuXG4vKipcbiAqIEFuIE9iamVjdCBjb250YWluaW5nIGEgc3RydWN0dXJlIGxpa2U6IGB7c3JjOiAndXJsJywgdHlwZTogJ21pbWV0eXBlJ31gIG9yIHN0cmluZ1xuICogdGhhdCBqdXN0IGNvbnRhaW5zIHRoZSBzcmMgdXJsIGFsb25lLlxuICogKiBgdmFyIFNvdXJjZU9iamVjdCA9IHtzcmM6ICdodHRwOi8vZXguY29tL3ZpZGVvLm1wNCcsIHR5cGU6ICd2aWRlby9tcDQnfTtgXG4gICAqIGB2YXIgU291cmNlU3RyaW5nID0gJ2h0dHA6Ly9leGFtcGxlLmNvbS9zb21lLXZpZGVvLm1wNCc7YFxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R8c3RyaW5nfSBUZWNoflNvdXJjZU9iamVjdFxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzcmNcbiAqICAgICAgICAgICBUaGUgdXJsIHRvIHRoZSBzb3VyY2VcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZVxuICogICAgICAgICAgIFRoZSBtaW1lIHR5cGUgb2YgdGhlIHNvdXJjZVxuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB1c2VkIGJ5IHtAbGluayBUZWNofSB0byBjcmVhdGUgYSBuZXcge0BsaW5rIFRleHRUcmFja30uXG4gKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1RlY2h9IHNlbGZcbiAqICAgICAgICBBbiBpbnN0YW5jZSBvZiB0aGUgVGVjaCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2luZFxuICogICAgICAgIGBUZXh0VHJhY2tgIGtpbmQgKHN1YnRpdGxlcywgY2FwdGlvbnMsIGRlc2NyaXB0aW9ucywgY2hhcHRlcnMsIG9yIG1ldGFkYXRhKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdXG4gKiAgICAgICAgTGFiZWwgdG8gaWRlbnRpZnkgdGhlIHRleHQgdHJhY2tcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlXVxuICogICAgICAgIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICogICAgICAgIEFuIG9iamVjdCB3aXRoIGFkZGl0aW9uYWwgdGV4dCB0cmFjayBvcHRpb25zXG4gKlxuICogQHJldHVybiB7VGV4dFRyYWNrfVxuICogICAgICAgICAgVGhlIHRleHQgdHJhY2sgdGhhdCB3YXMgY3JlYXRlZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhY2tIZWxwZXIoc2VsZiwga2luZCwgbGFiZWwsIGxhbmd1YWdlKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fTtcblxuICB2YXIgdHJhY2tzID0gc2VsZi50ZXh0VHJhY2tzKCk7XG5cbiAgb3B0aW9ucy5raW5kID0ga2luZDtcblxuICBpZiAobGFiZWwpIHtcbiAgICBvcHRpb25zLmxhYmVsID0gbGFiZWw7XG4gIH1cbiAgaWYgKGxhbmd1YWdlKSB7XG4gICAgb3B0aW9ucy5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuICB9XG4gIG9wdGlvbnMudGVjaCA9IHNlbGY7XG5cbiAgdmFyIHRyYWNrID0gbmV3IEFMTC50ZXh0LlRyYWNrQ2xhc3Mob3B0aW9ucyk7XG5cbiAgdHJhY2tzLmFkZFRyYWNrKHRyYWNrKTtcblxuICByZXR1cm4gdHJhY2s7XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgbWVkaWEgcGxheWJhY2sgdGVjaG5vbG9neSBjb250cm9sbGVycywgc3VjaCBhc1xuICoge0BsaW5rIEZsYXNofSBhbmQge0BsaW5rIEhUTUw1fVxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBUZWNoID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVGVjaCwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIFRlY2guXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IHJlYWR5XG4gICAqICAgICAgICBDYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGBIVE1MNWAgVGVjaCBpcyByZWFkeS5cbiAgICovXG4gIGZ1bmN0aW9uIFRlY2goKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciByZWFkeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZnVuY3Rpb24gKCkge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGVjaCk7XG5cbiAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSB0ZWNoIHRvIHJlcG9ydCB1c2VyIGFjdGl2aXR5IGF1dG9tYXRpY2FsbHkuXG4gICAgLy8gVGhpcyBpcyBkb25lIG1hbnVhbGx5IGluIGFkZENvbnRyb2xzTGlzdGVuZXJzXG4gICAgb3B0aW9ucy5yZXBvcnRUb3VjaEFjdGl2aXR5ID0gZmFsc2U7XG5cbiAgICAvLyBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgdGhlIGN1cnJlbnQgc291cmNlIGhhcyBwbGF5ZWQgYXQgYWxsIHRvXG4gICAgLy8gaW1wbGVtZW50IGEgdmVyeSBsaW1pdGVkIHBsYXllZCgpXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgbnVsbCwgb3B0aW9ucywgcmVhZHkpKTtcblxuICAgIF90aGlzLmhhc1N0YXJ0ZWRfID0gZmFsc2U7XG4gICAgX3RoaXMub24oJ3BsYXlpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmhhc1N0YXJ0ZWRfID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBfdGhpcy5vbignbG9hZHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5oYXNTdGFydGVkXyA9IGZhbHNlO1xuICAgIH0pO1xuXG4gICAgQUxMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBwcm9wcyA9IEFMTFtuYW1lXTtcblxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9uc1twcm9wcy5nZXR0ZXJOYW1lXSkge1xuICAgICAgICBfdGhpc1twcm9wcy5wcml2YXRlTmFtZV0gPSBvcHRpb25zW3Byb3BzLmdldHRlck5hbWVdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTWFudWFsbHkgdHJhY2sgcHJvZ3Jlc3MgaW4gY2FzZXMgd2hlcmUgdGhlIGJyb3dzZXIvZmxhc2ggcGxheWVyIGRvZXNuJ3QgcmVwb3J0IGl0LlxuICAgIGlmICghX3RoaXMuZmVhdHVyZXNQcm9ncmVzc0V2ZW50cykge1xuICAgICAgX3RoaXMubWFudWFsUHJvZ3Jlc3NPbigpO1xuICAgIH1cblxuICAgIC8vIE1hbnVhbGx5IHRyYWNrIHRpbWV1cGRhdGVzIGluIGNhc2VzIHdoZXJlIHRoZSBicm93c2VyL2ZsYXNoIHBsYXllciBkb2Vzbid0IHJlcG9ydCBpdC5cbiAgICBpZiAoIV90aGlzLmZlYXR1cmVzVGltZXVwZGF0ZUV2ZW50cykge1xuICAgICAgX3RoaXMubWFudWFsVGltZVVwZGF0ZXNPbigpO1xuICAgIH1cblxuICAgIFsnVGV4dCcsICdBdWRpbycsICdWaWRlbyddLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICBpZiAob3B0aW9uc1snbmF0aXZlJyArIHRyYWNrICsgJ1RyYWNrcyddID09PSBmYWxzZSkge1xuICAgICAgICBfdGhpc1snZmVhdHVyZXNOYXRpdmUnICsgdHJhY2sgKyAnVHJhY2tzJ10gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLm5hdGl2ZUNhcHRpb25zID09PSBmYWxzZSB8fCBvcHRpb25zLm5hdGl2ZVRleHRUcmFja3MgPT09IGZhbHNlKSB7XG4gICAgICBfdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMubmF0aXZlQ2FwdGlvbnMgPT09IHRydWUgfHwgb3B0aW9ucy5uYXRpdmVUZXh0VHJhY2tzID09PSB0cnVlKSB7XG4gICAgICBfdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghX3RoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICBfdGhpcy5lbXVsYXRlVGV4dFRyYWNrcygpO1xuICAgIH1cblxuICAgIF90aGlzLmF1dG9SZW1vdGVUZXh0VHJhY2tzXyA9IG5ldyBBTEwudGV4dC5MaXN0Q2xhc3MoKTtcblxuICAgIF90aGlzLmluaXRUcmFja0xpc3RlbmVycygpO1xuXG4gICAgLy8gVHVybiBvbiBjb21wb25lbnQgdGFwIGV2ZW50cyBvbmx5IGlmIG5vdCB1c2luZyBuYXRpdmUgY29udHJvbHNcbiAgICBpZiAoIW9wdGlvbnMubmF0aXZlQ29udHJvbHNGb3JUb3VjaCkge1xuICAgICAgX3RoaXMuZW1pdFRhcEV2ZW50cygpO1xuICAgIH1cblxuICAgIGlmIChfdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgX3RoaXMubmFtZV8gPSBfdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdVbmtub3duIFRlY2gnO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKiBGYWxsYmFja3MgZm9yIHVuc3VwcG9ydGVkIGV2ZW50IHR5cGVzXG4gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbiAgLyoqXG4gICAqIFBvbHlmaWxsIHRoZSBgcHJvZ3Jlc3NgIGV2ZW50IGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgaXQgbmF0aXZlbHkuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIFRlY2gjdHJhY2tQcm9ncmVzc31cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5tYW51YWxQcm9ncmVzc09uID0gZnVuY3Rpb24gbWFudWFsUHJvZ3Jlc3NPbigpIHtcbiAgICB0aGlzLm9uKCdkdXJhdGlvbmNoYW5nZScsIHRoaXMub25EdXJhdGlvbkNoYW5nZSk7XG5cbiAgICB0aGlzLm1hbnVhbFByb2dyZXNzID0gdHJ1ZTtcblxuICAgIC8vIFRyaWdnZXIgcHJvZ3Jlc3Mgd2F0Y2hpbmcgd2hlbiBhIHNvdXJjZSBiZWdpbnMgbG9hZGluZ1xuICAgIHRoaXMub25lKCdyZWFkeScsIHRoaXMudHJhY2tQcm9ncmVzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFR1cm4gb2ZmIHRoZSBwb2x5ZmlsbCBmb3IgYHByb2dyZXNzYCBldmVudHMgdGhhdCB3YXMgY3JlYXRlZCBpblxuICAgKiB7QGxpbmsgVGVjaCNtYW51YWxQcm9ncmVzc09ufVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLm1hbnVhbFByb2dyZXNzT2ZmID0gZnVuY3Rpb24gbWFudWFsUHJvZ3Jlc3NPZmYoKSB7XG4gICAgdGhpcy5tYW51YWxQcm9ncmVzcyA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKTtcblxuICAgIHRoaXMub2ZmKCdkdXJhdGlvbmNoYW5nZScsIHRoaXMub25EdXJhdGlvbkNoYW5nZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdXNlZCB0byB0cmlnZ2VyIGEgYHByb2dyZXNzYCBldmVudCB3aGVuIHRoZSBidWZmZXJlZCBwZXJjZW50IGNoYW5nZXMuIEl0XG4gICAqIHNldHMgYW4gaW50ZXJ2YWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBldmVyeSA1MDAgbWlsbGlzZWNvbmRzIHRvIGNoZWNrIGlmIHRoZVxuICAgKiBidWZmZXIgZW5kIHBlcmNlbnQgaGFzIGNoYW5nZWQuXG4gICAqXG4gICAqID4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkge0BsaW5rIFRlY2gjbWFudWFsUHJvZ3Jlc3NPbn1cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgcmVhZHlgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI3JlYWR5XG4gICAqIEBmaXJlcyBUZWNoI3Byb2dyZXNzXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUudHJhY2tQcm9ncmVzcyA9IGZ1bmN0aW9uIHRyYWNrUHJvZ3Jlc3MoZXZlbnQpIHtcbiAgICB0aGlzLnN0b3BUcmFja2luZ1Byb2dyZXNzKCk7XG4gICAgdGhpcy5wcm9ncmVzc0ludGVydmFsID0gdGhpcy5zZXRJbnRlcnZhbChiaW5kKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIERvbid0IHRyaWdnZXIgdW5sZXNzIGJ1ZmZlcmVkIGFtb3VudCBpcyBncmVhdGVyIHRoYW4gbGFzdCB0aW1lXG5cbiAgICAgIHZhciBudW1CdWZmZXJlZFBlcmNlbnQgPSB0aGlzLmJ1ZmZlcmVkUGVyY2VudCgpO1xuXG4gICAgICBpZiAodGhpcy5idWZmZXJlZFBlcmNlbnRfICE9PSBudW1CdWZmZXJlZFBlcmNlbnQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZSB7QGxpbmsgUGxheWVyI3Byb2dyZXNzfVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgVGVjaCNwcm9ncmVzc1xuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Byb2dyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVmZmVyZWRQZXJjZW50XyA9IG51bUJ1ZmZlcmVkUGVyY2VudDtcblxuICAgICAgaWYgKG51bUJ1ZmZlcmVkUGVyY2VudCA9PT0gMSkge1xuICAgICAgICB0aGlzLnN0b3BUcmFja2luZ1Byb2dyZXNzKCk7XG4gICAgICB9XG4gICAgfSksIDUwMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBvdXIgaW50ZXJuYWwgZHVyYXRpb24gb24gYSBgZHVyYXRpb25jaGFuZ2VgIGV2ZW50IGJ5IGNhbGxpbmdcbiAgICoge0BsaW5rIFRlY2gjZHVyYXRpb259LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBkdXJhdGlvbmNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjZHVyYXRpb25jaGFuZ2VcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5vbkR1cmF0aW9uQ2hhbmdlID0gZnVuY3Rpb24gb25EdXJhdGlvbkNoYW5nZShldmVudCkge1xuICAgIHRoaXMuZHVyYXRpb25fID0gdGhpcy5kdXJhdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYW5kIGNyZWF0ZSBhIGBUaW1lUmFuZ2VgIG9iamVjdCBmb3IgYnVmZmVyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gICAqICAgICAgICAgVGhlIHRpbWUgcmFuZ2Ugb2JqZWN0IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuYnVmZmVyZWQgPSBmdW5jdGlvbiBidWZmZXJlZCgpIHtcbiAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlcygwLCAwKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwZXJjZW50YWdlIG9mIHRoZSBjdXJyZW50IHZpZGVvIHRoYXQgaXMgY3VycmVudGx5IGJ1ZmZlcmVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgQSBudW1iZXIgZnJvbSAwIHRvIDEgdGhhdCByZXByZXNlbnRzIHRoZSBkZWNpbWFsIHBlcmNlbnRhZ2Ugb2YgdGhlXG4gICAqICAgICAgICAgdmlkZW8gdGhhdCBpcyBidWZmZXJlZC5cbiAgICpcbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5idWZmZXJlZFBlcmNlbnQgPSBmdW5jdGlvbiBidWZmZXJlZFBlcmNlbnQkJDEoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcmVkUGVyY2VudCh0aGlzLmJ1ZmZlcmVkKCksIHRoaXMuZHVyYXRpb25fKTtcbiAgfTtcblxuICAvKipcbiAgICogVHVybiBvZmYgdGhlIHBvbHlmaWxsIGZvciBgcHJvZ3Jlc3NgIGV2ZW50cyB0aGF0IHdhcyBjcmVhdGVkIGluXG4gICAqIHtAbGluayBUZWNoI21hbnVhbFByb2dyZXNzT259XG4gICAqIFN0b3AgbWFudWFsbHkgdHJhY2tpbmcgcHJvZ3Jlc3MgZXZlbnRzIGJ5IGNsZWFyaW5nIHRoZSBpbnRlcnZhbCB0aGF0IHdhcyBzZXQgaW5cbiAgICoge0BsaW5rIFRlY2gjdHJhY2tQcm9ncmVzc30uXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuc3RvcFRyYWNraW5nUHJvZ3Jlc3MgPSBmdW5jdGlvbiBzdG9wVHJhY2tpbmdQcm9ncmVzcygpIHtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwodGhpcy5wcm9ncmVzc0ludGVydmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogUG9seWZpbGwgdGhlIGB0aW1ldXBkYXRlYCBldmVudCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGl0LlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBUZWNoI3RyYWNrQ3VycmVudFRpbWV9XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUubWFudWFsVGltZVVwZGF0ZXNPbiA9IGZ1bmN0aW9uIG1hbnVhbFRpbWVVcGRhdGVzT24oKSB7XG4gICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlcyA9IHRydWU7XG5cbiAgICB0aGlzLm9uKCdwbGF5JywgdGhpcy50cmFja0N1cnJlbnRUaW1lKTtcbiAgICB0aGlzLm9uKCdwYXVzZScsIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUdXJuIG9mZiB0aGUgcG9seWZpbGwgZm9yIGB0aW1ldXBkYXRlYCBldmVudHMgdGhhdCB3YXMgY3JlYXRlZCBpblxuICAgKiB7QGxpbmsgVGVjaCNtYW51YWxUaW1lVXBkYXRlc09ufVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLm1hbnVhbFRpbWVVcGRhdGVzT2ZmID0gZnVuY3Rpb24gbWFudWFsVGltZVVwZGF0ZXNPZmYoKSB7XG4gICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlcyA9IGZhbHNlO1xuICAgIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUoKTtcbiAgICB0aGlzLm9mZigncGxheScsIHRoaXMudHJhY2tDdXJyZW50VGltZSk7XG4gICAgdGhpcy5vZmYoJ3BhdXNlJywgdGhpcy5zdG9wVHJhY2tpbmdDdXJyZW50VGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgYW4gaW50ZXJ2YWwgZnVuY3Rpb24gdG8gdHJhY2sgY3VycmVudCB0aW1lIGFuZCB0cmlnZ2VyIGB0aW1ldXBkYXRlYCBldmVyeVxuICAgKiAyNTAgbWlsbGlzZWNvbmRzLlxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI3BsYXlcbiAgICogQHRyaWdnZXJzIFRlY2gjdGltZXVwZGF0ZVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnRyYWNrQ3VycmVudFRpbWUgPSBmdW5jdGlvbiB0cmFja0N1cnJlbnRUaW1lKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRUaW1lSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50VGltZUludGVydmFsID0gdGhpcy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRyaWdnZXJlZCBhdCBhbiBpbnRlcnZhbCBvZiAyNTBtcyB0byBpbmRpY2F0ZWQgdGhhdCB0aW1lIGlzIHBhc3NpbmcgaW4gdGhlIHZpZGVvLlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBUZWNoI3RpbWV1cGRhdGVcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pO1xuXG4gICAgICAvLyA0MiA9IDI0IGZwcyAvLyAyNTAgaXMgd2hhdCBXZWJraXQgdXNlcyAvLyBGRiB1c2VzIDE1XG4gICAgfSwgMjUwKTtcbiAgfTtcblxuICAvKipcbiAgICogU3RvcCB0aGUgaW50ZXJ2YWwgZnVuY3Rpb24gY3JlYXRlZCBpbiB7QGxpbmsgVGVjaCN0cmFja0N1cnJlbnRUaW1lfSBzbyB0aGF0IHRoZVxuICAgKiBgdGltZXVwZGF0ZWAgZXZlbnQgaXMgbm8gbG9uZ2VyIHRyaWdnZXJlZC5cbiAgICpcbiAgICogQGxpc3RlbnMge1RlY2gjcGF1c2V9XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuc3RvcFRyYWNraW5nQ3VycmVudFRpbWUgPSBmdW5jdGlvbiBzdG9wVHJhY2tpbmdDdXJyZW50VGltZSgpIHtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwodGhpcy5jdXJyZW50VGltZUludGVydmFsKTtcblxuICAgIC8vICMxMDAyIC0gaWYgdGhlIHZpZGVvIGVuZHMgcmlnaHQgYmVmb3JlIHRoZSBuZXh0IHRpbWV1cGRhdGUgd291bGQgaGFwcGVuLFxuICAgIC8vIHRoZSBwcm9ncmVzcyBiYXIgd29uJ3QgbWFrZSBpdCBhbGwgdGhlIHdheSB0byB0aGUgZW5kXG4gICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUdXJuIG9mZiBhbGwgZXZlbnQgcG9seWZpbGxzLCBjbGVhciB0aGUgYFRlY2hgcyB7QGxpbmsgQXVkaW9UcmFja0xpc3R9LFxuICAgKiB7QGxpbmsgVmlkZW9UcmFja0xpc3R9LCBhbmQge0BsaW5rIFRleHRUcmFja0xpc3R9LCBhbmQgZGlzcG9zZSBvZiB0aGlzIFRlY2guXG4gICAqXG4gICAqIEBmaXJlcyBDb21wb25lbnQjZGlzcG9zZVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuXG4gICAgLy8gY2xlYXIgb3V0IGFsbCB0cmFja3MgYmVjYXVzZSB3ZSBjYW4ndCByZXVzZSB0aGVtIGJldHdlZW4gdGVjaHNcbiAgICB0aGlzLmNsZWFyVHJhY2tzKE5PUk1BTC5uYW1lcyk7XG5cbiAgICAvLyBUdXJuIG9mZiBhbnkgbWFudWFsIHByb2dyZXNzIG9yIHRpbWV1cGRhdGUgdHJhY2tpbmdcbiAgICBpZiAodGhpcy5tYW51YWxQcm9ncmVzcykge1xuICAgICAgdGhpcy5tYW51YWxQcm9ncmVzc09mZigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hbnVhbFRpbWVVcGRhdGVzKSB7XG4gICAgICB0aGlzLm1hbnVhbFRpbWVVcGRhdGVzT2ZmKCk7XG4gICAgfVxuXG4gICAgX0NvbXBvbmVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciBvdXQgYSBzaW5nbGUgYFRyYWNrTGlzdGAgb3IgYW4gYXJyYXkgb2YgYFRyYWNrTGlzdHNgIGdpdmVuIHRoZWlyIG5hbWVzLlxuICAgKlxuICAgKiA+IE5vdGU6IFRlY2hzIHdpdGhvdXQgc291cmNlIGhhbmRsZXJzIHNob3VsZCBjYWxsIHRoaXMgYmV0d2VlbiBzb3VyY2VzIGZvciBgdmlkZW9gXG4gICAqICAgICAgICAgJiBgYXVkaW9gIHRyYWNrcy4gWW91IGRvbid0IHdhbnQgdG8gdXNlIHRoZW0gYmV0d2VlbiB0cmFja3MhXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nW118c3RyaW5nfSB0eXBlc1xuICAgKiAgICAgICAgVHJhY2tMaXN0IG5hbWVzIHRvIGNsZWFyLCB2YWxpZCBuYW1lcyBhcmUgYHZpZGVvYCwgYGF1ZGlvYCwgYW5kXG4gICAqICAgICAgICBgdGV4dGAuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuY2xlYXJUcmFja3MgPSBmdW5jdGlvbiBjbGVhclRyYWNrcyh0eXBlcykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdHlwZXMgPSBbXS5jb25jYXQodHlwZXMpO1xuICAgIC8vIGNsZWFyIG91dCBhbGwgdHJhY2tzIGJlY2F1c2Ugd2UgY2FuJ3QgcmV1c2UgdGhlbSBiZXR3ZWVuIHRlY2hzXG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIGxpc3QgPSBfdGhpczJbdHlwZSArICdUcmFja3MnXSgpIHx8IFtdO1xuICAgICAgdmFyIGkgPSBsaXN0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgdHJhY2sgPSBsaXN0W2ldO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICBfdGhpczIucmVtb3ZlUmVtb3RlVGV4dFRyYWNrKHRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0LnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFueSBUZXh0VHJhY2tzIGFkZGVkIHZpYSBhZGRSZW1vdGVUZXh0VHJhY2sgdGhhdCBhcmVcbiAgICogZmxhZ2dlZCBmb3IgYXV0b21hdGljIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmNsZWFudXBBdXRvVGV4dFRyYWNrcyA9IGZ1bmN0aW9uIGNsZWFudXBBdXRvVGV4dFRyYWNrcygpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuYXV0b1JlbW90ZVRleHRUcmFja3NfIHx8IFtdO1xuICAgIHZhciBpID0gbGlzdC5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgdHJhY2sgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLnJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjayk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgdGVjaCwgd2hpY2ggd2lsbCByZW1vdmVzIGFsbCBzb3VyY2VzIGFuZCByZXNldCB0aGUgaW50ZXJuYWwgcmVhZHlTdGF0ZS5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHt9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IGFuIGVycm9yIG9uIHRoZSBUZWNoLlxuICAgKlxuICAgKiBAcGFyYW0ge01lZGlhRXJyb3J9IFtlcnJdXG4gICAqICAgICAgICBFcnJvciB0byBzZXQgb24gdGhlIFRlY2hcbiAgICpcbiAgICogQHJldHVybiB7TWVkaWFFcnJvcnxudWxsfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGVycm9yIG9iamVjdCBvbiB0aGUgdGVjaCwgb3IgbnVsbCBpZiB0aGVyZSBpc24ndCBvbmUuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZXJyb3JfID0gbmV3IE1lZGlhRXJyb3IoZXJyKTtcbiAgICAgIHRoaXMudHJpZ2dlcignZXJyb3InKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXJyb3JfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgVGltZVJhbmdlYHMgdGhhdCBoYXZlIGJlZW4gcGxheWVkIHRocm91Z2ggZm9yIHRoZSBjdXJyZW50IHNvdXJjZS5cbiAgICpcbiAgICogPiBOT1RFOiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGluY29tcGxldGUuIEl0IGRvZXMgbm90IHRyYWNrIHRoZSBwbGF5ZWQgYFRpbWVSYW5nZWAuXG4gICAqICAgICAgICAgSXQgb25seSBjaGVja3Mgd2V0aGVyIHRoZSBzb3VyY2UgaGFzIHBsYXllZCBhdCBhbGwgb3Igbm90LlxuICAgKlxuICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XG4gICAqICAgICAgICAgLSBBIHNpbmdsZSB0aW1lIHJhbmdlIGlmIHRoaXMgdmlkZW8gaGFzIHBsYXllZFxuICAgKiAgICAgICAgIC0gQW4gZW1wdHkgc2V0IG9mIHJhbmdlcyBpZiBub3QuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUucGxheWVkID0gZnVuY3Rpb24gcGxheWVkKCkge1xuICAgIGlmICh0aGlzLmhhc1N0YXJ0ZWRfKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlcygwLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXMoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2F1c2VzIGEgbWFudWFsIHRpbWUgdXBkYXRlIHRvIG9jY3VyIGlmIHtAbGluayBUZWNoI21hbnVhbFRpbWVVcGRhdGVzT259IHdhc1xuICAgKiBwcmV2aW91c2x5IGNhbGxlZC5cbiAgICpcbiAgICogQGZpcmVzIFRlY2gjdGltZXVwZGF0ZVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnNldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24gc2V0Q3VycmVudFRpbWUoKSB7XG4gICAgLy8gaW1wcm92ZSB0aGUgYWNjdXJhY3kgb2YgbWFudWFsIHRpbWV1cGRhdGVzXG4gICAgaWYgKHRoaXMubWFudWFsVGltZVVwZGF0ZXMpIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBtYW51YWwgYHRpbWV1cGRhdGVgIGV2ZW50LlxuICAgICAgICpcbiAgICAgICAqIEBldmVudCBUZWNoI3RpbWV1cGRhdGVcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVHVybiBvbiBsaXN0ZW5lcnMgZm9yIHtAbGluayBWaWRlb1RyYWNrTGlzdH0sIHtAbGluayB7QXVkaW9UcmFja0xpc3R9LCBhbmRcbiAgICoge0BsaW5rIFRleHRUcmFja0xpc3R9IGV2ZW50cy5cbiAgICpcbiAgICogVGhpcyBhZGRzIHtAbGluayBFdmVudFRhcmdldH5FdmVudExpc3RlbmVyc30gZm9yIGBhZGR0cmFja2AsIGFuZCAgYHJlbW92ZXRyYWNrYC5cbiAgICpcbiAgICogQGZpcmVzIFRlY2gjYXVkaW90cmFja2NoYW5nZVxuICAgKiBAZmlyZXMgVGVjaCN2aWRlb3RyYWNrY2hhbmdlXG4gICAqIEBmaXJlcyBUZWNoI3RleHR0cmFja2NoYW5nZVxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmluaXRUcmFja0xpc3RlbmVycyA9IGZ1bmN0aW9uIGluaXRUcmFja0xpc3RlbmVycygpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRyYWNrcyBhcmUgYWRkZWQgb3IgcmVtb3ZlZCBvbiB0aGUgVGVjaCB7QGxpbmsgQXVkaW9UcmFja0xpc3R9XG4gICAgICpcbiAgICAgKiBAZXZlbnQgVGVjaCNhdWRpb3RyYWNrY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdHJhY2tzIGFyZSBhZGRlZCBvciByZW1vdmVkIG9uIHRoZSBUZWNoIHtAbGluayBWaWRlb1RyYWNrTGlzdH1cbiAgICAgKlxuICAgICAqIEBldmVudCBUZWNoI3ZpZGVvdHJhY2tjaGFuZ2VcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0cmFja3MgYXJlIGFkZGVkIG9yIHJlbW92ZWQgb24gdGhlIFRlY2gge0BsaW5rIFRleHRUcmFja0xpc3R9XG4gICAgICpcbiAgICAgKiBAZXZlbnQgVGVjaCN0ZXh0dHJhY2tjaGFuZ2VcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgTk9STUFMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBwcm9wcyA9IE5PUk1BTFtuYW1lXTtcbiAgICAgIHZhciB0cmFja0xpc3RDaGFuZ2VzID0gZnVuY3Rpb24gdHJhY2tMaXN0Q2hhbmdlcygpIHtcbiAgICAgICAgX3RoaXMzLnRyaWdnZXIobmFtZSArICd0cmFja2NoYW5nZScpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHRyYWNrcyA9IF90aGlzM1twcm9wcy5nZXR0ZXJOYW1lXSgpO1xuXG4gICAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB0cmFja0xpc3RDaGFuZ2VzKTtcbiAgICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRyYWNrTGlzdENoYW5nZXMpO1xuXG4gICAgICBfdGhpczMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHRyYWNrTGlzdENoYW5nZXMpO1xuICAgICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0cmFja0xpc3RDaGFuZ2VzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbXVsYXRlIFRleHRUcmFja3MgdXNpbmcgdnR0LmpzIGlmIG5lY2Vzc2FyeVxuICAgKlxuICAgKiBAZmlyZXMgVGVjaCN2dHRqc2xvYWRlZFxuICAgKiBAZmlyZXMgVGVjaCN2dHRqc2Vycm9yXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuYWRkV2ViVnR0U2NyaXB0XyA9IGZ1bmN0aW9uIGFkZFdlYlZ0dFNjcmlwdF8oKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAod2luZG93LldlYlZUVCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxseSwgVGVjaC5lbF8gaXMgYSBjaGlsZCBvZiBhIGR1bW15LWRpdiB3YWl0IHVudGlsIHRoZSBDb21wb25lbnQgc3lzdGVtXG4gICAgLy8gc2lnbmFscyB0aGF0IHRoZSBUZWNoIGlzIHJlYWR5IGF0IHdoaWNoIHBvaW50IFRlY2guZWxfIGlzIHBhcnQgb2YgdGhlIERPTVxuICAgIC8vIGJlZm9yZSBpbnNlcnRpbmcgdGhlIFdlYlZUVCBzY3JpcHRcbiAgICBpZiAoZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLmVsKCkpKSB7XG5cbiAgICAgIC8vIGxvYWQgdmlhIHJlcXVpcmUgaWYgYXZhaWxhYmxlIGFuZCB2dHQuanMgc2NyaXB0IGxvY2F0aW9uIHdhcyBub3QgcGFzc2VkIGluXG4gICAgICAvLyBhcyBhbiBvcHRpb24uIG5vdnR0IGJ1aWxkcyB3aWxsIHR1cm4gdGhlIGFib3ZlIHJlcXVpcmUgY2FsbCBpbnRvIGFuIGVtcHR5IG9iamVjdFxuICAgICAgLy8gd2hpY2ggd2lsbCBjYXVzZSB0aGlzIGlmIGNoZWNrIHRvIGFsd2F5cyBmYWlsLlxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnNfWyd2dHQuanMnXSAmJiBpc1BsYWluKHZ0dCkgJiYgT2JqZWN0LmtleXModnR0KS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcigndnR0anNsb2FkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBsb2FkIHZ0dC5qcyB2aWEgdGhlIHNjcmlwdCBsb2NhdGlvbiBvcHRpb24gb3IgdGhlIGNkbiBvZiBubyBsb2NhdGlvbiB3YXNcbiAgICAgIC8vIHBhc3NlZCBpblxuICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gICAgICBzY3JpcHQuc3JjID0gdGhpcy5vcHRpb25zX1sndnR0LmpzJ10gfHwgJ2h0dHBzOi8vdmpzLnplbmNkbi5uZXQvdnR0anMvMC4xMi40L3Z0dC5taW4uanMnO1xuICAgICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdnR0LmpzIGlzIGxvYWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFRlY2gjdnR0anNsb2FkZWRcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXM0LnRyaWdnZXIoJ3Z0dGpzbG9hZGVkJyk7XG4gICAgICB9O1xuICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIHZ0dC5qcyB3YXMgbm90IGxvYWRlZCBkdWUgdG8gYW4gZXJyb3JcbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFRlY2gjdnR0anNsb2FkZWRcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXM0LnRyaWdnZXIoJ3Z0dGpzZXJyb3InKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzY3JpcHQub25sb2FkID0gbnVsbDtcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICAvLyBidXQgaGF2ZSBub3QgbG9hZGVkIHlldCBhbmQgd2Ugc2V0IGl0IHRvIHRydWUgYmVmb3JlIHRoZSBpbmplY3Qgc28gdGhhdFxuICAgICAgLy8gd2UgZG9uJ3Qgb3ZlcndyaXRlIHRoZSBpbmplY3RlZCB3aW5kb3cuV2ViVlRUIGlmIGl0IGxvYWRzIHJpZ2h0IGF3YXlcbiAgICAgIHdpbmRvdy5XZWJWVFQgPSB0cnVlO1xuICAgICAgdGhpcy5lbCgpLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWFkeSh0aGlzLmFkZFdlYlZ0dFNjcmlwdF8pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRW11bGF0ZSB0ZXh0dHJhY2tzXG4gICAqXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuZW11bGF0ZVRleHRUcmFja3MgPSBmdW5jdGlvbiBlbXVsYXRlVGV4dFRyYWNrcygpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnRleHRUcmFja3MoKTtcbiAgICB2YXIgcmVtb3RlVHJhY2tzID0gdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCk7XG4gICAgdmFyIGhhbmRsZUFkZFRyYWNrID0gZnVuY3Rpb24gaGFuZGxlQWRkVHJhY2soZSkge1xuICAgICAgcmV0dXJuIHRyYWNrcy5hZGRUcmFjayhlLnRyYWNrKTtcbiAgICB9O1xuICAgIHZhciBoYW5kbGVSZW1vdmVUcmFjayA9IGZ1bmN0aW9uIGhhbmRsZVJlbW92ZVRyYWNrKGUpIHtcbiAgICAgIHJldHVybiB0cmFja3MucmVtb3ZlVHJhY2soZS50cmFjayk7XG4gICAgfTtcblxuICAgIHJlbW90ZVRyYWNrcy5vbignYWRkdHJhY2snLCBoYW5kbGVBZGRUcmFjayk7XG4gICAgcmVtb3RlVHJhY2tzLm9uKCdyZW1vdmV0cmFjaycsIGhhbmRsZVJlbW92ZVRyYWNrKTtcblxuICAgIHRoaXMuYWRkV2ViVnR0U2NyaXB0XygpO1xuXG4gICAgdmFyIHVwZGF0ZURpc3BsYXkgPSBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgcmV0dXJuIF90aGlzNS50cmlnZ2VyKCd0ZXh0dHJhY2tjaGFuZ2UnKTtcbiAgICB9O1xuXG4gICAgdmFyIHRleHRUcmFja3NDaGFuZ2VzID0gZnVuY3Rpb24gdGV4dFRyYWNrc0NoYW5nZXMoKSB7XG4gICAgICB1cGRhdGVEaXNwbGF5KCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgICB0cmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdjdWVjaGFuZ2UnLCB1cGRhdGVEaXNwbGF5KTtcbiAgICAgICAgaWYgKHRyYWNrLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2N1ZWNoYW5nZScsIHVwZGF0ZURpc3BsYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRleHRUcmFja3NDaGFuZ2VzKCk7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRleHRUcmFja3NDaGFuZ2VzKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0ZXh0VHJhY2tzQ2hhbmdlcyk7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuXG4gICAgdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlbW90ZVRyYWNrcy5vZmYoJ2FkZHRyYWNrJywgaGFuZGxlQWRkVHJhY2spO1xuICAgICAgcmVtb3RlVHJhY2tzLm9mZigncmVtb3ZldHJhY2snLCBoYW5kbGVSZW1vdmVUcmFjayk7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgICAgdHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgdXBkYXRlRGlzcGxheSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgcmV0dXJucyBhIHJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrfSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBraW5kXG4gICAqICAgICAgICBgVGV4dFRyYWNrYCBraW5kIChzdWJ0aXRsZXMsIGNhcHRpb25zLCBkZXNjcmlwdGlvbnMsIGNoYXB0ZXJzLCBvciBtZXRhZGF0YSlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYWJlbF1cbiAgICogICAgICAgIExhYmVsIHRvIGlkZW50aWZ5IHRoZSB0ZXh0IHRyYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2VdXG4gICAqICAgICAgICBUd28gbGV0dGVyIGxhbmd1YWdlIGFiYnJldmlhdGlvblxuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2t9XG4gICAqICAgICAgICAgVGhlIFRleHRUcmFjayB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5hZGRUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKSB7XG4gICAgaWYgKCFraW5kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHRUcmFjayBraW5kIGlzIHJlcXVpcmVkIGJ1dCB3YXMgbm90IHByb3ZpZGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZVRyYWNrSGVscGVyKHRoaXMsIGtpbmQsIGxhYmVsLCBsYW5ndWFnZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlbXVsYXRlZCBUZXh0VHJhY2sgZm9yIHVzZSBieSBhZGRSZW1vdGVUZXh0VHJhY2tcbiAgICpcbiAgICogVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgdGhhdCBpbmhlcml0IGZyb21cbiAgICogVGVjaCBpbiBvcmRlciB0byBjcmVhdGUgbmF0aXZlIG9yIGN1c3RvbSBUZXh0VHJhY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiB0aGUgb3B0aW9ucyB0byBpbml0aWFsaXplIHRoZSBUZXh0VHJhY2sgd2l0aC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmtpbmRdXG4gICAqICAgICAgICBgVGV4dFRyYWNrYCBraW5kIChzdWJ0aXRsZXMsIGNhcHRpb25zLCBkZXNjcmlwdGlvbnMsIGNoYXB0ZXJzLCBvciBtZXRhZGF0YSkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbF0uXG4gICAqICAgICAgICBMYWJlbCB0byBpZGVudGlmeSB0aGUgdGV4dCB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2VdXG4gICAqICAgICAgICBUd28gbGV0dGVyIGxhbmd1YWdlIGFiYnJldmlhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7SFRNTFRyYWNrRWxlbWVudH1cbiAgICogICAgICAgICBUaGUgdHJhY2sgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBUZWNoLnByb3RvdHlwZS5jcmVhdGVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVSZW1vdGVUZXh0VHJhY2sob3B0aW9ucykge1xuICAgIHZhciB0cmFjayA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICB0ZWNoOiB0aGlzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IFJFTU9URS5yZW1vdGVUZXh0RWwuVHJhY2tDbGFzcyh0cmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZW1vdGUgdGV4dCB0cmFjayBvYmplY3QgYW5kIHJldHVybnMgYW4gaHRtbCB0cmFjayBlbGVtZW50LlxuICAgKlxuICAgKiA+IE5vdGU6IFRoaXMgY2FuIGJlIGFuIGVtdWxhdGVkIHtAbGluayBIVE1MVHJhY2tFbGVtZW50fSBvciBhIG5hdGl2ZSBvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBTZWUge0BsaW5rIFRlY2gjY3JlYXRlUmVtb3RlVGV4dFRyYWNrfSBmb3IgbW9yZSBkZXRhaWxlZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttYW51YWxDbGVhbnVwPXRydWVdXG4gICAqICAgICAgICAtIFdoZW4gZmFsc2U6IHRoZSBUZXh0VHJhY2sgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgZnJvbSB0aGUgdmlkZW9cbiAgICogICAgICAgICAgZWxlbWVudCB3aGVuZXZlciB0aGUgc291cmNlIGNoYW5nZXNcbiAgICogICAgICAgIC0gV2hlbiBUcnVlOiBUaGUgVGV4dFRyYWNrIHdpbGwgaGF2ZSB0byBiZSBjbGVhbmVkIHVwIG1hbnVhbGx5XG4gICAqXG4gICAqIEByZXR1cm4ge0hUTUxUcmFja0VsZW1lbnR9XG4gICAqICAgICAgICAgQW4gSHRtbCBUcmFjayBFbGVtZW50LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBUaGUgZGVmYXVsdCBmdW5jdGlvbmFsaXR5IGZvciB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgZXF1aXZhbGVudFxuICAgKiAgICAgICAgICAgICB0byBcIm1hbnVhbENsZWFudXA9ZmFsc2VcIiBpbiB0aGUgZnV0dXJlLiBUaGUgbWFudWFsQ2xlYW51cCBwYXJhbWV0ZXIgd2lsbFxuICAgKiAgICAgICAgICAgICBhbHNvIGJlIHJlbW92ZWQuXG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuYWRkUmVtb3RlVGV4dFRyYWNrID0gZnVuY3Rpb24gYWRkUmVtb3RlVGV4dFRyYWNrKCkge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBtYW51YWxDbGVhbnVwID0gYXJndW1lbnRzWzFdO1xuXG4gICAgdmFyIGh0bWxUcmFja0VsZW1lbnQgPSB0aGlzLmNyZWF0ZVJlbW90ZVRleHRUcmFjayhvcHRpb25zKTtcblxuICAgIGlmIChtYW51YWxDbGVhbnVwICE9PSB0cnVlICYmIG1hbnVhbENsZWFudXAgIT09IGZhbHNlKSB7XG4gICAgICAvLyBkZXByZWNhdGlvbiB3YXJuaW5nXG4gICAgICBsb2ckMS53YXJuKCdDYWxsaW5nIGFkZFJlbW90ZVRleHRUcmFjayB3aXRob3V0IGV4cGxpY2l0bHkgc2V0dGluZyB0aGUgXCJtYW51YWxDbGVhbnVwXCIgcGFyYW1ldGVyIHRvIGB0cnVlYCBpcyBkZXByZWNhdGVkIGFuZCBkZWZhdWx0IHRvIGBmYWxzZWAgaW4gZnV0dXJlIHZlcnNpb24gb2YgdmlkZW8uanMnKTtcbiAgICAgIG1hbnVhbENsZWFudXAgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIHN0b3JlIEhUTUxUcmFja0VsZW1lbnQgYW5kIFRleHRUcmFjayB0byByZW1vdGUgbGlzdFxuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrRWxzKCkuYWRkVHJhY2tFbGVtZW50XyhodG1sVHJhY2tFbGVtZW50KTtcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja3MoKS5hZGRUcmFjayhodG1sVHJhY2tFbGVtZW50LnRyYWNrKTtcblxuICAgIGlmIChtYW51YWxDbGVhbnVwICE9PSB0cnVlKSB7XG4gICAgICAvLyBjcmVhdGUgdGhlIFRleHRUcmFja0xpc3QgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczYuYXV0b1JlbW90ZVRleHRUcmFja3NfLmFkZFRyYWNrKGh0bWxUcmFja0VsZW1lbnQudHJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWxUcmFja0VsZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHJlbW90ZSB0ZXh0IHRyYWNrIGZyb20gdGhlIHJlbW90ZSBgVGV4dFRyYWNrTGlzdGAuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICAgKiAgICAgICAgYFRleHRUcmFja2AgdG8gcmVtb3ZlIGZyb20gdGhlIGBUZXh0VHJhY2tMaXN0YFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLnJlbW92ZVJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjaykge1xuICAgIHZhciB0cmFja0VsZW1lbnQgPSB0aGlzLnJlbW90ZVRleHRUcmFja0VscygpLmdldFRyYWNrRWxlbWVudEJ5VHJhY2tfKHRyYWNrKTtcblxuICAgIC8vIHJlbW92ZSBIVE1MVHJhY2tFbGVtZW50IGFuZCBUZXh0VHJhY2sgZnJvbSByZW1vdGUgbGlzdFxuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrRWxzKCkucmVtb3ZlVHJhY2tFbGVtZW50Xyh0cmFja0VsZW1lbnQpO1xuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrcygpLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICB0aGlzLmF1dG9SZW1vdGVUZXh0VHJhY2tzXy5yZW1vdmVUcmFjayh0cmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYXZhaWxhYmxlIG1lZGlhIHBsYXliYWNrIHF1YWxpdHkgbWV0cmljcyBhcyBzcGVjaWZpZWQgYnkgdGhlIFczQydzIE1lZGlhXG4gICAqIFBsYXliYWNrIFF1YWxpdHkgQVBJLlxuICAgKlxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3dpY2cuZ2l0aHViLmlvL21lZGlhLXBsYXliYWNrLXF1YWxpdHl9XG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBBbiBvYmplY3Qgd2l0aCBzdXBwb3J0ZWQgbWVkaWEgcGxheWJhY2sgcXVhbGl0eSBtZXRyaWNzXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID0gZnVuY3Rpb24gZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0byBzZXQgYSBwb3N0ZXIgZnJvbSBhIGBUZWNoYC5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuc2V0UG9zdGVyID0gZnVuY3Rpb24gc2V0UG9zdGVyKCkge307XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRvIGNoZWNrIGZvciB0aGUgcHJlc2VuY2Ugb2YgdGhlICdwbGF5c2luaW5lJyA8dmlkZW8+IGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUucGxheXNpbmxpbmUgPSBmdW5jdGlvbiBwbGF5c2lubGluZSgpIHt9O1xuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCB0byBzZXQgb3IgdW5zZXQgdGhlICdwbGF5c2luaW5lJyA8dmlkZW8+IGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgVGVjaC5wcm90b3R5cGUuc2V0UGxheXNpbmxpbmUgPSBmdW5jdGlvbiBzZXRQbGF5c2lubGluZSgpIHt9O1xuXG4gIC8qXG4gICAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiBtaW1lLXR5cGUuXG4gICAqXG4gICAqIFRoZSBiYXNlIHRlY2ggZG9lcyBub3Qgc3VwcG9ydCBhbnkgdHlwZSwgYnV0IHNvdXJjZSBoYW5kbGVycyBtaWdodFxuICAgKiBvdmVyd3JpdGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0eXBlXG4gICAqICAgICAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrIGZvciBzdXBwb3J0XG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciBlbXB0eSBzdHJpbmdcbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvY2FuUGxheVR5cGV9XG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuXG4gIFRlY2gucHJvdG90eXBlLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gY2FuUGxheVR5cGUoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgdGhpcyB0ZWNoLlxuICAgKlxuICAgKiBUaGUgYmFzZSB0ZWNoIGRvZXMgbm90IHN1cHBvcnQgYW55IHR5cGUsIGJ1dCBzb3VyY2UgaGFuZGxlcnMgbWlnaHRcbiAgICogb3ZlcndyaXRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBUaGUgbWVkaWEgdHlwZSB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgdGhlIG5hdGl2ZSB2aWRlbyBlbGVtZW50J3MgcmVzcG9uc2VcbiAgICovXG5cblxuICBUZWNoLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gY2FuUGxheVR5cGUoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gc291cmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNPYmpcbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIHRlY2hcbiAgICogQHJldHVybiB7c3RyaW5nfSAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKi9cblxuXG4gIFRlY2guY2FuUGxheVNvdXJjZSA9IGZ1bmN0aW9uIGNhblBsYXlTb3VyY2Uoc3JjT2JqLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFRlY2guY2FuUGxheVR5cGUoc3JjT2JqLnR5cGUpO1xuICB9O1xuXG4gIC8qXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBhcmd1bWVudCBpcyBhIFRlY2ggb3Igbm90LlxuICAgKiBDYW4gYmUgcGFzc2VkIGVpdGhlciBhIENsYXNzIGxpa2UgYEh0bWw1YCBvciBhIGluc3RhbmNlIGxpa2UgYHBsYXllci50ZWNoX2BcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudFxuICAgKiAgICAgICAgVGhlIGl0ZW0gdG8gY2hlY2tcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBXaGV0aGVyIGl0IGlzIGEgdGVjaCBvciBub3RcbiAgICogICAgICAgICAtIFRydWUgaWYgaXQgaXMgYSB0ZWNoXG4gICAqICAgICAgICAgLSBGYWxzZSBpZiBpdCBpcyBub3RcbiAgICovXG5cblxuICBUZWNoLmlzVGVjaCA9IGZ1bmN0aW9uIGlzVGVjaChjb21wb25lbnQpIHtcbiAgICByZXR1cm4gY29tcG9uZW50LnByb3RvdHlwZSBpbnN0YW5jZW9mIFRlY2ggfHwgY29tcG9uZW50IGluc3RhbmNlb2YgVGVjaCB8fCBjb21wb25lbnQgPT09IFRlY2g7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGBUZWNoYCBpbnRvIGEgc2hhcmVkIGxpc3QgZm9yIHZpZGVvanMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICBOYW1lIG9mIHRoZSBgVGVjaGAgdG8gcmVnaXN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0ZWNoXG4gICAqICAgICAgICBUaGUgYFRlY2hgIGNsYXNzIHRvIHJlZ2lzdGVyLlxuICAgKi9cblxuXG4gIFRlY2gucmVnaXN0ZXJUZWNoID0gZnVuY3Rpb24gcmVnaXN0ZXJUZWNoKG5hbWUsIHRlY2gpIHtcbiAgICBpZiAoIVRlY2gudGVjaHNfKSB7XG4gICAgICBUZWNoLnRlY2hzXyA9IHt9O1xuICAgIH1cblxuICAgIGlmICghVGVjaC5pc1RlY2godGVjaCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVjaCAnICsgbmFtZSArICcgbXVzdCBiZSBhIFRlY2gnKTtcbiAgICB9XG5cbiAgICBpZiAoIVRlY2guY2FuUGxheVR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGVjaHMgbXVzdCBoYXZlIGEgc3RhdGljIGNhblBsYXlUeXBlIG1ldGhvZCBvbiB0aGVtJyk7XG4gICAgfVxuICAgIGlmICghVGVjaC5jYW5QbGF5U291cmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlY2hzIG11c3QgaGF2ZSBhIHN0YXRpYyBjYW5QbGF5U291cmNlIG1ldGhvZCBvbiB0aGVtJyk7XG4gICAgfVxuXG4gICAgbmFtZSA9IHRvVGl0bGVDYXNlKG5hbWUpO1xuXG4gICAgVGVjaC50ZWNoc19bbmFtZV0gPSB0ZWNoO1xuICAgIGlmIChuYW1lICE9PSAnVGVjaCcpIHtcbiAgICAgIC8vIGNhbWVsIGNhc2UgdGhlIHRlY2hOYW1lIGZvciB1c2UgaW4gdGVjaE9yZGVyXG4gICAgICBUZWNoLmRlZmF1bHRUZWNoT3JkZXJfLnB1c2gobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0ZWNoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBgVGVjaGAgZnJvbSB0aGUgc2hhcmVkIGxpc3QgYnkgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIGBjYW1lbENhc2VgIG9yIGBUaXRsZUNhc2VgIG5hbWUgb2YgdGhlIFRlY2ggdG8gZ2V0XG4gICAqXG4gICAqIEByZXR1cm4ge1RlY2h8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIFRoZSBgVGVjaGAgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIHdhcyBubyB0ZWNoIHdpdGggdGhlIG5hbWUgcmVxdXN0ZWQuXG4gICAqL1xuXG5cbiAgVGVjaC5nZXRUZWNoID0gZnVuY3Rpb24gZ2V0VGVjaChuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmFtZSA9IHRvVGl0bGVDYXNlKG5hbWUpO1xuXG4gICAgaWYgKFRlY2gudGVjaHNfICYmIFRlY2gudGVjaHNfW25hbWVdKSB7XG4gICAgICByZXR1cm4gVGVjaC50ZWNoc19bbmFtZV07XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cudmlkZW9qcyAmJiB3aW5kb3cudmlkZW9qc1tuYW1lXSkge1xuICAgICAgbG9nJDEud2FybignVGhlICcgKyBuYW1lICsgJyB0ZWNoIHdhcyBhZGRlZCB0byB0aGUgdmlkZW9qcyBvYmplY3Qgd2hlbiBpdCBzaG91bGQgYmUgcmVnaXN0ZXJlZCB1c2luZyB2aWRlb2pzLnJlZ2lzdGVyVGVjaChuYW1lLCB0ZWNoKScpO1xuICAgICAgcmV0dXJuIHdpbmRvdy52aWRlb2pzW25hbWVdO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGVjaDtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBWaWRlb1RyYWNrTGlzdH1cbiAqXG4gKiBAcmV0dXJucyB7VmlkZW9UcmFja0xpc3R9XG4gKiBAbWV0aG9kIFRlY2gucHJvdG90eXBlLnZpZGVvVHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBBdWRpb1RyYWNrTGlzdH1cbiAqXG4gKiBAcmV0dXJucyB7QXVkaW9UcmFja0xpc3R9XG4gKiBAbWV0aG9kIFRlY2gucHJvdG90eXBlLmF1ZGlvVHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICpcbiAqIEByZXR1cm5zIHtUZXh0VHJhY2tMaXN0fVxuICogQG1ldGhvZCBUZWNoLnByb3RvdHlwZS50ZXh0VHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHJlbW90ZSBlbGVtZW50IHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICpcbiAqIEByZXR1cm5zIHtUZXh0VHJhY2tMaXN0fVxuICogQG1ldGhvZCBUZWNoLnByb3RvdHlwZS5yZW1vdGVUZXh0VHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHJlbW90ZSBlbGVtZW50IHtAbGluayBIdG1sVHJhY2tFbGVtZW50TGlzdH1cbiAqXG4gKiBAcmV0dXJucyB7SHRtbFRyYWNrRWxlbWVudExpc3R9XG4gKiBAbWV0aG9kIFRlY2gucHJvdG90eXBlLnJlbW90ZVRleHRUcmFja0Vsc1xuICovXG5cbkFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwcm9wcyA9IEFMTFtuYW1lXTtcblxuICBUZWNoLnByb3RvdHlwZVtwcm9wcy5nZXR0ZXJOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzW3Byb3BzLnByaXZhdGVOYW1lXSA9IHRoaXNbcHJvcHMucHJpdmF0ZU5hbWVdIHx8IG5ldyBwcm9wcy5MaXN0Q2xhc3MoKTtcbiAgICByZXR1cm4gdGhpc1twcm9wcy5wcml2YXRlTmFtZV07XG4gIH07XG59KTtcblxuLyoqXG4gKiBMaXN0IG9mIGFzc29jaWF0ZWQgdGV4dCB0cmFja3NcbiAqXG4gKiBAdHlwZSB7VGV4dFRyYWNrTGlzdH1cbiAqIEBwcml2YXRlXG4gKiBAcHJvcGVydHkgVGVjaCN0ZXh0VHJhY2tzX1xuICovXG5cbi8qKlxuICogTGlzdCBvZiBhc3NvY2lhdGVkIGF1ZGlvIHRyYWNrcy5cbiAqXG4gKiBAdHlwZSB7QXVkaW9UcmFja0xpc3R9XG4gKiBAcHJpdmF0ZVxuICogQHByb3BlcnR5IFRlY2gjYXVkaW9UcmFja3NfXG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIGFzc29jaWF0ZWQgdmlkZW8gdHJhY2tzLlxuICpcbiAqIEB0eXBlIHtWaWRlb1RyYWNrTGlzdH1cbiAqIEBwcml2YXRlXG4gKiBAcHJvcGVydHkgVGVjaCN2aWRlb1RyYWNrc19cbiAqL1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB2b2x1bWUgY29udHJvbC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzVm9sdW1lQ29udHJvbCA9IHRydWU7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdldGhlciB0aGUgYFRlY2hgIHN1cHBvcnQgZnVsbHNjcmVlbiByZXNpemUgY29udHJvbC5cbiAqIFJlc2l6aW5nIHBsdWdpbnMgdXNpbmcgcmVxdWVzdCBmdWxsc2NyZWVuIHJlbG9hZHMgdGhlIHBsdWdpblxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNGdWxsc2NyZWVuUmVzaXplID0gZmFsc2U7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIGNoYW5naW5nIHRoZSBzcGVlZCBhdCB3aGljaCB0aGUgdmlkZW9cbiAqIHBsYXlzLiBFeGFtcGxlczpcbiAqICAgLSBTZXQgcGxheWVyIHRvIHBsYXkgMnggKHR3aWNlKSBhcyBmYXN0XG4gKiAgIC0gU2V0IHBsYXllciB0byBwbGF5IDAuNXggKGhhbGYpIGFzIGZhc3RcbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzUGxheWJhY2tSYXRlID0gZmFsc2U7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIHRoZSBgcHJvZ3Jlc3NgIGV2ZW50LiBUaGlzIGlzIGN1cnJlbnRseVxuICogbm90IHRyaWdnZXJlZCBieSB2aWRlby1qcy1zd2YuIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSBpZlxuICoge0BsaW5rIFRlY2gjbWFudWFsUHJvZ3Jlc3NPbn0gc2hvdWxkIGJlIGNhbGxlZC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cblRlY2gucHJvdG90eXBlLmZlYXR1cmVzUHJvZ3Jlc3NFdmVudHMgPSBmYWxzZTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2V0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgdGhlIGB0aW1ldXBkYXRlYCBldmVudC4gVGhpcyBpcyBjdXJyZW50bHlcbiAqIG5vdCB0cmlnZ2VyZWQgYnkgdmlkZW8tanMtc3dmLiBUaGlzIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgaWZcbiAqIHtAbGluayBUZWNoI21hbnVhbFRpbWVVcGRhdGVzfSBzaG91bGQgYmUgY2FsbGVkLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNUaW1ldXBkYXRlRXZlbnRzID0gZmFsc2U7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIHRoZSBuYXRpdmUgYFRleHRUcmFja2BzLlxuICogVGhpcyB3aWxsIGhlbHAgdXMgaW50ZWdyYXRlIHdpdGggbmF0aXZlIGBUZXh0VHJhY2tgcyBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGVtLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzID0gZmFsc2U7XG5cbi8qKlxuICogQSBmdW5jdGlvbmFsIG1peGluIGZvciB0ZWNocyB0aGF0IHdhbnQgdG8gdXNlIHRoZSBTb3VyY2UgSGFuZGxlciBwYXR0ZXJuLlxuICogU291cmNlIGhhbmRsZXJzIGFyZSBzY3JpcHRzIGZvciBoYW5kbGluZyBzcGVjaWZpYyBmb3JtYXRzLlxuICogVGhlIHNvdXJjZSBoYW5kbGVyIHBhdHRlcm4gaXMgdXNlZCBmb3IgYWRhcHRpdmUgZm9ybWF0cyAoSExTLCBEQVNIKSB0aGF0XG4gKiBtYW51YWxseSBsb2FkIHZpZGVvIGRhdGEgYW5kIGZlZWQgaXQgaW50byBhIFNvdXJjZSBCdWZmZXIgKE1lZGlhIFNvdXJjZSBFeHRlbnNpb25zKVxuICogRXhhbXBsZTogYFRlY2gud2l0aFNvdXJjZUhhbmRsZXJzLmNhbGwoTXlUZWNoKTtgXG4gKlxuICogQHBhcmFtIHtUZWNofSBfVGVjaFxuICogICAgICAgIFRoZSB0ZWNoIHRvIGFkZCBzb3VyY2UgaGFuZGxlciBmdW5jdGlvbnMgdG8uXG4gKlxuICogQG1peGVzIFRlY2h+U291cmNlSGFuZGxlckFkZGl0aW9uc1xuICovXG5UZWNoLndpdGhTb3VyY2VIYW5kbGVycyA9IGZ1bmN0aW9uIChfVGVjaCkge1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHNvdXJjZSBoYW5kbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogICAgICAgIFRoZSBzb3VyY2UgaGFuZGxlciBjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuICAgKiAgICAgICAgUmVnaXN0ZXIgaXQgYXQgdGhlIGZvbGxvd2luZyBpbmRleFxuICAgKi9cbiAgX1RlY2gucmVnaXN0ZXJTb3VyY2VIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIsIGluZGV4KSB7XG4gICAgdmFyIGhhbmRsZXJzID0gX1RlY2guc291cmNlSGFuZGxlcnM7XG5cbiAgICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgICBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzID0gW107XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGFkZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG4gICAgICBpbmRleCA9IGhhbmRsZXJzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDAsIGhhbmRsZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gdHlwZS4gQWxzbyBjaGVja3MgdGhlXG4gICAqIFRlY2hzIHNvdXJjZUhhbmRsZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgIFRoZSBtaW1ldHlwZSB0byBjaGVjay5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gICAqL1xuICBfVGVjaC5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gX1RlY2guc291cmNlSGFuZGxlcnMgfHwgW107XG4gICAgdmFyIGNhbiA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbiA9IGhhbmRsZXJzW2ldLmNhblBsYXlUeXBlKHR5cGUpO1xuXG4gICAgICBpZiAoY2FuKSB7XG4gICAgICAgIHJldHVybiBjYW47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBzb3VyY2UgaGFuZGxlciB0aGF0IHN1cHBvcnRzIHRoZSBzb3VyY2UuXG4gICAqXG4gICAqIFRPRE86IEFuc3dlciBxdWVzdGlvbjogc2hvdWxkICdwcm9iYWJseScgYmUgcHJpb3JpdGl6ZWQgb3ZlciAnbWF5YmUnXG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNvdXJjZVxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgdGVjaFxuICAgKlxuICAgKiBAcmV0dXJuIHtTb3VyY2VIYW5kbGVyfG51bGx9XG4gICAqICAgICAgICAgIFRoZSBmaXJzdCBzb3VyY2UgaGFuZGxlciB0aGF0IHN1cHBvcnRzIHRoZSBzb3VyY2Ugb3IgbnVsbCBpZlxuICAgKiAgICAgICAgICBubyBTb3VyY2VIYW5kbGVyIHN1cHBvcnRzIHRoZSBzb3VyY2VcbiAgICovXG4gIF9UZWNoLnNlbGVjdFNvdXJjZUhhbmRsZXIgPSBmdW5jdGlvbiAoc291cmNlLCBvcHRpb25zKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gX1RlY2guc291cmNlSGFuZGxlcnMgfHwgW107XG4gICAgdmFyIGNhbiA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbiA9IGhhbmRsZXJzW2ldLmNhbkhhbmRsZVNvdXJjZShzb3VyY2UsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoY2FuKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHRlY2ggY2FuIHN1cHBvcnQgdGhlIGdpdmVuIHNvdXJjZS5cbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc3JjT2JqXG4gICAqICAgICAgICBUaGUgc291cmNlIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgICAgICAgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSB0ZWNoXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKi9cbiAgX1RlY2guY2FuUGxheVNvdXJjZSA9IGZ1bmN0aW9uIChzcmNPYmosIG9wdGlvbnMpIHtcbiAgICB2YXIgc2ggPSBfVGVjaC5zZWxlY3RTb3VyY2VIYW5kbGVyKHNyY09iaiwgb3B0aW9ucyk7XG5cbiAgICBpZiAoc2gpIHtcbiAgICAgIHJldHVybiBzaC5jYW5IYW5kbGVTb3VyY2Uoc3JjT2JqLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdXNpbmcgYSBzb3VyY2UgaGFuZGxlciwgcHJlZmVyIGl0cyBpbXBsZW1lbnRhdGlvbiBvZlxuICAgKiBhbnkgZnVuY3Rpb24gbm9ybWFsbHkgcHJvdmlkZWQgYnkgdGhlIHRlY2guXG4gICAqL1xuICB2YXIgZGVmZXJyYWJsZSA9IFsnc2Vla2FibGUnLCAnZHVyYXRpb24nXTtcblxuICAvKipcbiAgICogQSB3cmFwcGVyIGFyb3VuZCB7QGxpbmsgVGVjaCNzZWVrYWJsZX0gdGhhdCB3aWxsIGNhbGwgYSBgU291cmNlSGFuZGxlcmBzIHNlZWthYmxlXG4gICAqIGZ1bmN0aW9uIGlmIGl0IGV4aXN0cywgd2l0aCBhIGZhbGxiYWNrIHRvIHRoZSBUZWNocyBzZWVrYWJsZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQG1ldGhvZCBfVGVjaC5zZWVrYWJsZVxuICAgKi9cblxuICAvKipcbiAgICogQSB3cmFwcGVyIGFyb3VuZCB7QGxpbmsgVGVjaCNkdXJhdGlvbn0gdGhhdCB3aWxsIGNhbGwgYSBgU291cmNlSGFuZGxlcmBzIGR1cmF0aW9uXG4gICAqIGZ1bmN0aW9uIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIGl0IHdpbGwgZmFsbGJhY2sgdG8gdGhlIHRlY2hzIGR1cmF0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbWV0aG9kIF9UZWNoLmR1cmF0aW9uXG4gICAqL1xuXG4gIGRlZmVycmFibGUuZm9yRWFjaChmdW5jdGlvbiAoZm5OYW1lKSB7XG4gICAgdmFyIG9yaWdpbmFsRm4gPSB0aGlzW2ZuTmFtZV07XG5cbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzW2ZuTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5zb3VyY2VIYW5kbGVyXyAmJiB0aGlzLnNvdXJjZUhhbmRsZXJfW2ZuTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlSGFuZGxlcl9bZm5OYW1lXS5hcHBseSh0aGlzLnNvdXJjZUhhbmRsZXJfLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9LCBfVGVjaC5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmdW5jdGlvbiBmb3Igc2V0dGluZyB0aGUgc291cmNlIHVzaW5nIGEgc291cmNlIG9iamVjdFxuICAgKiBhbmQgc291cmNlIGhhbmRsZXJzLlxuICAgKiBTaG91bGQgbmV2ZXIgYmUgY2FsbGVkIHVubGVzcyBhIHNvdXJjZSBoYW5kbGVyIHdhcyBmb3VuZC5cbiAgICpcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gICAqICAgICAgICBBIHNvdXJjZSBvYmplY3Qgd2l0aCBzcmMgYW5kIHR5cGUga2V5c1xuICAgKi9cbiAgX1RlY2gucHJvdG90eXBlLnNldFNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICB2YXIgc2ggPSBfVGVjaC5zZWxlY3RTb3VyY2VIYW5kbGVyKHNvdXJjZSwgdGhpcy5vcHRpb25zXyk7XG5cbiAgICBpZiAoIXNoKSB7XG4gICAgICAvLyBGYWxsIGJhY2sgdG8gYSBuYXRpdmUgc291cmNlIGhhbmRlciB3aGVuIHVuc3VwcG9ydGVkIHNvdXJjZXMgYXJlXG4gICAgICAvLyBkZWxpYmVyYXRlbHkgc2V0XG4gICAgICBpZiAoX1RlY2gubmF0aXZlU291cmNlSGFuZGxlcikge1xuICAgICAgICBzaCA9IF9UZWNoLm5hdGl2ZVNvdXJjZUhhbmRsZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2ckMS5lcnJvcignTm8gc291cmNlIGhhbmRlciBmb3VuZCBmb3IgdGhlIGN1cnJlbnQgc291cmNlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERpc3Bvc2UgYW55IGV4aXN0aW5nIHNvdXJjZSBoYW5kbGVyXG4gICAgdGhpcy5kaXNwb3NlU291cmNlSGFuZGxlcigpO1xuICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgdGhpcy5kaXNwb3NlU291cmNlSGFuZGxlcik7XG5cbiAgICBpZiAoc2ggIT09IF9UZWNoLm5hdGl2ZVNvdXJjZUhhbmRsZXIpIHtcbiAgICAgIHRoaXMuY3VycmVudFNvdXJjZV8gPSBzb3VyY2U7XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2VIYW5kbGVyXyA9IHNoLmhhbmRsZVNvdXJjZShzb3VyY2UsIHRoaXMsIHRoaXMub3B0aW9uc18pO1xuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCB0aGlzLmRpc3Bvc2VTb3VyY2VIYW5kbGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYW4gdXAgYW55IGV4aXN0aW5nIFNvdXJjZUhhbmRsZXJzIGFuZCBsaXN0ZW5lcnMgd2hlbiB0aGUgVGVjaCBpcyBkaXNwb3NlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCNkaXNwb3NlXG4gICAqL1xuICBfVGVjaC5wcm90b3R5cGUuZGlzcG9zZVNvdXJjZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaWYgd2UgaGF2ZSBhIHNvdXJjZSBhbmQgZ2V0IGFub3RoZXIgb25lXG4gICAgLy8gdGhlbiB3ZSBhcmUgbG9hZGluZyBzb21ldGhpbmcgbmV3XG4gICAgLy8gdGhhbiBjbGVhciBhbGwgb2Ygb3VyIGN1cnJlbnQgdHJhY2tzXG4gICAgaWYgKHRoaXMuY3VycmVudFNvdXJjZV8pIHtcbiAgICAgIHRoaXMuY2xlYXJUcmFja3MoWydhdWRpbycsICd2aWRlbyddKTtcbiAgICAgIHRoaXMuY3VycmVudFNvdXJjZV8gPSBudWxsO1xuICAgIH1cblxuICAgIC8vIGFsd2F5cyBjbGVhbiB1cCBhdXRvLXRleHQgdHJhY2tzXG4gICAgdGhpcy5jbGVhbnVwQXV0b1RleHRUcmFja3MoKTtcblxuICAgIGlmICh0aGlzLnNvdXJjZUhhbmRsZXJfKSB7XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZUhhbmRsZXJfLmRpc3Bvc2UpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VIYW5kbGVyXy5kaXNwb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc291cmNlSGFuZGxlcl8gPSBudWxsO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIFRoZSBiYXNlIFRlY2ggY2xhc3MgbmVlZHMgdG8gYmUgcmVnaXN0ZXJlZCBhcyBhIENvbXBvbmVudC4gSXQgaXMgdGhlIG9ubHlcbi8vIFRlY2ggdGhhdCBjYW4gYmUgcmVnaXN0ZXJlZCBhcyBhIENvbXBvbmVudC5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGVjaCcsIFRlY2gpO1xuVGVjaC5yZWdpc3RlclRlY2goJ1RlY2gnLCBUZWNoKTtcblxuLyoqXG4gKiBBIGxpc3Qgb2YgdGVjaHMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGVjaE9yZGVyIG9uIFBsYXllcnNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5UZWNoLmRlZmF1bHRUZWNoT3JkZXJfID0gW107XG5cbnZhciBtaWRkbGV3YXJlcyA9IHt9O1xuXG5mdW5jdGlvbiB1c2UodHlwZSwgbWlkZGxld2FyZSkge1xuICBtaWRkbGV3YXJlc1t0eXBlXSA9IG1pZGRsZXdhcmVzW3R5cGVdIHx8IFtdO1xuICBtaWRkbGV3YXJlc1t0eXBlXS5wdXNoKG1pZGRsZXdhcmUpO1xufVxuXG5cblxuZnVuY3Rpb24gc2V0U291cmNlKHBsYXllciwgc3JjLCBuZXh0KSB7XG4gIHBsYXllci5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2V0U291cmNlSGVscGVyKHNyYywgbWlkZGxld2FyZXNbc3JjLnR5cGVdLCBuZXh0LCBwbGF5ZXIpO1xuICB9LCAxKTtcbn1cblxuZnVuY3Rpb24gc2V0VGVjaChtaWRkbGV3YXJlLCB0ZWNoKSB7XG4gIG1pZGRsZXdhcmUuZm9yRWFjaChmdW5jdGlvbiAobXcpIHtcbiAgICByZXR1cm4gbXcuc2V0VGVjaCAmJiBtdy5zZXRUZWNoKHRlY2gpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0JDEobWlkZGxld2FyZSwgdGVjaCwgbWV0aG9kKSB7XG4gIHJldHVybiBtaWRkbGV3YXJlLnJlZHVjZVJpZ2h0KG1pZGRsZXdhcmVJdGVyYXRvcihtZXRob2QpLCB0ZWNoW21ldGhvZF0oKSk7XG59XG5cbmZ1bmN0aW9uIHNldCQxKG1pZGRsZXdhcmUsIHRlY2gsIG1ldGhvZCwgYXJnKSB7XG4gIHJldHVybiB0ZWNoW21ldGhvZF0obWlkZGxld2FyZS5yZWR1Y2UobWlkZGxld2FyZUl0ZXJhdG9yKG1ldGhvZCksIGFyZykpO1xufVxuXG52YXIgYWxsb3dlZEdldHRlcnMgPSB7XG4gIGJ1ZmZlcmVkOiAxLFxuICBjdXJyZW50VGltZTogMSxcbiAgZHVyYXRpb246IDEsXG4gIHNlZWthYmxlOiAxLFxuICBwbGF5ZWQ6IDFcbn07XG5cbnZhciBhbGxvd2VkU2V0dGVycyA9IHtcbiAgc2V0Q3VycmVudFRpbWU6IDFcbn07XG5cbmZ1bmN0aW9uIG1pZGRsZXdhcmVJdGVyYXRvcihtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgbXcpIHtcbiAgICBpZiAobXdbbWV0aG9kXSkge1xuICAgICAgcmV0dXJuIG13W21ldGhvZF0odmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2V0U291cmNlSGVscGVyKCkge1xuICB2YXIgc3JjID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIG1pZGRsZXdhcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICB2YXIgbmV4dCA9IGFyZ3VtZW50c1syXTtcbiAgdmFyIHBsYXllciA9IGFyZ3VtZW50c1szXTtcbiAgdmFyIGFjYyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogW107XG4gIHZhciBsYXN0UnVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBmYWxzZTtcbiAgdmFyIG13RmFjdG9yeSA9IG1pZGRsZXdhcmVbMF0sXG4gICAgICBtd3Jlc3QgPSBtaWRkbGV3YXJlLnNsaWNlKDEpO1xuXG4gIC8vIGlmIG13RmFjdG9yeSBpcyBhIHN0cmluZywgdGhlbiB3ZSdyZSBhdCBhIGZvcmsgaW4gdGhlIHJvYWRcblxuICBpZiAodHlwZW9mIG13RmFjdG9yeSA9PT0gJ3N0cmluZycpIHtcbiAgICBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtaWRkbGV3YXJlc1ttd0ZhY3RvcnldLCBuZXh0LCBwbGF5ZXIsIGFjYywgbGFzdFJ1bik7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGFuIG13RmFjdG9yeSwgY2FsbCBpdCB3aXRoIHRoZSBwbGF5ZXIgdG8gZ2V0IHRoZSBtdyxcbiAgICAvLyB0aGVuIGNhbGwgdGhlIG13J3Mgc2V0U291cmNlIG1ldGhvZFxuICB9IGVsc2UgaWYgKG13RmFjdG9yeSkge1xuICAgIHZhciBtdyA9IG13RmFjdG9yeShwbGF5ZXIpO1xuXG4gICAgbXcuc2V0U291cmNlKGFzc2lnbih7fSwgc3JjKSwgZnVuY3Rpb24gKGVyciwgX3NyYykge1xuXG4gICAgICAvLyBzb21ldGhpbmcgaGFwcGVuZWQsIHRyeSB0aGUgbmV4dCBtaWRkbGV3YXJlIG9uIHRoZSBjdXJyZW50IGxldmVsXG4gICAgICAvLyBtYWtlIHN1cmUgdG8gdXNlIHRoZSBvbGQgc3JjXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtd3Jlc3QsIG5leHQsIHBsYXllciwgYWNjLCBsYXN0UnVuKTtcbiAgICAgIH1cblxuICAgICAgLy8gd2UndmUgc3VjY2VlZGVkLCBub3cgd2UgbmVlZCB0byBnbyBkZWVwZXJcbiAgICAgIGFjYy5wdXNoKG13KTtcblxuICAgICAgLy8gaWYgaXQncyB0aGUgc2FtZSB0aW1lLCBjb250aW51ZSBkb2VzIHRoZSBjdXJyZW50IGNoYWluXG4gICAgICAvLyBvdGhlcndpc2UsIHdlIHdhbnQgdG8gZ28gZG93biB0aGUgbmV3IGNoYWluXG4gICAgICBzZXRTb3VyY2VIZWxwZXIoX3NyYywgc3JjLnR5cGUgPT09IF9zcmMudHlwZSA/IG13cmVzdCA6IG1pZGRsZXdhcmVzW19zcmMudHlwZV0sIG5leHQsIHBsYXllciwgYWNjLCBsYXN0UnVuKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChtd3Jlc3QubGVuZ3RoKSB7XG4gICAgc2V0U291cmNlSGVscGVyKHNyYywgbXdyZXN0LCBuZXh0LCBwbGF5ZXIsIGFjYywgbGFzdFJ1bik7XG4gIH0gZWxzZSBpZiAobGFzdFJ1bikge1xuICAgIG5leHQoc3JjLCBhY2MpO1xuICB9IGVsc2Uge1xuICAgIHNldFNvdXJjZUhlbHBlcihzcmMsIG1pZGRsZXdhcmVzWycqJ10sIG5leHQsIHBsYXllciwgYWNjLCB0cnVlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBtb2R1bGUgZmlsdGVyLXNvdXJjZVxuICovXG4vKipcbiAqIEZpbHRlciBvdXQgc2luZ2xlIGJhZCBzb3VyY2Ugb2JqZWN0cyBvciBtdWx0aXBsZSBzb3VyY2Ugb2JqZWN0cyBpbiBhblxuICogYXJyYXkuIEFsc28gZmxhdHRlbnMgbmVzdGVkIHNvdXJjZSBvYmplY3QgYXJyYXlzIGludG8gYSAxIGRpbWVuc2lvbmFsXG4gKiBhcnJheSBvZiBzb3VyY2Ugb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fFRlY2h+U291cmNlT2JqZWN0W119IHNyY1xuICogICAgICAgIFRoZSBzcmMgb2JqZWN0IHRvIGZpbHRlclxuICpcbiAqIEByZXR1cm4ge1RlY2h+U291cmNlT2JqZWN0W119XG4gKiAgICAgICAgIEFuIGFycmF5IG9mIHNvdXJjZW9iamVjdHMgY29udGFpbmluZyBvbmx5IHZhbGlkIHNvdXJjZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZmlsdGVyU291cmNlID0gZnVuY3Rpb24gZmlsdGVyU291cmNlKHNyYykge1xuICAvLyB0cmF2ZXJzZSBhcnJheVxuICBpZiAoQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgdmFyIG5ld3NyYyA9IFtdO1xuXG4gICAgc3JjLmZvckVhY2goZnVuY3Rpb24gKHNyY29iaikge1xuICAgICAgc3Jjb2JqID0gZmlsdGVyU291cmNlKHNyY29iaik7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNyY29iaikpIHtcbiAgICAgICAgbmV3c3JjID0gbmV3c3JjLmNvbmNhdChzcmNvYmopO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChzcmNvYmopKSB7XG4gICAgICAgIG5ld3NyYy5wdXNoKHNyY29iaik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzcmMgPSBuZXdzcmM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgJiYgc3JjLnRyaW0oKSkge1xuICAgIC8vIGNvbnZlcnQgc3RyaW5nIGludG8gb2JqZWN0XG4gICAgc3JjID0gW3sgc3JjOiBzcmMgfV07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc3JjKSAmJiB0eXBlb2Ygc3JjLnNyYyA9PT0gJ3N0cmluZycgJiYgc3JjLnNyYyAmJiBzcmMuc3JjLnRyaW0oKSkge1xuICAgIC8vIHNyYyBpcyBhbHJlYWR5IHZhbGlkXG4gICAgc3JjID0gW3NyY107XG4gIH0gZWxzZSB7XG4gICAgLy8gaW52YWxpZCBzb3VyY2UsIHR1cm4gaXQgaW50byBhbiBlbXB0eSBhcnJheVxuICAgIHNyYyA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIHNyYztcbn07XG5cbi8qKlxuICogQGZpbGUgbG9hZGVyLmpzXG4gKi9cbi8qKlxuICogVGhlIGBNZWRpYUxvYWRlcmAgaXMgdGhlIGBDb21wb25lbnRgIHRoYXQgZGVjaWRlcyB3aGljaCBwbGF5YmFjayB0ZWNobm9sb2d5IHRvIGxvYWRcbiAqIHdoZW4gYSBwbGF5ZXIgaXMgaW5pdGlhbGl6ZWQuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIE1lZGlhTG9hZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTWVkaWFMb2FkZXIsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYXR0YWNoIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0cm9lIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBydW4gd2hlbiB0aGlzIGNvbXBvbmVudCBpcyByZWFkeS5cbiAgICovXG4gIGZ1bmN0aW9uIE1lZGlhTG9hZGVyKHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNZWRpYUxvYWRlcik7XG5cbiAgICAvLyBNZWRpYUxvYWRlciBoYXMgbm8gZWxlbWVudFxuICAgIHZhciBvcHRpb25zXyA9IG1lcmdlT3B0aW9ucyh7IGNyZWF0ZUVsOiBmYWxzZSB9LCBvcHRpb25zKTtcblxuICAgIC8vIElmIHRoZXJlIGFyZSBubyBzb3VyY2VzIHdoZW4gdGhlIHBsYXllciBpcyBpbml0aWFsaXplZCxcbiAgICAvLyBsb2FkIHRoZSBmaXJzdCBzdXBwb3J0ZWQgcGxheWJhY2sgdGVjaG5vbG9neS5cblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9uc18sIHJlYWR5KSk7XG5cbiAgICBpZiAoIW9wdGlvbnMucGxheWVyT3B0aW9ucy5zb3VyY2VzIHx8IG9wdGlvbnMucGxheWVyT3B0aW9ucy5zb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBvcHRpb25zLnBsYXllck9wdGlvbnMudGVjaE9yZGVyOyBpIDwgai5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGVjaE5hbWUgPSB0b1RpdGxlQ2FzZShqW2ldKTtcbiAgICAgICAgdmFyIHRlY2ggPSBUZWNoLmdldFRlY2godGVjaE5hbWUpO1xuXG4gICAgICAgIC8vIFN1cHBvcnQgb2xkIGJlaGF2aW9yIG9mIHRlY2hzIGJlaW5nIHJlZ2lzdGVyZWQgYXMgY29tcG9uZW50cy5cbiAgICAgICAgLy8gUmVtb3ZlIG9uY2UgdGhhdCBkZXByZWNhdGVkIGJlaGF2aW9yIGlzIHJlbW92ZWQuXG4gICAgICAgIGlmICghdGVjaE5hbWUpIHtcbiAgICAgICAgICB0ZWNoID0gQ29tcG9uZW50LmdldENvbXBvbmVudCh0ZWNoTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGlzIHRlY2hub2xvZ3lcbiAgICAgICAgaWYgKHRlY2ggJiYgdGVjaC5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgcGxheWVyLmxvYWRUZWNoXyh0ZWNoTmFtZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTG9vcCB0aHJvdWdoIHBsYXliYWNrIHRlY2hub2xvZ2llcyAoSFRNTDUsIEZsYXNoKSBhbmQgY2hlY2sgZm9yIHN1cHBvcnQuXG4gICAgICAvLyBUaGVuIGxvYWQgdGhlIGJlc3Qgc291cmNlLlxuICAgICAgLy8gQSBmZXcgYXNzdW1wdGlvbnMgaGVyZTpcbiAgICAgIC8vICAgQWxsIHBsYXliYWNrIHRlY2hub2xvZ2llcyByZXNwZWN0IHByZWxvYWQgZmFsc2UuXG4gICAgICBwbGF5ZXIuc3JjKG9wdGlvbnMucGxheWVyT3B0aW9ucy5zb3VyY2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIE1lZGlhTG9hZGVyO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01lZGlhTG9hZGVyJywgTWVkaWFMb2FkZXIpO1xuXG4vKipcbiAqIEBmaWxlIGJ1dHRvbi5qc1xuICovXG4vKipcbiAqIENsaWNrYWJsZSBDb21wb25lbnQgd2hpY2ggaXMgY2xpY2thYmxlIG9yIGtleWJvYXJkIGFjdGlvbmFibGUsXG4gKiBidXQgaXMgbm90IGEgbmF0aXZlIEhUTUwgYnV0dG9uLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBDbGlja2FibGVDb21wb25lbnQgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhDbGlja2FibGVDb21wb25lbnQsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSAge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIENsaWNrYWJsZUNvbXBvbmVudChwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDbGlja2FibGVDb21wb25lbnQpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5lbWl0VGFwRXZlbnRzKCk7XG5cbiAgICBfdGhpcy5lbmFibGUoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFnPWRpdl1cbiAgICogICAgICAgIFRoZSBlbGVtZW50J3Mgbm9kZSB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzPXt9XVxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXM9e31dXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciB0YWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdkaXYnO1xuICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgcHJvcHMgPSBhc3NpZ24oe1xuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3M9XCJ2anMtaWNvbi1wbGFjZWhvbGRlclwiPjwvc3Bhbj4nLFxuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKSxcbiAgICAgIHRhYkluZGV4OiAwXG4gICAgfSwgcHJvcHMpO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGxvZyQxLmVycm9yKCdDcmVhdGluZyBhIENsaWNrYWJsZUNvbXBvbmVudCB3aXRoIGFuIEhUTUwgZWxlbWVudCBvZiAnICsgdGFnICsgJyBpcyBub3Qgc3VwcG9ydGVkOyB1c2UgYSBCdXR0b24gaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgQVJJQSBhdHRyaWJ1dGVzIGZvciBjbGlja2FibGUgZWxlbWVudCB3aGljaCBpcyBub3QgYSBuYXRpdmUgSFRNTCBidXR0b25cbiAgICBhdHRyaWJ1dGVzID0gYXNzaWduKHtcbiAgICAgICdyb2xlJzogJ2J1dHRvbicsXG5cbiAgICAgIC8vIGxldCB0aGUgc2NyZWVuIHJlYWRlciB1c2VyIGtub3cgdGhhdCB0aGUgdGV4dCBvZiB0aGUgZWxlbWVudCBtYXkgY2hhbmdlXG4gICAgICAnYXJpYS1saXZlJzogJ3BvbGl0ZSdcbiAgICB9LCBhdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMudGFiSW5kZXhfID0gcHJvcHMudGFiSW5kZXg7XG5cbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsIHRhZywgcHJvcHMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgdGhpcy5jcmVhdGVDb250cm9sVGV4dEVsKGVsKTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgY29udHJvbCB0ZXh0IGVsZW1lbnQgb24gdGhpcyBgQ29tcG9uZW50YFxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtlbF1cbiAgICogICAgICAgIFBhcmVudCBlbGVtZW50IGZvciB0aGUgY29udHJvbCB0ZXh0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBjb250cm9sIHRleHQgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRyb2xUZXh0RWwgPSBmdW5jdGlvbiBjcmVhdGVDb250cm9sVGV4dEVsKGVsKSB7XG4gICAgdGhpcy5jb250cm9sVGV4dEVsXyA9IGNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtdGV4dCdcbiAgICB9KTtcblxuICAgIGlmIChlbCkge1xuICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250cm9sVGV4dEVsXyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9sVGV4dCh0aGlzLmNvbnRyb2xUZXh0XywgZWwpO1xuXG4gICAgcmV0dXJuIHRoaXMuY29udHJvbFRleHRFbF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGxvY2FsaXplIHRleHQgdG8gdXNlIGZvciB0aGUgY29udHJvbHMgb24gdGhlIGBDb21wb25lbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RleHRdXG4gICAqICAgICAgICBDb250cm9sIHRleHQgZm9yIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gW2VsPXRoaXMuZWwoKV1cbiAgICogICAgICAgIEVsZW1lbnQgdG8gc2V0IHRoZSB0aXRsZSBvbi5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIC0gVGhlIGNvbnRyb2wgdGV4dCB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmNvbnRyb2xUZXh0ID0gZnVuY3Rpb24gY29udHJvbFRleHQodGV4dCkge1xuICAgIHZhciBlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5lbCgpO1xuXG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250cm9sVGV4dF8gfHwgJ05lZWQgVGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsaXplZFRleHQgPSB0aGlzLmxvY2FsaXplKHRleHQpO1xuXG4gICAgdGhpcy5jb250cm9sVGV4dF8gPSB0ZXh0O1xuICAgIHRleHRDb250ZW50KHRoaXMuY29udHJvbFRleHRFbF8sIGxvY2FsaXplZFRleHQpO1xuICAgIGlmICghdGhpcy5ub25JY29uQ29udHJvbCkge1xuICAgICAgLy8gU2V0IHRpdGxlIGF0dHJpYnV0ZSBpZiBvbmx5IGFuIGljb24gaXMgc2hvd25cbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBsb2NhbGl6ZWRUZXh0KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWNvbnRyb2wgdmpzLWJ1dHRvbiAnICsgX0NvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhpcyBgQ29tcG9uZW50YHMgZWxlbWVudC5cbiAgICovXG5cblxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZF8pIHtcbiAgICAgIHRoaXMuZW5hYmxlZF8gPSB0cnVlO1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWRpc2FibGVkJyk7XG4gICAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy50YWJJbmRleF8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCB0aGlzLnRhYkluZGV4Xyk7XG4gICAgICB9XG4gICAgICB0aGlzLm9uKFsndGFwJywgJ2NsaWNrJ10sIHRoaXMuaGFuZGxlQ2xpY2spO1xuICAgICAgdGhpcy5vbignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzKTtcbiAgICAgIHRoaXMub24oJ2JsdXInLCB0aGlzLmhhbmRsZUJsdXIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZSB0aGlzIGBDb21wb25lbnRgcyBlbGVtZW50LlxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgdGhpcy5lbmFibGVkXyA9IGZhbHNlO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1kaXNhYmxlZCcpO1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnRhYkluZGV4XyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuZWxfLnJlbW92ZUF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICB9XG4gICAgdGhpcy5vZmYoWyd0YXAnLCAnY2xpY2snXSwgdGhpcy5oYW5kbGVDbGljayk7XG4gICAgdGhpcy5vZmYoJ2ZvY3VzJywgdGhpcy5oYW5kbGVGb2N1cyk7XG4gICAgdGhpcy5vZmYoJ2JsdXInLCB0aGlzLmhhbmRsZUJsdXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQ2xpY2thYmxlQ29tcG9uZW50YCBnZXRzOlxuICAgKiAtIENsaWNrZWQgKHZpYSB0aGUgYGNsaWNrYCBldmVudCwgbGlzdGVuaW5nIHN0YXJ0cyBpbiB0aGUgY29uc3RydWN0b3IpXG4gICAqIC0gVGFwcGVkICh2aWEgdGhlIGB0YXBgIGV2ZW50LCBsaXN0ZW5pbmcgc3RhcnRzIGluIHRoZSBjb25zdHJ1Y3RvcilcbiAgICogLSBUaGUgZm9sbG93aW5nIHRoaW5ncyBoYXBwZW4gaW4gb3JkZXI6XG4gICAqICAgMS4ge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVGb2N1c30gaXMgY2FsbGVkIHZpYSBhIGBmb2N1c2AgZXZlbnQgb24gdGhlXG4gICAqICAgICAgYENsaWNrYWJsZUNvbXBvbmVudGAuXG4gICAqICAgMi4ge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVGb2N1c30gYWRkcyBhIGxpc3RlbmVyIGZvciBga2V5ZG93bmAgb24gdXNpbmdcbiAgICogICAgICB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUtleVByZXNzfS5cbiAgICogICAzLiBgQ2xpY2thYmxlQ29tcG9uZW50YCBoYXMgbm90IGhhZCBhIGBibHVyYCBldmVudCAoYGJsdXJgIG1lYW5zIHRoYXQgZm9jdXMgd2FzIGxvc3QpLiBUaGUgdXNlciBwcmVzc2VzXG4gICAqICAgICAgdGhlIHNwYWNlIG9yIGVudGVyIGtleS5cbiAgICogICA0LiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUtleVByZXNzfSBjYWxscyB0aGlzIGZ1bmN0aW9uIHdpdGggdGhlIGBrZXlkb3duYFxuICAgKiAgICAgIGV2ZW50IGFzIGEgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICogQGFic3RyYWN0XG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7fTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGEgYENsaWNrYWJsZUNvbXBvbmVudGAgZ2FpbnMgZm9jdXMgdmlhIGEgYGZvY3VzYCBldmVudC5cbiAgICogVHVybnMgb24gbGlzdGVuaW5nIGZvciBga2V5ZG93bmAgZXZlbnRzLiBXaGVuIHRoZXkgaGFwcGVuIGl0XG4gICAqIGNhbGxzIGB0aGlzLmhhbmRsZUtleVByZXNzYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgZm9jdXNgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBmb2N1c1xuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlRm9jdXMgPSBmdW5jdGlvbiBoYW5kbGVGb2N1cyhldmVudCkge1xuICAgIG9uKGRvY3VtZW50LCAna2V5ZG93bicsIGJpbmQodGhpcywgdGhpcy5oYW5kbGVLZXlQcmVzcykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGlzIENsaWNrYWJsZUNvbXBvbmVudCBoYXMgZm9jdXMgYW5kIGEga2V5IGdldHMgcHJlc3NlZCBkb3duLiBCeVxuICAgKiBkZWZhdWx0IGl0IHdpbGwgY2FsbCBgdGhpcy5oYW5kbGVDbGlja2Agd2hlbiB0aGUga2V5IGlzIHNwYWNlIG9yIGVudGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKi9cblxuXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuXG4gICAgLy8gU3VwcG9ydCBTcGFjZSAoMzIpIG9yIEVudGVyICgxMykga2V5IG9wZXJhdGlvbiB0byBmaXJlIGEgY2xpY2sgZXZlbnRcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDMyIHx8IGV2ZW50LndoaWNoID09PSAxMykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMudHJpZ2dlcignY2xpY2snKTtcbiAgICB9IGVsc2UgaWYgKF9Db21wb25lbnQucHJvdG90eXBlLmhhbmRsZUtleVByZXNzKSB7XG5cbiAgICAgIC8vIFBhc3Mga2V5cHJlc3MgaGFuZGxpbmcgdXAgZm9yIHVuc3VwcG9ydGVkIGtleXNcbiAgICAgIF9Db21wb25lbnQucHJvdG90eXBlLmhhbmRsZUtleVByZXNzLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBgQ2xpY2thYmxlQ29tcG9uZW50YCBsb3NlcyBmb2N1cy4gVHVybnMgb2ZmIHRoZSBsaXN0ZW5lciBmb3JcbiAgICogYGtleWRvd25gIGV2ZW50cy4gV2hpY2ggU3RvcHMgYHRoaXMuaGFuZGxlS2V5UHJlc3NgIGZyb20gZ2V0dGluZyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGJsdXJgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBibHVyXG4gICAqL1xuXG5cbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVCbHVyID0gZnVuY3Rpb24gaGFuZGxlQmx1cihldmVudCkge1xuICAgIG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgfTtcblxuICByZXR1cm4gQ2xpY2thYmxlQ29tcG9uZW50O1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NsaWNrYWJsZUNvbXBvbmVudCcsIENsaWNrYWJsZUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGZpbGUgcG9zdGVyLWltYWdlLmpzXG4gKi9cbi8qKlxuICogQSBgQ2xpY2thYmxlQ29tcG9uZW50YCB0aGF0IGhhbmRsZXMgc2hvd2luZyB0aGUgcG9zdGVyIGltYWdlIGZvciB0aGUgcGxheWVyLlxuICpcbiAqIEBleHRlbmRzIENsaWNrYWJsZUNvbXBvbmVudFxuICovXG5cbnZhciBQb3N0ZXJJbWFnZSA9IGZ1bmN0aW9uIChfQ2xpY2thYmxlQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFBvc3RlckltYWdlLCBfQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGF0dGFjaCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFBvc3RlckltYWdlKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBvc3RlckltYWdlKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NsaWNrYWJsZUNvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudXBkYXRlKCk7XG4gICAgcGxheWVyLm9uKCdwb3N0ZXJjaGFuZ2UnLCBiaW5kKF90aGlzLCBfdGhpcy51cGRhdGUpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gdXAgYW5kIGRpc3Bvc2Ugb2YgdGhlIGBQb3N0ZXJJbWFnZWAuXG4gICAqL1xuXG5cbiAgUG9zdGVySW1hZ2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHRoaXMucGxheWVyKCkub2ZmKCdwb3N0ZXJjaGFuZ2UnLCB0aGlzLnVwZGF0ZSk7XG4gICAgX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBQb3N0ZXJJbWFnZWBzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFBvc3RlckltYWdlLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBlbCA9IGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcG9zdGVyJyxcblxuICAgICAgLy8gRG9uJ3Qgd2FudCBwb3N0ZXIgdG8gYmUgdGFiYmFibGUuXG4gICAgICB0YWJJbmRleDogLTFcbiAgICB9KTtcblxuICAgIC8vIFRvIGVuc3VyZSB0aGUgcG9zdGVyIGltYWdlIHJlc2l6ZXMgd2hpbGUgbWFpbnRhaW5pbmcgaXRzIG9yaWdpbmFsIGFzcGVjdFxuICAgIC8vIHJhdGlvLCB1c2UgYSBkaXYgd2l0aCBgYmFja2dyb3VuZC1zaXplYCB3aGVuIGF2YWlsYWJsZS4gRm9yIGJyb3dzZXJzIHRoYXRcbiAgICAvLyBkbyBub3Qgc3VwcG9ydCBgYmFja2dyb3VuZC1zaXplYCAoZS5nLiBJRTgpLCBmYWxsIGJhY2sgb24gdXNpbmcgYSByZWd1bGFyXG4gICAgLy8gaW1nIGVsZW1lbnQuXG4gICAgaWYgKCFCQUNLR1JPVU5EX1NJWkVfU1VQUE9SVEVEKSB7XG4gICAgICB0aGlzLmZhbGxiYWNrSW1nXyA9IGNyZWF0ZUVsKCdpbWcnKTtcbiAgICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuZmFsbGJhY2tJbWdfKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFuIHtAbGluayBFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBmb3Ige0BsaW5rIFBsYXllciNwb3N0ZXJjaGFuZ2V9IGV2ZW50cy5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3Bvc3RlcmNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYFBsYXllciNwb3N0ZXJjaGFuZ2VgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb24uXG4gICAqL1xuXG5cbiAgUG9zdGVySW1hZ2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIHZhciB1cmwgPSB0aGlzLnBsYXllcigpLnBvc3RlcigpO1xuXG4gICAgdGhpcy5zZXRTcmModXJsKTtcblxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gcG9zdGVyIHNvdXJjZSB3ZSBzaG91bGQgZGlzcGxheTpub25lIG9uIHRoaXMgY29tcG9uZW50XG4gICAgLy8gc28gaXQncyBub3Qgc3RpbGwgY2xpY2thYmxlIG9yIHJpZ2h0LWNsaWNrYWJsZVxuICAgIGlmICh1cmwpIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIG9mIHRoZSBgUG9zdGVySW1hZ2VgIGRlcGVuZGluZyBvbiB0aGUgZGlzcGxheSBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICogICAgICAgIFRoZSBVUkwgdG8gdGhlIHNvdXJjZSBmb3IgdGhlIGBQb3N0ZXJJbWFnZWAuXG4gICAqL1xuXG5cbiAgUG9zdGVySW1hZ2UucHJvdG90eXBlLnNldFNyYyA9IGZ1bmN0aW9uIHNldFNyYyh1cmwpIHtcbiAgICBpZiAodGhpcy5mYWxsYmFja0ltZ18pIHtcbiAgICAgIHRoaXMuZmFsbGJhY2tJbWdfLnNyYyA9IHVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJhY2tncm91bmRJbWFnZSA9ICcnO1xuXG4gICAgICAvLyBBbnkgZmFsc2V5IHZhbHVlcyBzaG91bGQgc3RheSBhcyBhbiBlbXB0eSBzdHJpbmcsIG90aGVyd2lzZVxuICAgICAgLy8gdGhpcyB3aWxsIHRocm93IGFuIGV4dHJhIGVycm9yXG4gICAgICBpZiAodXJsKSB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZSA9ICd1cmwoXCInICsgdXJsICsgJ1wiKSc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxfLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGJhY2tncm91bmRJbWFnZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFuIHtAbGluayBFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBmb3IgY2xpY2tzIG9uIHRoZSBgUG9zdGVySW1hZ2VgLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVDbGlja30gZm9yIGluc3RhbmNlcyB3aGVyZSB0aGlzIHdpbGwgYmUgdHJpZ2dlcmVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICogQGxpc3RlbnMga2V5ZG93blxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKyAgICAgICAgVGhlIGBjbGlja2AsIGB0YXBgIG9yIGBrZXlkb3duYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICovXG5cblxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIC8vIFdlIGRvbid0IHdhbnQgYSBjbGljayB0byB0cmlnZ2VyIHBsYXliYWNrIHdoZW4gY29udHJvbHMgYXJlIGRpc2FibGVkXG4gICAgaWYgKCF0aGlzLnBsYXllcl8uY29udHJvbHMoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBsYXllcl8ucGF1c2VkKCkpIHtcbiAgICAgIHRoaXMucGxheWVyXy5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUG9zdGVySW1hZ2U7XG59KENsaWNrYWJsZUNvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUG9zdGVySW1hZ2UnLCBQb3N0ZXJJbWFnZSk7XG5cbi8qKlxuICogQGZpbGUgdGV4dC10cmFjay1kaXNwbGF5LmpzXG4gKi9cbnZhciBkYXJrR3JheSA9ICcjMjIyJztcbnZhciBsaWdodEdyYXkgPSAnI2NjYyc7XG52YXIgZm9udE1hcCA9IHtcbiAgbW9ub3NwYWNlOiAnbW9ub3NwYWNlJyxcbiAgc2Fuc1NlcmlmOiAnc2Fucy1zZXJpZicsXG4gIHNlcmlmOiAnc2VyaWYnLFxuICBtb25vc3BhY2VTYW5zU2VyaWY6ICdcIkFuZGFsZSBNb25vXCIsIFwiTHVjaWRhIENvbnNvbGVcIiwgbW9ub3NwYWNlJyxcbiAgbW9ub3NwYWNlU2VyaWY6ICdcIkNvdXJpZXIgTmV3XCIsIG1vbm9zcGFjZScsXG4gIHByb3BvcnRpb25hbFNhbnNTZXJpZjogJ3NhbnMtc2VyaWYnLFxuICBwcm9wb3J0aW9uYWxTZXJpZjogJ3NlcmlmJyxcbiAgY2FzdWFsOiAnXCJDb21pYyBTYW5zIE1TXCIsIEltcGFjdCwgZmFudGFzeScsXG4gIHNjcmlwdDogJ1wiTW9ub3R5cGUgQ29yc2l2YVwiLCBjdXJzaXZlJyxcbiAgc21hbGxjYXBzOiAnXCJBbmRhbGUgTW9ub1wiLCBcIkx1Y2lkYSBDb25zb2xlXCIsIG1vbm9zcGFjZSwgc2Fucy1zZXJpZidcbn07XG5cbi8qKlxuICogQ29uc3RydWN0IGFuIHJnYmEgY29sb3IgZnJvbSBhIGdpdmVuIGhleCBjb2xvciBjb2RlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2xvclxuICogICAgICAgIEhleCBudW1iZXIgZm9yIGNvbG9yLCBsaWtlICNmMGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHlcbiAqICAgICAgICBWYWx1ZSBmb3Igb3BhY2l0eSwgMC4wIC0gMS4wLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGhlIHJnYmEgY29sb3IgdGhhdCB3YXMgY3JlYXRlZCwgbGlrZSAncmdiYSgyNTUsIDAsIDAsIDAuMyknLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdENvbG9yKGNvbG9yLCBvcGFjaXR5KSB7XG4gIHJldHVybiAncmdiYSgnICtcbiAgLy8gY29sb3IgbG9va3MgbGlrZSBcIiNmMGVcIlxuICBwYXJzZUludChjb2xvclsxXSArIGNvbG9yWzFdLCAxNikgKyAnLCcgKyBwYXJzZUludChjb2xvclsyXSArIGNvbG9yWzJdLCAxNikgKyAnLCcgKyBwYXJzZUludChjb2xvclszXSArIGNvbG9yWzNdLCAxNikgKyAnLCcgKyBvcGFjaXR5ICsgJyknO1xufVxuXG4vKipcbiAqIFRyeSB0byB1cGRhdGUgdGhlIHN0eWxlIG9mIGEgRE9NIGVsZW1lbnQuIFNvbWUgc3R5bGUgY2hhbmdlcyB3aWxsIHRocm93IGFuIGVycm9yLFxuICogcGFydGljdWxhcmx5IGluIElFOC4gVGhvc2Ugc2hvdWxkIGJlIG5vb3BzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgRE9NIGVsZW1lbnQgdG8gYmUgc3R5bGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVxuICogICAgICAgIFRoZSBDU1MgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgc3R5bGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlXG4gKiAgICAgICAgVGhlIHN0eWxlIHJ1bGUgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byB0aGUgcHJvcGVydHkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdHJ5VXBkYXRlU3R5bGUoZWwsIHN0eWxlLCBydWxlKSB7XG4gIHRyeSB7XG4gICAgZWwuc3R5bGVbc3R5bGVdID0gcnVsZTtcbiAgfSBjYXRjaCAoZSkge1xuXG4gICAgLy8gU2F0aXNmaWVzIGxpbnRlci5cbiAgICByZXR1cm47XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBkaXNwbGF5aW5nIHRleHQgdHJhY2sgY3Vlcy5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgVGV4dFRyYWNrRGlzcGxheSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFRleHRUcmFja0Rpc3BsYXksIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGBUZXh0VHJhY2tEaXNwbGF5YCBpcyByZWFkeS5cbiAgICovXG4gIGZ1bmN0aW9uIFRleHRUcmFja0Rpc3BsYXkocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRUcmFja0Rpc3BsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zLCByZWFkeSkpO1xuXG4gICAgcGxheWVyLm9uKCdsb2Fkc3RhcnQnLCBiaW5kKF90aGlzLCBfdGhpcy50b2dnbGVEaXNwbGF5KSk7XG4gICAgcGxheWVyLm9uKCd0ZXh0dHJhY2tjaGFuZ2UnLCBiaW5kKF90aGlzLCBfdGhpcy51cGRhdGVEaXNwbGF5KSk7XG4gICAgcGxheWVyLm9uKCdsb2Fkc3RhcnQnLCBiaW5kKF90aGlzLCBfdGhpcy5wcmVzZWxlY3RUcmFjaykpO1xuXG4gICAgLy8gVGhpcyB1c2VkIHRvIGJlIGNhbGxlZCBkdXJpbmcgcGxheWVyIGluaXQsIGJ1dCB3YXMgY2F1c2luZyBhbiBlcnJvclxuICAgIC8vIGlmIGEgdHJhY2sgc2hvdWxkIHNob3cgYnkgZGVmYXVsdCBhbmQgdGhlIGRpc3BsYXkgaGFkbid0IGxvYWRlZCB5ZXQuXG4gICAgLy8gU2hvdWxkIHByb2JhYmx5IGJlIG1vdmVkIHRvIGFuIGV4dGVybmFsIHRyYWNrIGxvYWRlciB3aGVuIHdlIHN1cHBvcnRcbiAgICAvLyB0cmFja3MgdGhhdCBkb24ndCBuZWVkIGEgZGlzcGxheS5cbiAgICBwbGF5ZXIucmVhZHkoYmluZChfdGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHBsYXllci50ZWNoXyAmJiBwbGF5ZXIudGVjaF8uZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBsYXllci5vbignZnVsbHNjcmVlbmNoYW5nZScsIGJpbmQodGhpcywgdGhpcy51cGRhdGVEaXNwbGF5KSk7XG5cbiAgICAgIHZhciB0cmFja3MgPSB0aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnMudHJhY2tzIHx8IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnBsYXllcl8uYWRkUmVtb3RlVGV4dFRyYWNrKHRyYWNrc1tpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJlc2VsZWN0VHJhY2soKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICogUHJlc2VsZWN0IGEgdHJhY2sgZm9sbG93aW5nIHRoaXMgcHJlY2VkZW5jZTpcbiAgKiAtIG1hdGNoZXMgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQge0BsaW5rIFRleHRUcmFja30ncyBsYW5ndWFnZSBhbmQga2luZFxuICAqIC0gbWF0Y2hlcyB0aGUgcHJldmlvdXNseSBzZWxlY3RlZCB7QGxpbmsgVGV4dFRyYWNrfSdzIGxhbmd1YWdlIG9ubHlcbiAgKiAtIGlzIHRoZSBmaXJzdCBkZWZhdWx0IGNhcHRpb25zIHRyYWNrXG4gICogLSBpcyB0aGUgZmlyc3QgZGVmYXVsdCBkZXNjcmlwdGlvbnMgdHJhY2tcbiAgKlxuICAqIEBsaXN0ZW5zIFBsYXllciNsb2Fkc3RhcnRcbiAgKi9cblxuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLnByZXNlbGVjdFRyYWNrID0gZnVuY3Rpb24gcHJlc2VsZWN0VHJhY2soKSB7XG4gICAgdmFyIG1vZGVzID0geyBjYXB0aW9uczogMSwgc3VidGl0bGVzOiAxIH07XG4gICAgdmFyIHRyYWNrTGlzdCA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCk7XG4gICAgdmFyIHVzZXJQcmVmID0gdGhpcy5wbGF5ZXJfLmNhY2hlXy5zZWxlY3RlZExhbmd1YWdlO1xuICAgIHZhciBmaXJzdERlc2MgPSB2b2lkIDA7XG4gICAgdmFyIGZpcnN0Q2FwdGlvbnMgPSB2b2lkIDA7XG4gICAgdmFyIHByZWZlcnJlZFRyYWNrID0gdm9pZCAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrTGlzdFtpXTtcblxuICAgICAgaWYgKHVzZXJQcmVmICYmIHVzZXJQcmVmLmVuYWJsZWQgJiYgdXNlclByZWYubGFuZ3VhZ2UgPT09IHRyYWNrLmxhbmd1YWdlKSB7XG4gICAgICAgIC8vIEFsd2F5cyBjaG9vc2UgdGhlIHRyYWNrIHRoYXQgbWF0Y2hlcyBib3RoIGxhbmd1YWdlIGFuZCBraW5kXG4gICAgICAgIGlmICh0cmFjay5raW5kID09PSB1c2VyUHJlZi5raW5kKSB7XG4gICAgICAgICAgcHJlZmVycmVkVHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAvLyBvciBjaG9vc2UgdGhlIGZpcnN0IHRyYWNrIHRoYXQgbWF0Y2hlcyBsYW5ndWFnZVxuICAgICAgICB9IGVsc2UgaWYgKCFwcmVmZXJyZWRUcmFjaykge1xuICAgICAgICAgIHByZWZlcnJlZFRyYWNrID0gdHJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBldmVyeXRoaW5nIGlmIG9mZlRleHRUcmFja01lbnVJdGVtIHdhcyBjbGlja2VkXG4gICAgICB9IGVsc2UgaWYgKHVzZXJQcmVmICYmICF1c2VyUHJlZi5lbmFibGVkKSB7XG4gICAgICAgIHByZWZlcnJlZFRyYWNrID0gbnVsbDtcbiAgICAgICAgZmlyc3REZXNjID0gbnVsbDtcbiAgICAgICAgZmlyc3RDYXB0aW9ucyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrWydkZWZhdWx0J10pIHtcbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdkZXNjcmlwdGlvbnMnICYmICFmaXJzdERlc2MpIHtcbiAgICAgICAgICBmaXJzdERlc2MgPSB0cmFjaztcbiAgICAgICAgfSBlbHNlIGlmICh0cmFjay5raW5kIGluIG1vZGVzICYmICFmaXJzdENhcHRpb25zKSB7XG4gICAgICAgICAgZmlyc3RDYXB0aW9ucyA9IHRyYWNrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIHByZWZlcnJlZFRyYWNrIG1hdGNoZXMgdGhlIHVzZXIgcHJlZmVyZW5jZSBhbmQgdGFrZXNcbiAgICAvLyBwcmVjZW5kZW5jZSBvdmVyIGFsbCB0aGUgb3RoZXIgdHJhY2tzLlxuICAgIC8vIFNvLCBkaXNwbGF5IHRoZSBwcmVmZXJyZWRUcmFjayBiZWZvcmUgdGhlIGZpcnN0IGRlZmF1bHQgdHJhY2tcbiAgICAvLyBhbmQgdGhlIHN1YnRpdGxlcy9jYXB0aW9ucyB0cmFjayBiZWZvcmUgdGhlIGRlc2NyaXB0aW9ucyB0cmFja1xuICAgIGlmIChwcmVmZXJyZWRUcmFjaykge1xuICAgICAgcHJlZmVycmVkVHJhY2subW9kZSA9ICdzaG93aW5nJztcbiAgICB9IGVsc2UgaWYgKGZpcnN0Q2FwdGlvbnMpIHtcbiAgICAgIGZpcnN0Q2FwdGlvbnMubW9kZSA9ICdzaG93aW5nJztcbiAgICB9IGVsc2UgaWYgKGZpcnN0RGVzYykge1xuICAgICAgZmlyc3REZXNjLm1vZGUgPSAnc2hvd2luZyc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUdXJuIGRpc3BsYXkgb2Yge0BsaW5rIFRleHRUcmFja30ncyBmcm9tIHRoZSBjdXJyZW50IHN0YXRlIGludG8gdGhlIG90aGVyIHN0YXRlLlxuICAgKiBUaGVyZSBhcmUgb25seSB0d28gc3RhdGVzOlxuICAgKiAtICdzaG93bidcbiAgICogLSAnaGlkZGVuJ1xuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjbG9hZHN0YXJ0XG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUudG9nZ2xlRGlzcGxheSA9IGZ1bmN0aW9uIHRvZ2dsZURpc3BsYXkoKSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy50ZWNoXyAmJiB0aGlzLnBsYXllcl8udGVjaF8uZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIHtAbGluayBDb21wb25lbnR9J3MgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBUZXh0VHJhY2tEaXNwbGF5LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdGV4dC10cmFjay1kaXNwbGF5J1xuICAgIH0sIHtcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJyxcbiAgICAgICdhcmlhLWF0b21pYyc6ICd0cnVlJ1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgZGlzcGxheWVkIHtAbGluayBUZXh0VHJhY2t9cy5cbiAgICovXG5cblxuICBUZXh0VHJhY2tEaXNwbGF5LnByb3RvdHlwZS5jbGVhckRpc3BsYXkgPSBmdW5jdGlvbiBjbGVhckRpc3BsYXkoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuV2ViVlRUID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3aW5kb3cuV2ViVlRULnByb2Nlc3NDdWVzKHdpbmRvdywgW10sIHRoaXMuZWxfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZGlzcGxheWVkIFRleHRUcmFjayB3aGVuIGEgZWl0aGVyIGEge0BsaW5rIFBsYXllciN0ZXh0dHJhY2tjaGFuZ2V9IG9yXG4gICAqIGEge0BsaW5rIFBsYXllciNmdWxsc2NyZWVuY2hhbmdlfSBpcyBmaXJlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3RleHR0cmFja2NoYW5nZVxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgKi9cblxuXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkgPSBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgdGhpcy5jbGVhckRpc3BsYXkoKTtcblxuICAgIC8vIFRyYWNrIGRpc3BsYXkgcHJpb3JpdGl6YXRpb24gbW9kZWw6IGlmIG11bHRpcGxlIHRyYWNrcyBhcmUgJ3Nob3dpbmcnLFxuICAgIC8vICBkaXNwbGF5IHRoZSBmaXJzdCAnc3VidGl0bGVzJyBvciAnY2FwdGlvbnMnIHRyYWNrIHdoaWNoIGlzICdzaG93aW5nJyxcbiAgICAvLyAgb3RoZXJ3aXNlIGRpc3BsYXkgdGhlIGZpcnN0ICdkZXNjcmlwdGlvbnMnIHRyYWNrIHdoaWNoIGlzICdzaG93aW5nJ1xuXG4gICAgdmFyIGRlc2NyaXB0aW9uc1RyYWNrID0gbnVsbDtcbiAgICB2YXIgY2FwdGlvbnNTdWJ0aXRsZXNUcmFjayA9IG51bGw7XG4gICAgdmFyIGkgPSB0cmFja3MubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICBpZiAodHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgIGlmICh0cmFjay5raW5kID09PSAnZGVzY3JpcHRpb25zJykge1xuICAgICAgICAgIGRlc2NyaXB0aW9uc1RyYWNrID0gdHJhY2s7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FwdGlvbnNTdWJ0aXRsZXNUcmFjayA9IHRyYWNrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNhcHRpb25zU3VidGl0bGVzVHJhY2spIHtcbiAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnYXJpYS1saXZlJykgIT09ICdvZmYnKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnb2ZmJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZUZvclRyYWNrKGNhcHRpb25zU3VidGl0bGVzVHJhY2spO1xuICAgIH0gZWxzZSBpZiAoZGVzY3JpcHRpb25zVHJhY2spIHtcbiAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnYXJpYS1saXZlJykgIT09ICdhc3NlcnRpdmUnKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnYXNzZXJ0aXZlJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZUZvclRyYWNrKGRlc2NyaXB0aW9uc1RyYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbiB7QGxpbmsgVGV4dHRyYWNrfSB0byB0byB0aGUge0BsaW5rIFRlY2h9cyB7QGxpbmsgVGV4dFRyYWNrTGlzdH0uXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xuICAgKiAgICAgICAgVGV4dCB0cmFjayBvYmplY3QgdG8gYmUgYWRkZWQgdG8gdGhlIGxpc3QuXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUudXBkYXRlRm9yVHJhY2sgPSBmdW5jdGlvbiB1cGRhdGVGb3JUcmFjayh0cmFjaykge1xuICAgIGlmICh0eXBlb2Ygd2luZG93LldlYlZUVCAhPT0gJ2Z1bmN0aW9uJyB8fCAhdHJhY2suYWN0aXZlQ3Vlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvdmVycmlkZXMgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrU2V0dGluZ3MuZ2V0VmFsdWVzKCk7XG4gICAgdmFyIGN1ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0cmFjay5hY3RpdmVDdWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgY3Vlcy5wdXNoKHRyYWNrLmFjdGl2ZUN1ZXNbX2ldKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuV2ViVlRULnByb2Nlc3NDdWVzKHdpbmRvdywgY3VlcywgdGhpcy5lbF8pO1xuXG4gICAgdmFyIGkgPSBjdWVzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBjdWUgPSBjdWVzW2ldO1xuXG4gICAgICBpZiAoIWN1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1ZURpdiA9IGN1ZS5kaXNwbGF5U3RhdGU7XG5cbiAgICAgIGlmIChvdmVycmlkZXMuY29sb3IpIHtcbiAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuY29sb3IgPSBvdmVycmlkZXMuY29sb3I7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLnRleHRPcGFjaXR5KSB7XG4gICAgICAgIHRyeVVwZGF0ZVN0eWxlKGN1ZURpdi5maXJzdENoaWxkLCAnY29sb3InLCBjb25zdHJ1Y3RDb2xvcihvdmVycmlkZXMuY29sb3IgfHwgJyNmZmYnLCBvdmVycmlkZXMudGV4dE9wYWNpdHkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVycmlkZXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG92ZXJyaWRlcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmJhY2tncm91bmRPcGFjaXR5KSB7XG4gICAgICAgIHRyeVVwZGF0ZVN0eWxlKGN1ZURpdi5maXJzdENoaWxkLCAnYmFja2dyb3VuZENvbG9yJywgY29uc3RydWN0Q29sb3Iob3ZlcnJpZGVzLmJhY2tncm91bmRDb2xvciB8fCAnIzAwMCcsIG92ZXJyaWRlcy5iYWNrZ3JvdW5kT3BhY2l0eSkpO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy53aW5kb3dDb2xvcikge1xuICAgICAgICBpZiAob3ZlcnJpZGVzLndpbmRvd09wYWNpdHkpIHtcbiAgICAgICAgICB0cnlVcGRhdGVTdHlsZShjdWVEaXYsICdiYWNrZ3JvdW5kQ29sb3InLCBjb25zdHJ1Y3RDb2xvcihvdmVycmlkZXMud2luZG93Q29sb3IsIG92ZXJyaWRlcy53aW5kb3dPcGFjaXR5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VlRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG92ZXJyaWRlcy53aW5kb3dDb2xvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy5lZGdlU3R5bGUpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcy5lZGdlU3R5bGUgPT09ICdkcm9wc2hhZG93Jykge1xuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMnB4IDJweCAzcHggJyArIGRhcmtHcmF5ICsgJywgMnB4IDJweCA0cHggJyArIGRhcmtHcmF5ICsgJywgMnB4IDJweCA1cHggJyArIGRhcmtHcmF5O1xuICAgICAgICB9IGVsc2UgaWYgKG92ZXJyaWRlcy5lZGdlU3R5bGUgPT09ICdyYWlzZWQnKSB7XG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUudGV4dFNoYWRvdyA9ICcxcHggMXB4ICcgKyBkYXJrR3JheSArICcsIDJweCAycHggJyArIGRhcmtHcmF5ICsgJywgM3B4IDNweCAnICsgZGFya0dyYXk7XG4gICAgICAgIH0gZWxzZSBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ2RlcHJlc3NlZCcpIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS50ZXh0U2hhZG93ID0gJzFweCAxcHggJyArIGxpZ2h0R3JheSArICcsIDAgMXB4ICcgKyBsaWdodEdyYXkgKyAnLCAtMXB4IC0xcHggJyArIGRhcmtHcmF5ICsgJywgMCAtMXB4ICcgKyBkYXJrR3JheTtcbiAgICAgICAgfSBlbHNlIGlmIChvdmVycmlkZXMuZWRnZVN0eWxlID09PSAndW5pZm9ybScpIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS50ZXh0U2hhZG93ID0gJzAgMCA0cHggJyArIGRhcmtHcmF5ICsgJywgMCAwIDRweCAnICsgZGFya0dyYXkgKyAnLCAwIDAgNHB4ICcgKyBkYXJrR3JheSArICcsIDAgMCA0cHggJyArIGRhcmtHcmF5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3ZlcnJpZGVzLmZvbnRQZXJjZW50ICYmIG92ZXJyaWRlcy5mb250UGVyY2VudCAhPT0gMSkge1xuICAgICAgICB2YXIgZm9udFNpemUgPSB3aW5kb3cucGFyc2VGbG9hdChjdWVEaXYuc3R5bGUuZm9udFNpemUpO1xuXG4gICAgICAgIGN1ZURpdi5zdHlsZS5mb250U2l6ZSA9IGZvbnRTaXplICogb3ZlcnJpZGVzLmZvbnRQZXJjZW50ICsgJ3B4JztcbiAgICAgICAgY3VlRGl2LnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgY3VlRGl2LnN0eWxlLnRvcCA9ICdhdXRvJztcbiAgICAgICAgY3VlRGl2LnN0eWxlLmJvdHRvbSA9ICcycHgnO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJyaWRlcy5mb250RmFtaWx5ICYmIG92ZXJyaWRlcy5mb250RmFtaWx5ICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcy5mb250RmFtaWx5ID09PSAnc21hbGwtY2FwcycpIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS5mb250VmFyaWFudCA9ICdzbWFsbC1jYXBzJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS5mb250RmFtaWx5ID0gZm9udE1hcFtvdmVycmlkZXMuZm9udEZhbWlseV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFja0Rpc3BsYXk7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGV4dFRyYWNrRGlzcGxheScsIFRleHRUcmFja0Rpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIGxvYWRpbmctc3Bpbm5lci5qc1xuICovXG4vKipcbiAqIEEgbG9hZGluZyBzcGlubmVyIGZvciB1c2UgZHVyaW5nIHdhaXRpbmcvbG9hZGluZyBldmVudHMuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIExvYWRpbmdTcGlubmVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTG9hZGluZ1NwaW5uZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIExvYWRpbmdTcGlubmVyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIExvYWRpbmdTcGlubmVyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYExvYWRpbmdTcGlubmVyYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGRvbSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cbiAgTG9hZGluZ1NwaW5uZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1sb2FkaW5nLXNwaW5uZXInLFxuICAgICAgZGlyOiAnbHRyJ1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBMb2FkaW5nU3Bpbm5lcjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdMb2FkaW5nU3Bpbm5lcicsIExvYWRpbmdTcGlubmVyKTtcblxuLyoqXG4gKiBAZmlsZSBidXR0b24uanNcbiAqL1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgYnV0dG9ucy5cbiAqXG4gKiBAZXh0ZW5kcyBDbGlja2FibGVDb21wb25lbnRcbiAqL1xuXG52YXIgQnV0dG9uID0gZnVuY3Rpb24gKF9DbGlja2FibGVDb21wb25lbnQpIHtcbiAgaW5oZXJpdHMoQnV0dG9uLCBfQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBCdXR0b24oKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQnV0dG9uKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ2xpY2thYmxlQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYEJ1dHRvbmBzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhZz1cImJ1dHRvblwiXVxuICAgKiAgICAgICAgVGhlIGVsZW1lbnQncyBub2RlIHR5cGUuIFRoaXMgYXJndW1lbnQgaXMgSUdOT1JFRDogbm8gbWF0dGVyIHdoYXRcbiAgICogICAgICAgIGlzIHBhc3NlZCwgaXQgd2lsbCBhbHdheXMgY3JlYXRlIGEgYGJ1dHRvbmAgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcz17fV1cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzPXt9XVxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cbiAgQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKHRhZykge1xuICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgdGFnID0gJ2J1dHRvbic7XG5cbiAgICBwcm9wcyA9IGFzc2lnbih7XG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cInZqcy1pY29uLXBsYWNlaG9sZGVyXCI+PC9zcGFuPicsXG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpXG4gICAgfSwgcHJvcHMpO1xuXG4gICAgLy8gQWRkIGF0dHJpYnV0ZXMgZm9yIGJ1dHRvbiBlbGVtZW50XG4gICAgYXR0cmlidXRlcyA9IGFzc2lnbih7XG5cbiAgICAgIC8vIE5lY2Vzc2FyeSBzaW5jZSB0aGUgZGVmYXVsdCBidXR0b24gdHlwZSBpcyBcInN1Ym1pdFwiXG4gICAgICAndHlwZSc6ICdidXR0b24nLFxuXG4gICAgICAvLyBsZXQgdGhlIHNjcmVlbiByZWFkZXIgdXNlciBrbm93IHRoYXQgdGhlIHRleHQgb2YgdGhlIGJ1dHRvbiBtYXkgY2hhbmdlXG4gICAgICAnYXJpYS1saXZlJzogJ3BvbGl0ZSdcbiAgICB9LCBhdHRyaWJ1dGVzKTtcblxuICAgIHZhciBlbCA9IENvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB0YWcsIHByb3BzLCBhdHRyaWJ1dGVzKTtcblxuICAgIHRoaXMuY3JlYXRlQ29udHJvbFRleHRFbChlbCk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNoaWxkIGBDb21wb25lbnRgIGluc2lkZSBvZiB0aGlzIGBCdXR0b25gLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xDb21wb25lbnR9IGNoaWxkXG4gICAqICAgICAgICBUaGUgbmFtZSBvciBpbnN0YW5jZSBvZiBhIGNoaWxkIHRvIGFkZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBvcHRpb25zIHRoYXQgd2lsbCBnZXQgcGFzc2VkIHRvIGNoaWxkcmVuIG9mXG4gICAqICAgICAgICB0aGUgY2hpbGQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAgICogICAgICAgICBUaGUgYENvbXBvbmVudGAgdGhhdCBnZXRzIGFkZGVkIGFzIGEgY2hpbGQuIFdoZW4gdXNpbmcgYSBzdHJpbmcgdGhlXG4gICAqICAgICAgICAgYENvbXBvbmVudGAgd2lsbCBnZXQgY3JlYXRlZCBieSB0aGlzIHByb2Nlc3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNVxuICAgKi9cblxuXG4gIEJ1dHRvbi5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZChjaGlsZCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICBsb2ckMS53YXJuKCdBZGRpbmcgYW4gYWN0aW9uYWJsZSAodXNlciBjb250cm9sbGFibGUpIGNoaWxkIHRvIGEgQnV0dG9uICgnICsgY2xhc3NOYW1lICsgJykgaXMgbm90IHN1cHBvcnRlZDsgdXNlIGEgQ2xpY2thYmxlQ29tcG9uZW50IGluc3RlYWQuJyk7XG5cbiAgICAvLyBBdm9pZCB0aGUgZXJyb3IgbWVzc2FnZSBnZW5lcmF0ZWQgYnkgQ2xpY2thYmxlQ29tcG9uZW50J3MgYWRkQ2hpbGQgbWV0aG9kXG4gICAgcmV0dXJuIENvbXBvbmVudC5wcm90b3R5cGUuYWRkQ2hpbGQuY2FsbCh0aGlzLCBjaGlsZCwgb3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGUgYEJ1dHRvbmAgZWxlbWVudCBzbyB0aGF0IGl0IGNhbiBiZSBhY3RpdmF0ZWQgb3IgY2xpY2tlZC4gVXNlIHRoaXMgd2l0aFxuICAgKiB7QGxpbmsgQnV0dG9uI2Rpc2FibGV9LlxuICAgKi9cblxuXG4gIEJ1dHRvbi5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIF9DbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmVuYWJsZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZWxfLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogRW5hYmxlIHRoZSBgQnV0dG9uYCBlbGVtZW50IHNvIHRoYXQgaXQgY2Fubm90IGJlIGFjdGl2YXRlZCBvciBjbGlja2VkLiBVc2UgdGhpcyB3aXRoXG4gICAqIHtAbGluayBCdXR0b24jZW5hYmxlfS5cbiAgICovXG5cblxuICBCdXR0b24ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIF9DbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmRpc2FibGUuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhIGBCdXR0b25gIGhhcyBmb2N1cyBhbmQgYGtleWRvd25gIGlzIHRyaWdnZXJlZCB2aWEgYSBrZXlcbiAgICogcHJlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBnZXQgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgQnV0dG9uLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG5cbiAgICAvLyBJZ25vcmUgU3BhY2UgKDMyKSBvciBFbnRlciAoMTMpIGtleSBvcGVyYXRpb24sIHdoaWNoIGlzIGhhbmRsZWQgYnkgdGhlIGJyb3dzZXIgZm9yIGEgYnV0dG9uLlxuICAgIGlmIChldmVudC53aGljaCA9PT0gMzIgfHwgZXZlbnQud2hpY2ggPT09IDEzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUGFzcyBrZXlwcmVzcyBoYW5kbGluZyB1cCBmb3IgdW5zdXBwb3J0ZWQga2V5c1xuICAgIF9DbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUtleVByZXNzLmNhbGwodGhpcywgZXZlbnQpO1xuICB9O1xuXG4gIHJldHVybiBCdXR0b247XG59KENsaWNrYWJsZUNvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQnV0dG9uJywgQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBiaWctcGxheS1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgaW5pdGlhbCBwbGF5IGJ1dHRvbiB0aGF0IHNob3dzIGJlZm9yZSB0aGUgdmlkZW8gaGFzIHBsYXllZC4gVGhlIGhpZGluZyBvZiB0aGVcbiAqIGBCaWdQbGF5QnV0dG9uYCBnZXQgZG9uZSB2aWEgQ1NTIGFuZCBgUGxheWVyYCBzdGF0ZXMuXG4gKlxuICogQGV4dGVuZHMgQnV0dG9uXG4gKi9cblxudmFyIEJpZ1BsYXlCdXR0b24gPSBmdW5jdGlvbiAoX0J1dHRvbikge1xuICBpbmhlcml0cyhCaWdQbGF5QnV0dG9uLCBfQnV0dG9uKTtcblxuICBmdW5jdGlvbiBCaWdQbGF5QnV0dG9uKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJpZ1BsYXlCdXR0b24pO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CdXR0b24uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LiBBbHdheXMgcmV0dXJucyAndmpzLWJpZy1wbGF5LWJ1dHRvbicuXG4gICAqL1xuICBCaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1iaWctcGxheS1idXR0b24nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQmlnUGxheUJ1dHRvbmAgXCJjbGlja2VkXCIuIFNlZSB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fVxuICAgKiBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICovXG5cblxuICBCaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIHBsYXlQcm9taXNlID0gdGhpcy5wbGF5ZXJfLnBsYXkoKTtcblxuICAgIHZhciBjYiA9IHRoaXMucGxheWVyXy5nZXRDaGlsZCgnY29udHJvbEJhcicpO1xuICAgIHZhciBwbGF5VG9nZ2xlID0gY2IgJiYgY2IuZ2V0Q2hpbGQoJ3BsYXlUb2dnbGUnKTtcblxuICAgIGlmICghcGxheVRvZ2dsZSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBsYXlQcm9taXNlKSB7XG4gICAgICBwbGF5UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHBsYXlUb2dnbGUuZm9jdXMoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBwbGF5VG9nZ2xlLmZvY3VzKCk7XG4gICAgICB9LCAxKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEJpZ1BsYXlCdXR0b247XG59KEJ1dHRvbik7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgQmlnUGxheUJ1dHRvbmBzIGNvbnRyb2xzLiBBZGRlZCB0byBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuQmlnUGxheUJ1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ1BsYXkgVmlkZW8nO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0JpZ1BsYXlCdXR0b24nLCBCaWdQbGF5QnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBjbG9zZS1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYENsb3NlQnV0dG9uYCBpcyBhIGB7QGxpbmsgQnV0dG9ufWAgdGhhdCBmaXJlcyBhIGBjbG9zZWAgZXZlbnQgd2hlblxuICogaXQgZ2V0cyBjbGlja2VkLlxuICpcbiAqIEBleHRlbmRzIEJ1dHRvblxuICovXG5cbnZhciBDbG9zZUJ1dHRvbiA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIGluaGVyaXRzKENsb3NlQnV0dG9uLCBfQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2xvc2VCdXR0b24ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xvc2VCdXR0b24pO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5jb250cm9sVGV4dChvcHRpb25zICYmIG9wdGlvbnMuY29udHJvbFRleHQgfHwgX3RoaXMubG9jYWxpemUoJ0Nsb3NlJykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgQ2xvc2VCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWNsb3NlLWJ1dHRvbiAnICsgX0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQ2xvc2VCdXR0b25gIGdldHMgY2xpY2tlZC4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlQ2xpY2t9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHdoZW4gdGhpcyB3aWxsIGJlXG4gICAqIHRyaWdnZXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyB0YXBcbiAgICogQGxpc3RlbnMgY2xpY2tcbiAgICogQGZpcmVzIENsb3NlQnV0dG9uI2Nsb3NlXG4gICAqL1xuXG5cbiAgQ2xvc2VCdXR0b24ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBhIGBDbG9zZUJ1dHRvbmAgaXMgY2xpY2tlZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBDbG9zZUJ1dHRvbiNjbG9zZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdXG4gICAgICogICAgICAgICAgIHNldCB0byBmYWxzZSBzbyB0aGF0IHRoZSBjbG9zZSBldmVudCBkb2VzIG5vdFxuICAgICAqICAgICAgICAgICBidWJibGUgdXAgdG8gcGFyZW50cyBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lclxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICdjbG9zZScsIGJ1YmJsZXM6IGZhbHNlIH0pO1xuICB9O1xuXG4gIHJldHVybiBDbG9zZUJ1dHRvbjtcbn0oQnV0dG9uKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDbG9zZUJ1dHRvbicsIENsb3NlQnV0dG9uKTtcblxuLyoqXG4gKiBAZmlsZSBwbGF5LXRvZ2dsZS5qc1xuICovXG4vKipcbiAqIEJ1dHRvbiB0byB0b2dnbGUgYmV0d2VlbiBwbGF5IGFuZCBwYXVzZS5cbiAqXG4gKiBAZXh0ZW5kcyBCdXR0b25cbiAqL1xuXG52YXIgUGxheVRvZ2dsZSA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIGluaGVyaXRzKFBsYXlUb2dnbGUsIF9CdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUGxheVRvZ2dsZShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5VG9nZ2xlKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAncGxheScsIF90aGlzLmhhbmRsZVBsYXkpO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ3BhdXNlJywgX3RoaXMuaGFuZGxlUGF1c2UpO1xuICAgIF90aGlzLm9uKHBsYXllciwgJ2VuZGVkJywgX3RoaXMuaGFuZGxlRW5kZWQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtcGxheS1jb250cm9sICcgKyBfQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgUGxheVRvZ2dsZWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLnBhdXNlZCgpKSB7XG4gICAgICB0aGlzLnBsYXllcl8ucGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBsYXllcl8ucGF1c2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgdmpzLXBsYXlpbmcgY2xhc3MgdG8gdGhlIGVsZW1lbnQgc28gaXQgY2FuIGNoYW5nZSBhcHBlYXJhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNwbGF5XG4gICAqL1xuXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlUGxheSA9IGZ1bmN0aW9uIGhhbmRsZVBsYXkoZXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZW5kZWQnKTtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGF1c2VkJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBsYXlpbmcnKTtcbiAgICAvLyBjaGFuZ2UgdGhlIGJ1dHRvbiB0ZXh0IHRvIFwiUGF1c2VcIlxuICAgIHRoaXMuY29udHJvbFRleHQoJ1BhdXNlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgdmpzLXBhdXNlZCBjbGFzcyB0byB0aGUgZWxlbWVudCBzbyBpdCBjYW4gY2hhbmdlIGFwcGVhcmFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3BhdXNlXG4gICAqL1xuXG5cbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlUGF1c2UgPSBmdW5jdGlvbiBoYW5kbGVQYXVzZShldmVudCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIC8vIGNoYW5nZSB0aGUgYnV0dG9uIHRleHQgdG8gXCJQbGF5XCJcbiAgICB0aGlzLmNvbnRyb2xUZXh0KCdQbGF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgdmpzLWVuZGVkIGNsYXNzIHRvIHRoZSBlbGVtZW50IHNvIGl0IGNhbiBjaGFuZ2UgYXBwZWFyYW5jZVxuICAgKlxuICAgKi9cblxuXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmhhbmRsZUVuZGVkID0gZnVuY3Rpb24gaGFuZGxlRW5kZWQoZXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGxheWluZycpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuICAgIC8vIGNoYW5nZSB0aGUgYnV0dG9uIHRleHQgdG8gXCJSZXBsYXlcIlxuICAgIHRoaXMuY29udHJvbFRleHQoJ1JlcGxheScpO1xuICB9O1xuXG4gIHJldHVybiBQbGF5VG9nZ2xlO1xufShCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFBsYXlUb2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cblBsYXlUb2dnbGUucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdQbGF5JztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5VG9nZ2xlJywgUGxheVRvZ2dsZSk7XG5cbi8qKlxuICogQGZpbGUgZm9ybWF0LXRpbWUuanNcbiAqIEBtb2R1bGUgRm9ybWF0LXRpbWVcbiAqL1xuXG4vKipcbiAqIEZvcm1hdCBzZWNvbmRzIGFzIGEgdGltZSBzdHJpbmcsIEg6TU06U1Mgb3IgTTpTUy4gU3VwcGx5aW5nIGEgZ3VpZGUgKGluIHNlY29uZHMpXG4gKiB3aWxsIGZvcmNlIGEgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3MgdG8gY292ZXIgdGhlIGxlbmd0aCBvZiB0aGUgZ3VpZGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHNcbiAqICAgICAgICBOdW1iZXIgb2Ygc2Vjb25kcyB0byBiZSB0dXJuZWQgaW50byBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBndWlkZVxuICogICAgICAgIE51bWJlciAoaW4gc2Vjb25kcykgdG8gbW9kZWwgdGhlIHN0cmluZyBhZnRlclxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgVGltZSBmb3JtYXR0ZWQgYXMgSDpNTTpTUyBvciBNOlNTXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFRpbWUoc2Vjb25kcykge1xuICB2YXIgZ3VpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHNlY29uZHM7XG5cbiAgc2Vjb25kcyA9IHNlY29uZHMgPCAwID8gMCA6IHNlY29uZHM7XG4gIHZhciBzID0gTWF0aC5mbG9vcihzZWNvbmRzICUgNjApO1xuICB2YXIgbSA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDYwICUgNjApO1xuICB2YXIgaCA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDM2MDApO1xuICB2YXIgZ20gPSBNYXRoLmZsb29yKGd1aWRlIC8gNjAgJSA2MCk7XG4gIHZhciBnaCA9IE1hdGguZmxvb3IoZ3VpZGUgLyAzNjAwKTtcblxuICAvLyBoYW5kbGUgaW52YWxpZCB0aW1lc1xuICBpZiAoaXNOYU4oc2Vjb25kcykgfHwgc2Vjb25kcyA9PT0gSW5maW5pdHkpIHtcbiAgICAvLyAnLScgaXMgZmFsc2UgZm9yIGFsbCByZWxhdGlvbmFsIG9wZXJhdG9ycyAoZS5nLiA8LCA+PSkgc28gdGhpcyBzZXR0aW5nXG4gICAgLy8gd2lsbCBhZGQgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGZpZWxkcyBzcGVjaWZpZWQgYnkgdGhlIGd1aWRlXG4gICAgaCA9IG0gPSBzID0gJy0nO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBzaG93IGhvdXJzXG4gIGggPSBoID4gMCB8fCBnaCA+IDAgPyBoICsgJzonIDogJyc7XG5cbiAgLy8gSWYgaG91cnMgYXJlIHNob3dpbmcsIHdlIG1heSBuZWVkIHRvIGFkZCBhIGxlYWRpbmcgemVyby5cbiAgLy8gQWx3YXlzIHNob3cgYXQgbGVhc3Qgb25lIGRpZ2l0IG9mIG1pbnV0ZXMuXG4gIG0gPSAoKGggfHwgZ20gPj0gMTApICYmIG0gPCAxMCA/ICcwJyArIG0gOiBtKSArICc6JztcblxuICAvLyBDaGVjayBpZiBsZWFkaW5nIHplcm8gaXMgbmVlZCBmb3Igc2Vjb25kc1xuICBzID0gcyA8IDEwID8gJzAnICsgcyA6IHM7XG5cbiAgcmV0dXJuIGggKyBtICsgcztcbn1cblxuLyoqXG4gKiBAZmlsZSBjdXJyZW50LXRpbWUtZGlzcGxheS5qc1xuICovXG4vKipcbiAqIERpc3BsYXlzIHRoZSBjdXJyZW50IHRpbWVcbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgQ3VycmVudFRpbWVEaXNwbGF5ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoQ3VycmVudFRpbWVEaXNwbGF5LCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIEN1cnJlbnRUaW1lRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDdXJyZW50VGltZURpc3BsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy50aHJvdHRsZWRVcGRhdGVDb250ZW50ID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMudXBkYXRlQ29udGVudCksIDI1KTtcbiAgICBfdGhpcy5vbihwbGF5ZXIsICd0aW1ldXBkYXRlJywgX3RoaXMudGhyb3R0bGVkVXBkYXRlQ29udGVudCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgQ3VycmVudFRpbWVEaXNwbGF5LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBlbCA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jdXJyZW50LXRpbWUgdmpzLXRpbWUtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGVudEVsXyA9IGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtY3VycmVudC10aW1lLWRpc3BsYXknXG4gICAgfSwge1xuICAgICAgLy8gdGVsbCBzY3JlZW4gcmVhZGVycyBub3QgdG8gYXV0b21hdGljYWxseSByZWFkIHRoZSB0aW1lIGFzIGl0IGNoYW5nZXNcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xuICAgIH0sIGNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtdGV4dCcsXG4gICAgICB0ZXh0Q29udGVudDogdGhpcy5sb2NhbGl6ZSgnQ3VycmVudCBUaW1lJylcbiAgICB9KSk7XG5cbiAgICB0aGlzLnVwZGF0ZVRleHROb2RlXygpO1xuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsXyk7XG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBcImN1cnJlbnQgdGltZVwiIHRleHQgbm9kZSB3aXRoIG5ldyBjb250ZW50IHVzaW5nIHRoZVxuICAgKiBjb250ZW50cyBvZiB0aGUgYGZvcm1hdHRlZFRpbWVfYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDdXJyZW50VGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZVRleHROb2RlXyA9IGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlXygpIHtcbiAgICBpZiAodGhpcy50ZXh0Tm9kZV8pIHtcbiAgICAgIHRoaXMuY29udGVudEVsXy5yZW1vdmVDaGlsZCh0aGlzLnRleHROb2RlXyk7XG4gICAgfVxuICAgIHRoaXMudGV4dE5vZGVfID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyAnICsgKHRoaXMuZm9ybWF0dGVkVGltZV8gfHwgJzA6MDAnKSk7XG4gICAgdGhpcy5jb250ZW50RWxfLmFwcGVuZENoaWxkKHRoaXMudGV4dE5vZGVfKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGN1cnJlbnQgdGltZSBkaXNwbGF5XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgdGltZXVwZGF0ZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciN0aW1ldXBkYXRlXG4gICAqL1xuXG5cbiAgQ3VycmVudFRpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gdXBkYXRlQ29udGVudChldmVudCkge1xuICAgIC8vIEFsbG93cyBmb3Igc21vb3RoIHNjcnViYmluZywgd2hlbiBwbGF5ZXIgY2FuJ3Qga2VlcCB1cC5cbiAgICB2YXIgdGltZSA9IHRoaXMucGxheWVyXy5zY3J1YmJpbmcoKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG4gICAgdmFyIGZvcm1hdHRlZFRpbWUgPSBmb3JtYXRUaW1lKHRpbWUsIHRoaXMucGxheWVyXy5kdXJhdGlvbigpKTtcblxuICAgIGlmIChmb3JtYXR0ZWRUaW1lICE9PSB0aGlzLmZvcm1hdHRlZFRpbWVfKSB7XG4gICAgICB0aGlzLmZvcm1hdHRlZFRpbWVfID0gZm9ybWF0dGVkVGltZTtcbiAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlVGV4dE5vZGVfKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEN1cnJlbnRUaW1lRGlzcGxheTtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDdXJyZW50VGltZURpc3BsYXknLCBDdXJyZW50VGltZURpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIGR1cmF0aW9uLWRpc3BsYXkuanNcbiAqL1xuLyoqXG4gKiBEaXNwbGF5cyB0aGUgZHVyYXRpb25cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgRHVyYXRpb25EaXNwbGF5ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoRHVyYXRpb25EaXNwbGF5LCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIER1cmF0aW9uRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBEdXJhdGlvbkRpc3BsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy50aHJvdHRsZWRVcGRhdGVDb250ZW50ID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMudXBkYXRlQ29udGVudCksIDI1KTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgWydkdXJhdGlvbmNoYW5nZScsXG5cbiAgICAvLyBBbHNvIGxpc3RlbiBmb3IgdGltZXVwZGF0ZSBhbmQgbG9hZGVkbWV0YWRhdGEgYmVjYXVzZSByZW1vdmluZyB0aG9zZVxuICAgIC8vIGxpc3RlbmVycyBjb3VsZCBoYXZlIGJyb2tlbiBkZXBlbmRlbnQgYXBwbGljYXRpb25zL2xpYnJhcmllcy4gVGhlc2VcbiAgICAvLyBjYW4gbGlrZWx5IGJlIHJlbW92ZWQgZm9yIDcuMC5cbiAgICAnbG9hZGVkbWV0YWRhdGEnLCAndGltZXVwZGF0ZSddLCBfdGhpcy50aHJvdHRsZWRVcGRhdGVDb250ZW50KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBEdXJhdGlvbkRpc3BsYXkucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIGVsID0gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWR1cmF0aW9uIHZqcy10aW1lLWNvbnRyb2wgdmpzLWNvbnRyb2wnXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWR1cmF0aW9uLWRpc3BsYXknXG4gICAgfSwge1xuICAgICAgLy8gdGVsbCBzY3JlZW4gcmVhZGVycyBub3QgdG8gYXV0b21hdGljYWxseSByZWFkIHRoZSB0aW1lIGFzIGl0IGNoYW5nZXNcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xuICAgIH0sIGNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtdGV4dCcsXG4gICAgICB0ZXh0Q29udGVudDogdGhpcy5sb2NhbGl6ZSgnRHVyYXRpb24gVGltZScpXG4gICAgfSkpO1xuXG4gICAgdGhpcy51cGRhdGVUZXh0Tm9kZV8oKTtcbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgXCJjdXJyZW50IHRpbWVcIiB0ZXh0IG5vZGUgd2l0aCBuZXcgY29udGVudCB1c2luZyB0aGVcbiAgICogY29udGVudHMgb2YgdGhlIGBmb3JtYXR0ZWRUaW1lX2AgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgRHVyYXRpb25EaXNwbGF5LnByb3RvdHlwZS51cGRhdGVUZXh0Tm9kZV8gPSBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZV8oKSB7XG4gICAgaWYgKHRoaXMudGV4dE5vZGVfKSB7XG4gICAgICB0aGlzLmNvbnRlbnRFbF8ucmVtb3ZlQ2hpbGQodGhpcy50ZXh0Tm9kZV8pO1xuICAgIH1cbiAgICB0aGlzLnRleHROb2RlXyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJyArICh0aGlzLmZvcm1hdHRlZFRpbWVfIHx8ICcwOjAwJykpO1xuICAgIHRoaXMuY29udGVudEVsXy5hcHBlbmRDaGlsZCh0aGlzLnRleHROb2RlXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBkdXJhdGlvbiB0aW1lIGRpc3BsYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgZHVyYXRpb25jaGFuZ2VgLCBgdGltZXVwZGF0ZWAsIG9yIGBsb2FkZWRtZXRhZGF0YWAgZXZlbnQgdGhhdCBjYXVzZWRcbiAgICogICAgICAgIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcbiAgICogQGxpc3RlbnMgUGxheWVyI3RpbWV1cGRhdGVcbiAgICogQGxpc3RlbnMgUGxheWVyI2xvYWRlZG1ldGFkYXRhXG4gICAqL1xuXG5cbiAgRHVyYXRpb25EaXNwbGF5LnByb3RvdHlwZS51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gdXBkYXRlQ29udGVudChldmVudCkge1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuXG4gICAgaWYgKGR1cmF0aW9uICYmIHRoaXMuZHVyYXRpb25fICE9PSBkdXJhdGlvbikge1xuICAgICAgdGhpcy5kdXJhdGlvbl8gPSBkdXJhdGlvbjtcbiAgICAgIHRoaXMuZm9ybWF0dGVkVGltZV8gPSBmb3JtYXRUaW1lKGR1cmF0aW9uKTtcbiAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlVGV4dE5vZGVfKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIER1cmF0aW9uRGlzcGxheTtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdEdXJhdGlvbkRpc3BsYXknLCBEdXJhdGlvbkRpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIHRpbWUtZGl2aWRlci5qc1xuICovXG4vKipcbiAqIFRoZSBzZXBhcmF0b3IgYmV0d2VlbiB0aGUgY3VycmVudCB0aW1lIGFuZCBkdXJhdGlvbi5cbiAqIENhbiBiZSBoaWRkZW4gaWYgaXQncyBub3QgbmVlZGVkIGluIHRoZSBkZXNpZ24uXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFRpbWVEaXZpZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVGltZURpdmlkZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRpbWVEaXZpZGVyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVEaXZpZGVyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgY29tcG9uZW50J3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgVGltZURpdmlkZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10aW1lLWNvbnRyb2wgdmpzLXRpbWUtZGl2aWRlcicsXG4gICAgICBpbm5lckhUTUw6ICc8ZGl2PjxzcGFuPi88L3NwYW4+PC9kaXY+J1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBUaW1lRGl2aWRlcjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUaW1lRGl2aWRlcicsIFRpbWVEaXZpZGVyKTtcblxuLyoqXG4gKiBAZmlsZSByZW1haW5pbmctdGltZS1kaXNwbGF5LmpzXG4gKi9cbi8qKlxuICogRGlzcGxheXMgdGhlIHRpbWUgbGVmdCBpbiB0aGUgdmlkZW9cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgUmVtYWluaW5nVGltZURpc3BsYXkgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhSZW1haW5pbmdUaW1lRGlzcGxheSwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBSZW1haW5pbmdUaW1lRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBSZW1haW5pbmdUaW1lRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy51cGRhdGVDb250ZW50KSwgMjUpO1xuICAgIF90aGlzLm9uKHBsYXllciwgWyd0aW1ldXBkYXRlJywgJ2R1cmF0aW9uY2hhbmdlJ10sIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFJlbWFpbmluZ1RpbWVEaXNwbGF5LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBlbCA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1yZW1haW5pbmctdGltZSB2anMtdGltZS1jb250cm9sIHZqcy1jb250cm9sJ1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250ZW50RWxfID0gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1yZW1haW5pbmctdGltZS1kaXNwbGF5J1xuICAgIH0sIHtcbiAgICAgIC8vIHRlbGwgc2NyZWVuIHJlYWRlcnMgbm90IHRvIGF1dG9tYXRpY2FsbHkgcmVhZCB0aGUgdGltZSBhcyBpdCBjaGFuZ2VzXG4gICAgICAnYXJpYS1saXZlJzogJ29mZidcbiAgICB9LCBjcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jb250cm9sLXRleHQnLFxuICAgICAgdGV4dENvbnRlbnQ6IHRoaXMubG9jYWxpemUoJ1JlbWFpbmluZyBUaW1lJylcbiAgICB9KSk7XG5cbiAgICB0aGlzLnVwZGF0ZVRleHROb2RlXygpO1xuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsXyk7XG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBcInJlbWFpbmluZyB0aW1lXCIgdGV4dCBub2RlIHdpdGggbmV3IGNvbnRlbnQgdXNpbmcgdGhlXG4gICAqIGNvbnRlbnRzIG9mIHRoZSBgZm9ybWF0dGVkVGltZV9gIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFJlbWFpbmluZ1RpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVUZXh0Tm9kZV8gPSBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZV8oKSB7XG4gICAgaWYgKHRoaXMudGV4dE5vZGVfKSB7XG4gICAgICB0aGlzLmNvbnRlbnRFbF8ucmVtb3ZlQ2hpbGQodGhpcy50ZXh0Tm9kZV8pO1xuICAgIH1cbiAgICB0aGlzLnRleHROb2RlXyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgLScgKyAodGhpcy5mb3JtYXR0ZWRUaW1lXyB8fCAnMDowMCcpKTtcbiAgICB0aGlzLmNvbnRlbnRFbF8uYXBwZW5kQ2hpbGQodGhpcy50ZXh0Tm9kZV8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgcmVtYWluaW5nIHRpbWUgZGlzcGxheS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGB0aW1ldXBkYXRlYCBvciBgZHVyYXRpb25jaGFuZ2VgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGltZXVwZGF0ZVxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcbiAgICovXG5cblxuICBSZW1haW5pbmdUaW1lRGlzcGxheS5wcm90b3R5cGUudXBkYXRlQ29udGVudCA9IGZ1bmN0aW9uIHVwZGF0ZUNvbnRlbnQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpIHtcbiAgICAgIHZhciBmb3JtYXR0ZWRUaW1lID0gZm9ybWF0VGltZSh0aGlzLnBsYXllcl8ucmVtYWluaW5nVGltZSgpKTtcblxuICAgICAgaWYgKGZvcm1hdHRlZFRpbWUgIT09IHRoaXMuZm9ybWF0dGVkVGltZV8pIHtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZWRUaW1lXyA9IGZvcm1hdHRlZFRpbWU7XG4gICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlVGV4dE5vZGVfKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJlbWFpbmluZ1RpbWVEaXNwbGF5O1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1JlbWFpbmluZ1RpbWVEaXNwbGF5JywgUmVtYWluaW5nVGltZURpc3BsYXkpO1xuXG4vKipcbiAqIEBmaWxlIGxpdmUtZGlzcGxheS5qc1xuICovXG4vLyBUT0RPIC0gRnV0dXJlIG1ha2UgaXQgY2xpY2sgdG8gc25hcCB0byBsaXZlXG5cbi8qKlxuICogRGlzcGxheXMgdGhlIGxpdmUgaW5kaWNhdG9yIHdoZW4gZHVyYXRpb24gaXMgSW5maW5pdHkuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIExpdmVEaXNwbGF5ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTGl2ZURpc3BsYXksIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTGl2ZURpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTGl2ZURpc3BsYXkpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGVTaG93aW5nKCk7XG4gICAgX3RoaXMub24oX3RoaXMucGxheWVyKCksICdkdXJhdGlvbmNoYW5nZScsIF90aGlzLnVwZGF0ZVNob3dpbmcpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIExpdmVEaXNwbGF5LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBlbCA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1saXZlLWNvbnRyb2wgdmpzLWNvbnRyb2wnXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBjcmVhdGVFbCgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxpdmUtZGlzcGxheScsXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4nICsgdGhpcy5sb2NhbGl6ZSgnU3RyZWFtIFR5cGUnKSArICc8L3NwYW4+JyArIHRoaXMubG9jYWxpemUoJ0xJVkUnKVxuICAgIH0sIHtcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBkdXJhdGlvbiB0byBzZWUgaWYgdGhlIExpdmVEaXNwbGF5IHNob3VsZCBiZSBzaG93aW5nIG9yIG5vdC4gVGhlbiBzaG93L2hpZGVcbiAgICogaXQgYWNjb3JkaW5nbHlcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIHtAbGluayBQbGF5ZXIjZHVyYXRpb25jaGFuZ2V9IGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcbiAgICovXG5cblxuICBMaXZlRGlzcGxheS5wcm90b3R5cGUudXBkYXRlU2hvd2luZyA9IGZ1bmN0aW9uIHVwZGF0ZVNob3dpbmcoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXIoKS5kdXJhdGlvbigpID09PSBJbmZpbml0eSkge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTGl2ZURpc3BsYXk7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTGl2ZURpc3BsYXknLCBMaXZlRGlzcGxheSk7XG5cbi8qKlxuICogQGZpbGUgc2xpZGVyLmpzXG4gKi9cbi8qKlxuICogVGhlIGJhc2UgZnVuY3Rpb25hbGl0eSBmb3IgYSBzbGlkZXIuIENhbiBiZSB2ZXJ0aWNhbCBvciBob3Jpem9udGFsLlxuICogRm9yIGluc3RhbmNlIHRoZSB2b2x1bWUgYmFyIG9yIHRoZSBzZWVrIGJhciBvbiBhIHZpZGVvIGlzIGEgc2xpZGVyLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBTbGlkZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhTbGlkZXIsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFNsaWRlcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTbGlkZXIpO1xuXG4gICAgLy8gU2V0IHByb3BlcnR5IG5hbWVzIHRvIGJhciB0byBtYXRjaCB3aXRoIHRoZSBjaGlsZCBTbGlkZXIgY2xhc3MgaXMgbG9va2luZyBmb3JcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmJhciA9IF90aGlzLmdldENoaWxkKF90aGlzLm9wdGlvbnNfLmJhck5hbWUpO1xuXG4gICAgLy8gU2V0IGEgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjbGFzcyBvbiB0aGUgc2xpZGVyIGRlcGVuZGluZyBvbiB0aGUgc2xpZGVyIHR5cGVcbiAgICBfdGhpcy52ZXJ0aWNhbCghIV90aGlzLm9wdGlvbnNfLnZlcnRpY2FsKTtcblxuICAgIF90aGlzLm9uKCdtb3VzZWRvd24nLCBfdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgIF90aGlzLm9uKCd0b3VjaHN0YXJ0JywgX3RoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICBfdGhpcy5vbignZm9jdXMnLCBfdGhpcy5oYW5kbGVGb2N1cyk7XG4gICAgX3RoaXMub24oJ2JsdXInLCBfdGhpcy5oYW5kbGVCbHVyKTtcbiAgICBfdGhpcy5vbignY2xpY2snLCBfdGhpcy5oYW5kbGVDbGljayk7XG5cbiAgICBfdGhpcy5vbihwbGF5ZXIsICdjb250cm9sc3Zpc2libGUnLCBfdGhpcy51cGRhdGUpO1xuXG4gICAgaWYgKF90aGlzLnBsYXllckV2ZW50KSB7XG4gICAgICBfdGhpcy5vbihwbGF5ZXIsIF90aGlzLnBsYXllckV2ZW50LCBfdGhpcy51cGRhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQnV0dG9uYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqICAgICAgICBUeXBlIG9mIGVsZW1lbnQgdG8gY3JlYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzPXt9XVxuICAgKiAgICAgICAgTGlzdCBvZiBwcm9wZXJ0aWVzIGluIE9iamVjdCBmb3JtLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXM9e31dXG4gICAqICAgICAgICBsaXN0IG9mIGF0dHJpYnV0ZXMgaW4gT2JqZWN0IGZvcm0uXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKHR5cGUpIHtcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIC8vIEFkZCB0aGUgc2xpZGVyIGVsZW1lbnQgY2xhc3MgdG8gYWxsIHN1YiBjbGFzc2VzXG4gICAgcHJvcHMuY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lICsgJyB2anMtc2xpZGVyJztcbiAgICBwcm9wcyA9IGFzc2lnbih7XG4gICAgICB0YWJJbmRleDogMFxuICAgIH0sIHByb3BzKTtcblxuICAgIGF0dHJpYnV0ZXMgPSBhc3NpZ24oe1xuICAgICAgJ3JvbGUnOiAnc2xpZGVyJyxcbiAgICAgICdhcmlhLXZhbHVlbm93JzogMCxcbiAgICAgICdhcmlhLXZhbHVlbWluJzogMCxcbiAgICAgICdhcmlhLXZhbHVlbWF4JzogMTAwLFxuICAgICAgJ3RhYkluZGV4JzogMFxuICAgIH0sIGF0dHJpYnV0ZXMpO1xuXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgdHlwZSwgcHJvcHMsIGF0dHJpYnV0ZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50cyBvbiB0aGUgYFNsaWRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cbiAgICogQGxpc3RlbnMgdG91Y2hzdGFydFxuICAgKiBAZmlyZXMgU2xpZGVyI3NsaWRlcmFjdGl2ZVxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG4gICAgdmFyIGRvYyA9IHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBibG9ja1RleHRTZWxlY3Rpb24oKTtcblxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkaW5nJyk7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHNsaWRlciBpcyBpbiBhbiBhY3RpdmUgc3RhdGVcbiAgICAgKlxuICAgICAqIEBldmVudCBTbGlkZXIjc2xpZGVyYWN0aXZlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignc2xpZGVyYWN0aXZlJyk7XG5cbiAgICB0aGlzLm9uKGRvYywgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKGRvYywgJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIHRoaXMub24oZG9jLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub24oZG9jLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuXG4gICAgdGhpcy5oYW5kbGVNb3VzZU1vdmUoZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGhlIGBtb3VzZW1vdmVgLCBgdG91Y2htb3ZlYCwgYW5kIGBtb3VzZWRvd25gIGV2ZW50cyBvbiB0aGlzIGBTbGlkZXJgLlxuICAgKiBUaGUgYG1vdXNlbW92ZWAgYW5kIGB0b3VjaG1vdmVgIGV2ZW50cyB3aWxsIG9ubHkgb25seSB0cmlnZ2VyIHRoaXMgZnVuY3Rpb24gZHVyaW5nXG4gICAqIGBtb3VzZWRvd25gIGFuZCBgdG91Y2hzdGFydGAuIFRoaXMgaXMgZHVlIHRvIHtAbGluayBTbGlkZXIjaGFuZGxlTW91c2VEb3dufSBhbmRcbiAgICoge0BsaW5rIFNsaWRlciNoYW5kbGVNb3VzZVVwfS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZWRvd25gLCBgbW91c2Vtb3ZlYCwgYHRvdWNoc3RhcnRgLCBvciBgdG91Y2htb3ZlYCBldmVudCB0aGF0IHRyaWdnZXJlZFxuICAgKiAgICAgICAgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZW1vdmVcbiAgICogQGxpc3RlbnMgdG91Y2htb3ZlXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHt9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNldXBgIG9yIGB0b3VjaGVuZGAgZXZlbnRzIG9uIHRoZSBgU2xpZGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRvdWNoZW5kXG4gICAqIEBsaXN0ZW5zIG1vdXNldXBcbiAgICogQGZpcmVzIFNsaWRlciNzbGlkZXJpbmFjdGl2ZVxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoKSB7XG4gICAgdmFyIGRvYyA9IHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdW5ibG9ja1RleHRTZWxlY3Rpb24oKTtcblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zbGlkaW5nJyk7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHNsaWRlciBpcyBubyBsb25nZXIgaW4gYW4gYWN0aXZlIHN0YXRlLlxuICAgICAqXG4gICAgICogQGV2ZW50IFNsaWRlciNzbGlkZXJpbmFjdGl2ZVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3NsaWRlcmluYWN0aXZlJyk7XG5cbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5vZmYoZG9jLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MgYmFyIG9mIHRoZSBgU2xpZGVyYC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICogICAgICAgICAgVGhlIHBlcmNlbnRhZ2Ugb2YgcHJvZ3Jlc3MgdGhlIHByb2dyZXNzIGJhciByZXByZXNlbnRzIGFzIGFcbiAgICogICAgICAgICAgbnVtYmVyIGZyb20gMCB0byAxLlxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG4gICAgLy8gSW4gVm9sdW1lQmFyIGluaXQgd2UgaGF2ZSBhIHNldFRpbWVvdXQgZm9yIHVwZGF0ZSB0aGF0IHBvcHMgYW5kIHVwZGF0ZVxuICAgIC8vIHRvIHRoZSBlbmQgb2YgdGhlIGV4ZWN1dGlvbiBzdGFjay4gVGhlIHBsYXllciBpcyBkZXN0cm95ZWQgYmVmb3JlIHRoZW5cbiAgICAvLyB1cGRhdGUgd2lsbCBjYXVzZSBhbiBlcnJvclxuICAgIGlmICghdGhpcy5lbF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBzY3J1YmJpbmcsIHdlIGNvdWxkIHVzZSBhIGNhY2hlZCB2YWx1ZSB0byBtYWtlIHRoZSBoYW5kbGUga2VlcCB1cFxuICAgIC8vIHdpdGggdGhlIHVzZXIncyBtb3VzZS4gT24gSFRNTDUgYnJvd3NlcnMgc2NydWJiaW5nIGlzIHJlYWxseSBzbW9vdGgsIGJ1dFxuICAgIC8vIHNvbWUgZmxhc2ggcGxheWVycyBhcmUgc2xvdywgc28gd2UgbWlnaHQgd2FudCB0byB1dGlsaXplIHRoaXMgbGF0ZXIuXG4gICAgLy8gdmFyIHByb2dyZXNzID0gICh0aGlzLnBsYXllcl8uc2NydWJiaW5nKCkpID8gdGhpcy5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgLyB0aGlzLnBsYXllcl8uZHVyYXRpb24oKSA6IHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpIC8gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG4gICAgdmFyIHByb2dyZXNzID0gdGhpcy5nZXRQZXJjZW50KCk7XG4gICAgdmFyIGJhciA9IHRoaXMuYmFyO1xuXG4gICAgLy8gSWYgdGhlcmUncyBubyBiYXIuLi5cbiAgICBpZiAoIWJhcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByb3RlY3QgYWdhaW5zdCBubyBkdXJhdGlvbiBhbmQgb3RoZXIgZGl2aXNpb24gaXNzdWVzXG4gICAgaWYgKHR5cGVvZiBwcm9ncmVzcyAhPT0gJ251bWJlcicgfHwgcHJvZ3Jlc3MgIT09IHByb2dyZXNzIHx8IHByb2dyZXNzIDwgMCB8fCBwcm9ncmVzcyA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHByb2dyZXNzID0gMDtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IHRvIGEgcGVyY2VudGFnZSBmb3Igc2V0dGluZ1xuICAgIHZhciBwZXJjZW50YWdlID0gKHByb2dyZXNzICogMTAwKS50b0ZpeGVkKDIpICsgJyUnO1xuICAgIHZhciBzdHlsZSA9IGJhci5lbCgpLnN0eWxlO1xuXG4gICAgLy8gU2V0IHRoZSBuZXcgYmFyIHdpZHRoIG9yIGhlaWdodFxuICAgIGlmICh0aGlzLnZlcnRpY2FsKCkpIHtcbiAgICAgIHN0eWxlLmhlaWdodCA9IHBlcmNlbnRhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLndpZHRoID0gcGVyY2VudGFnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBkaXN0YW5jZSBmb3Igc2xpZGVyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgU2xpZGVyLlxuICAgKiAgICAgICAgIC0gcG9zdGl0aW9uLnggZm9yIHZlcnRpY2FsIGBTbGlkZXJgc1xuICAgKiAgICAgICAgIC0gcG9zdGl0aW9uLnkgZm9yIGhvcml6b250YWwgYFNsaWRlcmBzXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5jYWxjdWxhdGVEaXN0YW5jZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSB7XG4gICAgdmFyIHBvc2l0aW9uID0gZ2V0UG9pbnRlclBvc2l0aW9uKHRoaXMuZWxfLCBldmVudCk7XG5cbiAgICBpZiAodGhpcy52ZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb24ueTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uLng7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBmb2N1c2AgZXZlbnQgb24gdGhpcyBgU2xpZGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgZm9jdXNgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBmb2N1c1xuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlRm9jdXMgPSBmdW5jdGlvbiBoYW5kbGVGb2N1cygpIHtcbiAgICB0aGlzLm9uKHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5UHJlc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBga2V5ZG93bmAgZXZlbnQgb24gdGhlIGBTbGlkZXJgLiBXYXRjaGVzIGZvciBsZWZ0LCByaWd0aCwgdXAsIGFuZCBkb3duXG4gICAqIGFycm93IGtleXMuIFRoaXMgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIGNhbGxlZCB3aGVuIHRoZSBzbGlkZXIgaGFzIGZvY3VzLiBTZWVcbiAgICoge0BsaW5rIFNsaWRlciNoYW5kbGVGb2N1c30gYW5kIHtAbGluayBTbGlkZXIjaGFuZGxlQmx1cn0uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICB0aGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG4gICAgLy8gTGVmdCBhbmQgRG93biBBcnJvd3NcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDM3IHx8IGV2ZW50LndoaWNoID09PSA0MCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc3RlcEJhY2soKTtcblxuICAgICAgLy8gVXAgYW5kIFJpZ2h0IEFycm93c1xuICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDM4IHx8IGV2ZW50LndoaWNoID09PSAzOSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc3RlcEZvcndhcmQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBibHVyYCBldmVudCBvbiB0aGlzIGBTbGlkZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBibHVyYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgYmx1clxuICAgKi9cblxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuICAgIHRoaXMub2ZmKHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5UHJlc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0ZW5lciBmb3IgY2xpY2sgZXZlbnRzIG9uIHNsaWRlciwgdXNlZCB0byBwcmV2ZW50IGNsaWNrc1xuICAgKiAgIGZyb20gYnViYmxpbmcgdXAgdG8gcGFyZW50IGVsZW1lbnRzIGxpa2UgYnV0dG9uIG1lbnVzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICAgICAgIEV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgb2JqZWN0IHRvIHJ1blxuICAgKi9cblxuXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldC9zZXQgaWYgc2xpZGVyIGlzIGhvcml6b250YWwgZm9yIHZlcnRpY2FsXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb2xdXG4gICAqICAgICAgICAtIHRydWUgaWYgc2xpZGVyIGlzIHZlcnRpY2FsLFxuICAgKiAgICAgICAgLSBmYWxzZSBpcyBob3Jpem9udGFsXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSB0cnVlIGlmIHNsaWRlciBpcyB2ZXJ0aWNhbCwgYW5kIGdldHRpbmdcbiAgICogICAgICAgICAtIGZhbHNlIGlmIHRoZSBzbGlkZXIgaXMgaG9yaXpvbnRhbCwgYW5kIGdldHRpbmdcbiAgICovXG5cblxuICBTbGlkZXIucHJvdG90eXBlLnZlcnRpY2FsID0gZnVuY3Rpb24gdmVydGljYWwoYm9vbCkge1xuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnZlcnRpY2FsXyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnZlcnRpY2FsXyA9ICEhYm9vbDtcblxuICAgIGlmICh0aGlzLnZlcnRpY2FsXykge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNsaWRlci12ZXJ0aWNhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLWhvcml6b250YWwnKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNsaWRlcjtcbn0oQ29tcG9uZW50KTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTbGlkZXInLCBTbGlkZXIpO1xuXG4vKipcbiAqIEBmaWxlIGxvYWQtcHJvZ3Jlc3MtYmFyLmpzXG4gKi9cbi8qKlxuICogU2hvd3MgbG9hZGluZyBwcm9ncmVzc1xuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBMb2FkUHJvZ3Jlc3NCYXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhMb2FkUHJvZ3Jlc3NCYXIsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTG9hZFByb2dyZXNzQmFyKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIExvYWRQcm9ncmVzc0Jhcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnBhcnRFbHNfID0gW107XG4gICAgX3RoaXMub24ocGxheWVyLCAncHJvZ3Jlc3MnLCBfdGhpcy51cGRhdGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIExvYWRQcm9ncmVzc0Jhci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWxvYWQtcHJvZ3Jlc3MnLFxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PHNwYW4+JyArIHRoaXMubG9jYWxpemUoJ0xvYWRlZCcpICsgJzwvc3Bhbj46IDAlPC9zcGFuPidcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHByb2dyZXNzIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYHByb2dyZXNzYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3Byb2dyZXNzXG4gICAqL1xuXG5cbiAgTG9hZFByb2dyZXNzQmFyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLnBsYXllcl8uYnVmZmVyZWQoKTtcbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcbiAgICB2YXIgYnVmZmVyZWRFbmQgPSB0aGlzLnBsYXllcl8uYnVmZmVyZWRFbmQoKTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnBhcnRFbHNfO1xuXG4gICAgLy8gZ2V0IHRoZSBwZXJjZW50IHdpZHRoIG9mIGEgdGltZSBjb21wYXJlZCB0byB0aGUgdG90YWwgZW5kXG4gICAgdmFyIHBlcmNlbnRpZnkgPSBmdW5jdGlvbiBwZXJjZW50aWZ5KHRpbWUsIGVuZCkge1xuICAgICAgLy8gbm8gTmFOXG4gICAgICB2YXIgcGVyY2VudCA9IHRpbWUgLyBlbmQgfHwgMDtcblxuICAgICAgcmV0dXJuIChwZXJjZW50ID49IDEgPyAxIDogcGVyY2VudCkgKiAxMDAgKyAnJSc7XG4gICAgfTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgd2lkdGggb2YgdGhlIHByb2dyZXNzIGJhclxuICAgIHRoaXMuZWxfLnN0eWxlLndpZHRoID0gcGVyY2VudGlmeShidWZmZXJlZEVuZCwgZHVyYXRpb24pO1xuXG4gICAgLy8gYWRkIGNoaWxkIGVsZW1lbnRzIHRvIHJlcHJlc2VudCB0aGUgaW5kaXZpZHVhbCBidWZmZXJlZCB0aW1lIHJhbmdlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KGkpO1xuICAgICAgdmFyIGVuZCA9IGJ1ZmZlcmVkLmVuZChpKTtcbiAgICAgIHZhciBwYXJ0ID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmICghcGFydCkge1xuICAgICAgICBwYXJ0ID0gdGhpcy5lbF8uYXBwZW5kQ2hpbGQoY3JlYXRlRWwoKSk7XG4gICAgICAgIGNoaWxkcmVuW2ldID0gcGFydDtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHRoZSBwZXJjZW50IGJhc2VkIG9uIHRoZSB3aWR0aCBvZiB0aGUgcHJvZ3Jlc3MgYmFyIChidWZmZXJlZEVuZClcbiAgICAgIHBhcnQuc3R5bGUubGVmdCA9IHBlcmNlbnRpZnkoc3RhcnQsIGJ1ZmZlcmVkRW5kKTtcbiAgICAgIHBhcnQuc3R5bGUud2lkdGggPSBwZXJjZW50aWZ5KGVuZCAtIHN0YXJ0LCBidWZmZXJlZEVuZCk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHVudXNlZCBidWZmZXJlZCByYW5nZSBlbGVtZW50c1xuICAgIGZvciAodmFyIF9pID0gY2hpbGRyZW4ubGVuZ3RoOyBfaSA+IGJ1ZmZlcmVkLmxlbmd0aDsgX2ktLSkge1xuICAgICAgdGhpcy5lbF8ucmVtb3ZlQ2hpbGQoY2hpbGRyZW5bX2kgLSAxXSk7XG4gICAgfVxuICAgIGNoaWxkcmVuLmxlbmd0aCA9IGJ1ZmZlcmVkLmxlbmd0aDtcbiAgfTtcblxuICByZXR1cm4gTG9hZFByb2dyZXNzQmFyO1xufShDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0xvYWRQcm9ncmVzc0JhcicsIExvYWRQcm9ncmVzc0Jhcik7XG5cbi8qKlxuICogQGZpbGUgdGltZS10b29sdGlwLmpzXG4gKi9cbi8qKlxuICogVGltZSB0b29sdGlwcyBkaXNwbGF5IGEgdGltZSBhYm92ZSB0aGUgcHJvZ3Jlc3MgYmFyLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBUaW1lVG9vbHRpcCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFRpbWVUb29sdGlwLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUaW1lVG9vbHRpcCgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lVG9vbHRpcCk7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIHRpbWUgdG9vbHRpcCBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBUaW1lVG9vbHRpcC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXRpbWUtdG9vbHRpcCdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHRpbWUgdG9vbHRpcCByZWxhdGl2ZSB0byB0aGUgYFNlZWtCYXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2Vla0JhclJlY3RcbiAgICogICAgICAgIFRoZSBgQ2xpZW50UmVjdGAgZm9yIHRoZSB7QGxpbmsgU2Vla0Jhcn0gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlZWtCYXJQb2ludFxuICAgKiAgICAgICAgQSBudW1iZXIgZnJvbSAwIHRvIDEsIHJlcHJlc2VudGluZyBhIGhvcml6b250YWwgcmVmZXJlbmNlIHBvaW50XG4gICAqICAgICAgICBmcm9tIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHtAbGluayBTZWVrQmFyfVxuICAgKi9cblxuXG4gIFRpbWVUb29sdGlwLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCwgY29udGVudCkge1xuICAgIHZhciB0b29sdGlwUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLmVsXyk7XG4gICAgdmFyIHBsYXllclJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy5wbGF5ZXJfLmVsKCkpO1xuICAgIHZhciBzZWVrQmFyUG9pbnRQeCA9IHNlZWtCYXJSZWN0LndpZHRoICogc2Vla0JhclBvaW50O1xuXG4gICAgLy8gZG8gbm90aGluZyBpZiBlaXRoZXIgcmVjdCBpc24ndCBhdmFpbGFibGVcbiAgICAvLyBmb3IgZXhhbXBsZSwgaWYgdGhlIHBsYXllciBpc24ndCBpbiB0aGUgRE9NIGZvciB0ZXN0aW5nXG4gICAgaWYgKCFwbGF5ZXJSZWN0IHx8ICF0b29sdGlwUmVjdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgdGhlIHNwYWNlIGxlZnQgb2YgdGhlIGBzZWVrQmFyUG9pbnRgIGF2YWlsYWJsZSB3aXRoaW4gdGhlIGJvdW5kc1xuICAgIC8vIG9mIHRoZSBwbGF5ZXIuIFdlIGNhbGN1bGF0ZSBhbnkgZ2FwIGJldHdlZW4gdGhlIGxlZnQgZWRnZSBvZiB0aGUgcGxheWVyXG4gICAgLy8gYW5kIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGBTZWVrQmFyYCBhbmQgYWRkIHRoZSBudW1iZXIgb2YgcGl4ZWxzIGluIHRoZVxuICAgIC8vIGBTZWVrQmFyYCBiZWZvcmUgaGl0dGluZyB0aGUgYHNlZWtCYXJQb2ludGBcbiAgICB2YXIgc3BhY2VMZWZ0T2ZQb2ludCA9IHNlZWtCYXJSZWN0LmxlZnQgLSBwbGF5ZXJSZWN0LmxlZnQgKyBzZWVrQmFyUG9pbnRQeDtcblxuICAgIC8vIFRoaXMgaXMgdGhlIHNwYWNlIHJpZ2h0IG9mIHRoZSBgc2Vla0JhclBvaW50YCBhdmFpbGFibGUgd2l0aGluIHRoZSBib3VuZHNcbiAgICAvLyBvZiB0aGUgcGxheWVyLiBXZSBjYWxjdWxhdGUgdGhlIG51bWJlciBvZiBwaXhlbHMgZnJvbSB0aGUgYHNlZWtCYXJQb2ludGBcbiAgICAvLyB0byB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgYFNlZWtCYXJgIGFuZCBhZGQgdG8gdGhhdCBhbnkgZ2FwIGJldHdlZW4gdGhlXG4gICAgLy8gcmlnaHQgZWRnZSBvZiB0aGUgYFNlZWtCYXJgIGFuZCB0aGUgcGxheWVyLlxuICAgIHZhciBzcGFjZVJpZ2h0T2ZQb2ludCA9IHNlZWtCYXJSZWN0LndpZHRoIC0gc2Vla0JhclBvaW50UHggKyAocGxheWVyUmVjdC5yaWdodCAtIHNlZWtCYXJSZWN0LnJpZ2h0KTtcblxuICAgIC8vIFRoaXMgaXMgdGhlIG51bWJlciBvZiBwaXhlbHMgYnkgd2hpY2ggdGhlIHRvb2x0aXAgd2lsbCBuZWVkIHRvIGJlIHB1bGxlZFxuICAgIC8vIGZ1cnRoZXIgdG8gdGhlIHJpZ2h0IHRvIGNlbnRlciBpdCBvdmVyIHRoZSBgc2Vla0JhclBvaW50YC5cbiAgICB2YXIgcHVsbFRvb2x0aXBCeSA9IHRvb2x0aXBSZWN0LndpZHRoIC8gMjtcblxuICAgIC8vIEFkanVzdCB0aGUgYHB1bGxUb29sdGlwQnlgIGRpc3RhbmNlIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0IGRlcGVuZGluZyBvblxuICAgIC8vIHRoZSByZXN1bHRzIG9mIHRoZSBzcGFjZSBjYWxjdWxhdGlvbnMgYWJvdmUuXG4gICAgaWYgKHNwYWNlTGVmdE9mUG9pbnQgPCBwdWxsVG9vbHRpcEJ5KSB7XG4gICAgICBwdWxsVG9vbHRpcEJ5ICs9IHB1bGxUb29sdGlwQnkgLSBzcGFjZUxlZnRPZlBvaW50O1xuICAgIH0gZWxzZSBpZiAoc3BhY2VSaWdodE9mUG9pbnQgPCBwdWxsVG9vbHRpcEJ5KSB7XG4gICAgICBwdWxsVG9vbHRpcEJ5ID0gc3BhY2VSaWdodE9mUG9pbnQ7XG4gICAgfVxuXG4gICAgLy8gRHVlIHRvIHRoZSBpbXByZWNpc2lvbiBvZiBkZWNpbWFsL3JhdGlvIGJhc2VkIGNhbGN1bGF0aW9ucyBhbmQgdmFyeWluZ1xuICAgIC8vIHJvdW5kaW5nIGJlaGF2aW9ycywgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIHRoZSBzcGFjaW5nIGFkanVzdG1lbnQgaXMgb2ZmXG4gICAgLy8gYnkgYSBwaXhlbCBvciB0d28uIFRoaXMgYWRkcyBpbnN1cmFuY2UgdG8gdGhlc2UgY2FsY3VsYXRpb25zLlxuICAgIGlmIChwdWxsVG9vbHRpcEJ5IDwgMCkge1xuICAgICAgcHVsbFRvb2x0aXBCeSA9IDA7XG4gICAgfSBlbHNlIGlmIChwdWxsVG9vbHRpcEJ5ID4gdG9vbHRpcFJlY3Qud2lkdGgpIHtcbiAgICAgIHB1bGxUb29sdGlwQnkgPSB0b29sdGlwUmVjdC53aWR0aDtcbiAgICB9XG5cbiAgICB0aGlzLmVsXy5zdHlsZS5yaWdodCA9ICctJyArIHB1bGxUb29sdGlwQnkgKyAncHgnO1xuICAgIHRleHRDb250ZW50KHRoaXMuZWxfLCBjb250ZW50KTtcbiAgfTtcblxuICByZXR1cm4gVGltZVRvb2x0aXA7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGltZVRvb2x0aXAnLCBUaW1lVG9vbHRpcCk7XG5cbi8qKlxuICogQGZpbGUgcGxheS1wcm9ncmVzcy1iYXIuanNcbiAqL1xuLyoqXG4gKiBVc2VkIGJ5IHtAbGluayBTZWVrQmFyfSB0byBkaXNwbGF5IG1lZGlhIHBsYXliYWNrIHByb2dyZXNzIGFzIHBhcnQgb2YgdGhlXG4gKiB7QGxpbmsgUHJvZ3Jlc3NDb250cm9sfS5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgUGxheVByb2dyZXNzQmFyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUGxheVByb2dyZXNzQmFyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQbGF5UHJvZ3Jlc3NCYXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxheVByb2dyZXNzQmFyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgdGhlIERPTSBlbGVtZW50IGZvciB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBQbGF5UHJvZ3Jlc3NCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wbGF5LXByb2dyZXNzIHZqcy1zbGlkZXItYmFyJyxcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPjxzcGFuPicgKyB0aGlzLmxvY2FsaXplKCdQcm9ncmVzcycpICsgJzwvc3Bhbj46IDAlPC9zcGFuPidcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogRW5xdWV1ZXMgdXBkYXRlcyB0byBpdHMgb3duIERPTSBhcyB3ZWxsIGFzIHRoZSBET00gb2YgaXRzXG4gICAqIHtAbGluayBUaW1lVG9vbHRpcH0gY2hpbGQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZWVrQmFyUmVjdFxuICAgKiAgICAgICAgVGhlIGBDbGllbnRSZWN0YCBmb3IgdGhlIHtAbGluayBTZWVrQmFyfSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vla0JhclBvaW50XG4gICAqICAgICAgICBBIG51bWJlciBmcm9tIDAgdG8gMSwgcmVwcmVzZW50aW5nIGEgaG9yaXpvbnRhbCByZWZlcmVuY2UgcG9pbnRcbiAgICogICAgICAgIGZyb20gdGhlIGxlZnQgZWRnZSBvZiB0aGUge0BsaW5rIFNlZWtCYXJ9XG4gICAqL1xuXG5cbiAgUGxheVByb2dyZXNzQmFyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgckFGIElELCBjYW5jZWwgaXQgc28gd2UgZG9uJ3Qgb3Zlci1xdWV1ZS5cbiAgICBpZiAodGhpcy5yYWZJZF8pIHtcbiAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWZJZF8pO1xuICAgIH1cblxuICAgIHRoaXMucmFmSWRfID0gdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRpbWUgPSBfdGhpczIucGxheWVyXy5zY3J1YmJpbmcoKSA/IF90aGlzMi5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgOiBfdGhpczIucGxheWVyXy5jdXJyZW50VGltZSgpO1xuXG4gICAgICB2YXIgY29udGVudCA9IGZvcm1hdFRpbWUodGltZSwgX3RoaXMyLnBsYXllcl8uZHVyYXRpb24oKSk7XG4gICAgICB2YXIgdGltZVRvb2x0aXAgPSBfdGhpczIuZ2V0Q2hpbGQoJ3RpbWVUb29sdGlwJyk7XG5cbiAgICAgIGlmICh0aW1lVG9vbHRpcCkge1xuICAgICAgICB0aW1lVG9vbHRpcC51cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFBsYXlQcm9ncmVzc0Jhcjtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHtAbGluayBQbGF5UHJvZ3Jlc3NCYXJ9LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuUGxheVByb2dyZXNzQmFyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgY2hpbGRyZW46IFtdXG59O1xuXG4vLyBUaW1lIHRvb2x0aXBzIHNob3VsZCBub3QgYmUgYWRkZWQgdG8gYSBwbGF5ZXIgb24gbW9iaWxlIGRldmljZXMgb3IgSUU4XG5pZiAoKCFJRV9WRVJTSU9OIHx8IElFX1ZFUlNJT04gPiA4KSAmJiAhSVNfSU9TICYmICFJU19BTkRST0lEKSB7XG4gIFBsYXlQcm9ncmVzc0Jhci5wcm90b3R5cGUub3B0aW9uc18uY2hpbGRyZW4ucHVzaCgndGltZVRvb2x0aXAnKTtcbn1cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5UHJvZ3Jlc3NCYXInLCBQbGF5UHJvZ3Jlc3NCYXIpO1xuXG4vKipcbiAqIEBmaWxlIG1vdXNlLXRpbWUtZGlzcGxheS5qc1xuICovXG4vKipcbiAqIFRoZSB7QGxpbmsgTW91c2VUaW1lRGlzcGxheX0gY29tcG9uZW50IHRyYWNrcyBtb3VzZSBtb3ZlbWVudCBvdmVyIHRoZVxuICoge0BsaW5rIFByb2dyZXNzQ29udHJvbH0uIEl0IGRpc3BsYXlzIGFuIGluZGljYXRvciBhbmQgYSB7QGxpbmsgVGltZVRvb2x0aXB9XG4gKiBpbmRpY2F0aW5nIHRoZSB0aW1lIHdoaWNoIGlzIHJlcHJlc2VudGVkIGJ5IGEgZ2l2ZW4gcG9pbnQgaW4gdGhlXG4gKiB7QGxpbmsgUHJvZ3Jlc3NDb250cm9sfS5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgTW91c2VUaW1lRGlzcGxheSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1vdXNlVGltZURpc3BsYXksIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSB7QGxpbmsgUGxheWVyfSB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTW91c2VUaW1lRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNb3VzZVRpbWVEaXNwbGF5KTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudXBkYXRlID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMudXBkYXRlKSwgMjUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIERPTSBlbGVtZW50IGZvciB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgTW91c2VUaW1lRGlzcGxheS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLW1vdXNlLWRpc3BsYXknXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIHVwZGF0ZXMgdG8gaXRzIG93biBET00gYXMgd2VsbCBhcyB0aGUgRE9NIG9mIGl0c1xuICAgKiB7QGxpbmsgVGltZVRvb2x0aXB9IGNoaWxkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2Vla0JhclJlY3RcbiAgICogICAgICAgIFRoZSBgQ2xpZW50UmVjdGAgZm9yIHRoZSB7QGxpbmsgU2Vla0Jhcn0gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlZWtCYXJQb2ludFxuICAgKiAgICAgICAgQSBudW1iZXIgZnJvbSAwIHRvIDEsIHJlcHJlc2VudGluZyBhIGhvcml6b250YWwgcmVmZXJlbmNlIHBvaW50XG4gICAqICAgICAgICBmcm9tIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHtAbGluayBTZWVrQmFyfVxuICAgKi9cblxuXG4gIE1vdXNlVGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVrQmFyUmVjdCwgc2Vla0JhclBvaW50KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBleGlzdGluZyByQUYgSUQsIGNhbmNlbCBpdCBzbyB3ZSBkb24ndCBvdmVyLXF1ZXVlLlxuICAgIGlmICh0aGlzLnJhZklkXykge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkXyk7XG4gICAgfVxuXG4gICAgdGhpcy5yYWZJZF8gPSB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZHVyYXRpb24gPSBfdGhpczIucGxheWVyXy5kdXJhdGlvbigpO1xuICAgICAgdmFyIGNvbnRlbnQgPSBmb3JtYXRUaW1lKHNlZWtCYXJQb2ludCAqIGR1cmF0aW9uLCBkdXJhdGlvbik7XG5cbiAgICAgIF90aGlzMi5lbF8uc3R5bGUubGVmdCA9IHNlZWtCYXJSZWN0LndpZHRoICogc2Vla0JhclBvaW50ICsgJ3B4JztcbiAgICAgIF90aGlzMi5nZXRDaGlsZCgndGltZVRvb2x0aXAnKS51cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCwgY29udGVudCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1vdXNlVGltZURpc3BsYXk7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciBgTW91c2VUaW1lRGlzcGxheWBcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cbk1vdXNlVGltZURpc3BsYXkucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWyd0aW1lVG9vbHRpcCddXG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01vdXNlVGltZURpc3BsYXknLCBNb3VzZVRpbWVEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSBzZWVrLWJhci5qc1xuICovXG4vLyBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdGhlIGBzdGVwKmAgZnVuY3Rpb25zIG1vdmUgdGhlIHRpbWVsaW5lLlxudmFyIFNURVBfU0VDT05EUyA9IDU7XG5cbi8qKlxuICogU2VlayBiYXIgYW5kIGNvbnRhaW5lciBmb3IgdGhlIHByb2dyZXNzIGJhcnMuIFVzZXMge0BsaW5rIFBsYXlQcm9ncmVzc0Jhcn1cbiAqIGFzIGl0cyBgYmFyYC5cbiAqXG4gKiBAZXh0ZW5kcyBTbGlkZXJcbiAqL1xuXG52YXIgU2Vla0JhciA9IGZ1bmN0aW9uIChfU2xpZGVyKSB7XG4gIGluaGVyaXRzKFNlZWtCYXIsIF9TbGlkZXIpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gU2Vla0JhcihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTZWVrQmFyKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1NsaWRlci5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudXBkYXRlID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMudXBkYXRlKSwgNTApO1xuICAgIF90aGlzLm9uKHBsYXllciwgWyd0aW1ldXBkYXRlJywgJ2VuZGVkJ10sIF90aGlzLnVwZGF0ZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX1NsaWRlci5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLXByb2dyZXNzLWhvbGRlcidcbiAgICB9LCB7XG4gICAgICAnYXJpYS1sYWJlbCc6IHRoaXMubG9jYWxpemUoJ1Byb2dyZXNzIEJhcicpXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgc2VlayBiYXIncyBVSS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGB0aW1ldXBkYXRlYCBvciBgZW5kZWRgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGltZXVwZGF0ZVxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZW5kZWRcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIHBlcmNlbnQgPSBfU2xpZGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcblxuICAgIC8vIEFsbG93cyBmb3Igc21vb3RoIHNjcnViYmluZywgd2hlbiBwbGF5ZXIgY2FuJ3Qga2VlcCB1cC5cbiAgICB2YXIgdGltZSA9IHRoaXMucGxheWVyXy5zY3J1YmJpbmcoKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XG5cbiAgICAvLyBtYWNoaW5lIHJlYWRhYmxlIHZhbHVlIG9mIHByb2dyZXNzIGJhciAocGVyY2VudGFnZSBjb21wbGV0ZSlcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCAocGVyY2VudCAqIDEwMCkudG9GaXhlZCgyKSk7XG5cbiAgICAvLyBodW1hbiByZWFkYWJsZSB2YWx1ZSBvZiBwcm9ncmVzcyBiYXIgKHRpbWUgY29tcGxldGUpXG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVldGV4dCcsIHRoaXMubG9jYWxpemUoJ3Byb2dyZXNzIGJhciB0aW1pbmc6IGN1cnJlbnRUaW1lPXsxfSBkdXJhdGlvbj17Mn0nLCBbZm9ybWF0VGltZSh0aW1lLCBkdXJhdGlvbiksIGZvcm1hdFRpbWUoZHVyYXRpb24sIGR1cmF0aW9uKV0sICd7MX0gb2YgezJ9JykpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBgUGxheVByb2dyZXNzQmFyYC5cbiAgICB0aGlzLmJhci51cGRhdGUoZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMuZWxfKSwgcGVyY2VudCk7XG5cbiAgICByZXR1cm4gcGVyY2VudDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBwZXJjZW50YWdlIG9mIG1lZGlhIHBsYXllZCBzbyBmYXIuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgcGVyY2VudGFnZSBvZiBtZWRpYSBwbGF5ZWQgc28gZmFyICgwIHRvIDEpLlxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmdldFBlcmNlbnQgPSBmdW5jdGlvbiBnZXRQZXJjZW50KCkge1xuXG4gICAgLy8gQWxsb3dzIGZvciBzbW9vdGggc2NydWJiaW5nLCB3aGVuIHBsYXllciBjYW4ndCBrZWVwIHVwLlxuICAgIHZhciB0aW1lID0gdGhpcy5wbGF5ZXJfLnNjcnViYmluZygpID8gdGhpcy5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgOiB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKTtcblxuICAgIHZhciBwZXJjZW50ID0gdGltZSAvIHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xuXG4gICAgcmV0dXJuIHBlcmNlbnQgPj0gMSA/IDEgOiBwZXJjZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgZG93biBvbiBzZWVrIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICB0aGlzLnBsYXllcl8uc2NydWJiaW5nKHRydWUpO1xuXG4gICAgdGhpcy52aWRlb1dhc1BsYXlpbmcgPSAhdGhpcy5wbGF5ZXJfLnBhdXNlZCgpO1xuICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xuXG4gICAgX1NsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duLmNhbGwodGhpcywgZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgbW92ZSBvbiBzZWVrIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZW1vdmVgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZW1vdmVcbiAgICovXG5cblxuICBTZWVrQmFyLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB2YXIgbmV3VGltZSA9IHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpICogdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XG5cbiAgICAvLyBEb24ndCBsZXQgdmlkZW8gZW5kIHdoaWxlIHNjcnViYmluZy5cbiAgICBpZiAobmV3VGltZSA9PT0gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpIHtcbiAgICAgIG5ld1RpbWUgPSBuZXdUaW1lIC0gMC4xO1xuICAgIH1cblxuICAgIC8vIFNldCBuZXcgdGltZSAodGVsbCBwbGF5ZXIgdG8gc2VlayB0byBuZXcgdGltZSlcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUobmV3VGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSB1cCBvbiBzZWVrIGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZXVwYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2V1cFxuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGV2ZW50KSB7XG4gICAgX1NsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VVcC5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgIHRoaXMucGxheWVyXy5zY3J1YmJpbmcoZmFsc2UpO1xuICAgIGlmICh0aGlzLnZpZGVvV2FzUGxheWluZykge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vdmUgbW9yZSBxdWlja2x5IGZhc3QgZm9yd2FyZCBmb3Iga2V5Ym9hcmQtb25seSB1c2Vyc1xuICAgKi9cblxuXG4gIFNlZWtCYXIucHJvdG90eXBlLnN0ZXBGb3J3YXJkID0gZnVuY3Rpb24gc3RlcEZvcndhcmQoKSB7XG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpICsgU1RFUF9TRUNPTkRTKTtcbiAgfTtcblxuICAvKipcbiAgICogTW92ZSBtb3JlIHF1aWNrbHkgcmV3aW5kIGZvciBrZXlib2FyZC1vbmx5IHVzZXJzXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuc3RlcEJhY2sgPSBmdW5jdGlvbiBzdGVwQmFjaygpIHtcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUodGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCkgLSBTVEVQX1NFQ09ORFMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgcGxheWVyXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBlbnRlciBvciBzcGFjZSBpcyB1c2VkIG9uIHRoZSBzZWVrYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAqXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlQWN0aW9uID0gZnVuY3Rpb24gaGFuZGxlQWN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5wYXVzZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGlzIFNlZWtCYXIgaGFzIGZvY3VzIGFuZCBhIGtleSBnZXRzIHByZXNzZWQgZG93bi4gQnlcbiAgICogZGVmYXVsdCBpdCB3aWxsIGNhbGwgYHRoaXMuaGFuZGxlQWN0aW9uYCB3aGVuIHRoZSBrZXkgaXMgc3BhY2Ugb3IgZW50ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuXG4gICAgLy8gU3VwcG9ydCBTcGFjZSAoMzIpIG9yIEVudGVyICgxMykga2V5IG9wZXJhdGlvbiB0byBmaXJlIGEgY2xpY2sgZXZlbnRcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDMyIHx8IGV2ZW50LndoaWNoID09PSAxMykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuaGFuZGxlQWN0aW9uKGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKF9TbGlkZXIucHJvdG90eXBlLmhhbmRsZUtleVByZXNzKSB7XG5cbiAgICAgIC8vIFBhc3Mga2V5cHJlc3MgaGFuZGxpbmcgdXAgZm9yIHVuc3VwcG9ydGVkIGtleXNcbiAgICAgIF9TbGlkZXIucHJvdG90eXBlLmhhbmRsZUtleVByZXNzLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU2Vla0Jhcjtcbn0oU2xpZGVyKTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBgU2Vla0JhcmBcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cblNlZWtCYXIucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWydsb2FkUHJvZ3Jlc3NCYXInLCAncGxheVByb2dyZXNzQmFyJ10sXG4gIGJhck5hbWU6ICdwbGF5UHJvZ3Jlc3NCYXInXG59O1xuXG4vLyBNb3VzZVRpbWVEaXNwbGF5IHRvb2x0aXBzIHNob3VsZCBub3QgYmUgYWRkZWQgdG8gYSBwbGF5ZXIgb24gbW9iaWxlIGRldmljZXMgb3IgSUU4XG5pZiAoKCFJRV9WRVJTSU9OIHx8IElFX1ZFUlNJT04gPiA4KSAmJiAhSVNfSU9TICYmICFJU19BTkRST0lEKSB7XG4gIFNlZWtCYXIucHJvdG90eXBlLm9wdGlvbnNfLmNoaWxkcmVuLnNwbGljZSgxLCAwLCAnbW91c2VUaW1lRGlzcGxheScpO1xufVxuXG4vKipcbiAqIENhbGwgdGhlIHVwZGF0ZSBldmVudCBmb3IgdGhpcyBTbGlkZXIgd2hlbiB0aGlzIGV2ZW50IGhhcHBlbnMgb24gdGhlIHBsYXllci5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5TZWVrQmFyLnByb3RvdHlwZS5wbGF5ZXJFdmVudCA9ICd0aW1ldXBkYXRlJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTZWVrQmFyJywgU2Vla0Jhcik7XG5cbi8qKlxuICogQGZpbGUgcHJvZ3Jlc3MtY29udHJvbC5qc1xuICovXG4vKipcbiAqIFRoZSBQcm9ncmVzcyBDb250cm9sIGNvbXBvbmVudCBjb250YWlucyB0aGUgc2VlayBiYXIsIGxvYWQgcHJvZ3Jlc3MsXG4gKiBhbmQgcGxheSBwcm9ncmVzcy5cbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgUHJvZ3Jlc3NDb250cm9sID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUHJvZ3Jlc3NDb250cm9sLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFByb2dyZXNzQ29udHJvbChwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9ncmVzc0NvbnRyb2wpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5oYW5kbGVNb3VzZU1vdmUgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVNb3VzZU1vdmUpLCAyNSk7XG4gICAgX3RoaXMub24oX3RoaXMuZWxfLCAnbW91c2Vtb3ZlJywgX3RoaXMuaGFuZGxlTW91c2VNb3ZlKTtcblxuICAgIF90aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2VlayA9IHRocm90dGxlKGJpbmQoX3RoaXMsIF90aGlzLmhhbmRsZU1vdXNlU2VlayksIDI1KTtcbiAgICBfdGhpcy5vbihbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sIF90aGlzLmhhbmRsZU1vdXNlRG93bik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcHJvZ3Jlc3MtY29udHJvbCB2anMtY29udHJvbCdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogV2hlbiB0aGUgbW91c2UgbW92ZXMgb3ZlciB0aGUgYFByb2dyZXNzQ29udHJvbGAsIHRoZSBwb2ludGVyIHBvc2l0aW9uXG4gICAqIGdldHMgcGFzc2VkIGRvd24gdG8gdGhlIGBNb3VzZVRpbWVEaXNwbGF5YCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYG1vdXNlbW92ZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW4gbW91c2Vtb3ZlXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB2YXIgc2Vla0JhciA9IHRoaXMuZ2V0Q2hpbGQoJ3NlZWtCYXInKTtcbiAgICB2YXIgbW91c2VUaW1lRGlzcGxheSA9IHNlZWtCYXIuZ2V0Q2hpbGQoJ21vdXNlVGltZURpc3BsYXknKTtcbiAgICB2YXIgc2Vla0JhckVsID0gc2Vla0Jhci5lbCgpO1xuICAgIHZhciBzZWVrQmFyUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzZWVrQmFyRWwpO1xuICAgIHZhciBzZWVrQmFyUG9pbnQgPSBnZXRQb2ludGVyUG9zaXRpb24oc2Vla0JhckVsLCBldmVudCkueDtcblxuICAgIC8vIFRoZSBkZWZhdWx0IHNraW4gaGFzIGEgZ2FwIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBgU2Vla0JhcmAuIFRoaXMgbWVhbnNcbiAgICAvLyB0aGF0IGl0J3MgcG9zc2libGUgdG8gdHJpZ2dlciB0aGlzIGJlaGF2aW9yIG91dHNpZGUgdGhlIGJvdW5kYXJpZXMgb2ZcbiAgICAvLyB0aGUgYFNlZWtCYXJgLiBUaGlzIGVuc3VyZXMgd2Ugc3RheSB3aXRoaW4gaXQgYXQgYWxsIHRpbWVzLlxuICAgIGlmIChzZWVrQmFyUG9pbnQgPiAxKSB7XG4gICAgICBzZWVrQmFyUG9pbnQgPSAxO1xuICAgIH0gZWxzZSBpZiAoc2Vla0JhclBvaW50IDwgMCkge1xuICAgICAgc2Vla0JhclBvaW50ID0gMDtcbiAgICB9XG5cbiAgICBpZiAobW91c2VUaW1lRGlzcGxheSkge1xuICAgICAgbW91c2VUaW1lRGlzcGxheS51cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBIHRocm90dGxlZCB2ZXJzaW9uIG9mIHRoZSB7QGxpbmsgUHJvZ3Jlc3NDb250cm9sI2hhbmRsZU1vdXNlU2Vla30gbGlzdGVuZXIuXG4gICAqXG4gICAqIEBtZXRob2QgUHJvZ3Jlc3NDb250cm9sI3Rocm90dGxlZEhhbmRsZU1vdXNlU2Vla1xuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBtb3VzZW1vdmVgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVuIG1vdXNlbW92ZVxuICAgKiBAbGlzdGVuIHRvdWNobW92ZVxuICAgKi9cblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZW1vdmVgIG9yIGB0b3VjaG1vdmVgIGV2ZW50cyBvbiB0aGUgYFByb2dyZXNzQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZW1vdmVcbiAgICogQGxpc3RlbnMgdG91Y2htb3ZlXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZVNlZWsgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVNlZWsoZXZlbnQpIHtcbiAgICB2YXIgc2Vla0JhciA9IHRoaXMuZ2V0Q2hpbGQoJ3NlZWtCYXInKTtcblxuICAgIHNlZWtCYXIuaGFuZGxlTW91c2VNb3ZlKGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudHMgb24gdGhlIGBQcm9ncmVzc0NvbnRyb2xgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vkb3duXG4gICAqIEBsaXN0ZW5zIHRvdWNoc3RhcnRcbiAgICovXG5cblxuICBQcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdGhpcy5vbihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2Vlayk7XG4gICAgdGhpcy5vbihkb2MsICd0b3VjaG1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2Vlayk7XG4gICAgdGhpcy5vbihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50cyBvbiB0aGUgYFByb2dyZXNzQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbGlzdGVucyB0b3VjaGVuZFxuICAgKiBAbGlzdGVucyBtb3VzZXVwXG4gICAqL1xuXG5cbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gaGFuZGxlTW91c2VVcChldmVudCkge1xuICAgIHZhciBkb2MgPSB0aGlzLmVsXy5vd25lckRvY3VtZW50O1xuXG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZVNlZWspO1xuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNobW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VTZWVrKTtcbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gIH07XG5cbiAgcmV0dXJuIFByb2dyZXNzQ29udHJvbDtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGBQcm9ncmVzc0NvbnRyb2xgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Qcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLm9wdGlvbnNfID0ge1xuICBjaGlsZHJlbjogWydzZWVrQmFyJ11cbn07XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUHJvZ3Jlc3NDb250cm9sJywgUHJvZ3Jlc3NDb250cm9sKTtcblxuLyoqXG4gKiBAZmlsZSBmdWxsc2NyZWVuLXRvZ2dsZS5qc1xuICovXG4vKipcbiAqIFRvZ2dsZSBmdWxsc2NyZWVuIHZpZGVvXG4gKlxuICogQGV4dGVuZHMgQnV0dG9uXG4gKi9cblxudmFyIEZ1bGxzY3JlZW5Ub2dnbGUgPSBmdW5jdGlvbiAoX0J1dHRvbikge1xuICBpbmhlcml0cyhGdWxsc2NyZWVuVG9nZ2xlLCBfQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIEZ1bGxzY3JlZW5Ub2dnbGUocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRnVsbHNjcmVlblRvZ2dsZSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBfdGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIEZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWZ1bGxzY3JlZW4tY29udHJvbCAnICsgX0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGZ1bGxzY3JlZW5jaGFuZ2Ugb24gdGhlIHBsYXllciBhbmQgY2hhbmdlIGNvbnRyb2wgdGV4dCBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIHtAbGluayBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZX0gZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgKiAgICAgICAgY2FsbGVkLlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgKi9cblxuXG4gIEZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWVyXy5pc0Z1bGxzY3JlZW4oKSkge1xuICAgICAgdGhpcy5jb250cm9sVGV4dCgnTm9uLUZ1bGxzY3JlZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250cm9sVGV4dCgnRnVsbHNjcmVlbicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBGdWxsc2NyZWVuVG9nZ2xlYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgRnVsbHNjcmVlblRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGlmICghdGhpcy5wbGF5ZXJfLmlzRnVsbHNjcmVlbigpKSB7XG4gICAgICB0aGlzLnBsYXllcl8ucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5ZXJfLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBGdWxsc2NyZWVuVG9nZ2xlO1xufShCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYEZ1bGxzY3JlZW5Ub2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdGdWxsc2NyZWVuJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdGdWxsc2NyZWVuVG9nZ2xlJywgRnVsbHNjcmVlblRvZ2dsZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgdm9sdW1lIGNvbnRyb2wgaXMgc3VwcG9ydGVkIGFuZCBpZiBpdCBpc24ndCBoaWRlIHRoZVxuICogYENvbXBvbmVudGAgdGhhdCB3YXMgcGFzc2VkICB1c2luZyB0aGUgYHZqcy1oaWRkZW5gIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBzZWxmXG4gKiAgICAgICAgVGhlIGNvbXBvbmVudCB0aGF0IHNob3VsZCBiZSBoaWRkZW4gaWYgdm9sdW1lIGlzIHVuc3VwcG9ydGVkXG4gKlxuICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICogICAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSBwbGF5ZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY2hlY2tWb2x1bWVTdXBwb3J0ID0gZnVuY3Rpb24gY2hlY2tWb2x1bWVTdXBwb3J0KHNlbGYsIHBsYXllcikge1xuICAvLyBoaWRlIHZvbHVtZSBjb250cm9scyB3aGVuIHRoZXkncmUgbm90IHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCB0ZWNoXG4gIGlmIChwbGF5ZXIudGVjaF8gJiYgIXBsYXllci50ZWNoXy5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wpIHtcbiAgICBzZWxmLmFkZENsYXNzKCd2anMtaGlkZGVuJyk7XG4gIH1cblxuICBzZWxmLm9uKHBsYXllciwgJ2xvYWRzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBsYXllci50ZWNoXy5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wpIHtcbiAgICAgIHNlbGYuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBmaWxlIHZvbHVtZS1sZXZlbC5qc1xuICovXG4vKipcbiAqIFNob3dzIHZvbHVtZSBsZXZlbFxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBWb2x1bWVMZXZlbCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFZvbHVtZUxldmVsLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBWb2x1bWVMZXZlbCgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWb2x1bWVMZXZlbCk7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgVm9sdW1lTGV2ZWwucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtbGV2ZWwnLFxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PC9zcGFuPidcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVm9sdW1lTGV2ZWw7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lTGV2ZWwnLCBWb2x1bWVMZXZlbCk7XG5cbi8qKlxuICogQGZpbGUgdm9sdW1lLWJhci5qc1xuICovXG4vLyBSZXF1aXJlZCBjaGlsZHJlblxuLyoqXG4gKiBUaGUgYmFyIHRoYXQgY29udGFpbnMgdGhlIHZvbHVtZSBsZXZlbCBhbmQgY2FuIGJlIGNsaWNrZWQgb24gdG8gYWRqdXN0IHRoZSBsZXZlbFxuICpcbiAqIEBleHRlbmRzIFNsaWRlclxuICovXG5cbnZhciBWb2x1bWVCYXIgPSBmdW5jdGlvbiAoX1NsaWRlcikge1xuICBpbmhlcml0cyhWb2x1bWVCYXIsIF9TbGlkZXIpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVm9sdW1lQmFyKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZvbHVtZUJhcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9TbGlkZXIuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLm9uKCdzbGlkZXJhY3RpdmUnLCBfdGhpcy51cGRhdGVMYXN0Vm9sdW1lXyk7XG4gICAgX3RoaXMub24ocGxheWVyLCAndm9sdW1lY2hhbmdlJywgX3RoaXMudXBkYXRlQVJJQUF0dHJpYnV0ZXMpO1xuICAgIHBsYXllci5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMudXBkYXRlQVJJQUF0dHJpYnV0ZXMoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9TbGlkZXIucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtYmFyIHZqcy1zbGlkZXItYmFyJ1xuICAgIH0sIHtcbiAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5sb2NhbGl6ZSgnVm9sdW1lIExldmVsJyksXG4gICAgICAnYXJpYS1saXZlJzogJ3BvbGl0ZSdcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdmVtZW50IGV2ZW50cyBvbiB0aGUge0BsaW5rIFZvbHVtZU1lbnVCdXR0b259LlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBtb3VzZW1vdmVcbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgIHRoaXMuY2hlY2tNdXRlZCgpO1xuICAgIHRoaXMucGxheWVyXy52b2x1bWUodGhpcy5jYWxjdWxhdGVEaXN0YW5jZShldmVudCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJZiB0aGUgcGxheWVyIGlzIG11dGVkIHVubXV0ZSBpdC5cbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmNoZWNrTXV0ZWQgPSBmdW5jdGlvbiBjaGVja011dGVkKCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8ubXV0ZWQoKSkge1xuICAgICAgdGhpcy5wbGF5ZXJfLm11dGVkKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBwZXJjZW50IG9mIHZvbHVtZSBsZXZlbFxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVm9sdW1lIGxldmVsIHBlcmNlbnQgYXMgYSBkZWNpbWFsIG51bWJlci5cbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLmdldFBlcmNlbnQgPSBmdW5jdGlvbiBnZXRQZXJjZW50KCkge1xuICAgIGlmICh0aGlzLnBsYXllcl8ubXV0ZWQoKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBsYXllcl8udm9sdW1lKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlIHZvbHVtZSBsZXZlbCBmb3Iga2V5Ym9hcmQgdXNlcnNcbiAgICovXG5cblxuICBWb2x1bWVCYXIucHJvdG90eXBlLnN0ZXBGb3J3YXJkID0gZnVuY3Rpb24gc3RlcEZvcndhcmQoKSB7XG4gICAgdGhpcy5jaGVja011dGVkKCk7XG4gICAgdGhpcy5wbGF5ZXJfLnZvbHVtZSh0aGlzLnBsYXllcl8udm9sdW1lKCkgKyAwLjEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNyZWFzZSB2b2x1bWUgbGV2ZWwgZm9yIGtleWJvYXJkIHVzZXJzXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5zdGVwQmFjayA9IGZ1bmN0aW9uIHN0ZXBCYWNrKCkge1xuICAgIHRoaXMuY2hlY2tNdXRlZCgpO1xuICAgIHRoaXMucGxheWVyXy52b2x1bWUodGhpcy5wbGF5ZXJfLnZvbHVtZSgpIC0gMC4xKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIEFSSUEgYWNjZXNzaWJpbGl0eSBhdHRyaWJ1dGVzXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBgdm9sdW1lY2hhbmdlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3ZvbHVtZWNoYW5nZVxuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUudXBkYXRlQVJJQUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiB1cGRhdGVBUklBQXR0cmlidXRlcyhldmVudCkge1xuICAgIHZhciBhcmlhVmFsdWUgPSB0aGlzLnBsYXllcl8ubXV0ZWQoKSA/IDAgOiB0aGlzLnZvbHVtZUFzUGVyY2VudGFnZV8oKTtcblxuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycsIGFyaWFWYWx1ZSk7XG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVldGV4dCcsIGFyaWFWYWx1ZSArICclJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHBsYXllciB2b2x1bWUgYXMgYSBwZXJjZW50YWdlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVm9sdW1lQmFyLnByb3RvdHlwZS52b2x1bWVBc1BlcmNlbnRhZ2VfID0gZnVuY3Rpb24gdm9sdW1lQXNQZXJjZW50YWdlXygpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLnBsYXllcl8udm9sdW1lKCkgKiAxMDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBWb2x1bWVCYXIsIHN0b3JlIHRoZSB2b2x1bWUgYW5kIGxpc3RlbiBmb3JcbiAgICogdGhlIGVuZCBvZiB0aGUgZHJhZy4gV2hlbiB0aGUgZHJhZyBlbmRzLCBpZiB0aGUgdm9sdW1lIHdhcyBzZXQgdG8gemVybyxcbiAgICogc2V0IGxhc3RWb2x1bWUgdG8gdGhlIHN0b3JlZCB2b2x1bWUuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHNsaWRlcmFjdGl2ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFZvbHVtZUJhci5wcm90b3R5cGUudXBkYXRlTGFzdFZvbHVtZV8gPSBmdW5jdGlvbiB1cGRhdGVMYXN0Vm9sdW1lXygpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciB2b2x1bWVCZWZvcmVEcmFnID0gdGhpcy5wbGF5ZXJfLnZvbHVtZSgpO1xuXG4gICAgdGhpcy5vbmUoJ3NsaWRlcmluYWN0aXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzMi5wbGF5ZXJfLnZvbHVtZSgpID09PSAwKSB7XG4gICAgICAgIF90aGlzMi5wbGF5ZXJfLmxhc3RWb2x1bWVfKHZvbHVtZUJlZm9yZURyYWcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBWb2x1bWVCYXI7XG59KFNsaWRlcik7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgYFZvbHVtZUJhcmBcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5cblZvbHVtZUJhci5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ3ZvbHVtZUxldmVsJ10sXG4gIGJhck5hbWU6ICd2b2x1bWVMZXZlbCdcbn07XG5cbi8qKlxuICogQ2FsbCB0aGUgdXBkYXRlIGV2ZW50IGZvciB0aGlzIFNsaWRlciB3aGVuIHRoaXMgZXZlbnQgaGFwcGVucyBvbiB0aGUgcGxheWVyLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblZvbHVtZUJhci5wcm90b3R5cGUucGxheWVyRXZlbnQgPSAndm9sdW1lY2hhbmdlJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdWb2x1bWVCYXInLCBWb2x1bWVCYXIpO1xuXG4vKipcbiAqIEBmaWxlIHZvbHVtZS1jb250cm9sLmpzXG4gKi9cbi8vIFJlcXVpcmVkIGNoaWxkcmVuXG4vKipcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNvbnRyb2xsaW5nIHRoZSB2b2x1bWUgbGV2ZWxcbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgVm9sdW1lQ29udHJvbCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFZvbHVtZUNvbnRyb2wsIF9Db21wb25lbnQpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVm9sdW1lQ29udHJvbChwbGF5ZXIpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVm9sdW1lQ29udHJvbCk7XG5cbiAgICBvcHRpb25zLnZlcnRpY2FsID0gb3B0aW9ucy52ZXJ0aWNhbCB8fCBmYWxzZTtcblxuICAgIC8vIFBhc3MgdGhlIHZlcnRpY2FsIG9wdGlvbiBkb3duIHRvIHRoZSBWb2x1bWVCYXIgaWZcbiAgICAvLyB0aGUgVm9sdW1lQmFyIGlzIHR1cm5lZCBvbi5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudm9sdW1lQmFyID09PSAndW5kZWZpbmVkJyB8fCBpc1BsYWluKG9wdGlvbnMudm9sdW1lQmFyKSkge1xuICAgICAgb3B0aW9ucy52b2x1bWVCYXIgPSBvcHRpb25zLnZvbHVtZUJhciB8fCB7fTtcbiAgICAgIG9wdGlvbnMudm9sdW1lQmFyLnZlcnRpY2FsID0gb3B0aW9ucy52ZXJ0aWNhbDtcbiAgICB9XG5cbiAgICAvLyBoaWRlIHRoaXMgY29udHJvbCBpZiB2b2x1bWUgc3VwcG9ydCBpcyBtaXNzaW5nXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBjaGVja1ZvbHVtZVN1cHBvcnQoX3RoaXMsIHBsYXllcik7XG5cbiAgICBfdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZU1vdmUgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVNb3VzZU1vdmUpLCAyNSk7XG5cbiAgICBfdGhpcy5vbignbW91c2Vkb3duJywgX3RoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICBfdGhpcy5vbigndG91Y2hzdGFydCcsIF90aGlzLmhhbmRsZU1vdXNlRG93bik7XG5cbiAgICAvLyB3aGlsZSB0aGUgc2xpZGVyIGlzIGFjdGl2ZSAodGhlIG1vdXNlIGhhcyBiZWVuIHByZXNzZWQgZG93biBhbmRcbiAgICAvLyBpcyBkcmFnZ2luZykgb3IgaW4gZm9jdXMgd2UgZG8gbm90IHdhbnQgdG8gaGlkZSB0aGUgVm9sdW1lQmFyXG4gICAgX3RoaXMub24oX3RoaXMudm9sdW1lQmFyLCBbJ2ZvY3VzJywgJ3NsaWRlcmFjdGl2ZSddLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy52b2x1bWVCYXIuYWRkQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XG4gICAgICBfdGhpcy5hZGRDbGFzcygndmpzLXNsaWRlci1hY3RpdmUnKTtcbiAgICAgIF90aGlzLnRyaWdnZXIoJ3NsaWRlcmFjdGl2ZScpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMub24oX3RoaXMudm9sdW1lQmFyLCBbJ2JsdXInLCAnc2xpZGVyaW5hY3RpdmUnXSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMudm9sdW1lQmFyLnJlbW92ZUNsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xuICAgICAgX3RoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XG4gICAgICBfdGhpcy50cmlnZ2VyKCdzbGlkZXJpbmFjdGl2ZScpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFZvbHVtZUNvbnRyb2wucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS1ob3Jpem9udGFsJztcblxuICAgIGlmICh0aGlzLm9wdGlvbnNfLnZlcnRpY2FsKSB7XG4gICAgICBvcmllbnRhdGlvbkNsYXNzID0gJ3Zqcy12b2x1bWUtdmVydGljYWwnO1xuICAgIH1cblxuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdm9sdW1lLWNvbnRyb2wgdmpzLWNvbnRyb2wgJyArIG9yaWVudGF0aW9uQ2xhc3NcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudHMgb24gdGhlIGBWb2x1bWVDb250cm9sYC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBsaXN0ZW5zIG1vdXNlZG93blxuICAgKiBAbGlzdGVucyB0b3VjaHN0YXJ0XG4gICAqL1xuXG5cbiAgVm9sdW1lQ29udHJvbC5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG4gICAgdmFyIGRvYyA9IHRoaXMuZWxfLm93bmVyRG9jdW1lbnQ7XG5cbiAgICB0aGlzLm9uKGRvYywgJ21vdXNlbW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNobW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9uKGRvYywgJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgIHRoaXMub24oZG9jLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNldXBgIG9yIGB0b3VjaGVuZGAgZXZlbnRzIG9uIHRoZSBgVm9sdW1lQ29udHJvbGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAbGlzdGVucyB0b3VjaGVuZFxuICAgKiBAbGlzdGVucyBtb3VzZXVwXG4gICAqL1xuXG5cbiAgVm9sdW1lQ29udHJvbC5wcm90b3R5cGUuaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoZXZlbnQpIHtcbiAgICB2YXIgZG9jID0gdGhpcy5lbF8ub3duZXJEb2N1bWVudDtcblxuICAgIHRoaXMub2ZmKGRvYywgJ21vdXNlbW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VNb3ZlKTtcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaG1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XG4gICAgdGhpcy5vZmYoZG9jLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50cyBvbiB0aGUgYFZvbHVtZUNvbnRyb2xgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cbiAgICpcbiAgICogQGxpc3RlbnMgbW91c2Vkb3duXG4gICAqIEBsaXN0ZW5zIHRvdWNoc3RhcnRcbiAgICovXG5cblxuICBWb2x1bWVDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB0aGlzLnZvbHVtZUJhci5oYW5kbGVNb3VzZU1vdmUoZXZlbnQpO1xuICB9O1xuXG4gIHJldHVybiBWb2x1bWVDb250cm9sO1xufShDb21wb25lbnQpO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIGBWb2x1bWVDb250cm9sYFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuVm9sdW1lQ29udHJvbC5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ3ZvbHVtZUJhciddXG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZUNvbnRyb2wnLCBWb2x1bWVDb250cm9sKTtcblxuLyoqXG4gKiBAZmlsZSBtdXRlLXRvZ2dsZS5qc1xuICovXG4vKipcbiAqIEEgYnV0dG9uIGNvbXBvbmVudCBmb3IgbXV0aW5nIHRoZSBhdWRpby5cbiAqXG4gKiBAZXh0ZW5kcyBCdXR0b25cbiAqL1xuXG52YXIgTXV0ZVRvZ2dsZSA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XG4gIGluaGVyaXRzKE11dGVUb2dnbGUsIF9CdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gTXV0ZVRvZ2dsZShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNdXRlVG9nZ2xlKTtcblxuICAgIC8vIGhpZGUgdGhpcyBjb250cm9sIGlmIHZvbHVtZSBzdXBwb3J0IGlzIG1pc3NpbmdcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIGNoZWNrVm9sdW1lU3VwcG9ydChfdGhpcywgcGxheWVyKTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgWydsb2Fkc3RhcnQnLCAndm9sdW1lY2hhbmdlJ10sIF90aGlzLnVwZGF0ZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBNdXRlVG9nZ2xlLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1tdXRlLWNvbnRyb2wgJyArIF9CdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBNdXRlVG9nZ2xlYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgTXV0ZVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIHZhciB2b2wgPSB0aGlzLnBsYXllcl8udm9sdW1lKCk7XG4gICAgdmFyIGxhc3RWb2x1bWUgPSB0aGlzLnBsYXllcl8ubGFzdFZvbHVtZV8oKTtcblxuICAgIGlmICh2b2wgPT09IDApIHtcbiAgICAgIHZhciB2b2x1bWVUb1NldCA9IGxhc3RWb2x1bWUgPCAwLjEgPyAwLjEgOiBsYXN0Vm9sdW1lO1xuXG4gICAgICB0aGlzLnBsYXllcl8udm9sdW1lKHZvbHVtZVRvU2V0KTtcbiAgICAgIHRoaXMucGxheWVyXy5tdXRlZChmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheWVyXy5tdXRlZCh0aGlzLnBsYXllcl8ubXV0ZWQoKSA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGBNdXRlVG9nZ2xlYCBidXR0b24gYmFzZWQgb24gdGhlIHN0YXRlIG9mIGB2b2x1bWVgIGFuZCBgbXV0ZWRgXG4gICAqIG9uIHRoZSBwbGF5ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSB7QGxpbmsgUGxheWVyI2xvYWRzdGFydH0gZXZlbnQgaWYgdGhpcyBmdW5jdGlvbiB3YXMgY2FsbGVkXG4gICAqICAgICAgICB0aHJvdWdoIGFuIGV2ZW50LlxuICAgKlxuICAgKiBAbGlzdGVucyBQbGF5ZXIjbG9hZHN0YXJ0XG4gICAqIEBsaXN0ZW5zIFBsYXllciN2b2x1bWVjaGFuZ2VcbiAgICovXG5cblxuICBNdXRlVG9nZ2xlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcbiAgICB0aGlzLnVwZGF0ZUljb25fKCk7XG4gICAgdGhpcy51cGRhdGVDb250cm9sVGV4dF8oKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBgTXV0ZVRvZ2dsZWAgaWNvbi5cbiAgICpcbiAgICogUG9zc2libGUgc3RhdGVzIChnaXZlbiBgbGV2ZWxgIHZhcmlhYmxlIGJlbG93KTpcbiAgICogLSAwOiBjcm9zc2VkIG91dFxuICAgKiAtIDE6IHplcm8gYmFycyBvZiB2b2x1bWVcbiAgICogLSAyOiBvbmUgYmFyIG9mIHZvbHVtZVxuICAgKiAtIDM6IHR3byBiYXJzIG9mIHZvbHVtZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIE11dGVUb2dnbGUucHJvdG90eXBlLnVwZGF0ZUljb25fID0gZnVuY3Rpb24gdXBkYXRlSWNvbl8oKSB7XG4gICAgdmFyIHZvbCA9IHRoaXMucGxheWVyXy52b2x1bWUoKTtcbiAgICB2YXIgbGV2ZWwgPSAzO1xuXG4gICAgaWYgKHZvbCA9PT0gMCB8fCB0aGlzLnBsYXllcl8ubXV0ZWQoKSkge1xuICAgICAgbGV2ZWwgPSAwO1xuICAgIH0gZWxzZSBpZiAodm9sIDwgMC4zMykge1xuICAgICAgbGV2ZWwgPSAxO1xuICAgIH0gZWxzZSBpZiAodm9sIDwgMC42Nykge1xuICAgICAgbGV2ZWwgPSAyO1xuICAgIH1cblxuICAgIC8vIFRPRE8gaW1wcm92ZSBtdXRlZCBpY29uIGNsYXNzZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbF8sICd2anMtdm9sLScgKyBpKTtcbiAgICB9XG4gICAgYWRkQ2xhc3ModGhpcy5lbF8sICd2anMtdm9sLScgKyBsZXZlbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIElmIGBtdXRlZGAgaGFzIGNoYW5nZWQgb24gdGhlIHBsYXllciwgdXBkYXRlIHRoZSBjb250cm9sIHRleHRcbiAgICogKGB0aXRsZWAgYXR0cmlidXRlIG9uIGB2anMtbXV0ZS1jb250cm9sYCBlbGVtZW50IGFuZCBjb250ZW50IG9mXG4gICAqIGB2anMtY29udHJvbC10ZXh0YCBlbGVtZW50KS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBNdXRlVG9nZ2xlLnByb3RvdHlwZS51cGRhdGVDb250cm9sVGV4dF8gPSBmdW5jdGlvbiB1cGRhdGVDb250cm9sVGV4dF8oKSB7XG4gICAgdmFyIHNvdW5kT2ZmID0gdGhpcy5wbGF5ZXJfLm11dGVkKCkgfHwgdGhpcy5wbGF5ZXJfLnZvbHVtZSgpID09PSAwO1xuICAgIHZhciB0ZXh0ID0gc291bmRPZmYgPyAnVW5tdXRlJyA6ICdNdXRlJztcblxuICAgIGlmICh0aGlzLmNvbnRyb2xUZXh0KCkgIT09IHRleHQpIHtcbiAgICAgIHRoaXMuY29udHJvbFRleHQodGV4dCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBNdXRlVG9nZ2xlO1xufShCdXR0b24pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYE11dGVUb2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbk11dGVUb2dnbGUucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdNdXRlJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNdXRlVG9nZ2xlJywgTXV0ZVRvZ2dsZSk7XG5cbi8qKlxuICogQGZpbGUgdm9sdW1lLWNvbnRyb2wuanNcbiAqL1xuLy8gUmVxdWlyZWQgY2hpbGRyZW5cbi8qKlxuICogQSBDb21wb25lbnQgdG8gY29udGFpbiB0aGUgTXV0ZVRvZ2dsZSBhbmQgVm9sdW1lQ29udHJvbCBzbyB0aGF0XG4gKiB0aGV5IGNhbiB3b3JrIHRvZ2V0aGVyLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBWb2x1bWVQYW5lbCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFZvbHVtZVBhbmVsLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFZvbHVtZVBhbmVsKHBsYXllcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWb2x1bWVQYW5lbCk7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5saW5lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9ucy5pbmxpbmUgPSBvcHRpb25zLmlubGluZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5pbmxpbmUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIHBhc3MgdGhlIGlubGluZSBvcHRpb24gZG93biB0byB0aGUgVm9sdW1lQ29udHJvbCBhcyB2ZXJ0aWNhbCBpZlxuICAgIC8vIHRoZSBWb2x1bWVDb250cm9sIGlzIG9uLlxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy52b2x1bWVDb250cm9sID09PSAndW5kZWZpbmVkJyB8fCBpc1BsYWluKG9wdGlvbnMudm9sdW1lQ29udHJvbCkpIHtcbiAgICAgIG9wdGlvbnMudm9sdW1lQ29udHJvbCA9IG9wdGlvbnMudm9sdW1lQ29udHJvbCB8fCB7fTtcbiAgICAgIG9wdGlvbnMudm9sdW1lQ29udHJvbC52ZXJ0aWNhbCA9ICFvcHRpb25zLmlubGluZTtcbiAgICB9XG5cbiAgICAvLyBoaWRlIHRoaXMgY29udHJvbCBpZiB2b2x1bWUgc3VwcG9ydCBpcyBtaXNzaW5nXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBjaGVja1ZvbHVtZVN1cHBvcnQoX3RoaXMsIHBsYXllcik7XG5cbiAgICAvLyB3aGlsZSB0aGUgc2xpZGVyIGlzIGFjdGl2ZSAodGhlIG1vdXNlIGhhcyBiZWVuIHByZXNzZWQgZG93biBhbmRcbiAgICAvLyBpcyBkcmFnZ2luZykgb3IgaW4gZm9jdXMgd2UgZG8gbm90IHdhbnQgdG8gaGlkZSB0aGUgVm9sdW1lQmFyXG4gICAgX3RoaXMub24oX3RoaXMudm9sdW1lQ29udHJvbCwgWydzbGlkZXJhY3RpdmUnXSwgX3RoaXMuc2xpZGVyQWN0aXZlXyk7XG4gICAgX3RoaXMub24oX3RoaXMubXV0ZVRvZ2dsZSwgJ2ZvY3VzJywgX3RoaXMuc2xpZGVyQWN0aXZlXyk7XG5cbiAgICBfdGhpcy5vbihfdGhpcy52b2x1bWVDb250cm9sLCBbJ3NsaWRlcmluYWN0aXZlJ10sIF90aGlzLnNsaWRlckluYWN0aXZlXyk7XG4gICAgX3RoaXMub24oX3RoaXMubXV0ZVRvZ2dsZSwgJ2JsdXInLCBfdGhpcy5zbGlkZXJJbmFjdGl2ZV8pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdmpzLXNsaWRlci1hY3RpdmUgY2xhc3MgdG8gdGhlIFZvbHVtZVBhbmVsXG4gICAqXG4gICAqIEBsaXN0ZW5zIFZvbHVtZUNvbnRyb2wjc2xpZGVyYWN0aXZlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVm9sdW1lUGFuZWwucHJvdG90eXBlLnNsaWRlckFjdGl2ZV8gPSBmdW5jdGlvbiBzbGlkZXJBY3RpdmVfKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdmpzLXNsaWRlci1hY3RpdmUgY2xhc3MgdG8gdGhlIFZvbHVtZVBhbmVsXG4gICAqXG4gICAqIEBsaXN0ZW5zIFZvbHVtZUNvbnRyb2wjc2xpZGVyaW5hY3RpdmVcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBWb2x1bWVQYW5lbC5wcm90b3R5cGUuc2xpZGVySW5hY3RpdmVfID0gZnVuY3Rpb24gc2xpZGVySW5hY3RpdmVfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgVm9sdW1lUGFuZWwucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS1wYW5lbC1ob3Jpem9udGFsJztcblxuICAgIGlmICghdGhpcy5vcHRpb25zXy5pbmxpbmUpIHtcbiAgICAgIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS1wYW5lbC12ZXJ0aWNhbCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtcGFuZWwgdmpzLWNvbnRyb2wgJyArIG9yaWVudGF0aW9uQ2xhc3NcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVm9sdW1lUGFuZWw7XG59KENvbXBvbmVudCk7XG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgYFZvbHVtZUNvbnRyb2xgXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5Wb2x1bWVQYW5lbC5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ211dGVUb2dnbGUnLCAndm9sdW1lQ29udHJvbCddXG59O1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZVBhbmVsJywgVm9sdW1lUGFuZWwpO1xuXG4vKipcbiAqIEBmaWxlIG1lbnUuanNcbiAqL1xuLyoqXG4gKiBUaGUgTWVudSBjb21wb25lbnQgaXMgdXNlZCB0byBidWlsZCBwb3B1cCBtZW51cywgaW5jbHVkaW5nIHN1YnRpdGxlIGFuZFxuICogY2FwdGlvbnMgc2VsZWN0aW9uIG1lbnVzLlxuICpcbiAqIEBleHRlbmRzIENvbXBvbmVudFxuICovXG5cbnZhciBNZW51ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoTWVudSwgX0NvbXBvbmVudCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICB0aGUgcGxheWVyIHRoYXQgdGhpcyBjb21wb25lbnQgc2hvdWxkIGF0dGFjaCB0b1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIE1lbnUocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVudSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBfdGhpcy5tZW51QnV0dG9uXyA9IG9wdGlvbnMubWVudUJ1dHRvbjtcbiAgICB9XG5cbiAgICBfdGhpcy5mb2N1c2VkQ2hpbGRfID0gLTE7XG5cbiAgICBfdGhpcy5vbigna2V5ZG93bicsIF90aGlzLmhhbmRsZUtleVByZXNzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEge0BsaW5rIE1lbnVJdGVtfSB0byB0aGUgbWVudS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBjb21wb25lbnRcbiAgICogICAgICAgIFRoZSBuYW1lIG9yIGluc3RhbmNlIG9mIHRoZSBgTWVudUl0ZW1gIHRvIGFkZC5cbiAgICpcbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24gYWRkSXRlbShjb21wb25lbnQpIHtcbiAgICB0aGlzLmFkZENoaWxkKGNvbXBvbmVudCk7XG4gICAgY29tcG9uZW50Lm9uKCdjbGljaycsIGJpbmQodGhpcywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAvLyBVbnByZXNzIHRoZSBhc3NvY2lhdGVkIE1lbnVCdXR0b24sIGFuZCBtb3ZlIGZvY3VzIGJhY2sgdG8gaXRcbiAgICAgIGlmICh0aGlzLm1lbnVCdXR0b25fKSB7XG4gICAgICAgIHRoaXMubWVudUJ1dHRvbl8udW5wcmVzc0J1dHRvbigpO1xuXG4gICAgICAgIC8vIGRvbid0IGZvY3VzIG1lbnUgYnV0dG9uIGlmIGl0ZW0gaXMgYSBjYXB0aW9uIHNldHRpbmdzIGl0ZW1cbiAgICAgICAgLy8gYmVjYXVzZSBmb2N1cyB3aWxsIG1vdmUgZWxzZXdoZXJlIGFuZCBpdCBsb2dzIGFuIGVycm9yIG9uIElFOFxuICAgICAgICBpZiAoY29tcG9uZW50Lm5hbWUoKSAhPT0gJ0NhcHRpb25TZXR0aW5nc01lbnVJdGVtJykge1xuICAgICAgICAgIHRoaXMubWVudUJ1dHRvbl8uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgTWVudWBzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIHRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWRcbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBjb250ZW50RWxUeXBlID0gdGhpcy5vcHRpb25zXy5jb250ZW50RWxUeXBlIHx8ICd1bCc7XG5cbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBjcmVhdGVFbChjb250ZW50RWxUeXBlLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbWVudS1jb250ZW50J1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250ZW50RWxfLnNldEF0dHJpYnV0ZSgncm9sZScsICdtZW51Jyk7XG5cbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XG4gICAgICBhcHBlbmQ6IHRoaXMuY29udGVudEVsXyxcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51J1xuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RWxfKTtcblxuICAgIC8vIFByZXZlbnQgY2xpY2tzIGZyb20gYnViYmxpbmcgdXAuIE5lZWRlZCBmb3IgTWVudSBCdXR0b25zLFxuICAgIC8vIHdoZXJlIGEgY2xpY2sgb24gdGhlIHBhcmVudCBpcyBzaWduaWZpY2FudFxuICAgIG9uKGVsLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgYGtleWRvd25gIGV2ZW50IG9uIHRoaXMgbWVudS4gVGhpcyBsaXN0ZW5lciBpcyBhZGRlZCBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBBIGBrZXlkb3duYCBldmVudCB0aGF0IGhhcHBlbmVkIG9uIHRoZSBtZW51LlxuICAgKlxuICAgKiBAbGlzdGVucyBrZXlkb3duXG4gICAqL1xuXG5cbiAgTWVudS5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xuICAgIC8vIExlZnQgYW5kIERvd24gQXJyb3dzXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzNyB8fCBldmVudC53aGljaCA9PT0gNDApIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnN0ZXBGb3J3YXJkKCk7XG5cbiAgICAgIC8vIFVwIGFuZCBSaWdodCBBcnJvd3NcbiAgICB9IGVsc2UgaWYgKGV2ZW50LndoaWNoID09PSAzOCB8fCBldmVudC53aGljaCA9PT0gMzkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnN0ZXBCYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIHRvIG5leHQgKGxvd2VyKSBtZW51IGl0ZW0gZm9yIGtleWJvYXJkIHVzZXJzLlxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLnN0ZXBGb3J3YXJkID0gZnVuY3Rpb24gc3RlcEZvcndhcmQoKSB7XG4gICAgdmFyIHN0ZXBDaGlsZCA9IDA7XG5cbiAgICBpZiAodGhpcy5mb2N1c2VkQ2hpbGRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0ZXBDaGlsZCA9IHRoaXMuZm9jdXNlZENoaWxkXyArIDE7XG4gICAgfVxuICAgIHRoaXMuZm9jdXMoc3RlcENoaWxkKTtcbiAgfTtcblxuICAvKipcbiAgICogTW92ZSB0byBwcmV2aW91cyAoaGlnaGVyKSBtZW51IGl0ZW0gZm9yIGtleWJvYXJkIHVzZXJzLlxuICAgKi9cblxuXG4gIE1lbnUucHJvdG90eXBlLnN0ZXBCYWNrID0gZnVuY3Rpb24gc3RlcEJhY2soKSB7XG4gICAgdmFyIHN0ZXBDaGlsZCA9IDA7XG5cbiAgICBpZiAodGhpcy5mb2N1c2VkQ2hpbGRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0ZXBDaGlsZCA9IHRoaXMuZm9jdXNlZENoaWxkXyAtIDE7XG4gICAgfVxuICAgIHRoaXMuZm9jdXMoc3RlcENoaWxkKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGZvY3VzIG9uIGEge0BsaW5rIE1lbnVJdGVtfSBpbiB0aGUgYE1lbnVgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtpdGVtPTBdXG4gICAqICAgICAgICBJbmRleCBvZiBjaGlsZCBpdGVtIHNldCBmb2N1cyBvbi5cbiAgICovXG5cblxuICBNZW51LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIHZhciBpdGVtID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbigpLnNsaWNlKCk7XG4gICAgdmFyIGhhdmVUaXRsZSA9IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlblswXS5jbGFzc05hbWUgJiYgL3Zqcy1tZW51LXRpdGxlLy50ZXN0KGNoaWxkcmVuWzBdLmNsYXNzTmFtZSk7XG5cbiAgICBpZiAoaGF2ZVRpdGxlKSB7XG4gICAgICBjaGlsZHJlbi5zaGlmdCgpO1xuICAgIH1cblxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoaXRlbSA8IDApIHtcbiAgICAgICAgaXRlbSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0gPj0gY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGl0ZW0gPSBjaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZvY3VzZWRDaGlsZF8gPSBpdGVtO1xuXG4gICAgICBjaGlsZHJlbltpdGVtXS5lbF8uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1lbnU7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTWVudScsIE1lbnUpO1xuXG4vKipcbiAqIEBmaWxlIG1lbnUtYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogQSBgTWVudUJ1dHRvbmAgY2xhc3MgZm9yIGFueSBwb3B1cCB7QGxpbmsgTWVudX0uXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIE1lbnVCdXR0b24gPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhNZW51QnV0dG9uLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIE1lbnVCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1lbnVCdXR0b24pO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5tZW51QnV0dG9uXyA9IG5ldyBCdXR0b24ocGxheWVyLCBvcHRpb25zKTtcblxuICAgIF90aGlzLm1lbnVCdXR0b25fLmNvbnRyb2xUZXh0KF90aGlzLmNvbnRyb2xUZXh0Xyk7XG4gICAgX3RoaXMubWVudUJ1dHRvbl8uZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsICd0cnVlJyk7XG5cbiAgICAvLyBBZGQgYnVpbGRDU1NDbGFzcyB2YWx1ZXMgdG8gdGhlIGJ1dHRvbiwgbm90IHRoZSB3cmFwcGVyXG4gICAgdmFyIGJ1dHRvbkNsYXNzID0gQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzKCk7XG5cbiAgICBfdGhpcy5tZW51QnV0dG9uXy5lbF8uY2xhc3NOYW1lID0gX3RoaXMuYnVpbGRDU1NDbGFzcygpICsgJyAnICsgYnV0dG9uQ2xhc3M7XG4gICAgX3RoaXMubWVudUJ1dHRvbl8ucmVtb3ZlQ2xhc3MoJ3Zqcy1jb250cm9sJyk7XG5cbiAgICBfdGhpcy5hZGRDaGlsZChfdGhpcy5tZW51QnV0dG9uXyk7XG5cbiAgICBfdGhpcy51cGRhdGUoKTtcblxuICAgIF90aGlzLmVuYWJsZWRfID0gdHJ1ZTtcblxuICAgIF90aGlzLm9uKF90aGlzLm1lbnVCdXR0b25fLCAndGFwJywgX3RoaXMuaGFuZGxlQ2xpY2spO1xuICAgIF90aGlzLm9uKF90aGlzLm1lbnVCdXR0b25fLCAnY2xpY2snLCBfdGhpcy5oYW5kbGVDbGljayk7XG4gICAgX3RoaXMub24oX3RoaXMubWVudUJ1dHRvbl8sICdmb2N1cycsIF90aGlzLmhhbmRsZUZvY3VzKTtcbiAgICBfdGhpcy5vbihfdGhpcy5tZW51QnV0dG9uXywgJ2JsdXInLCBfdGhpcy5oYW5kbGVCbHVyKTtcblxuICAgIF90aGlzLm9uKCdrZXlkb3duJywgX3RoaXMuaGFuZGxlU3VibWVudUtleVByZXNzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBtZW51IGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIG9mIGl0cyBpdGVtcy5cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIG1lbnUgPSB0aGlzLmNyZWF0ZU1lbnUoKTtcblxuICAgIGlmICh0aGlzLm1lbnUpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5tZW51KTtcbiAgICB9XG5cbiAgICB0aGlzLm1lbnUgPSBtZW51O1xuICAgIHRoaXMuYWRkQ2hpbGQobWVudSk7XG5cbiAgICAvKipcbiAgICAgKiBUcmFjayB0aGUgc3RhdGUgb2YgdGhlIG1lbnUgYnV0dG9uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYnV0dG9uUHJlc3NlZF8gPSBmYWxzZTtcbiAgICB0aGlzLm1lbnVCdXR0b25fLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcblxuICAgIGlmICh0aGlzLml0ZW1zICYmIHRoaXMuaXRlbXMubGVuZ3RoIDw9IHRoaXMuaGlkZVRocmVzaG9sZF8pIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbWVudSBhbmQgYWRkIGFsbCBpdGVtcyB0byBpdC5cbiAgICpcbiAgICogQHJldHVybiB7TWVudX1cbiAgICogICAgICAgICBUaGUgY29uc3RydWN0ZWQgbWVudVxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmNyZWF0ZU1lbnUgPSBmdW5jdGlvbiBjcmVhdGVNZW51KCkge1xuICAgIHZhciBtZW51ID0gbmV3IE1lbnUodGhpcy5wbGF5ZXJfLCB7IG1lbnVCdXR0b246IHRoaXMgfSk7XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBtZW51IGlmIHRoZSBudW1iZXIgb2YgaXRlbXMgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoaXMgdGhyZXNob2xkLiBUaGlzIGRlZmF1bHRzXG4gICAgICogdG8gMCBhbmQgd2hlbmV2ZXIgd2UgYWRkIGl0ZW1zIHdoaWNoIGNhbiBiZSBoaWRkZW4gdG8gdGhlIG1lbnUgd2UnbGwgaW5jcmVtZW50IGl0LiBXZSBsaXN0XG4gICAgICogaXQgaGVyZSBiZWNhdXNlIGV2ZXJ5IHRpbWUgd2UgcnVuIGBjcmVhdGVNZW51YCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gPSAwO1xuXG4gICAgLy8gQWRkIGEgdGl0bGUgbGlzdCBpdGVtIHRvIHRoZSB0b3BcbiAgICBpZiAodGhpcy5vcHRpb25zXy50aXRsZSkge1xuICAgICAgdmFyIHRpdGxlID0gY3JlYXRlRWwoJ2xpJywge1xuICAgICAgICBjbGFzc05hbWU6ICd2anMtbWVudS10aXRsZScsXG4gICAgICAgIGlubmVySFRNTDogdG9UaXRsZUNhc2UodGhpcy5vcHRpb25zXy50aXRsZSksXG4gICAgICAgIHRhYkluZGV4OiAtMVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gKz0gMTtcblxuICAgICAgbWVudS5jaGlsZHJlbl8udW5zaGlmdCh0aXRsZSk7XG4gICAgICBwcmVwZW5kVG8odGl0bGUsIG1lbnUuY29udGVudEVsKCkpO1xuICAgIH1cblxuICAgIHRoaXMuaXRlbXMgPSB0aGlzLmNyZWF0ZUl0ZW1zKCk7XG5cbiAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgLy8gQWRkIG1lbnUgaXRlbXMgdG8gdGhlIG1lbnVcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtZW51LmFkZEl0ZW0odGhpcy5pdGVtc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbnU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgbGlzdCBvZiBtZW51IGl0ZW1zLiBTcGVjaWZpYyB0byBlYWNoIHN1YmNsYXNzLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge307XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYE1lbnVCdXR0b25zYHMgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkV3JhcHBlckNTU0NsYXNzKClcbiAgICB9LCB7fSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsbG93IHN1YiBjb21wb25lbnRzIHRvIHN0YWNrIENTUyBjbGFzcyBuYW1lcyBmb3IgdGhlIHdyYXBwZXIgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIGNvbnN0cnVjdGVkIHdyYXBwZXIgRE9NIGBjbGFzc05hbWVgXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICB2YXIgbWVudUJ1dHRvbkNsYXNzID0gJ3Zqcy1tZW51LWJ1dHRvbic7XG5cbiAgICAvLyBJZiB0aGUgaW5saW5lIG9wdGlvbiBpcyBwYXNzZWQsIHdlIHdhbnQgdG8gdXNlIGRpZmZlcmVudCBzdHlsZXMgYWx0b2dldGhlci5cbiAgICBpZiAodGhpcy5vcHRpb25zXy5pbmxpbmUgPT09IHRydWUpIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLWlubGluZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLXBvcHVwJztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBGaXggdGhlIENTUyBzbyB0aGF0IHRoaXMgaXNuJ3QgbmVjZXNzYXJ5XG4gICAgdmFyIGJ1dHRvbkNsYXNzID0gQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzKCk7XG5cbiAgICByZXR1cm4gJ3Zqcy1tZW51LWJ1dHRvbiAnICsgbWVudUJ1dHRvbkNsYXNzICsgJyAnICsgYnV0dG9uQ2xhc3MgKyAnICcgKyBfQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICB2YXIgbWVudUJ1dHRvbkNsYXNzID0gJ3Zqcy1tZW51LWJ1dHRvbic7XG5cbiAgICAvLyBJZiB0aGUgaW5saW5lIG9wdGlvbiBpcyBwYXNzZWQsIHdlIHdhbnQgdG8gdXNlIGRpZmZlcmVudCBzdHlsZXMgYWx0b2dldGhlci5cbiAgICBpZiAodGhpcy5vcHRpb25zXy5pbmxpbmUgPT09IHRydWUpIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLWlubGluZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLXBvcHVwJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ3Zqcy1tZW51LWJ1dHRvbiAnICsgbWVudUJ1dHRvbkNsYXNzICsgJyAnICsgX0NvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBsb2NhbGl6ZWQgY29udHJvbCB0ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhY2Nlc3NpYmlsaXR5LlxuICAgKlxuICAgKiA+IE5PVEU6IFRoaXMgd2lsbCBjb21lIGZyb20gdGhlIGludGVybmFsIGBtZW51QnV0dG9uX2AgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0XVxuICAgKiAgICAgICAgQ29udHJvbCB0ZXh0IGZvciBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtlbD10aGlzLm1lbnVCdXR0b25fLmVsKCldXG4gICAqICAgICAgICBFbGVtZW50IHRvIHNldCB0aGUgdGl0bGUgb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAtIFRoZSBjb250cm9sIHRleHQgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHQgPSBmdW5jdGlvbiBjb250cm9sVGV4dCh0ZXh0KSB7XG4gICAgdmFyIGVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLm1lbnVCdXR0b25fLmVsKCk7XG5cbiAgICByZXR1cm4gdGhpcy5tZW51QnV0dG9uXy5jb250cm9sVGV4dCh0ZXh0LCBlbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGNsaWNrIG9uIGEgYE1lbnVCdXR0b25gLlxuICAgKiBTZWUge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVDbGlja30gZm9yIGluc3RhbmNlcyB3aGVyZSB0aGlzIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIC8vIFdoZW4geW91IGNsaWNrIHRoZSBidXR0b24gaXQgYWRkcyBmb2N1cywgd2hpY2ggd2lsbCBzaG93IHRoZSBtZW51LlxuICAgIC8vIFNvIHdlJ2xsIHJlbW92ZSBmb2N1cyB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGJ1dHRvbi4gRm9jdXMgaXMgbmVlZGVkXG4gICAgLy8gZm9yIHRhYiBuYXZpZ2F0aW9uLlxuXG4gICAgdGhpcy5vbmUodGhpcy5tZW51LmNvbnRlbnRFbCgpLCAnbW91c2VsZWF2ZScsIGJpbmQodGhpcywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuICAgICAgdGhpcy5lbF8uYmx1cigpO1xuICAgIH0pKTtcbiAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXykge1xuICAgICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJlc3NCdXR0b24oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZm9jdXMgdG8gdGhlIGFjdHVhbCBidXR0b24sIG5vdCB0byB0aGlzIGVsZW1lbnRcbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIHRoaXMubWVudUJ1dHRvbl8uZm9jdXMoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBmb2N1cyBmcm9tIHRoZSBhY3R1YWwgYnV0dG9uLCBub3QgdGhpcyBlbGVtZW50XG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgdGhpcy5tZW51QnV0dG9uXy5ibHVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhIGBNZW51QnV0dG9uYCBnYWlucyBmb2N1cyB2aWEgYSBgZm9jdXNgIGV2ZW50LlxuICAgKiBUdXJucyBvbiBsaXN0ZW5pbmcgZm9yIGBrZXlkb3duYCBldmVudHMuIFdoZW4gdGhleSBoYXBwZW4gaXRcbiAgICogY2FsbHMgYHRoaXMuaGFuZGxlS2V5UHJlc3NgLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBmb2N1c2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGZvY3VzXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlRm9jdXMgPSBmdW5jdGlvbiBoYW5kbGVGb2N1cygpIHtcbiAgICBvbihkb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBgTWVudUJ1dHRvbmAgbG9zZXMgZm9jdXMuIFR1cm5zIG9mZiB0aGUgbGlzdGVuZXIgZm9yXG4gICAqIGBrZXlkb3duYCBldmVudHMuIFdoaWNoIFN0b3BzIGB0aGlzLmhhbmRsZUtleVByZXNzYCBmcm9tIGdldHRpbmcgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGBibHVyYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgYmx1clxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuICAgIG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRhYiwgZXNjYXBlLCBkb3duIGFycm93LCBhbmQgdXAgYXJyb3cga2V5cyBmb3IgYE1lbnVCdXR0b25gLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVLZXlQcmVzc30gZm9yIGluc3RhbmNlcyB3aGVyZSB0aGlzIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XG5cbiAgICAvLyBFc2NhcGUgKDI3KSBrZXkgb3IgVGFiICg5KSBrZXkgdW5wcmVzcyB0aGUgJ2J1dHRvbidcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDI3IHx8IGV2ZW50LndoaWNoID09PSA5KSB7XG4gICAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXykge1xuICAgICAgICB0aGlzLnVucHJlc3NCdXR0b24oKTtcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IHByZXZlbnREZWZhdWx0IGZvciBUYWIga2V5IC0gd2Ugc3RpbGwgd2FudCB0byBsb3NlIGZvY3VzXG4gICAgICBpZiAoZXZlbnQud2hpY2ggIT09IDkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gU2V0IGZvY3VzIGJhY2sgdG8gdGhlIG1lbnUgYnV0dG9uJ3MgYnV0dG9uXG4gICAgICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLmZvY3VzKCk7XG4gICAgICB9XG4gICAgICAvLyBVcCAoMzgpIGtleSBvciBEb3duICg0MCkga2V5IHByZXNzIHRoZSAnYnV0dG9uJ1xuICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDM4IHx8IGV2ZW50LndoaWNoID09PSA0MCkge1xuICAgICAgaWYgKCF0aGlzLmJ1dHRvblByZXNzZWRfKSB7XG4gICAgICAgIHRoaXMucHJlc3NCdXR0b24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIGBrZXlkb3duYCBldmVudCBvbiBhIHN1Yi1tZW51LiBUaGUgbGlzdGVuZXIgZm9yIHRoaXMgaXMgYWRkZWQgaW5cbiAgICogdGhlIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgS2V5IHByZXNzIGV2ZW50XG4gICAqXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVTdWJtZW51S2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVTdWJtZW51S2V5UHJlc3MoZXZlbnQpIHtcblxuICAgIC8vIEVzY2FwZSAoMjcpIGtleSBvciBUYWIgKDkpIGtleSB1bnByZXNzIHRoZSAnYnV0dG9uJ1xuICAgIGlmIChldmVudC53aGljaCA9PT0gMjcgfHwgZXZlbnQud2hpY2ggPT09IDkpIHtcbiAgICAgIGlmICh0aGlzLmJ1dHRvblByZXNzZWRfKSB7XG4gICAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgcHJldmVudERlZmF1bHQgZm9yIFRhYiBrZXkgLSB3ZSBzdGlsbCB3YW50IHRvIGxvc2UgZm9jdXNcbiAgICAgIGlmIChldmVudC53aGljaCAhPT0gOSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBTZXQgZm9jdXMgYmFjayB0byB0aGUgbWVudSBidXR0b24ncyBidXR0b25cbiAgICAgICAgdGhpcy5tZW51QnV0dG9uXy5lbF8uZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1dCB0aGUgY3VycmVudCBgTWVudUJ1dHRvbmAgaW50byBhIHByZXNzZWQgc3RhdGUuXG4gICAqL1xuXG5cbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUucHJlc3NCdXR0b24gPSBmdW5jdGlvbiBwcmVzc0J1dHRvbigpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkXykge1xuICAgICAgdGhpcy5idXR0b25QcmVzc2VkXyA9IHRydWU7XG4gICAgICB0aGlzLm1lbnUubG9ja1Nob3dpbmcoKTtcbiAgICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG4gICAgICAvLyBzZXQgdGhlIGZvY3VzIGludG8gdGhlIHN1Ym1lbnVcbiAgICAgIHRoaXMubWVudS5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGFrZSB0aGUgY3VycmVudCBgTWVudUJ1dHRvbmAgb3V0IG9mIGEgcHJlc3NlZCBzdGF0ZS5cbiAgICovXG5cblxuICBNZW51QnV0dG9uLnByb3RvdHlwZS51bnByZXNzQnV0dG9uID0gZnVuY3Rpb24gdW5wcmVzc0J1dHRvbigpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkXykge1xuICAgICAgdGhpcy5idXR0b25QcmVzc2VkXyA9IGZhbHNlO1xuICAgICAgdGhpcy5tZW51LnVubG9ja1Nob3dpbmcoKTtcbiAgICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzYWJsZSB0aGUgYE1lbnVCdXR0b25gLiBEb24ndCBhbGxvdyBpdCB0byBiZSBjbGlja2VkLlxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xuXG4gICAgdGhpcy5lbmFibGVkXyA9IGZhbHNlO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1kaXNhYmxlZCcpO1xuXG4gICAgdGhpcy5tZW51QnV0dG9uXy5kaXNhYmxlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0aGUgYE1lbnVCdXR0b25gLiBBbGxvdyBpdCB0byBiZSBjbGlja2VkLlxuICAgKi9cblxuXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICB0aGlzLmVuYWJsZWRfID0gdHJ1ZTtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZGlzYWJsZWQnKTtcblxuICAgIHRoaXMubWVudUJ1dHRvbl8uZW5hYmxlKCk7XG4gIH07XG5cbiAgcmV0dXJuIE1lbnVCdXR0b247XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTWVudUJ1dHRvbicsIE1lbnVCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIHRyYWNrLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBidXR0b25zIHRoYXQgdG9nZ2xlIHNwZWNpZmljICB0cmFjayB0eXBlcyAoZS5nLiBzdWJ0aXRsZXMpLlxuICpcbiAqIEBleHRlbmRzIE1lbnVCdXR0b25cbiAqL1xuXG52YXIgVHJhY2tCdXR0b24gPSBmdW5jdGlvbiAoX01lbnVCdXR0b24pIHtcbiAgaW5oZXJpdHMoVHJhY2tCdXR0b24sIF9NZW51QnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFRyYWNrQnV0dG9uKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYWNrQnV0dG9uKTtcblxuICAgIHZhciB0cmFja3MgPSBvcHRpb25zLnRyYWNrcztcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIGlmIChfdGhpcy5pdGVtcy5sZW5ndGggPD0gMSkge1xuICAgICAgX3RoaXMuaGlkZSgpO1xuICAgIH1cblxuICAgIGlmICghdHJhY2tzKSB7XG4gICAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUhhbmRsZXIgPSBiaW5kKF90aGlzLCBfdGhpcy51cGRhdGUpO1xuXG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdXBkYXRlSGFuZGxlcik7XG4gICAgX3RoaXMucGxheWVyXy5vbigncmVhZHknLCB1cGRhdGVIYW5kbGVyKTtcblxuICAgIF90aGlzLnBsYXllcl8ub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB1cGRhdGVIYW5kbGVyKTtcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHVwZGF0ZUhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBUcmFja0J1dHRvbjtcbn0oTWVudUJ1dHRvbik7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVHJhY2tCdXR0b24nLCBUcmFja0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgbWVudS1pdGVtLmpzXG4gKi9cbi8qKlxuICogVGhlIGNvbXBvbmVudCBmb3IgYSBtZW51IGl0ZW0uIGA8bGk+YFxuICpcbiAqIEBleHRlbmRzIENsaWNrYWJsZUNvbXBvbmVudFxuICovXG5cbnZhciBNZW51SXRlbSA9IGZ1bmN0aW9uIChfQ2xpY2thYmxlQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKE1lbnVJdGVtLCBfQ2xpY2thYmxlQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNZW51SXRlbSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9DbGlja2FibGVDb21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnNlbGVjdGFibGUgPSBvcHRpb25zLnNlbGVjdGFibGU7XG5cbiAgICBfdGhpcy5zZWxlY3RlZChvcHRpb25zLnNlbGVjdGVkKTtcblxuICAgIGlmIChfdGhpcy5zZWxlY3RhYmxlKSB7XG4gICAgICAvLyBUT0RPOiBNYXkgbmVlZCB0byBiZSBlaXRoZXIgbWVudWl0ZW1jaGVja2JveCBvciBtZW51aXRlbXJhZGlvLFxuICAgICAgLy8gICAgICAgYW5kIG1heSBuZWVkIGxvZ2ljYWwgZ3JvdXBpbmcgb2YgbWVudSBpdGVtcy5cbiAgICAgIF90aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbWVudWl0ZW1jaGVja2JveCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdyb2xlJywgJ21lbnVpdGVtJyk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBNZW51SXRlbSdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZT1saV1cbiAgICogICAgICAgIEVsZW1lbnQncyBub2RlIHR5cGUsIG5vdCBhY3R1YWxseSB1c2VkLCBhbHdheXMgc2V0IHRvIGBsaWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHM9e31dXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRycz17fV1cbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIE1lbnVJdGVtLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKHR5cGUsIHByb3BzLCBhdHRycykge1xuICAgIC8vIFRoZSBjb250cm9sIGlzIHRleHR1YWwsIG5vdCBqdXN0IGFuIGljb25cbiAgICB0aGlzLm5vbkljb25Db250cm9sID0gdHJ1ZTtcblxuICAgIHJldHVybiBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdsaScsIGFzc2lnbih7XG4gICAgICBjbGFzc05hbWU6ICd2anMtbWVudS1pdGVtJyxcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGNsYXNzPVwidmpzLW1lbnUtaXRlbS10ZXh0XCI+JyArIHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zXy5sYWJlbCkgKyAnPC9zcGFuPicsXG4gICAgICB0YWJJbmRleDogLTFcbiAgICB9LCBwcm9wcyksIGF0dHJzKTtcbiAgfTtcblxuICAvKipcbiAgICogQW55IGNsaWNrIG9uIGEgYE1lbnVJdGVtYCBwdXRzIGludCBpbnRvIHRoZSBzZWxlY3RlZCBzdGF0ZS5cbiAgICogU2VlIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlQ2xpY2t9IGZvciBpbnN0YW5jZXMgd2hlcmUgdGhpcyBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIE1lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdGhpcy5zZWxlY3RlZCh0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzdGF0ZSBmb3IgdGhpcyBtZW51IGl0ZW0gYXMgc2VsZWN0ZWQgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqICAgICAgICBpZiB0aGUgbWVudSBpdGVtIGlzIHNlbGVjdGVkIG9yIG5vdFxuICAgKi9cblxuXG4gIE1lbnVJdGVtLnByb3RvdHlwZS5zZWxlY3RlZCA9IGZ1bmN0aW9uIHNlbGVjdGVkKF9zZWxlY3RlZCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgIGlmIChfc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNlbGVjdGVkJyk7XG4gICAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJywgJ3RydWUnKTtcbiAgICAgICAgLy8gYXJpYS1jaGVja2VkIGlzbid0IGZ1bGx5IHN1cHBvcnRlZCBieSBicm93c2Vycy9zY3JlZW4gcmVhZGVycyxcbiAgICAgICAgLy8gc28gaW5kaWNhdGUgc2VsZWN0ZWQgc3RhdGUgdG8gc2NyZWVuIHJlYWRlciBpbiB0aGUgY29udHJvbCB0ZXh0LlxuICAgICAgICB0aGlzLmNvbnRyb2xUZXh0KCcsIHNlbGVjdGVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2VsZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgLy8gSW5kaWNhdGUgdW4tc2VsZWN0ZWQgc3RhdGUgdG8gc2NyZWVuIHJlYWRlclxuICAgICAgICAvLyBOb3RlIHRoYXQgYSBzcGFjZSBjbGVhcnMgb3V0IHRoZSBzZWxlY3RlZCBzdGF0ZSB0ZXh0XG4gICAgICAgIHRoaXMuY29udHJvbFRleHQoJyAnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1lbnVJdGVtO1xufShDbGlja2FibGVDb21wb25lbnQpO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01lbnVJdGVtJywgTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIHRleHQtdHJhY2stbWVudS1pdGVtLmpzXG4gKi9cbi8qKlxuICogVGhlIHNwZWNpZmljIG1lbnUgaXRlbSB0eXBlIGZvciBzZWxlY3RpbmcgYSBsYW5ndWFnZSB3aXRoaW4gYSB0ZXh0IHRyYWNrIGtpbmRcbiAqXG4gKiBAZXh0ZW5kcyBNZW51SXRlbVxuICovXG5cbnZhciBUZXh0VHJhY2tNZW51SXRlbSA9IGZ1bmN0aW9uIChfTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoVGV4dFRyYWNrTWVudUl0ZW0sIF9NZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgICB2YXIgdHJhY2sgPSBvcHRpb25zLnRyYWNrO1xuICAgIHZhciB0cmFja3MgPSBwbGF5ZXIudGV4dFRyYWNrcygpO1xuXG4gICAgLy8gTW9kaWZ5IG9wdGlvbnMgZm9yIHBhcmVudCBNZW51SXRlbSBjbGFzcydzIGluaXQuXG4gICAgb3B0aW9ucy5sYWJlbCA9IHRyYWNrLmxhYmVsIHx8IHRyYWNrLmxhbmd1YWdlIHx8ICdVbmtub3duJztcbiAgICBvcHRpb25zLnNlbGVjdGVkID0gdHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnRyYWNrID0gdHJhY2s7XG4gICAgdmFyIGNoYW5nZUhhbmRsZXIgPSBiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UpO1xuICAgIHZhciBzZWxlY3RlZExhbmd1YWdlQ2hhbmdlSGFuZGxlciA9IGJpbmQoX3RoaXMsIF90aGlzLmhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UpO1xuXG4gICAgcGxheWVyLm9uKFsnbG9hZHN0YXJ0JywgJ3RleHR0cmFja2NoYW5nZSddLCBjaGFuZ2VIYW5kbGVyKTtcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGVkbGFuZ3VhZ2VjaGFuZ2UnLCBzZWxlY3RlZExhbmd1YWdlQ2hhbmdlSGFuZGxlcik7XG4gICAgX3RoaXMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0ZWRsYW5ndWFnZWNoYW5nZScsIHNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2VIYW5kbGVyKTtcbiAgICB9KTtcblxuICAgIC8vIGlPUzcgZG9lc24ndCBkaXNwYXRjaCBjaGFuZ2UgZXZlbnRzIHRvIFRleHRUcmFja0xpc3RzIHdoZW4gYW5cbiAgICAvLyBhc3NvY2lhdGVkIHRyYWNrJ3MgbW9kZSBjaGFuZ2VzLiBXaXRob3V0IHNvbWV0aGluZyBsaWtlXG4gICAgLy8gT2JqZWN0Lm9ic2VydmUoKSAoYWxzbyBub3QgcHJlc2VudCBvbiBpT1M3KSwgaXQncyBub3RcbiAgICAvLyBwb3NzaWJsZSB0byBkZXRlY3QgY2hhbmdlcyB0byB0aGUgbW9kZSBhdHRyaWJ1dGUgYW5kIHBvbHlmaWxsXG4gICAgLy8gdGhlIGNoYW5nZSBldmVudC4gQXMgYSBwb29yIHN1YnN0aXR1dGUsIHdlIG1hbnVhbGx5IGRpc3BhdGNoXG4gICAgLy8gY2hhbmdlIGV2ZW50cyB3aGVuZXZlciB0aGUgY29udHJvbHMgbW9kaWZ5IHRoZSBtb2RlLlxuICAgIGlmICh0cmFja3Mub25jaGFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGV2ZW50ID0gdm9pZCAwO1xuXG4gICAgICBfdGhpcy5vbihbJ3RhcCcsICdjbGljayddLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKHdpbmRvdy5FdmVudCkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgLy8gQW5kcm9pZCAyLjMgdGhyb3dzIGFuIElsbGVnYWwgQ29uc3RydWN0b3IgZXJyb3IgZm9yIHdpbmRvdy5FdmVudFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBldmVudCA9IG5ldyB3aW5kb3cuRXZlbnQoJ2NoYW5nZScpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICAgIGV2ZW50LmluaXRFdmVudCgnY2hhbmdlJywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFja3MuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgVGV4dFRyYWNrTWVudUl0ZW1gIGlzIFwiY2xpY2tlZFwiLiBTZWVcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICB2YXIga2luZCA9IHRoaXMudHJhY2sua2luZDtcbiAgICB2YXIga2luZHMgPSB0aGlzLnRyYWNrLmtpbmRzO1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKCFraW5kcykge1xuICAgICAga2luZHMgPSBba2luZF07XG4gICAgfVxuXG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgIGlmICghdHJhY2tzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgaWYgKHRyYWNrID09PSB0aGlzLnRyYWNrICYmIGtpbmRzLmluZGV4T2YodHJhY2sua2luZCkgPiAtMSkge1xuICAgICAgICBpZiAodHJhY2subW9kZSAhPT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgICAgdHJhY2subW9kZSA9ICdzaG93aW5nJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFjay5tb2RlICE9PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgIHRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRleHQgdHJhY2sgbGlzdCBjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBgY2hhbmdlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgVGV4dFRyYWNrTGlzdCNjaGFuZ2VcbiAgICovXG5cblxuICBUZXh0VHJhY2tNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlVHJhY2tzQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlVHJhY2tzQ2hhbmdlKGV2ZW50KSB7XG4gICAgdGhpcy5zZWxlY3RlZCh0aGlzLnRyYWNrLm1vZGUgPT09ICdzaG93aW5nJyk7XG4gIH07XG5cbiAgVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVTZWxlY3RlZExhbmd1YWdlQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMudHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICB2YXIgc2VsZWN0ZWRMYW5ndWFnZSA9IHRoaXMucGxheWVyXy5jYWNoZV8uc2VsZWN0ZWRMYW5ndWFnZTtcblxuICAgICAgLy8gRG9uJ3QgcmVwbGFjZSB0aGUga2luZCBvZiB0cmFjayBhY3Jvc3MgdGhlIHNhbWUgbGFuZ3VhZ2VcbiAgICAgIGlmIChzZWxlY3RlZExhbmd1YWdlICYmIHNlbGVjdGVkTGFuZ3VhZ2UuZW5hYmxlZCAmJiBzZWxlY3RlZExhbmd1YWdlLmxhbmd1YWdlID09PSB0aGlzLnRyYWNrLmxhbmd1YWdlICYmIHNlbGVjdGVkTGFuZ3VhZ2Uua2luZCAhPT0gdGhpcy50cmFjay5raW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wbGF5ZXJfLmNhY2hlXy5zZWxlY3RlZExhbmd1YWdlID0ge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBsYW5ndWFnZTogdGhpcy50cmFjay5sYW5ndWFnZSxcbiAgICAgICAga2luZDogdGhpcy50cmFjay5raW5kXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGV4dFRyYWNrTWVudUl0ZW07XG59KE1lbnVJdGVtKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tNZW51SXRlbScsIFRleHRUcmFja01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBvZmYtdGV4dC10cmFjay1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBBIHNwZWNpYWwgbWVudSBpdGVtIGZvciB0dXJuaW5nIG9mIGEgc3BlY2lmaWMgdHlwZSBvZiB0ZXh0IHRyYWNrXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrTWVudUl0ZW1cbiAqL1xuXG52YXIgT2ZmVGV4dFRyYWNrTWVudUl0ZW0gPSBmdW5jdGlvbiAoX1RleHRUcmFja01lbnVJdGVtKSB7XG4gIGluaGVyaXRzKE9mZlRleHRUcmFja01lbnVJdGVtLCBfVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gT2ZmVGV4dFRyYWNrTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgT2ZmVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG4gICAgLy8gQ3JlYXRlIHBzZXVkbyB0cmFjayBpbmZvXG4gICAgLy8gUmVxdWlyZXMgb3B0aW9uc1sna2luZCddXG4gICAgb3B0aW9ucy50cmFjayA9IHtcbiAgICAgIHBsYXllcjogcGxheWVyLFxuICAgICAga2luZDogb3B0aW9ucy5raW5kLFxuICAgICAga2luZHM6IG9wdGlvbnMua2luZHMsXG4gICAgICAnZGVmYXVsdCc6IGZhbHNlLFxuICAgICAgbW9kZTogJ2Rpc2FibGVkJ1xuICAgIH07XG5cbiAgICBpZiAoIW9wdGlvbnMua2luZHMpIHtcbiAgICAgIG9wdGlvbnMua2luZHMgPSBbb3B0aW9ucy5raW5kXTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5sYWJlbCkge1xuICAgICAgb3B0aW9ucy50cmFjay5sYWJlbCA9IG9wdGlvbnMubGFiZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMudHJhY2subGFiZWwgPSBvcHRpb25zLmtpbmRzLmpvaW4oJyBhbmQgJykgKyAnIG9mZic7XG4gICAgfVxuXG4gICAgLy8gTWVudUl0ZW0gaXMgc2VsZWN0YWJsZVxuICAgIG9wdGlvbnMuc2VsZWN0YWJsZSA9IHRydWU7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tNZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuc2VsZWN0ZWQodHJ1ZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0ZXh0IHRyYWNrIGNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuXG4gICAqL1xuXG5cbiAgT2ZmVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVRyYWNrc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCkge1xuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcigpLnRleHRUcmFja3MoKTtcbiAgICB2YXIgc2VsZWN0ZWQgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0cmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmtpbmRzLmluZGV4T2YodHJhY2sua2luZCkgPiAtMSAmJiB0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RlZChzZWxlY3RlZCk7XG4gIH07XG5cbiAgT2ZmVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVTZWxlY3RlZExhbmd1YWdlQ2hhbmdlKGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyKCkudGV4dFRyYWNrcygpO1xuICAgIHZhciBhbGxIaWRkZW4gPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0cmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGlmIChbJ2NhcHRpb25zJywgJ2Rlc2NyaXB0aW9ucycsICdzdWJ0aXRsZXMnXS5pbmRleE9mKHRyYWNrLmtpbmQpID4gLTEgJiYgdHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgIGFsbEhpZGRlbiA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWxsSGlkZGVuKSB7XG4gICAgICB0aGlzLnBsYXllcl8uY2FjaGVfLnNlbGVjdGVkTGFuZ3VhZ2UgPSB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gT2ZmVGV4dFRyYWNrTWVudUl0ZW07XG59KFRleHRUcmFja01lbnVJdGVtKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdPZmZUZXh0VHJhY2tNZW51SXRlbScsIE9mZlRleHRUcmFja01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBidXR0b25zIHRoYXQgdG9nZ2xlIHNwZWNpZmljIHRleHQgdHJhY2sgdHlwZXMgKGUuZy4gc3VidGl0bGVzKVxuICpcbiAqIEBleHRlbmRzIE1lbnVCdXR0b25cbiAqL1xuXG52YXIgVGV4dFRyYWNrQnV0dG9uID0gZnVuY3Rpb24gKF9UcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhUZXh0VHJhY2tCdXR0b24sIF9UcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0VHJhY2tCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRUcmFja0J1dHRvbik7XG5cbiAgICBvcHRpb25zLnRyYWNrcyA9IHBsYXllci50ZXh0VHJhY2tzKCk7XG5cbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtZW51IGl0ZW0gZm9yIGVhY2ggdGV4dCB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja01lbnVJdGVtW119IFtpdGVtcz1bXV1cbiAgICogICAgICAgIEV4aXN0aW5nIGFycmF5IG9mIGl0ZW1zIHRvIHVzZSBkdXJpbmcgY3JlYXRpb25cbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrTWVudUl0ZW1bXX1cbiAgICogICAgICAgICBBcnJheSBvZiBtZW51IGl0ZW1zIHRoYXQgd2VyZSBjcmVhdGVkXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgdmFyIFRyYWNrTWVudUl0ZW0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFRleHRUcmFja01lbnVJdGVtO1xuXG5cbiAgICAvLyBMYWJlbCBpcyBhbiBvdmVyaWRlIGZvciB0aGUgW3RyYWNrXSBvZmYgbGFiZWxcbiAgICAvLyBVU2VkIHRvIGxvY2FsaXNlIGNhcHRpb25zL3N1YnRpdGxlc1xuICAgIHZhciBsYWJlbCA9IHZvaWQgMDtcblxuICAgIGlmICh0aGlzLmxhYmVsXykge1xuICAgICAgbGFiZWwgPSB0aGlzLmxhYmVsXyArICcgb2ZmJztcbiAgICB9XG4gICAgLy8gQWRkIGFuIE9GRiBtZW51IGl0ZW0gdG8gdHVybiBhbGwgdHJhY2tzIG9mZlxuICAgIGl0ZW1zLnB1c2gobmV3IE9mZlRleHRUcmFja01lbnVJdGVtKHRoaXMucGxheWVyXywge1xuICAgICAga2luZHM6IHRoaXMua2luZHNfLFxuICAgICAga2luZDogdGhpcy5raW5kXyxcbiAgICAgIGxhYmVsOiBsYWJlbFxuICAgIH0pKTtcblxuICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gKz0gMTtcblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMua2luZHNfKSkge1xuICAgICAgdGhpcy5raW5kc18gPSBbdGhpcy5raW5kX107XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcblxuICAgICAgLy8gb25seSBhZGQgdHJhY2tzIHRoYXQgYXJlIG9mIGFuIGFwcHJvcHJpYXRlIGtpbmQgYW5kIGhhdmUgYSBsYWJlbFxuICAgICAgaWYgKHRoaXMua2luZHNfLmluZGV4T2YodHJhY2sua2luZCkgPiAtMSkge1xuXG4gICAgICAgIHZhciBpdGVtID0gbmV3IFRyYWNrTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7XG4gICAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICAgIC8vIE1lbnVJdGVtIGlzIHNlbGVjdGFibGVcbiAgICAgICAgICBzZWxlY3RhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0uYWRkQ2xhc3MoJ3Zqcy0nICsgdHJhY2sua2luZCArICctbWVudS1pdGVtJyk7XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIHJldHVybiBUZXh0VHJhY2tCdXR0b247XG59KFRyYWNrQnV0dG9uKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tCdXR0b24nLCBUZXh0VHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGNoYXB0ZXJzLXRyYWNrLW1lbnUtaXRlbS5qc1xuICovXG4vKipcbiAqIFRoZSBjaGFwdGVyIHRyYWNrIG1lbnUgaXRlbVxuICpcbiAqIEBleHRlbmRzIE1lbnVJdGVtXG4gKi9cblxudmFyIENoYXB0ZXJzVHJhY2tNZW51SXRlbSA9IGZ1bmN0aW9uIChfTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoQ2hhcHRlcnNUcmFja01lbnVJdGVtLCBfTWVudUl0ZW0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2hhcHRlcnNUcmFja01lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENoYXB0ZXJzVHJhY2tNZW51SXRlbSk7XG5cbiAgICB2YXIgdHJhY2sgPSBvcHRpb25zLnRyYWNrO1xuICAgIHZhciBjdWUgPSBvcHRpb25zLmN1ZTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBwbGF5ZXIuY3VycmVudFRpbWUoKTtcblxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxuICAgIG9wdGlvbnMuc2VsZWN0YWJsZSA9IHRydWU7XG4gICAgb3B0aW9ucy5sYWJlbCA9IGN1ZS50ZXh0O1xuICAgIG9wdGlvbnMuc2VsZWN0ZWQgPSBjdWUuc3RhcnRUaW1lIDw9IGN1cnJlbnRUaW1lICYmIGN1cnJlbnRUaW1lIDwgY3VlLmVuZFRpbWU7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9NZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMudHJhY2sgPSB0cmFjaztcbiAgICBfdGhpcy5jdWUgPSBjdWU7XG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgYmluZChfdGhpcywgX3RoaXMudXBkYXRlKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgQ2hhcHRlcnNUcmFja01lbnVJdGVtYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNUcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMpO1xuICAgIHRoaXMucGxheWVyXy5jdXJyZW50VGltZSh0aGlzLmN1ZS5zdGFydFRpbWUpO1xuICAgIHRoaXMudXBkYXRlKHRoaXMuY3VlLnN0YXJ0VGltZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjaGFwdGVyIG1lbnUgaXRlbVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGN1ZWNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRleHRUcmFjayNjdWVjaGFuZ2VcbiAgICovXG5cblxuICBDaGFwdGVyc1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIHZhciBjdWUgPSB0aGlzLmN1ZTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKTtcblxuICAgIC8vIHZqcy5sb2coY3VycmVudFRpbWUsIGN1ZS5zdGFydFRpbWUpO1xuICAgIHRoaXMuc2VsZWN0ZWQoY3VlLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSAmJiBjdXJyZW50VGltZSA8IGN1ZS5lbmRUaW1lKTtcbiAgfTtcblxuICByZXR1cm4gQ2hhcHRlcnNUcmFja01lbnVJdGVtO1xufShNZW51SXRlbSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2hhcHRlcnNUcmFja01lbnVJdGVtJywgQ2hhcHRlcnNUcmFja01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBjaGFwdGVycy1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBjaGFwdGVyc1xuICogQ2hhcHRlcnMgYWN0IG11Y2ggZGlmZmVyZW50bHkgdGhhbiBvdGhlciB0ZXh0IHRyYWNrc1xuICogQ3VlcyBhcmUgbmF2aWdhdGlvbiB2cy4gb3RoZXIgdHJhY2tzIG9mIGFsdGVybmF0aXZlIGxhbmd1YWdlc1xuICpcbiAqIEBleHRlbmRzIFRleHRUcmFja0J1dHRvblxuICovXG5cbnZhciBDaGFwdGVyc0J1dHRvbiA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrQnV0dG9uKSB7XG4gIGluaGVyaXRzKENoYXB0ZXJzQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIGZ1bmN0aW9uIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gQ2hhcHRlcnNCdXR0b24ocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENoYXB0ZXJzQnV0dG9uKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zLCByZWFkeSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY2hhcHRlcnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtY2hhcHRlcnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIG1lbnUgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgaXRzIGl0ZW1zLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBBbiBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgVGV4dFRyYWNrTGlzdCNhZGR0cmFja1xuICAgKiBAbGlzdGVucyBUZXh0VHJhY2tMaXN0I3JlbW92ZXRyYWNrXG4gICAqIEBsaXN0ZW5zIFRleHRUcmFja0xpc3QjY2hhbmdlXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xuICAgIGlmICghdGhpcy50cmFja18gfHwgZXZlbnQgJiYgKGV2ZW50LnR5cGUgPT09ICdhZGR0cmFjaycgfHwgZXZlbnQudHlwZSA9PT0gJ3JlbW92ZXRyYWNrJykpIHtcbiAgICAgIHRoaXMuc2V0VHJhY2sodGhpcy5maW5kQ2hhcHRlcnNUcmFjaygpKTtcbiAgICB9XG4gICAgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRyYWNrIGZvciB0aGUgY2hhcHRlcnMgYnV0dG9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcbiAgICogICAgICAgIFRoZSBuZXcgdHJhY2sgdG8gc2VsZWN0LiBOb3RoaW5nIHdpbGwgY2hhbmdlIGlmIHRoaXMgaXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgKiAgICAgICAgdHJhY2suXG4gICAqL1xuXG5cbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLnNldFRyYWNrID0gZnVuY3Rpb24gc2V0VHJhY2sodHJhY2spIHtcbiAgICBpZiAodGhpcy50cmFja18gPT09IHRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnVwZGF0ZUhhbmRsZXJfKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhhbmRsZXJfID0gdGhpcy51cGRhdGUuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBoZXJlIHRoaXMudHJhY2tfIHJlZmVycyB0byB0aGUgb2xkIHRyYWNrIGluc3RhbmNlXG4gICAgaWYgKHRoaXMudHJhY2tfKSB7XG4gICAgICB2YXIgcmVtb3RlVGV4dFRyYWNrRWwgPSB0aGlzLnBsYXllcl8ucmVtb3RlVGV4dFRyYWNrRWxzKCkuZ2V0VHJhY2tFbGVtZW50QnlUcmFja18odGhpcy50cmFja18pO1xuXG4gICAgICBpZiAocmVtb3RlVGV4dFRyYWNrRWwpIHtcbiAgICAgICAgcmVtb3RlVGV4dFRyYWNrRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMudXBkYXRlSGFuZGxlcl8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyYWNrXyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy50cmFja18gPSB0cmFjaztcblxuICAgIC8vIGhlcmUgdGhpcy50cmFja18gcmVmZXJzIHRvIHRoZSBuZXcgdHJhY2sgaW5zdGFuY2VcbiAgICBpZiAodGhpcy50cmFja18pIHtcbiAgICAgIHRoaXMudHJhY2tfLm1vZGUgPSAnaGlkZGVuJztcblxuICAgICAgdmFyIF9yZW1vdGVUZXh0VHJhY2tFbCA9IHRoaXMucGxheWVyXy5yZW1vdGVUZXh0VHJhY2tFbHMoKS5nZXRUcmFja0VsZW1lbnRCeVRyYWNrXyh0aGlzLnRyYWNrXyk7XG5cbiAgICAgIGlmIChfcmVtb3RlVGV4dFRyYWNrRWwpIHtcbiAgICAgICAgX3JlbW90ZVRleHRUcmFja0VsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLnVwZGF0ZUhhbmRsZXJfKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHRyYWNrIG9iamVjdCB0aGF0IGlzIGN1cnJlbnRseSBpbiB1c2UgYnkgdGhpcyBDaGFwdGVyc0J1dHRvblxuICAgKlxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2t8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHRyYWNrIG9yIHVuZGVmaW5lZCBpZiBub25lIHdhcyBmb3VuZC5cbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuZmluZENoYXB0ZXJzVHJhY2sgPSBmdW5jdGlvbiBmaW5kQ2hhcHRlcnNUcmFjaygpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKSB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSB0cmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIC8vIFdlIHdpbGwgYWx3YXlzIGNob29zZSB0aGUgbGFzdCB0cmFjayBhcyBvdXIgY2hhcHRlcnNUcmFja1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICBpZiAodHJhY2sua2luZCA9PT0gdGhpcy5raW5kXykge1xuICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNhcHRpb24gZm9yIHRoZSBDaGFwdGVyc0J1dHRvbiBiYXNlZCBvbiB0aGUgdHJhY2sgbGFiZWwuIFRoaXMgd2lsbCBhbHNvXG4gICAqIHVzZSB0aGUgY3VycmVudCB0cmFja3MgbG9jYWxpemVkIGtpbmQgYXMgYSBmYWxsYmFjayBpZiBhIGxhYmVsIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIHRyYWNrcyBjdXJyZW50IGxhYmVsIG9yIHRoZSBsb2NhbGl6ZWQgdHJhY2sga2luZC5cbiAgICovXG5cblxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuZ2V0TWVudUNhcHRpb24gPSBmdW5jdGlvbiBnZXRNZW51Q2FwdGlvbigpIHtcbiAgICBpZiAodGhpcy50cmFja18gJiYgdGhpcy50cmFja18ubGFiZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrXy5sYWJlbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG9jYWxpemUodG9UaXRsZUNhc2UodGhpcy5raW5kXykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgbWVudSBmcm9tIGNoYXB0ZXIgdHJhY2tcbiAgICpcbiAgICogQHJldHVybiB7TWVudX1cbiAgICogICAgICAgICBOZXcgbWVudSBmb3IgdGhlIGNoYXB0ZXIgYnV0dG9uc1xuICAgKi9cblxuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVNZW51ID0gZnVuY3Rpb24gY3JlYXRlTWVudSgpIHtcbiAgICB0aGlzLm9wdGlvbnNfLnRpdGxlID0gdGhpcy5nZXRNZW51Q2FwdGlvbigpO1xuICAgIHJldHVybiBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVNZW51LmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1lbnUgaXRlbSBmb3IgZWFjaCB0ZXh0IHRyYWNrXG4gICAqXG4gICAqIEByZXR1cm4ge1RleHRUcmFja01lbnVJdGVtW119XG4gICAqICAgICAgICAgQXJyYXkgb2YgbWVudSBpdGVtc1xuICAgKi9cblxuXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKCF0aGlzLnRyYWNrXykge1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cblxuICAgIHZhciBjdWVzID0gdGhpcy50cmFja18uY3VlcztcblxuICAgIGlmICghY3Vlcykge1xuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3Vlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjdWUgPSBjdWVzW2ldO1xuICAgICAgdmFyIG1pID0gbmV3IENoYXB0ZXJzVHJhY2tNZW51SXRlbSh0aGlzLnBsYXllcl8sIHsgdHJhY2s6IHRoaXMudHJhY2tfLCBjdWU6IGN1ZSB9KTtcblxuICAgICAgaXRlbXMucHVzaChtaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9O1xuXG4gIHJldHVybiBDaGFwdGVyc0J1dHRvbjtcbn0oVGV4dFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBga2luZGAgb2YgVGV4dFRyYWNrIHRvIGxvb2sgZm9yIHRvIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMgbWVudS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkNoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5raW5kXyA9ICdjaGFwdGVycyc7XG5cbi8qKlxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgQ2hhcHRlcnNCdXR0b25gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdDaGFwdGVycyc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2hhcHRlcnNCdXR0b24nLCBDaGFwdGVyc0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgZGVzY3JpcHRpb25zLWJ1dHRvbi5qc1xuICovXG4vKipcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIGRlc2NyaXB0aW9uc1xuICpcbiAqIEBleHRlbmRzIFRleHRUcmFja0J1dHRvblxuICovXG5cbnZhciBEZXNjcmlwdGlvbnNCdXR0b24gPSBmdW5jdGlvbiAoX1RleHRUcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhEZXNjcmlwdGlvbnNCdXR0b24sIF9UZXh0VHJhY2tCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gRGVzY3JpcHRpb25zQnV0dG9uKHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBEZXNjcmlwdGlvbnNCdXR0b24pO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zLCByZWFkeSkpO1xuXG4gICAgdmFyIHRyYWNrcyA9IHBsYXllci50ZXh0VHJhY2tzKCk7XG4gICAgdmFyIGNoYW5nZUhhbmRsZXIgPSBiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UpO1xuXG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgIF90aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGV4dCB0cmFjayBjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1blxuICAgKlxuICAgKiBAbGlzdGVucyBUZXh0VHJhY2tMaXN0I2NoYW5nZVxuICAgKi9cblxuXG4gIERlc2NyaXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuaGFuZGxlVHJhY2tzQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlVHJhY2tzQ2hhbmdlKGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyKCkudGV4dFRyYWNrcygpO1xuICAgIHZhciBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgd2hldGhlciBhIHRyYWNrIG9mIGEgZGlmZmVyZW50IGtpbmQgaXMgc2hvd2luZ1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdHJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xuXG4gICAgICBpZiAodHJhY2sua2luZCAhPT0gdGhpcy5raW5kXyAmJiB0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBhbm90aGVyIHRyYWNrIGlzIHNob3dpbmcsIGRpc2FibGUgdGhpcyBtZW51IGJ1dHRvblxuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuXG5cbiAgRGVzY3JpcHRpb25zQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1kZXNjcmlwdGlvbnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgRGVzY3JpcHRpb25zQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkV3JhcHBlckNTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWRlc2NyaXB0aW9ucy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIERlc2NyaXB0aW9uc0J1dHRvbjtcbn0oVGV4dFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBga2luZGAgb2YgVGV4dFRyYWNrIHRvIGxvb2sgZm9yIHRvIGFzc29jaWF0ZSBpdCB3aXRoIHRoaXMgbWVudS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkRlc2NyaXB0aW9uc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnZGVzY3JpcHRpb25zJztcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBEZXNjcmlwdGlvbnNCdXR0b25gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuRGVzY3JpcHRpb25zQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnRGVzY3JpcHRpb25zJztcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdEZXNjcmlwdGlvbnNCdXR0b24nLCBEZXNjcmlwdGlvbnNCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIHN1YnRpdGxlcy1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBzdWJ0aXRsZXNcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tCdXR0b25cbiAqL1xuXG52YXIgU3VidGl0bGVzQnV0dG9uID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoU3VidGl0bGVzQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gW3JlYWR5XVxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyByZWFkeS5cbiAgICovXG4gIGZ1bmN0aW9uIFN1YnRpdGxlc0J1dHRvbihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3VidGl0bGVzQnV0dG9uKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zLCByZWFkeSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBTdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXN1YnRpdGxlcy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBTdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtc3VidGl0bGVzLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gU3VidGl0bGVzQnV0dG9uO1xufShUZXh0VHJhY2tCdXR0b24pO1xuXG4vKipcbiAqIGBraW5kYCBvZiBUZXh0VHJhY2sgdG8gbG9vayBmb3IgdG8gYXNzb2NpYXRlIGl0IHdpdGggdGhpcyBtZW51LlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuU3VidGl0bGVzQnV0dG9uLnByb3RvdHlwZS5raW5kXyA9ICdzdWJ0aXRsZXMnO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFN1YnRpdGxlc0J1dHRvbmBzIGNvbnRyb2xzLiBBZGRlZCBmb3IgbG9jYWxpemF0aW9uLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5TdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdTdWJ0aXRsZXMnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1N1YnRpdGxlc0J1dHRvbicsIFN1YnRpdGxlc0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgY2FwdGlvbi1zZXR0aW5ncy1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBUaGUgbWVudSBpdGVtIGZvciBjYXB0aW9uIHRyYWNrIHNldHRpbmdzIG1lbnVcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tNZW51SXRlbVxuICovXG5cbnZhciBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0sIF9UZXh0VHJhY2tNZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSk7XG5cbiAgICBvcHRpb25zLnRyYWNrID0ge1xuICAgICAgcGxheWVyOiBwbGF5ZXIsXG4gICAgICBraW5kOiBvcHRpb25zLmtpbmQsXG4gICAgICBsYWJlbDogb3B0aW9ucy5raW5kICsgJyBzZXR0aW5ncycsXG4gICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgICdkZWZhdWx0JzogZmFsc2UsXG4gICAgICBtb2RlOiAnZGlzYWJsZWQnXG4gICAgfTtcblxuICAgIC8vIENhcHRpb25TZXR0aW5nc01lbnVJdGVtIGhhcyBubyBjb25jZXB0IG9mICdzZWxlY3RlZCdcbiAgICBvcHRpb25zLnNlbGVjdGFibGUgPSBmYWxzZTtcblxuICAgIG9wdGlvbnMubmFtZSA9ICdDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSc7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tNZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy10ZXh0dHJhY2stc2V0dGluZ3MnKTtcbiAgICBfdGhpcy5jb250cm9sVGV4dCgnLCBvcGVucyAnICsgb3B0aW9ucy5raW5kICsgJyBzZXR0aW5ncyBkaWFsb2cnKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbWAgaXMgXCJjbGlja2VkXCIuIFNlZVxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICAqICAgICAgICBjYWxsZWQuXG4gICAqXG4gICAqIEBsaXN0ZW5zIHRhcFxuICAgKiBAbGlzdGVucyBjbGlja1xuICAgKi9cblxuXG4gIENhcHRpb25TZXR0aW5nc01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdGhpcy5wbGF5ZXIoKS5nZXRDaGlsZCgndGV4dFRyYWNrU2V0dGluZ3MnKS5vcGVuKCk7XG4gIH07XG5cbiAgcmV0dXJuIENhcHRpb25TZXR0aW5nc01lbnVJdGVtO1xufShUZXh0VHJhY2tNZW51SXRlbSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0nLCBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSk7XG5cbi8qKlxuICogQGZpbGUgY2FwdGlvbnMtYnV0dG9uLmpzXG4gKi9cbi8qKlxuICogVGhlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHRvZ2dsaW5nIGFuZCBzZWxlY3RpbmcgY2FwdGlvbnNcbiAqXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tCdXR0b25cbiAqL1xuXG52YXIgQ2FwdGlvbnNCdXR0b24gPSBmdW5jdGlvbiAoX1RleHRUcmFja0J1dHRvbikge1xuICBpbmhlcml0cyhDYXB0aW9uc0J1dHRvbiwgX1RleHRUcmFja0J1dHRvbik7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgcmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBDYXB0aW9uc0J1dHRvbihwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FwdGlvbnNCdXR0b24pO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIENhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jYXB0aW9ucy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBDYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1jYXB0aW9ucy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBjYXB0aW9uIG1lbnUgaXRlbXNcbiAgICpcbiAgICogQHJldHVybiB7Q2FwdGlvblNldHRpbmdzTWVudUl0ZW1bXX1cbiAgICogICAgICAgICBUaGUgYXJyYXkgb2YgY3VycmVudCBtZW51IGl0ZW1zLlxuICAgKi9cblxuXG4gIENhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKCEodGhpcy5wbGF5ZXIoKS50ZWNoXyAmJiB0aGlzLnBsYXllcigpLnRlY2hfLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmV3IENhcHRpb25TZXR0aW5nc01lbnVJdGVtKHRoaXMucGxheWVyXywgeyBraW5kOiB0aGlzLmtpbmRfIH0pKTtcblxuICAgICAgdGhpcy5oaWRlVGhyZXNob2xkXyArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcy5jYWxsKHRoaXMsIGl0ZW1zKTtcbiAgfTtcblxuICByZXR1cm4gQ2FwdGlvbnNCdXR0b247XG59KFRleHRUcmFja0J1dHRvbik7XG5cbi8qKlxuICogYGtpbmRgIG9mIFRleHRUcmFjayB0byBsb29rIGZvciB0byBhc3NvY2lhdGUgaXQgd2l0aCB0aGlzIG1lbnUuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5DYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnY2FwdGlvbnMnO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYENhcHRpb25zQnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbkNhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnQ2FwdGlvbnMnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NhcHRpb25zQnV0dG9uJywgQ2FwdGlvbnNCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIHN1YnMtY2Fwcy1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBTdWJzQ2Fwc01lbnVJdGVtIGhhcyBhbiBbY2NdIGljb24gdG8gZGlzdGluZ3Vpc2ggY2FwdGlvbnMgZnJvbSBzdWJ0aXRsZXNcbiAqIGluIHRoZSBTdWJzQ2Fwc01lbnUuXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrTWVudUl0ZW1cbiAqL1xuXG52YXIgU3Vic0NhcHNNZW51SXRlbSA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrTWVudUl0ZW0pIHtcbiAgaW5oZXJpdHMoU3Vic0NhcHNNZW51SXRlbSwgX1RleHRUcmFja01lbnVJdGVtKTtcblxuICBmdW5jdGlvbiBTdWJzQ2Fwc01lbnVJdGVtKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN1YnNDYXBzTWVudUl0ZW0pO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tNZW51SXRlbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFN1YnNDYXBzTWVudUl0ZW0ucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwodHlwZSwgcHJvcHMsIGF0dHJzKSB7XG4gICAgdmFyIGlubmVySFRNTCA9ICc8c3BhbiBjbGFzcz1cInZqcy1tZW51LWl0ZW0tdGV4dFwiPicgKyB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubGFiZWwpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9uc18udHJhY2sua2luZCA9PT0gJ2NhcHRpb25zJykge1xuICAgICAgaW5uZXJIVE1MICs9ICdcXG4gICAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwidmpzLWljb24tcGxhY2Vob2xkZXJcIj48L3NwYW4+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4gJyArIHRoaXMubG9jYWxpemUoJ0NhcHRpb25zJykgKyAnPC9zcGFuPlxcbiAgICAgICc7XG4gICAgfVxuXG4gICAgaW5uZXJIVE1MICs9ICc8L3NwYW4+JztcblxuICAgIHZhciBlbCA9IF9UZXh0VHJhY2tNZW51SXRlbS5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB0eXBlLCBhc3NpZ24oe1xuICAgICAgaW5uZXJIVE1MOiBpbm5lckhUTUxcbiAgICB9LCBwcm9wcyksIGF0dHJzKTtcblxuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICByZXR1cm4gU3Vic0NhcHNNZW51SXRlbTtcbn0oVGV4dFRyYWNrTWVudUl0ZW0pO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1N1YnNDYXBzTWVudUl0ZW0nLCBTdWJzQ2Fwc01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBzdWItY2Fwcy1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBjYXB0aW9ucyBhbmQvb3Igc3VidGl0bGVzXG4gKlxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXG4gKi9cblxudmFyIFN1YnNDYXBzQnV0dG9uID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoU3Vic0NhcHNCdXR0b24sIF9UZXh0VHJhY2tCdXR0b24pO1xuXG4gIGZ1bmN0aW9uIFN1YnNDYXBzQnV0dG9uKHBsYXllcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJzQ2Fwc0J1dHRvbik7XG5cbiAgICAvLyBBbHRob3VnaCBOb3J0aCBBbWVyaWNhIHVzZXMgXCJjYXB0aW9uc1wiIGluIG1vc3QgY2FzZXMgZm9yXG4gICAgLy8gXCJjYXB0aW9ucyBhbmQgc3VidGl0bGVzXCIgb3RoZXIgbG9jYWxlcyB1c2UgXCJzdWJ0aXRsZXNcIlxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMubGFiZWxfID0gJ3N1YnRpdGxlcyc7XG4gICAgaWYgKFsnZW4nLCAnZW4tdXMnLCAnZW4tY2EnLCAnZnItY2EnXS5pbmRleE9mKF90aGlzLnBsYXllcl8ubGFuZ3VhZ2VfKSA+IC0xKSB7XG4gICAgICBfdGhpcy5sYWJlbF8gPSAnY2FwdGlvbnMnO1xuICAgIH1cbiAgICBfdGhpcy5tZW51QnV0dG9uXy5jb250cm9sVGV4dCh0b1RpdGxlQ2FzZShfdGhpcy5sYWJlbF8pKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKi9cblxuXG4gIFN1YnNDYXBzQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1zdWJzLWNhcHMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgU3Vic0NhcHNCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtc3Vicy1jYXBzLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGNhcHRpb24vc3VidGl0bGVzIG1lbnUgaXRlbXNcbiAgICpcbiAgICogQHJldHVybiB7Q2FwdGlvblNldHRpbmdzTWVudUl0ZW1bXX1cbiAgICogICAgICAgICBUaGUgYXJyYXkgb2YgY3VycmVudCBtZW51IGl0ZW1zLlxuICAgKi9cblxuXG4gIFN1YnNDYXBzQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKCEodGhpcy5wbGF5ZXIoKS50ZWNoXyAmJiB0aGlzLnBsYXllcigpLnRlY2hfLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmV3IENhcHRpb25TZXR0aW5nc01lbnVJdGVtKHRoaXMucGxheWVyXywgeyBraW5kOiB0aGlzLmxhYmVsXyB9KSk7XG5cbiAgICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gKz0gMTtcbiAgICB9XG5cbiAgICBpdGVtcyA9IF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zLmNhbGwodGhpcywgaXRlbXMsIFN1YnNDYXBzTWVudUl0ZW0pO1xuICAgIHJldHVybiBpdGVtcztcbiAgfTtcblxuICByZXR1cm4gU3Vic0NhcHNCdXR0b247XG59KFRleHRUcmFja0J1dHRvbik7XG5cbi8qKlxuICogYGtpbmRgcyBvZiBUZXh0VHJhY2sgdG8gbG9vayBmb3IgdG8gYXNzb2NpYXRlIGl0IHdpdGggdGhpcyBtZW51LlxuICpcbiAqIEB0eXBlIHthcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5TdWJzQ2Fwc0J1dHRvbi5wcm90b3R5cGUua2luZHNfID0gWydjYXB0aW9ucycsICdzdWJ0aXRsZXMnXTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBTdWJzQ2Fwc0J1dHRvbmBzIGNvbnRyb2xzLlxuICpcbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuU3Vic0NhcHNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdTdWJ0aXRsZXMnO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1N1YnNDYXBzQnV0dG9uJywgU3Vic0NhcHNCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIGF1ZGlvLXRyYWNrLW1lbnUtaXRlbS5qc1xuICovXG4vKipcbiAqIEFuIHtAbGluayBBdWRpb1RyYWNrfSB7QGxpbmsgTWVudUl0ZW19XG4gKlxuICogQGV4dGVuZHMgTWVudUl0ZW1cbiAqL1xuXG52YXIgQXVkaW9UcmFja01lbnVJdGVtID0gZnVuY3Rpb24gKF9NZW51SXRlbSkge1xuICBpbmhlcml0cyhBdWRpb1RyYWNrTWVudUl0ZW0sIF9NZW51SXRlbSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBBdWRpb1RyYWNrTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9UcmFja01lbnVJdGVtKTtcblxuICAgIHZhciB0cmFjayA9IG9wdGlvbnMudHJhY2s7XG4gICAgdmFyIHRyYWNrcyA9IHBsYXllci5hdWRpb1RyYWNrcygpO1xuXG4gICAgLy8gTW9kaWZ5IG9wdGlvbnMgZm9yIHBhcmVudCBNZW51SXRlbSBjbGFzcydzIGluaXQuXG4gICAgb3B0aW9ucy5sYWJlbCA9IHRyYWNrLmxhYmVsIHx8IHRyYWNrLmxhbmd1YWdlIHx8ICdVbmtub3duJztcbiAgICBvcHRpb25zLnNlbGVjdGVkID0gdHJhY2suZW5hYmxlZDtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVJdGVtLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy50cmFjayA9IHRyYWNrO1xuXG4gICAgdmFyIGNoYW5nZUhhbmRsZXIgPSBiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UpO1xuXG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgIF90aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYEF1ZGlvVHJhY2tNZW51SXRlbSBpcyBcImNsaWNrZWRcIi4gU2VlIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9XG4gICAqIGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgQXVkaW9UcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpO1xuXG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIHRyYWNrLmVuYWJsZWQgPSB0cmFjayA9PT0gdGhpcy50cmFjaztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhbnkge0BsaW5rIEF1ZGlvVHJhY2t9IGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIHtAbGluayBBdWRpb1RyYWNrTGlzdCNjaGFuZ2V9IGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxuICAgKlxuICAgKiBAbGlzdGVucyBBdWRpb1RyYWNrTGlzdCNjaGFuZ2VcbiAgICovXG5cblxuICBBdWRpb1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVRyYWNrc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCkge1xuICAgIHRoaXMuc2VsZWN0ZWQodGhpcy50cmFjay5lbmFibGVkKTtcbiAgfTtcblxuICByZXR1cm4gQXVkaW9UcmFja01lbnVJdGVtO1xufShNZW51SXRlbSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQXVkaW9UcmFja01lbnVJdGVtJywgQXVkaW9UcmFja01lbnVJdGVtKTtcblxuLyoqXG4gKiBAZmlsZSBhdWRpby10cmFjay1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYnV0dG9ucyB0aGF0IHRvZ2dsZSBzcGVjaWZpYyB7QGxpbmsgQXVkaW9UcmFja30gdHlwZXMuXG4gKlxuICogQGV4dGVuZHMgVHJhY2tCdXR0b25cbiAqL1xuXG52YXIgQXVkaW9UcmFja0J1dHRvbiA9IGZ1bmN0aW9uIChfVHJhY2tCdXR0b24pIHtcbiAgaW5oZXJpdHMoQXVkaW9UcmFja0J1dHRvbiwgX1RyYWNrQnV0dG9uKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2tCdXR0b24ocGxheWVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvVHJhY2tCdXR0b24pO1xuXG4gICAgb3B0aW9ucy50cmFja3MgPSBwbGF5ZXIuYXVkaW9UcmFja3MoKTtcblxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBBdWRpb1RyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1hdWRpby1idXR0b24gJyArIF9UcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIEF1ZGlvVHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtYXVkaW8tYnV0dG9uICcgKyBfVHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1lbnUgaXRlbSBmb3IgZWFjaCBhdWRpbyB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2tNZW51SXRlbVtdfSBbaXRlbXM9W11dXG4gICAqICAgICAgICBBbiBhcnJheSBvZiBleGlzdGluZyBtZW51IGl0ZW1zIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB7QXVkaW9UcmFja01lbnVJdGVtW119XG4gICAqICAgICAgICAgQW4gYXJyYXkgb2YgbWVudSBpdGVtc1xuICAgKi9cblxuXG4gIEF1ZGlvVHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zID0gZnVuY3Rpb24gY3JlYXRlSXRlbXMoKSB7XG4gICAgdmFyIGl0ZW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcblxuICAgIC8vIGlmIHRoZXJlJ3Mgb25seSBvbmUgYXVkaW8gdHJhY2ssIHRoZXJlIG5vIHBvaW50IGluIHNob3dpbmcgaXRcbiAgICB0aGlzLmhpZGVUaHJlc2hvbGRfID0gMTtcblxuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8uYXVkaW9UcmFja3MoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIGl0ZW1zLnB1c2gobmV3IEF1ZGlvVHJhY2tNZW51SXRlbSh0aGlzLnBsYXllcl8sIHtcbiAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICAvLyBNZW51SXRlbSBpcyBzZWxlY3RhYmxlXG4gICAgICAgIHNlbGVjdGFibGU6IHRydWVcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH07XG5cbiAgcmV0dXJuIEF1ZGlvVHJhY2tCdXR0b247XG59KFRyYWNrQnV0dG9uKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBBdWRpb1RyYWNrQnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5BdWRpb1RyYWNrQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnQXVkaW8gVHJhY2snO1xuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdBdWRpb1RyYWNrQnV0dG9uJywgQXVkaW9UcmFja0J1dHRvbik7XG5cbi8qKlxuICogQGZpbGUgcGxheWJhY2stcmF0ZS1tZW51LWl0ZW0uanNcbiAqL1xuLyoqXG4gKiBUaGUgc3BlY2lmaWMgbWVudSBpdGVtIHR5cGUgZm9yIHNlbGVjdGluZyBhIHBsYXliYWNrIHJhdGUuXG4gKlxuICogQGV4dGVuZHMgTWVudUl0ZW1cbiAqL1xuXG52YXIgUGxheWJhY2tSYXRlTWVudUl0ZW0gPSBmdW5jdGlvbiAoX01lbnVJdGVtKSB7XG4gIGluaGVyaXRzKFBsYXliYWNrUmF0ZU1lbnVJdGVtLCBfTWVudUl0ZW0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUGxheWJhY2tSYXRlTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxheWJhY2tSYXRlTWVudUl0ZW0pO1xuXG4gICAgdmFyIGxhYmVsID0gb3B0aW9ucy5yYXRlO1xuICAgIHZhciByYXRlID0gcGFyc2VGbG9hdChsYWJlbCwgMTApO1xuXG4gICAgLy8gTW9kaWZ5IG9wdGlvbnMgZm9yIHBhcmVudCBNZW51SXRlbSBjbGFzcydzIGluaXQuXG4gICAgb3B0aW9ucy5sYWJlbCA9IGxhYmVsO1xuICAgIG9wdGlvbnMuc2VsZWN0ZWQgPSByYXRlID09PSAxO1xuICAgIG9wdGlvbnMuc2VsZWN0YWJsZSA9IHRydWU7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9NZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMubGFiZWwgPSBsYWJlbDtcbiAgICBfdGhpcy5yYXRlID0gcmF0ZTtcblxuICAgIF90aGlzLm9uKHBsYXllciwgJ3JhdGVjaGFuZ2UnLCBfdGhpcy51cGRhdGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYFBsYXliYWNrUmF0ZU1lbnVJdGVtYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBfTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcyk7XG4gICAgdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUodGhpcy5yYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBQbGF5YmFja1JhdGVNZW51SXRlbSB3aGVuIHRoZSBwbGF5YmFja3JhdGUgY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxuICAgKiAgICAgICAgVGhlIGByYXRlY2hhbmdlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI3JhdGVjaGFuZ2VcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51SXRlbS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XG4gICAgdGhpcy5zZWxlY3RlZCh0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpID09PSB0aGlzLnJhdGUpO1xuICB9O1xuXG4gIHJldHVybiBQbGF5YmFja1JhdGVNZW51SXRlbTtcbn0oTWVudUl0ZW0pO1xuXG4vKipcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFBsYXliYWNrUmF0ZU1lbnVJdGVtYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5QbGF5YmFja1JhdGVNZW51SXRlbS5wcm90b3R5cGUuY29udGVudEVsVHlwZSA9ICdidXR0b24nO1xuXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXliYWNrUmF0ZU1lbnVJdGVtJywgUGxheWJhY2tSYXRlTWVudUl0ZW0pO1xuXG4vKipcbiAqIEBmaWxlIHBsYXliYWNrLXJhdGUtbWVudS1idXR0b24uanNcbiAqL1xuLyoqXG4gKiBUaGUgY29tcG9uZW50IGZvciBjb250cm9sbGluZyB0aGUgcGxheWJhY2sgcmF0ZS5cbiAqXG4gKiBAZXh0ZW5kcyBNZW51QnV0dG9uXG4gKi9cblxudmFyIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24gPSBmdW5jdGlvbiAoX01lbnVCdXR0b24pIHtcbiAgaW5oZXJpdHMoUGxheWJhY2tSYXRlTWVudUJ1dHRvbiwgX01lbnVCdXR0b24pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gUGxheWJhY2tSYXRlTWVudUJ1dHRvbihwbGF5ZXIsIG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbGF5YmFja1JhdGVNZW51QnV0dG9uKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICBfdGhpcy51cGRhdGVMYWJlbCgpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAnbG9hZHN0YXJ0JywgX3RoaXMudXBkYXRlVmlzaWJpbGl0eSk7XG4gICAgX3RoaXMub24ocGxheWVyLCAncmF0ZWNoYW5nZScsIF90aGlzLnVwZGF0ZUxhYmVsKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xuICAgIHZhciBlbCA9IF9NZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5sYWJlbEVsXyA9IGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtcGxheWJhY2stcmF0ZS12YWx1ZScsXG4gICAgICBpbm5lckhUTUw6IDEuMFxuICAgIH0pO1xuXG4gICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5sYWJlbEVsXyk7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1wbGF5YmFjay1yYXRlICcgKyBfTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XG4gICAgcmV0dXJuICd2anMtcGxheWJhY2stcmF0ZSAnICsgX01lbnVCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgcGxheWJhY2sgcmF0ZSBtZW51XG4gICAqXG4gICAqIEByZXR1cm4ge01lbnV9XG4gICAqICAgICAgICAgTWVudSBvYmplY3QgcG9wdWxhdGVkIHdpdGgge0BsaW5rIFBsYXliYWNrUmF0ZU1lbnVJdGVtfXNcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVNZW51ID0gZnVuY3Rpb24gY3JlYXRlTWVudSgpIHtcbiAgICB2YXIgbWVudSA9IG5ldyBNZW51KHRoaXMucGxheWVyKCkpO1xuICAgIHZhciByYXRlcyA9IHRoaXMucGxheWJhY2tSYXRlcygpO1xuXG4gICAgaWYgKHJhdGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gcmF0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbWVudS5hZGRDaGlsZChuZXcgUGxheWJhY2tSYXRlTWVudUl0ZW0odGhpcy5wbGF5ZXIoKSwgeyByYXRlOiByYXRlc1tpXSArICd4JyB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbnU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgQVJJQSBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXNcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS51cGRhdGVBUklBQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHVwZGF0ZUFSSUFBdHRyaWJ1dGVzKCkge1xuICAgIC8vIEN1cnJlbnQgcGxheWJhY2sgcmF0ZVxuICAgIHRoaXMuZWwoKS5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBQbGF5YmFja1JhdGVNZW51QnV0dG9uYCBpcyBcImNsaWNrZWRcIi4gU2VlXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgICogICAgICAgIGNhbGxlZC5cbiAgICpcbiAgICogQGxpc3RlbnMgdGFwXG4gICAqIEBsaXN0ZW5zIGNsaWNrXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIC8vIHNlbGVjdCBuZXh0IHJhdGUgb3B0aW9uXG4gICAgdmFyIGN1cnJlbnRSYXRlID0gdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUoKTtcbiAgICB2YXIgcmF0ZXMgPSB0aGlzLnBsYXliYWNrUmF0ZXMoKTtcblxuICAgIC8vIHRoaXMgd2lsbCBzZWxlY3QgZmlyc3Qgb25lIGlmIHRoZSBsYXN0IG9uZSBjdXJyZW50bHkgc2VsZWN0ZWRcbiAgICB2YXIgbmV3UmF0ZSA9IHJhdGVzWzBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJhdGVzW2ldID4gY3VycmVudFJhdGUpIHtcbiAgICAgICAgbmV3UmF0ZSA9IHJhdGVzW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUobmV3UmF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBwb3NzaWJsZSBwbGF5YmFjayByYXRlc1xuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogICAgICAgICBBbGwgcG9zc2libGUgcGxheWJhY2sgcmF0ZXNcbiAgICovXG5cblxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5wbGF5YmFja1JhdGVzID0gZnVuY3Rpb24gcGxheWJhY2tSYXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zXy5wbGF5YmFja1JhdGVzIHx8IHRoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnMucGxheWJhY2tSYXRlcztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgcGxheWJhY2sgcmF0ZXMgaXMgc3VwcG9ydGVkIGJ5IHRoZSB0ZWNoXG4gICAqIGFuZCBhbiBhcnJheSBvZiBwbGF5YmFjayByYXRlcyBleGlzdHNcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBXaGV0aGVyIGNoYW5naW5nIHBsYXliYWNrIHJhdGUgaXMgc3VwcG9ydGVkXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUucGxheWJhY2tSYXRlU3VwcG9ydGVkID0gZnVuY3Rpb24gcGxheWJhY2tSYXRlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXllcigpLnRlY2hfICYmIHRoaXMucGxheWVyKCkudGVjaF8uZmVhdHVyZXNQbGF5YmFja1JhdGUgJiYgdGhpcy5wbGF5YmFja1JhdGVzKCkgJiYgdGhpcy5wbGF5YmFja1JhdGVzKCkubGVuZ3RoID4gMDtcbiAgfTtcblxuICAvKipcbiAgICogSGlkZSBwbGF5YmFjayByYXRlIGNvbnRyb2xzIHdoZW4gdGhleSdyZSBubyBwbGF5YmFjayByYXRlIG9wdGlvbnMgdG8gc2VsZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cbiAgICpcbiAgICogQGxpc3RlbnMgUGxheWVyI2xvYWRzdGFydFxuICAgKi9cblxuXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLnVwZGF0ZVZpc2liaWxpdHkgPSBmdW5jdGlvbiB1cGRhdGVWaXNpYmlsaXR5KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGxheWJhY2tSYXRlU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGJ1dHRvbiBsYWJlbCB3aGVuIHJhdGUgY2hhbmdlZFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXG4gICAqXG4gICAqIEBsaXN0ZW5zIFBsYXllciNyYXRlY2hhbmdlXG4gICAqL1xuXG5cbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUudXBkYXRlTGFiZWwgPSBmdW5jdGlvbiB1cGRhdGVMYWJlbChldmVudCkge1xuICAgIGlmICh0aGlzLnBsYXliYWNrUmF0ZVN1cHBvcnRlZCgpKSB7XG4gICAgICB0aGlzLmxhYmVsRWxfLmlubmVySFRNTCA9IHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKCkgKyAneCc7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQbGF5YmFja1JhdGVNZW51QnV0dG9uO1xufShNZW51QnV0dG9uKTtcblxuLyoqXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBGdWxsc2NyZWVuVG9nZ2xlYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5QbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnUGxheWJhY2sgUmF0ZSc7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUGxheWJhY2tSYXRlTWVudUJ1dHRvbicsIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24pO1xuXG4vKipcbiAqIEBmaWxlIHNwYWNlci5qc1xuICovXG4vKipcbiAqIEp1c3QgYW4gZW1wdHkgc3BhY2VyIGVsZW1lbnQgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBhcHBlbmQgcG9pbnQgZm9yIHBsdWdpbnMsIGV0Yy5cbiAqIEFsc28gY2FuIGJlIHVzZWQgdG8gY3JlYXRlIHNwYWNlIGJldHdlZW4gZWxlbWVudHMgd2hlbiBuZWNlc3NhcnkuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIFNwYWNlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFNwYWNlciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3BhY2VyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFNwYWNlcik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXG4gICAqL1xuICBTcGFjZXIucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLXNwYWNlciAnICsgX0NvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIFNwYWNlci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBTcGFjZXI7XG59KENvbXBvbmVudCk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU3BhY2VyJywgU3BhY2VyKTtcblxuLyoqXG4gKiBAZmlsZSBjdXN0b20tY29udHJvbC1zcGFjZXIuanNcbiAqL1xuLyoqXG4gKiBTcGFjZXIgc3BlY2lmaWNhbGx5IG1lYW50IHRvIGJlIHVzZWQgYXMgYW4gaW5zZXJ0aW9uIHBvaW50IGZvciBuZXcgcGx1Z2lucywgZXRjLlxuICpcbiAqIEBleHRlbmRzIFNwYWNlclxuICovXG5cbnZhciBDdXN0b21Db250cm9sU3BhY2VyID0gZnVuY3Rpb24gKF9TcGFjZXIpIHtcbiAgaW5oZXJpdHMoQ3VzdG9tQ29udHJvbFNwYWNlciwgX1NwYWNlcik7XG5cbiAgZnVuY3Rpb24gQ3VzdG9tQ29udHJvbFNwYWNlcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDdXN0b21Db250cm9sU3BhY2VyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU3BhY2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cbiAgICovXG4gIEN1c3RvbUNvbnRyb2xTcGFjZXIucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xuICAgIHJldHVybiAndmpzLWN1c3RvbS1jb250cm9sLXNwYWNlciAnICsgX1NwYWNlci5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKi9cblxuXG4gIEN1c3RvbUNvbnRyb2xTcGFjZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgdmFyIGVsID0gX1NwYWNlci5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB7XG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpXG4gICAgfSk7XG5cbiAgICAvLyBOby1mbGV4L3RhYmxlLWNlbGwgbW9kZSByZXF1aXJlcyB0aGVyZSBiZSBzb21lIGNvbnRlbnRcbiAgICAvLyBpbiB0aGUgY2VsbCB0byBmaWxsIHRoZSByZW1haW5pbmcgc3BhY2Ugb2YgdGhlIHRhYmxlLlxuICAgIGVsLmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICAgIHJldHVybiBlbDtcbiAgfTtcblxuICByZXR1cm4gQ3VzdG9tQ29udHJvbFNwYWNlcjtcbn0oU3BhY2VyKTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDdXN0b21Db250cm9sU3BhY2VyJywgQ3VzdG9tQ29udHJvbFNwYWNlcik7XG5cbi8qKlxuICogQGZpbGUgY29udHJvbC1iYXIuanNcbiAqL1xuLy8gUmVxdWlyZWQgY2hpbGRyZW5cbi8qKlxuICogQ29udGFpbmVyIG9mIG1haW4gY29udHJvbHMuXG4gKlxuICogQGV4dGVuZHMgQ29tcG9uZW50XG4gKi9cblxudmFyIENvbnRyb2xCYXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhDb250cm9sQmFyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBDb250cm9sQmFyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRyb2xCYXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICovXG4gIENvbnRyb2xCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jb250cm9sLWJhcicsXG4gICAgICBkaXI6ICdsdHInXG4gICAgfSwge1xuICAgICAgLy8gVGhlIGNvbnRyb2wgYmFyIGlzIGEgZ3JvdXAsIGJ1dCB3ZSBkb24ndCBhcmlhLWxhYmVsIGl0IHRvIGF2b2lkXG4gICAgICAvLyAgb3Zlci1hbm5vdW5jaW5nIGJ5IEpBV1NcbiAgICAgIHJvbGU6ICdncm91cCdcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQ29udHJvbEJhcjtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGBDb250cm9sQmFyYFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuQ29udHJvbEJhci5wcm90b3R5cGUub3B0aW9uc18gPSB7XG4gIGNoaWxkcmVuOiBbJ3BsYXlUb2dnbGUnLCAndm9sdW1lUGFuZWwnLCAnY3VycmVudFRpbWVEaXNwbGF5JywgJ3RpbWVEaXZpZGVyJywgJ2R1cmF0aW9uRGlzcGxheScsICdwcm9ncmVzc0NvbnRyb2wnLCAnbGl2ZURpc3BsYXknLCAncmVtYWluaW5nVGltZURpc3BsYXknLCAnY3VzdG9tQ29udHJvbFNwYWNlcicsICdwbGF5YmFja1JhdGVNZW51QnV0dG9uJywgJ2NoYXB0ZXJzQnV0dG9uJywgJ2Rlc2NyaXB0aW9uc0J1dHRvbicsICdzdWJzQ2Fwc0J1dHRvbicsICdhdWRpb1RyYWNrQnV0dG9uJywgJ2Z1bGxzY3JlZW5Ub2dnbGUnXVxufTtcblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDb250cm9sQmFyJywgQ29udHJvbEJhcik7XG5cbi8qKlxuICogQGZpbGUgZXJyb3ItZGlzcGxheS5qc1xuICovXG4vKipcbiAqIEEgZGlzcGxheSB0aGF0IGluZGljYXRlcyBhbiBlcnJvciBoYXMgb2NjdXJyZWQuIFRoaXMgbWVhbnMgdGhhdCB0aGUgdmlkZW9cbiAqIGlzIHVucGxheWFibGUuXG4gKlxuICogQGV4dGVuZHMgTW9kYWxEaWFsb2dcbiAqL1xuXG52YXIgRXJyb3JEaXNwbGF5ID0gZnVuY3Rpb24gKF9Nb2RhbERpYWxvZykge1xuICBpbmhlcml0cyhFcnJvckRpc3BsYXksIF9Nb2RhbERpYWxvZyk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAgICpcbiAgICogQHBhcmFtICB7UGxheWVyfSBwbGF5ZXJcbiAgICogICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gRXJyb3JEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEVycm9yRGlzcGxheSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Nb2RhbERpYWxvZy5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xuXG4gICAgX3RoaXMub24ocGxheWVyLCAnZXJyb3InLCBfdGhpcy5vcGVuKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBTaW5jZSB2ZXJzaW9uIDUuXG4gICAqL1xuXG5cbiAgRXJyb3JEaXNwbGF5LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gJ3Zqcy1lcnJvci1kaXNwbGF5ICcgKyBfTW9kYWxEaWFsb2cucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbG9jYWxpemVkIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gdGhlIGBQbGF5ZXJgcyBlcnJvci5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBgUGxheWVyYHMgZXJyb3IgbWVzc2FnZSBsb2NhbGl6ZWQgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICAgKi9cblxuXG4gIEVycm9yRGlzcGxheS5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5wbGF5ZXIoKS5lcnJvcigpO1xuXG4gICAgcmV0dXJuIGVycm9yID8gdGhpcy5sb2NhbGl6ZShlcnJvci5tZXNzYWdlKSA6ICcnO1xuICB9O1xuXG4gIHJldHVybiBFcnJvckRpc3BsYXk7XG59KE1vZGFsRGlhbG9nKTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciBhbiBgRXJyb3JEaXNwbGF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuRXJyb3JEaXNwbGF5LnByb3RvdHlwZS5vcHRpb25zXyA9IG1lcmdlT3B0aW9ucyhNb2RhbERpYWxvZy5wcm90b3R5cGUub3B0aW9uc18sIHtcbiAgcGF1c2VPbk9wZW46IGZhbHNlLFxuICBmaWxsQWx3YXlzOiB0cnVlLFxuICB0ZW1wb3Jhcnk6IGZhbHNlLFxuICB1bmNsb3NlYWJsZTogdHJ1ZVxufSk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnRXJyb3JEaXNwbGF5JywgRXJyb3JEaXNwbGF5KTtcblxuLyoqXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLXNldHRpbmdzLmpzXG4gKi9cbnZhciBMT0NBTF9TVE9SQUdFX0tFWSA9ICd2anMtdGV4dC10cmFjay1zZXR0aW5ncyc7XG5cbnZhciBDT0xPUl9CTEFDSyA9IFsnIzAwMCcsICdCbGFjayddO1xudmFyIENPTE9SX0JMVUUgPSBbJyMwMEYnLCAnQmx1ZSddO1xudmFyIENPTE9SX0NZQU4gPSBbJyMwRkYnLCAnQ3lhbiddO1xudmFyIENPTE9SX0dSRUVOID0gWycjMEYwJywgJ0dyZWVuJ107XG52YXIgQ09MT1JfTUFHRU5UQSA9IFsnI0YwRicsICdNYWdlbnRhJ107XG52YXIgQ09MT1JfUkVEID0gWycjRjAwJywgJ1JlZCddO1xudmFyIENPTE9SX1dISVRFID0gWycjRkZGJywgJ1doaXRlJ107XG52YXIgQ09MT1JfWUVMTE9XID0gWycjRkYwJywgJ1llbGxvdyddO1xuXG52YXIgT1BBQ0lUWV9PUEFRVUUgPSBbJzEnLCAnT3BhcXVlJ107XG52YXIgT1BBQ0lUWV9TRU1JID0gWycwLjUnLCAnU2VtaS1UcmFuc3BhcmVudCddO1xudmFyIE9QQUNJVFlfVFJBTlMgPSBbJzAnLCAnVHJhbnNwYXJlbnQnXTtcblxuLy8gQ29uZmlndXJhdGlvbiBmb3IgdGhlIHZhcmlvdXMgPHNlbGVjdD4gZWxlbWVudHMgaW4gdGhlIERPTSBvZiB0aGlzIGNvbXBvbmVudC5cbi8vXG4vLyBQb3NzaWJsZSBrZXlzIGluY2x1ZGU6XG4vL1xuLy8gYGRlZmF1bHRgOlxuLy8gICBUaGUgZGVmYXVsdCBvcHRpb24gaW5kZXguIE9ubHkgbmVlZHMgdG8gYmUgcHJvdmlkZWQgaWYgbm90IHplcm8uXG4vLyBgcGFyc2VyYDpcbi8vICAgQSBmdW5jdGlvbiB3aGljaCBpcyB1c2VkIHRvIHBhcnNlIHRoZSB2YWx1ZSBmcm9tIHRoZSBzZWxlY3RlZCBvcHRpb24gaW5cbi8vICAgYSBjdXN0b21pemVkIHdheS5cbi8vIGBzZWxlY3RvcmA6XG4vLyAgIFRoZSBzZWxlY3RvciB1c2VkIHRvIGZpbmQgdGhlIGFzc29jaWF0ZWQgPHNlbGVjdD4gZWxlbWVudC5cbnZhciBzZWxlY3RDb25maWdzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICBzZWxlY3RvcjogJy52anMtYmctY29sb3IgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtYmFja2dyb3VuZC1jb2xvci0lcycsXG4gICAgbGFiZWw6ICdDb2xvcicsXG4gICAgb3B0aW9uczogW0NPTE9SX0JMQUNLLCBDT0xPUl9XSElURSwgQ09MT1JfUkVELCBDT0xPUl9HUkVFTiwgQ09MT1JfQkxVRSwgQ09MT1JfWUVMTE9XLCBDT0xPUl9NQUdFTlRBLCBDT0xPUl9DWUFOXVxuICB9LFxuXG4gIGJhY2tncm91bmRPcGFjaXR5OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLWJnLW9wYWNpdHkgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtYmFja2dyb3VuZC1vcGFjaXR5LSVzJyxcbiAgICBsYWJlbDogJ1RyYW5zcGFyZW5jeScsXG4gICAgb3B0aW9uczogW09QQUNJVFlfT1BBUVVFLCBPUEFDSVRZX1NFTUksIE9QQUNJVFlfVFJBTlNdXG4gIH0sXG5cbiAgY29sb3I6IHtcbiAgICBzZWxlY3RvcjogJy52anMtZmctY29sb3IgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtZm9yZWdyb3VuZC1jb2xvci0lcycsXG4gICAgbGFiZWw6ICdDb2xvcicsXG4gICAgb3B0aW9uczogW0NPTE9SX1dISVRFLCBDT0xPUl9CTEFDSywgQ09MT1JfUkVELCBDT0xPUl9HUkVFTiwgQ09MT1JfQkxVRSwgQ09MT1JfWUVMTE9XLCBDT0xPUl9NQUdFTlRBLCBDT0xPUl9DWUFOXVxuICB9LFxuXG4gIGVkZ2VTdHlsZToge1xuICAgIHNlbGVjdG9yOiAnLnZqcy1lZGdlLXN0eWxlID4gc2VsZWN0JyxcbiAgICBpZDogJyVzJyxcbiAgICBsYWJlbDogJ1RleHQgRWRnZSBTdHlsZScsXG4gICAgb3B0aW9uczogW1snbm9uZScsICdOb25lJ10sIFsncmFpc2VkJywgJ1JhaXNlZCddLCBbJ2RlcHJlc3NlZCcsICdEZXByZXNzZWQnXSwgWyd1bmlmb3JtJywgJ1VuaWZvcm0nXSwgWydkcm9wc2hhZG93JywgJ0Ryb3BzaGFkb3cnXV1cbiAgfSxcblxuICBmb250RmFtaWx5OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLWZvbnQtZmFtaWx5ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLWZvbnQtZmFtaWx5LSVzJyxcbiAgICBsYWJlbDogJ0ZvbnQgRmFtaWx5JyxcbiAgICBvcHRpb25zOiBbWydwcm9wb3J0aW9uYWxTYW5zU2VyaWYnLCAnUHJvcG9ydGlvbmFsIFNhbnMtU2VyaWYnXSwgWydtb25vc3BhY2VTYW5zU2VyaWYnLCAnTW9ub3NwYWNlIFNhbnMtU2VyaWYnXSwgWydwcm9wb3J0aW9uYWxTZXJpZicsICdQcm9wb3J0aW9uYWwgU2VyaWYnXSwgWydtb25vc3BhY2VTZXJpZicsICdNb25vc3BhY2UgU2VyaWYnXSwgWydjYXN1YWwnLCAnQ2FzdWFsJ10sIFsnc2NyaXB0JywgJ1NjcmlwdCddLCBbJ3NtYWxsLWNhcHMnLCAnU21hbGwgQ2FwcyddXVxuICB9LFxuXG4gIGZvbnRQZXJjZW50OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLWZvbnQtcGVyY2VudCA+IHNlbGVjdCcsXG4gICAgaWQ6ICdjYXB0aW9ucy1mb250LXNpemUtJXMnLFxuICAgIGxhYmVsOiAnRm9udCBTaXplJyxcbiAgICBvcHRpb25zOiBbWycwLjUwJywgJzUwJSddLCBbJzAuNzUnLCAnNzUlJ10sIFsnMS4wMCcsICcxMDAlJ10sIFsnMS4yNScsICcxMjUlJ10sIFsnMS41MCcsICcxNTAlJ10sIFsnMS43NScsICcxNzUlJ10sIFsnMi4wMCcsICcyMDAlJ10sIFsnMy4wMCcsICczMDAlJ10sIFsnNC4wMCcsICc0MDAlJ11dLFxuICAgICdkZWZhdWx0JzogMixcbiAgICBwYXJzZXI6IGZ1bmN0aW9uIHBhcnNlcih2KSB7XG4gICAgICByZXR1cm4gdiA9PT0gJzEuMDAnID8gbnVsbCA6IE51bWJlcih2KTtcbiAgICB9XG4gIH0sXG5cbiAgdGV4dE9wYWNpdHk6IHtcbiAgICBzZWxlY3RvcjogJy52anMtdGV4dC1vcGFjaXR5ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLWZvcmVncm91bmQtb3BhY2l0eS0lcycsXG4gICAgbGFiZWw6ICdUcmFuc3BhcmVuY3knLFxuICAgIG9wdGlvbnM6IFtPUEFDSVRZX09QQVFVRSwgT1BBQ0lUWV9TRU1JXVxuICB9LFxuXG4gIC8vIE9wdGlvbnMgZm9yIHRoaXMgb2JqZWN0IGFyZSBkZWZpbmVkIGJlbG93LlxuICB3aW5kb3dDb2xvcjoge1xuICAgIHNlbGVjdG9yOiAnLnZqcy13aW5kb3ctY29sb3IgPiBzZWxlY3QnLFxuICAgIGlkOiAnY2FwdGlvbnMtd2luZG93LWNvbG9yLSVzJyxcbiAgICBsYWJlbDogJ0NvbG9yJ1xuICB9LFxuXG4gIC8vIE9wdGlvbnMgZm9yIHRoaXMgb2JqZWN0IGFyZSBkZWZpbmVkIGJlbG93LlxuICB3aW5kb3dPcGFjaXR5OiB7XG4gICAgc2VsZWN0b3I6ICcudmpzLXdpbmRvdy1vcGFjaXR5ID4gc2VsZWN0JyxcbiAgICBpZDogJ2NhcHRpb25zLXdpbmRvdy1vcGFjaXR5LSVzJyxcbiAgICBsYWJlbDogJ1RyYW5zcGFyZW5jeScsXG4gICAgb3B0aW9uczogW09QQUNJVFlfVFJBTlMsIE9QQUNJVFlfU0VNSSwgT1BBQ0lUWV9PUEFRVUVdXG4gIH1cbn07XG5cbnNlbGVjdENvbmZpZ3Mud2luZG93Q29sb3Iub3B0aW9ucyA9IHNlbGVjdENvbmZpZ3MuYmFja2dyb3VuZENvbG9yLm9wdGlvbnM7XG5cbi8qKlxuICogR2V0IHRoZSBhY3R1YWwgdmFsdWUgb2YgYW4gb3B0aW9uLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWVcbiAqICAgICAgICAgVGhlIHZhbHVlIHRvIGdldFxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbcGFyc2VyXVxuICogICAgICAgICBPcHRpb25hbCBmdW5jdGlvbiB0byBhZGp1c3QgdGhlIHZhbHVlLlxuICpcbiAqIEByZXR1cm4ge01peGVkfVxuICogICAgICAgICAtIFdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgbm8gdmFsdWUgZXhpc3RzXG4gKiAgICAgICAgIC0gV2lsbCBiZSBgdW5kZWZpbmVkYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgXCJub25lXCIuXG4gKiAgICAgICAgIC0gV2lsbCBiZSB0aGUgYWN0dWFsIHZhbHVlIG90aGVyd2lzZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZU9wdGlvblZhbHVlKHZhbHVlLCBwYXJzZXIpIHtcbiAgaWYgKHBhcnNlcikge1xuICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNlbGVjdGVkIDxvcHRpb24+IGVsZW1lbnQgd2l0aGluIGEgPHNlbGVjdD4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbFxuICogICAgICAgICB0aGUgZWxlbWVudCB0byBsb29rIGluXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IFtwYXJzZXJdXG4gKiAgICAgICAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFkanVzdCB0aGUgdmFsdWUuXG4gKlxuICogQHJldHVybiB7TWl4ZWR9XG4gKiAgICAgICAgIC0gV2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBubyB2YWx1ZSBleGlzdHNcbiAqICAgICAgICAgLSBXaWxsIGJlIGB1bmRlZmluZWRgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBcIm5vbmVcIi5cbiAqICAgICAgICAgLSBXaWxsIGJlIHRoZSBhY3R1YWwgdmFsdWUgb3RoZXJ3aXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoZWwsIHBhcnNlcikge1xuICB2YXIgdmFsdWUgPSBlbC5vcHRpb25zW2VsLm9wdGlvbnMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG5cbiAgcmV0dXJuIHBhcnNlT3B0aW9uVmFsdWUodmFsdWUsIHBhcnNlcik7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc2VsZWN0ZWQgPG9wdGlvbj4gZWxlbWVudCB3aXRoaW4gYSA8c2VsZWN0PiBlbGVtZW50IGJhc2VkIG9uIGFcbiAqIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqICAgICAgICBUaGUgZWxlbWVudCB0byBsb29rIGluLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogICAgICAgIHRoZSBwcm9wZXJ0eSB0byBsb29rIG9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJzZXJdXG4gKiAgICAgICAgT3B0aW9uYWwgZnVuY3Rpb24gdG8gYWRqdXN0IHRoZSB2YWx1ZSBiZWZvcmUgY29tcGFyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldFNlbGVjdGVkT3B0aW9uKGVsLCB2YWx1ZSwgcGFyc2VyKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsLm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGFyc2VPcHRpb25WYWx1ZShlbC5vcHRpb25zW2ldLnZhbHVlLCBwYXJzZXIpID09PSB2YWx1ZSkge1xuICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYW5pcHVsYXRlIFRleHQgVHJhY2tzIHNldHRpbmdzLlxuICpcbiAqIEBleHRlbmRzIE1vZGFsRGlhbG9nXG4gKi9cblxudmFyIFRleHRUcmFja1NldHRpbmdzID0gZnVuY3Rpb24gKF9Nb2RhbERpYWxvZykge1xuICBpbmhlcml0cyhUZXh0VHJhY2tTZXR0aW5ncywgX01vZGFsRGlhbG9nKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXG4gICAqICAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gVGV4dFRyYWNrU2V0dGluZ3MocGxheWVyLCBvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrU2V0dGluZ3MpO1xuXG4gICAgb3B0aW9ucy50ZW1wb3JhcnkgPSBmYWxzZTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01vZGFsRGlhbG9nLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy51cGRhdGVEaXNwbGF5ID0gYmluZChfdGhpcywgX3RoaXMudXBkYXRlRGlzcGxheSk7XG5cbiAgICAvLyBmaWxsIHRoZSBtb2RhbCBhbmQgcHJldGVuZCB3ZSBoYXZlIG9wZW5lZCBpdFxuICAgIF90aGlzLmZpbGwoKTtcbiAgICBfdGhpcy5oYXNCZWVuT3BlbmVkXyA9IF90aGlzLmhhc0JlZW5GaWxsZWRfID0gdHJ1ZTtcblxuICAgIF90aGlzLmVuZERpYWxvZyA9IGNyZWF0ZUVsKCdwJywge1xuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtdGV4dCcsXG4gICAgICB0ZXh0Q29udGVudDogX3RoaXMubG9jYWxpemUoJ0VuZCBvZiBkaWFsb2cgd2luZG93LicpXG4gICAgfSk7XG4gICAgX3RoaXMuZWwoKS5hcHBlbmRDaGlsZChfdGhpcy5lbmREaWFsb2cpO1xuXG4gICAgX3RoaXMuc2V0RGVmYXVsdHMoKTtcblxuICAgIC8vIEdyYWIgYHBlcnNpc3RUZXh0VHJhY2tTZXR0aW5nc2AgZnJvbSB0aGUgcGxheWVyIG9wdGlvbnMgaWYgbm90IHBhc3NlZCBpbiBjaGlsZCBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMucGVyc2lzdFRleHRUcmFja1NldHRpbmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIF90aGlzLm9wdGlvbnNfLnBlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncyA9IF90aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnMucGVyc2lzdFRleHRUcmFja1NldHRpbmdzO1xuICAgIH1cblxuICAgIF90aGlzLm9uKF90aGlzLiQoJy52anMtZG9uZS1idXR0b24nKSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2F2ZVNldHRpbmdzKCk7XG4gICAgICBfdGhpcy5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMub24oX3RoaXMuJCgnLnZqcy1kZWZhdWx0LWJ1dHRvbicpLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXREZWZhdWx0cygpO1xuICAgICAgX3RoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuXG4gICAgZWFjaChzZWxlY3RDb25maWdzLCBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICBfdGhpcy5vbihfdGhpcy4kKGNvbmZpZy5zZWxlY3RvciksICdjaGFuZ2UnLCBfdGhpcy51cGRhdGVEaXNwbGF5KTtcbiAgICB9KTtcblxuICAgIGlmIChfdGhpcy5vcHRpb25zXy5wZXJzaXN0VGV4dFRyYWNrU2V0dGluZ3MpIHtcbiAgICAgIF90aGlzLnJlc3RvcmVTZXR0aW5ncygpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgPHNlbGVjdD4gZWxlbWVudCB3aXRoIGNvbmZpZ3VyZWQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiAgICAgICAgQ29uZmlndXJhdGlvbiBrZXkgdG8gdXNlIGR1cmluZyBjcmVhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEFuIEhUTUwgc3RyaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbFNlbGVjdF8gPSBmdW5jdGlvbiBjcmVhdGVFbFNlbGVjdF8oa2V5KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgbGVnZW5kSWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnbGFiZWwnO1xuXG4gICAgdmFyIGNvbmZpZyA9IHNlbGVjdENvbmZpZ3Nba2V5XTtcbiAgICB2YXIgaWQgPSBjb25maWcuaWQucmVwbGFjZSgnJXMnLCB0aGlzLmlkXyk7XG5cbiAgICByZXR1cm4gWyc8JyArIHR5cGUgKyAnIGlkPVwiJyArIGlkICsgJ1wiIGNsYXNzPVwiJyArICh0eXBlID09PSAnbGFiZWwnID8gJ3Zqcy1sYWJlbCcgOiAnJykgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZShjb25maWcubGFiZWwpLCAnPC8nICsgdHlwZSArICc+JywgJzxzZWxlY3QgYXJpYS1sYWJlbGxlZGJ5PVwiJyArIGxlZ2VuZElkICsgJyAnICsgaWQgKyAnXCI+J10uY29uY2F0KGNvbmZpZy5vcHRpb25zLm1hcChmdW5jdGlvbiAobykge1xuICAgICAgdmFyIG9wdGlvbklkID0gaWQgKyAnLScgKyBvWzFdO1xuXG4gICAgICByZXR1cm4gWyc8b3B0aW9uIGlkPVwiJyArIG9wdGlvbklkICsgJ1wiIHZhbHVlPVwiJyArIG9bMF0gKyAnXCIgJywgJ2FyaWEtbGFiZWxsZWRieT1cIicgKyBsZWdlbmRJZCArICcgJyArIGlkICsgJyAnICsgb3B0aW9uSWQgKyAnXCI+JywgX3RoaXMyLmxvY2FsaXplKG9bMV0pLCAnPC9vcHRpb24+J10uam9pbignJyk7XG4gICAgfSkpLmNvbmNhdCgnPC9zZWxlY3Q+Jykuam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBmb3JlZ3JvdW5kIGNvbG9yIGVsZW1lbnQgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIEFuIEhUTUwgc3RyaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbEZnQ29sb3JfID0gZnVuY3Rpb24gY3JlYXRlRWxGZ0NvbG9yXygpIHtcbiAgICB2YXIgbGVnZW5kSWQgPSAnY2FwdGlvbnMtdGV4dC1sZWdlbmQtJyArIHRoaXMuaWRfO1xuXG4gICAgcmV0dXJuIFsnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWZnLWNvbG9yIHZqcy10cmFjay1zZXR0aW5nXCI+JywgJzxsZWdlbmQgaWQ9XCInICsgbGVnZW5kSWQgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnVGV4dCcpLCAnPC9sZWdlbmQ+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2NvbG9yJywgbGVnZW5kSWQpLCAnPHNwYW4gY2xhc3M9XCJ2anMtdGV4dC1vcGFjaXR5IHZqcy1vcGFjaXR5XCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ3RleHRPcGFjaXR5JywgbGVnZW5kSWQpLCAnPC9zcGFuPicsICc8L2ZpZWxkc2V0PiddLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYmFja2dyb3VuZCBjb2xvciBlbGVtZW50IGZvciB0aGUgY29tcG9uZW50XG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBBbiBIVE1MIHN0cmluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxCZ0NvbG9yXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsQmdDb2xvcl8oKSB7XG4gICAgdmFyIGxlZ2VuZElkID0gJ2NhcHRpb25zLWJhY2tncm91bmQtJyArIHRoaXMuaWRfO1xuXG4gICAgcmV0dXJuIFsnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWJnLWNvbG9yIHZqcy10cmFjay1zZXR0aW5nXCI+JywgJzxsZWdlbmQgaWQ9XCInICsgbGVnZW5kSWQgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnQmFja2dyb3VuZCcpLCAnPC9sZWdlbmQ+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2JhY2tncm91bmRDb2xvcicsIGxlZ2VuZElkKSwgJzxzcGFuIGNsYXNzPVwidmpzLWJnLW9wYWNpdHkgdmpzLW9wYWNpdHlcIj4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0XygnYmFja2dyb3VuZE9wYWNpdHknLCBsZWdlbmRJZCksICc8L3NwYW4+JywgJzwvZmllbGRzZXQ+J10uam9pbignJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB3aW5kb3cgY29sb3IgZWxlbWVudCBmb3IgdGhlIGNvbXBvbmVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgQW4gSFRNTCBzdHJpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNyZWF0ZUVsV2luQ29sb3JfID0gZnVuY3Rpb24gY3JlYXRlRWxXaW5Db2xvcl8oKSB7XG4gICAgdmFyIGxlZ2VuZElkID0gJ2NhcHRpb25zLXdpbmRvdy0nICsgdGhpcy5pZF87XG5cbiAgICByZXR1cm4gWyc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtd2luZG93LWNvbG9yIHZqcy10cmFjay1zZXR0aW5nXCI+JywgJzxsZWdlbmQgaWQ9XCInICsgbGVnZW5kSWQgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnV2luZG93JyksICc8L2xlZ2VuZD4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0Xygnd2luZG93Q29sb3InLCBsZWdlbmRJZCksICc8c3BhbiBjbGFzcz1cInZqcy13aW5kb3ctb3BhY2l0eSB2anMtb3BhY2l0eVwiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCd3aW5kb3dPcGFjaXR5JywgbGVnZW5kSWQpLCAnPC9zcGFuPicsICc8L2ZpZWxkc2V0PiddLmpvaW4oJycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgY29sb3IgZWxlbWVudHMgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNyZWF0ZUVsQ29sb3JzXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsQ29sb3JzXygpIHtcbiAgICByZXR1cm4gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10cmFjay1zZXR0aW5ncy1jb2xvcnMnLFxuICAgICAgaW5uZXJIVE1MOiBbdGhpcy5jcmVhdGVFbEZnQ29sb3JfKCksIHRoaXMuY3JlYXRlRWxCZ0NvbG9yXygpLCB0aGlzLmNyZWF0ZUVsV2luQ29sb3JfKCldLmpvaW4oJycpXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBmb250IGVsZW1lbnRzIGZvciB0aGUgY29tcG9uZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxGb250XyA9IGZ1bmN0aW9uIGNyZWF0ZUVsRm9udF8oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICBjbGFzc05hbWU6ICd2anMtdHJhY2stc2V0dGluZ3MtZm9udFwiPicsXG4gICAgICBpbm5lckhUTUw6IFsnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWZvbnQtcGVyY2VudCB2anMtdHJhY2stc2V0dGluZ1wiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCdmb250UGVyY2VudCcsICcnLCAnbGVnZW5kJyksICc8L2ZpZWxkc2V0PicsICc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtZWRnZS1zdHlsZSB2anMtdHJhY2stc2V0dGluZ1wiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCdlZGdlU3R5bGUnLCAnJywgJ2xlZ2VuZCcpLCAnPC9maWVsZHNldD4nLCAnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWZvbnQtZmFtaWx5IHZqcy10cmFjay1zZXR0aW5nXCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2ZvbnRGYW1pbHknLCAnJywgJ2xlZ2VuZCcpLCAnPC9maWVsZHNldD4nXS5qb2luKCcnKVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgY29udHJvbHMgZm9yIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbENvbnRyb2xzXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsQ29udHJvbHNfKCkge1xuICAgIHZhciBkZWZhdWx0c0Rlc2NyaXB0aW9uID0gdGhpcy5sb2NhbGl6ZSgncmVzdG9yZSBhbGwgc2V0dGluZ3MgdG8gdGhlIGRlZmF1bHQgdmFsdWVzJyk7XG5cbiAgICByZXR1cm4gY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10cmFjay1zZXR0aW5ncy1jb250cm9scycsXG4gICAgICBpbm5lckhUTUw6IFsnPGJ1dHRvbiBjbGFzcz1cInZqcy1kZWZhdWx0LWJ1dHRvblwiIHRpdGxlPVwiJyArIGRlZmF1bHRzRGVzY3JpcHRpb24gKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnUmVzZXQnKSwgJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPiAnICsgZGVmYXVsdHNEZXNjcmlwdGlvbiArICc8L3NwYW4+JywgJzwvYnV0dG9uPicsICc8YnV0dG9uIGNsYXNzPVwidmpzLWRvbmUtYnV0dG9uXCI+JyArIHRoaXMubG9jYWxpemUoJ0RvbmUnKSArICc8L2J1dHRvbj4nXS5qb2luKCcnKVxuICAgIH0pO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gY29udGVudCgpIHtcbiAgICByZXR1cm4gW3RoaXMuY3JlYXRlRWxDb2xvcnNfKCksIHRoaXMuY3JlYXRlRWxGb250XygpLCB0aGlzLmNyZWF0ZUVsQ29udHJvbHNfKCldO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uIGxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKCdDYXB0aW9uIFNldHRpbmdzIERpYWxvZycpO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5kZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKCdCZWdpbm5pbmcgb2YgZGlhbG9nIHdpbmRvdy4gRXNjYXBlIHdpbGwgY2FuY2VsIGFuZCBjbG9zZSB0aGUgd2luZG93LicpO1xuICB9O1xuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcbiAgICByZXR1cm4gX01vZGFsRGlhbG9nLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcykgKyAnIHZqcy10ZXh0LXRyYWNrLXNldHRpbmdzJztcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3Qgb2YgdGV4dCB0cmFjayBzZXR0aW5ncyAob3IgbnVsbCkuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogICAgICAgICBBbiBvYmplY3Qgd2l0aCBjb25maWcgdmFsdWVzIHBhcnNlZCBmcm9tIHRoZSBET00gb3IgbG9jYWxTdG9yYWdlLlxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiBnZXRWYWx1ZXMoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICByZXR1cm4gcmVkdWNlKHNlbGVjdENvbmZpZ3MsIGZ1bmN0aW9uIChhY2N1bSwgY29uZmlnLCBrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoX3RoaXMzLiQoY29uZmlnLnNlbGVjdG9yKSwgY29uZmlnLnBhcnNlcik7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFjY3VtW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjY3VtO1xuICAgIH0sIHt9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0ZXh0IHRyYWNrIHNldHRpbmdzIGZyb20gYW4gb2JqZWN0IG9mIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlc1xuICAgKiAgICAgICAgQW4gb2JqZWN0IHdpdGggY29uZmlnIHZhbHVlcyBwYXJzZWQgZnJvbSB0aGUgRE9NIG9yIGxvY2FsU3RvcmFnZS5cbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24gc2V0VmFsdWVzKHZhbHVlcykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgZWFjaChzZWxlY3RDb25maWdzLCBmdW5jdGlvbiAoY29uZmlnLCBrZXkpIHtcbiAgICAgIHNldFNlbGVjdGVkT3B0aW9uKF90aGlzNC4kKGNvbmZpZy5zZWxlY3RvciksIHZhbHVlc1trZXldLCBjb25maWcucGFyc2VyKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhbGwgYDxzZWxlY3Q+YCBlbGVtZW50cyB0byB0aGVpciBkZWZhdWx0IHZhbHVlcy5cbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiBzZXREZWZhdWx0cygpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIGVhY2goc2VsZWN0Q29uZmlncywgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgdmFyIGluZGV4ID0gY29uZmlnLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBjb25maWdbJ2RlZmF1bHQnXSA6IDA7XG5cbiAgICAgIF90aGlzNS4kKGNvbmZpZy5zZWxlY3Rvcikuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXN0b3JlIHRleHR0cmFjayBzZXR0aW5ncyBmcm9tIGxvY2FsU3RvcmFnZVxuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5yZXN0b3JlU2V0dGluZ3MgPSBmdW5jdGlvbiByZXN0b3JlU2V0dGluZ3MoKSB7XG4gICAgdmFyIHZhbHVlcyA9IHZvaWQgMDtcblxuICAgIHRyeSB7XG4gICAgICB2YWx1ZXMgPSBKU09OLnBhcnNlKHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nJDEud2FybihlcnIpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgIHRoaXMuc2V0VmFsdWVzKHZhbHVlcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTYXZlIHRleHQgdHJhY2sgc2V0dGluZ3MgdG8gbG9jYWxTdG9yYWdlXG4gICAqL1xuXG5cbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLnNhdmVTZXR0aW5ncyA9IGZ1bmN0aW9uIHNhdmVTZXR0aW5ncygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9uc18ucGVyc2lzdFRleHRUcmFja1NldHRpbmdzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCk7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkodmFsdWVzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oTE9DQUxfU1RPUkFHRV9LRVkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nJDEud2FybihlcnIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIGRpc3BsYXkgb2YgdGV4dCB0cmFjayBzZXR0aW5nc1xuICAgKi9cblxuXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5ID0gZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICB2YXIgdHREaXNwbGF5ID0gdGhpcy5wbGF5ZXJfLmdldENoaWxkKCd0ZXh0VHJhY2tEaXNwbGF5Jyk7XG5cbiAgICBpZiAodHREaXNwbGF5KSB7XG4gICAgICB0dERpc3BsYXkudXBkYXRlRGlzcGxheSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogY29uZGl0aW9uYWxseSBibHVyIHRoZSBlbGVtZW50IGFuZCByZWZvY3VzIHRoZSBjYXB0aW9ucyBidXR0b25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY29uZGl0aW9uYWxCbHVyXyA9IGZ1bmN0aW9uIGNvbmRpdGlvbmFsQmx1cl8oKSB7XG4gICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfID0gbnVsbDtcbiAgICB0aGlzLm9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuXG4gICAgdmFyIGNiID0gdGhpcy5wbGF5ZXJfLmNvbnRyb2xCYXI7XG4gICAgdmFyIHN1YnNDYXBzQnRuID0gY2IgJiYgY2Iuc3Vic0NhcHNCdXR0b247XG4gICAgdmFyIGNjQnRuID0gY2IgJiYgY2IuY2FwdGlvbnNCdXR0b247XG5cbiAgICBpZiAoc3Vic0NhcHNCdG4pIHtcbiAgICAgIHN1YnNDYXBzQnRuLmZvY3VzKCk7XG4gICAgfSBlbHNlIGlmIChjY0J0bikge1xuICAgICAgY2NCdG4uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRleHRUcmFja1NldHRpbmdzO1xufShNb2RhbERpYWxvZyk7XG5cbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGV4dFRyYWNrU2V0dGluZ3MnLCBUZXh0VHJhY2tTZXR0aW5ncyk7XG5cbnZhciBfdGVtcGxhdGVPYmplY3QkMiA9IHRhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFsnVGV4dCBUcmFja3MgYXJlIGJlaW5nIGxvYWRlZCBmcm9tIGFub3RoZXIgb3JpZ2luIGJ1dCB0aGUgY3Jvc3NvcmlnaW4gYXR0cmlidXRlIGlzblxcJ3QgdXNlZC5cXG4gICAgICAgICAgICBUaGlzIG1heSBwcmV2ZW50IHRleHQgdHJhY2tzIGZyb20gbG9hZGluZy4nXSwgWydUZXh0IFRyYWNrcyBhcmUgYmVpbmcgbG9hZGVkIGZyb20gYW5vdGhlciBvcmlnaW4gYnV0IHRoZSBjcm9zc29yaWdpbiBhdHRyaWJ1dGUgaXNuXFwndCB1c2VkLlxcbiAgICAgICAgICAgIFRoaXMgbWF5IHByZXZlbnQgdGV4dCB0cmFja3MgZnJvbSBsb2FkaW5nLiddKTtcblxuLyoqXG4gKiBAZmlsZSBodG1sNS5qc1xuICovXG4vKipcbiAqIEhUTUw1IE1lZGlhIENvbnRyb2xsZXIgLSBXcmFwcGVyIGZvciBIVE1MNSBNZWRpYSBBUElcbiAqXG4gKiBAbWl4ZXMgVGVjaH5Tb3VjZUhhbmRsZXJBZGRpdGlvbnNcbiAqIEBleHRlbmRzIFRlY2hcbiAqL1xuXG52YXIgSHRtbDUgPSBmdW5jdGlvbiAoX1RlY2gpIHtcbiAgaW5oZXJpdHMoSHRtbDUsIF9UZWNoKTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgVGVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wb25lbnR+UmVhZHlDYWxsYmFja30gcmVhZHlcbiAgICogICAgICAgIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgYEhUTUw1YCBUZWNoIGlzIHJlYWR5LlxuICAgKi9cbiAgZnVuY3Rpb24gSHRtbDUob3B0aW9ucywgcmVhZHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBIdG1sNSk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZWNoLmNhbGwodGhpcywgb3B0aW9ucywgcmVhZHkpKTtcblxuICAgIHZhciBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcbiAgICB2YXIgY3Jvc3NvcmlnaW5UcmFja3MgPSBmYWxzZTtcblxuICAgIC8vIFNldCB0aGUgc291cmNlIGlmIG9uZSBpcyBwcm92aWRlZFxuICAgIC8vIDEpIENoZWNrIGlmIHRoZSBzb3VyY2UgaXMgbmV3IChpZiBub3QsIHdlIHdhbnQgdG8ga2VlcCB0aGUgb3JpZ2luYWwgc28gcGxheWJhY2sgaXNuJ3QgaW50ZXJydXB0ZWQpXG4gICAgLy8gMikgQ2hlY2sgdG8gc2VlIGlmIHRoZSBuZXR3b3JrIHN0YXRlIG9mIHRoZSB0YWcgd2FzIGZhaWxlZCBhdCBpbml0LCBhbmQgaWYgc28sIHJlc2V0IHRoZSBzb3VyY2VcbiAgICAvLyBhbnl3YXkgc28gdGhlIGVycm9yIGdldHMgZmlyZWQuXG4gICAgaWYgKHNvdXJjZSAmJiAoX3RoaXMuZWxfLmN1cnJlbnRTcmMgIT09IHNvdXJjZS5zcmMgfHwgb3B0aW9ucy50YWcgJiYgb3B0aW9ucy50YWcuaW5pdE5ldHdvcmtTdGF0ZV8gPT09IDMpKSB7XG4gICAgICBfdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuaGFuZGxlTGF0ZUluaXRfKF90aGlzLmVsXyk7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLmVsXy5oYXNDaGlsZE5vZGVzKCkpIHtcblxuICAgICAgdmFyIG5vZGVzID0gX3RoaXMuZWxfLmNoaWxkTm9kZXM7XG4gICAgICB2YXIgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgcmVtb3ZlTm9kZXMgPSBbXTtcblxuICAgICAgd2hpbGUgKG5vZGVzTGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tub2Rlc0xlbmd0aF07XG4gICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICd0cmFjaycpIHtcbiAgICAgICAgICBpZiAoIV90aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgICAgICAgLy8gRW1wdHkgdmlkZW8gdGFnIHRyYWNrcyBzbyB0aGUgYnVpbHQtaW4gcGxheWVyIGRvZXNuJ3QgdXNlIHRoZW0gYWxzby5cbiAgICAgICAgICAgIC8vIFRoaXMgbWF5IG5vdCBiZSBmYXN0IGVub3VnaCB0byBzdG9wIEhUTUw1IGJyb3dzZXJzIGZyb20gcmVhZGluZyB0aGUgdGFnc1xuICAgICAgICAgICAgLy8gc28gd2UnbGwgbmVlZCB0byB0dXJuIG9mZiBhbnkgZGVmYXVsdCB0cmFja3MgaWYgd2UncmUgbWFudWFsbHkgZG9pbmdcbiAgICAgICAgICAgIC8vIGNhcHRpb25zIGFuZCBzdWJ0aXRsZXMuIHZpZGVvRWxlbWVudC50ZXh0VHJhY2tzXG4gICAgICAgICAgICByZW1vdmVOb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzdG9yZSBIVE1MVHJhY2tFbGVtZW50IGFuZCBUZXh0VHJhY2sgdG8gcmVtb3RlIGxpc3RcbiAgICAgICAgICAgIF90aGlzLnJlbW90ZVRleHRUcmFja0VscygpLmFkZFRyYWNrRWxlbWVudF8obm9kZSk7XG4gICAgICAgICAgICBfdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkuYWRkVHJhY2sobm9kZS50cmFjayk7XG4gICAgICAgICAgICBfdGhpcy50ZXh0VHJhY2tzKCkuYWRkVHJhY2sobm9kZS50cmFjayk7XG4gICAgICAgICAgICBpZiAoIWNyb3Nzb3JpZ2luVHJhY2tzICYmICFfdGhpcy5lbF8uaGFzQXR0cmlidXRlKCdjcm9zc29yaWdpbicpICYmIGlzQ3Jvc3NPcmlnaW4obm9kZS5zcmMpKSB7XG4gICAgICAgICAgICAgIGNyb3Nzb3JpZ2luVHJhY2tzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdmVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfdGhpcy5lbF8ucmVtb3ZlQ2hpbGQocmVtb3ZlTm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aGlzLnByb3h5TmF0aXZlVHJhY2tzXygpO1xuICAgIGlmIChfdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MgJiYgY3Jvc3NvcmlnaW5UcmFja3MpIHtcbiAgICAgIGxvZyQxLndhcm4odHNtbChfdGVtcGxhdGVPYmplY3QkMikpO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBpZiBuYXRpdmUgY29udHJvbHMgc2hvdWxkIGJlIHVzZWRcbiAgICAvLyBPdXIgZ29hbCBzaG91bGQgYmUgdG8gZ2V0IHRoZSBjdXN0b20gY29udHJvbHMgb24gbW9iaWxlIHNvbGlkIGV2ZXJ5d2hlcmVcbiAgICAvLyBzbyB3ZSBjYW4gcmVtb3ZlIHRoaXMgYWxsIHRvZ2V0aGVyLiBSaWdodCBub3cgdGhpcyB3aWxsIGJsb2NrIGN1c3RvbVxuICAgIC8vIGNvbnRyb2xzIG9uIHRvdWNoIGVuYWJsZWQgbGFwdG9wcyBsaWtlIHRoZSBDaHJvbWUgUGl4ZWxcbiAgICBpZiAoKFRPVUNIX0VOQUJMRUQgfHwgSVNfSVBIT05FIHx8IElTX05BVElWRV9BTkRST0lEKSAmJiBvcHRpb25zLm5hdGl2ZUNvbnRyb2xzRm9yVG91Y2ggPT09IHRydWUpIHtcbiAgICAgIF90aGlzLnNldENvbnRyb2xzKHRydWUpO1xuICAgIH1cblxuICAgIC8vIG9uIGlPUywgd2Ugd2FudCB0byBwcm94eSBgd2Via2l0YmVnaW5mdWxsc2NyZWVuYCBhbmQgYHdlYmtpdGVuZGZ1bGxzY3JlZW5gXG4gICAgLy8gaW50byBhIGBmdWxsc2NyZWVuY2hhbmdlYCBldmVudFxuICAgIF90aGlzLnByb3h5V2Via2l0RnVsbHNjcmVlbl8oKTtcblxuICAgIF90aGlzLnRyaWdnZXJSZWFkeSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIG9mIGBIVE1MNWAgbWVkaWEgZWxlbWVudCBhbmQgcmVtb3ZlIGFsbCB0cmFja3MuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIEh0bWw1LmRpc3Bvc2VNZWRpYUVsZW1lbnQodGhpcy5lbF8pO1xuICAgIC8vIHRlY2ggd2lsbCBoYW5kbGUgY2xlYXJpbmcgb2YgdGhlIGVtdWxhdGVkIHRyYWNrIGxpc3RcbiAgICBfVGVjaC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm94eSBhbGwgbmF0aXZlIHRyYWNrIGxpc3QgZXZlbnRzIHRvIG91ciB0cmFjayBsaXN0cyBpZiB0aGUgYnJvd3NlciB3ZSBhcmUgcGxheWluZ1xuICAgKiBpbiBzdXBwb3J0cyB0aGF0IHR5cGUgb2YgdHJhY2sgbGlzdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUucHJveHlOYXRpdmVUcmFja3NfID0gZnVuY3Rpb24gcHJveHlOYXRpdmVUcmFja3NfKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgTk9STUFMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBwcm9wcyA9IE5PUk1BTFtuYW1lXTtcbiAgICAgIHZhciBlbFRyYWNrcyA9IF90aGlzMi5lbCgpW3Byb3BzLmdldHRlck5hbWVdO1xuICAgICAgdmFyIHRlY2hUcmFja3MgPSBfdGhpczJbcHJvcHMuZ2V0dGVyTmFtZV0oKTtcblxuICAgICAgaWYgKCFfdGhpczJbJ2ZlYXR1cmVzTmF0aXZlJyArIHByb3BzLmNhcGl0YWxOYW1lICsgJ1RyYWNrcyddIHx8ICFlbFRyYWNrcyB8fCAhZWxUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbGlzdGVuZXJzID0ge1xuICAgICAgICBjaGFuZ2U6IGZ1bmN0aW9uIGNoYW5nZShlKSB7XG4gICAgICAgICAgdGVjaFRyYWNrcy50cmlnZ2VyKHtcbiAgICAgICAgICAgIHR5cGU6ICdjaGFuZ2UnLFxuICAgICAgICAgICAgdGFyZ2V0OiB0ZWNoVHJhY2tzLFxuICAgICAgICAgICAgY3VycmVudFRhcmdldDogdGVjaFRyYWNrcyxcbiAgICAgICAgICAgIHNyY0VsZW1lbnQ6IHRlY2hUcmFja3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkdHJhY2s6IGZ1bmN0aW9uIGFkZHRyYWNrKGUpIHtcbiAgICAgICAgICB0ZWNoVHJhY2tzLmFkZFRyYWNrKGUudHJhY2spO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmV0cmFjazogZnVuY3Rpb24gcmVtb3ZldHJhY2soZSkge1xuICAgICAgICAgIHRlY2hUcmFja3MucmVtb3ZlVHJhY2soZS50cmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgcmVtb3ZlT2xkVHJhY2tzID0gZnVuY3Rpb24gcmVtb3ZlT2xkVHJhY2tzKCkge1xuICAgICAgICB2YXIgcmVtb3ZlVHJhY2tzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZWNoVHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsVHJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoZWxUcmFja3Nbal0gPT09IHRlY2hUcmFja3NbaV0pIHtcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICByZW1vdmVUcmFja3MucHVzaCh0ZWNoVHJhY2tzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAocmVtb3ZlVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIHRlY2hUcmFja3MucmVtb3ZlVHJhY2socmVtb3ZlVHJhY2tzLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBPYmplY3Qua2V5cyhsaXN0ZW5lcnMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbZXZlbnROYW1lXTtcblxuICAgICAgICBlbFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICBfdGhpczIub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlbFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZW1vdmUgKG5hdGl2ZSkgdHJhY2tzIHRoYXQgYXJlIG5vdCB1c2VkIGFueW1vcmVcbiAgICAgIF90aGlzMi5vbignbG9hZHN0YXJ0JywgcmVtb3ZlT2xkVHJhY2tzKTtcbiAgICAgIF90aGlzMi5vbignZGlzcG9zZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIub2ZmKCdsb2Fkc3RhcnQnLCByZW1vdmVPbGRUcmFja3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgYEh0bWw1YCBUZWNoJ3MgRE9NIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5vcHRpb25zXy50YWc7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgbW92aW5nIHRoZSBlbGVtZW50IGludG8gdGhlIGJveC5cbiAgICAvLyBPbiB0aGUgaVBob25lIHZpZGVvIHdpbGwgYnJlYWsgaWYgeW91IG1vdmUgdGhlIGVsZW1lbnQsXG4gICAgLy8gU28gd2UgaGF2ZSB0byBjcmVhdGUgYSBicmFuZCBuZXcgZWxlbWVudC5cbiAgICAvLyBJZiB3ZSBpbmdlc3RlZCB0aGUgcGxheWVyIGRpdiwgd2UgZG8gbm90IG5lZWQgdG8gbW92ZSB0aGUgbWVkaWEgZWxlbWVudC5cbiAgICBpZiAoIWVsIHx8ICEodGhpcy5vcHRpb25zXy5wbGF5ZXJFbEluZ2VzdCB8fCB0aGlzLm1vdmluZ01lZGlhRWxlbWVudEluRE9NKSkge1xuXG4gICAgICAvLyBJZiB0aGUgb3JpZ2luYWwgdGFnIGlzIHN0aWxsIHRoZXJlLCBjbG9uZSBhbmQgcmVtb3ZlIGl0LlxuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNsb25lLCBlbCk7XG4gICAgICAgIH1cbiAgICAgICAgSHRtbDUuZGlzcG9zZU1lZGlhRWxlbWVudChlbCk7XG4gICAgICAgIGVsID0gY2xvbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIG5hdGl2ZSBjb250cm9scyBzaG91bGQgYmUgdXNlZFxuICAgICAgICB2YXIgdGFnQXR0cmlidXRlcyA9IHRoaXMub3B0aW9uc18udGFnICYmIGdldEF0dHJpYnV0ZXModGhpcy5vcHRpb25zXy50YWcpO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IG1lcmdlT3B0aW9ucyh7fSwgdGFnQXR0cmlidXRlcyk7XG5cbiAgICAgICAgaWYgKCFUT1VDSF9FTkFCTEVEIHx8IHRoaXMub3B0aW9uc18ubmF0aXZlQ29udHJvbHNGb3JUb3VjaCAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLmNvbnRyb2xzO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0QXR0cmlidXRlcyhlbCwgYXNzaWduKGF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICBpZDogdGhpcy5vcHRpb25zXy50ZWNoSWQsXG4gICAgICAgICAgJ2NsYXNzJzogJ3Zqcy10ZWNoJ1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGVsLnBsYXllcklkID0gdGhpcy5vcHRpb25zXy5wbGF5ZXJJZDtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc3BlY2lmaWMgdGFnIHNldHRpbmdzLCBpbiBjYXNlIHRoZXkgd2VyZSBvdmVycmlkZGVuXG4gICAgdmFyIHNldHRpbmdzQXR0cnMgPSBbJ2F1dG9wbGF5JywgJ3ByZWxvYWQnLCAnbG9vcCcsICdtdXRlZCcsICdwbGF5c2lubGluZSddO1xuXG4gICAgZm9yICh2YXIgaSA9IHNldHRpbmdzQXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhdHRyID0gc2V0dGluZ3NBdHRyc1tpXTtcbiAgICAgIHZhciBvdmVyd3JpdGVBdHRycyA9IHt9O1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc19bYXR0cl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG92ZXJ3cml0ZUF0dHJzW2F0dHJdID0gdGhpcy5vcHRpb25zX1thdHRyXTtcbiAgICAgIH1cbiAgICAgIHNldEF0dHJpYnV0ZXMoZWwsIG92ZXJ3cml0ZUF0dHJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCBiZSB0cmlnZ2VyZWQgaWYgdGhlIGxvYWRzdGFydCBldmVudCBoYXMgYWxyZWFkeSBmaXJlZCwgYmVmb3JlIHZpZGVvanMgd2FzXG4gICAqIHJlYWR5LiBUd28ga25vd24gZXhhbXBsZXMgb2Ygd2hlbiB0aGlzIGNhbiBoYXBwZW4gYXJlOlxuICAgKiAxLiBJZiB3ZSdyZSBsb2FkaW5nIHRoZSBwbGF5YmFjayBvYmplY3QgYWZ0ZXIgaXQgaGFzIHN0YXJ0ZWQgbG9hZGluZ1xuICAgKiAyLiBUaGUgbWVkaWEgaXMgYWxyZWFkeSBwbGF5aW5nIHRoZSAob2Z0ZW4gd2l0aCBhdXRvcGxheSBvbikgdGhlblxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgZmlyZSBhbm90aGVyIGxvYWRzdGFydCBzbyB0aGF0IHZpZGVvanMgY2FuIGNhdGNodXAuXG4gICAqXG4gICAqIEBmaXJlcyBUZWNoI2xvYWRzdGFydFxuICAgKlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqICAgICAgICAgcmV0dXJucyBub3RoaW5nLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5oYW5kbGVMYXRlSW5pdF8gPSBmdW5jdGlvbiBoYW5kbGVMYXRlSW5pdF8oZWwpIHtcbiAgICBpZiAoZWwubmV0d29ya1N0YXRlID09PSAwIHx8IGVsLm5ldHdvcmtTdGF0ZSA9PT0gMykge1xuICAgICAgLy8gVGhlIHZpZGVvIGVsZW1lbnQgaGFzbid0IHN0YXJ0ZWQgbG9hZGluZyB0aGUgc291cmNlIHlldFxuICAgICAgLy8gb3IgZGlkbid0IGZpbmQgYSBzb3VyY2VcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWwucmVhZHlTdGF0ZSA9PT0gMCkge1xuICAgICAgLy8gTmV0d29ya1N0YXRlIGlzIHNldCBzeW5jaHJvbm91c2x5IEJVVCBsb2Fkc3RhcnQgaXMgZmlyZWQgYXQgdGhlXG4gICAgICAvLyBlbmQgb2YgdGhlIGN1cnJlbnQgc3RhY2ssIHVzdWFsbHkgYmVmb3JlIHNldEludGVydmFsKGZuLCAwKS5cbiAgICAgIC8vIFNvIGF0IHRoaXMgcG9pbnQgd2Uga25vdyBsb2Fkc3RhcnQgbWF5IGhhdmUgYWxyZWFkeSBmaXJlZCBvciBpc1xuICAgICAgLy8gYWJvdXQgdG8gZmlyZSwgYW5kIGVpdGhlciB3YXkgdGhlIHBsYXllciBoYXNuJ3Qgc2VlbiBpdCB5ZXQuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGZpcmUgbG9hZHN0YXJ0IHByZW1hdHVyZWx5IGhlcmUgYW5kIGNhdXNlIGFcbiAgICAgIC8vIGRvdWJsZSBsb2Fkc3RhcnQgc28gd2UnbGwgd2FpdCBhbmQgc2VlIGlmIGl0IGhhcHBlbnMgYmV0d2VlbiBub3dcbiAgICAgIC8vIGFuZCB0aGUgbmV4dCBsb29wLCBhbmQgZmlyZSBpdCBpZiBub3QuXG4gICAgICAvLyBIT1dFVkVSLCB3ZSBhbHNvIHdhbnQgdG8gbWFrZSBzdXJlIGl0IGZpcmVzIGJlZm9yZSBsb2FkZWRtZXRhZGF0YVxuICAgICAgLy8gd2hpY2ggY291bGQgYWxzbyBoYXBwZW4gYmV0d2VlbiBub3cgYW5kIHRoZSBuZXh0IGxvb3AsIHNvIHdlJ2xsXG4gICAgICAvLyB3YXRjaCBmb3IgdGhhdCBhbHNvLlxuICAgICAgdmFyIGxvYWRzdGFydEZpcmVkID0gZmFsc2U7XG4gICAgICB2YXIgc2V0TG9hZHN0YXJ0RmlyZWQgPSBmdW5jdGlvbiBzZXRMb2Fkc3RhcnRGaXJlZCgpIHtcbiAgICAgICAgbG9hZHN0YXJ0RmlyZWQgPSB0cnVlO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5vbignbG9hZHN0YXJ0Jywgc2V0TG9hZHN0YXJ0RmlyZWQpO1xuXG4gICAgICB2YXIgdHJpZ2dlckxvYWRzdGFydCA9IGZ1bmN0aW9uIHRyaWdnZXJMb2Fkc3RhcnQoKSB7XG4gICAgICAgIC8vIFdlIGRpZCBtaXNzIHRoZSBvcmlnaW5hbCBsb2Fkc3RhcnQuIE1ha2Ugc3VyZSB0aGUgcGxheWVyXG4gICAgICAgIC8vIHNlZXMgbG9hZHN0YXJ0IGJlZm9yZSBsb2FkZWRtZXRhZGF0YVxuICAgICAgICBpZiAoIWxvYWRzdGFydEZpcmVkKSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vbignbG9hZGVkbWV0YWRhdGEnLCB0cmlnZ2VyTG9hZHN0YXJ0KTtcblxuICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub2ZmKCdsb2Fkc3RhcnQnLCBzZXRMb2Fkc3RhcnRGaXJlZCk7XG4gICAgICAgIHRoaXMub2ZmKCdsb2FkZWRtZXRhZGF0YScsIHRyaWdnZXJMb2Fkc3RhcnQpO1xuXG4gICAgICAgIGlmICghbG9hZHN0YXJ0RmlyZWQpIHtcbiAgICAgICAgICAvLyBXZSBkaWQgbWlzcyB0aGUgb3JpZ2luYWwgbmF0aXZlIGxvYWRzdGFydC4gRmlyZSBpdCBub3cuXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGcm9tIGhlcmUgb24gd2Uga25vdyB0aGF0IGxvYWRzdGFydCBhbHJlYWR5IGZpcmVkIGFuZCB3ZSBtaXNzZWQgaXQuXG4gICAgLy8gVGhlIG90aGVyIHJlYWR5U3RhdGUgZXZlbnRzIGFyZW4ndCBhcyBtdWNoIG9mIGEgcHJvYmxlbSBpZiB3ZSBkb3VibGVcbiAgICAvLyB0aGVtLCBzbyBub3QgZ29pbmcgdG8gZ28gdG8gYXMgbXVjaCB0cm91YmxlIGFzIGxvYWRzdGFydCB0byBwcmV2ZW50XG4gICAgLy8gdGhhdCB1bmxlc3Mgd2UgZmluZCByZWFzb24gdG8uXG4gICAgdmFyIGV2ZW50c1RvVHJpZ2dlciA9IFsnbG9hZHN0YXJ0J107XG5cbiAgICAvLyBsb2FkZWRtZXRhZGF0YTogbmV3bHkgZXF1YWwgdG8gSEFWRV9NRVRBREFUQSAoMSkgb3IgZ3JlYXRlclxuICAgIGV2ZW50c1RvVHJpZ2dlci5wdXNoKCdsb2FkZWRtZXRhZGF0YScpO1xuXG4gICAgLy8gbG9hZGVkZGF0YTogbmV3bHkgaW5jcmVhc2VkIHRvIEhBVkVfQ1VSUkVOVF9EQVRBICgyKSBvciBncmVhdGVyXG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgZXZlbnRzVG9UcmlnZ2VyLnB1c2goJ2xvYWRlZGRhdGEnKTtcbiAgICB9XG5cbiAgICAvLyBjYW5wbGF5OiBuZXdseSBpbmNyZWFzZWQgdG8gSEFWRV9GVVRVUkVfREFUQSAoMykgb3IgZ3JlYXRlclxuICAgIGlmIChlbC5yZWFkeVN0YXRlID49IDMpIHtcbiAgICAgIGV2ZW50c1RvVHJpZ2dlci5wdXNoKCdjYW5wbGF5Jyk7XG4gICAgfVxuXG4gICAgLy8gY2FucGxheXRocm91Z2g6IG5ld2x5IGVxdWFsIHRvIEhBVkVfRU5PVUdIX0RBVEEgKDQpXG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPj0gNCkge1xuICAgICAgZXZlbnRzVG9UcmlnZ2VyLnB1c2goJ2NhbnBsYXl0aHJvdWdoJyk7XG4gICAgfVxuXG4gICAgLy8gV2Ugc3RpbGwgbmVlZCB0byBnaXZlIHRoZSBwbGF5ZXIgdGltZSB0byBhZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICBldmVudHNUb1RyaWdnZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0aGlzLnRyaWdnZXIodHlwZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGN1cnJlbnQgdGltZSBmb3IgdGhlIGBIVE1MNWAgdGVjaC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHNcbiAgICogICAgICAgIFNldCB0aGUgY3VycmVudCB0aW1lIG9mIHRoZSBtZWRpYSB0byB0aGlzLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5zZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uIHNldEN1cnJlbnRUaW1lKHNlY29uZHMpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbF8uY3VycmVudFRpbWUgPSBzZWNvbmRzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZyQxKGUsICdWaWRlbyBpcyBub3QgcmVhZHkuIChWaWRlby5qcyknKTtcbiAgICAgIC8vIHRoaXMud2FybmluZyhWaWRlb0pTLndhcm5pbmdzLnZpZGVvTm90UmVhZHkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGR1cmF0aW9uIG9mIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBtZWRpYSBvciAwIGlmIHRoZXJlIGlzIG5vIGR1cmF0aW9uLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uIGR1cmF0aW9uKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgLy8gQW5kcm9pZCBDaHJvbWUgd2lsbCByZXBvcnQgZHVyYXRpb24gYXMgSW5maW5pdHkgZm9yIFZPRCBITFMgdW50aWwgYWZ0ZXJcbiAgICAvLyBwbGF5YmFjayBoYXMgc3RhcnRlZCwgd2hpY2ggdHJpZ2dlcnMgdGhlIGxpdmUgZGlzcGxheSBlcnJvbmVvdXNseS5cbiAgICAvLyBSZXR1cm4gTmFOIGlmIHBsYXliYWNrIGhhcyBub3Qgc3RhcnRlZCBhbmQgdHJpZ2dlciBhIGR1cmF0aW9udXBkYXRlIG9uY2VcbiAgICAvLyB0aGUgZHVyYXRpb24gY2FuIGJlIHJlbGlhYmx5IGtub3duLlxuICAgIGlmICh0aGlzLmVsXy5kdXJhdGlvbiA9PT0gSW5maW5pdHkgJiYgSVNfQU5EUk9JRCAmJiBJU19DSFJPTUUgJiYgdGhpcy5lbF8uY3VycmVudFRpbWUgPT09IDApIHtcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBmaXJzdCBgdGltZXVwZGF0ZWAgd2l0aCBjdXJyZW50VGltZSA+IDAgLSB0aGVyZSBtYXkgYmVcbiAgICAgIC8vIHNldmVyYWwgd2l0aCAwXG4gICAgICB2YXIgY2hlY2tQcm9ncmVzcyA9IGZ1bmN0aW9uIGNoZWNrUHJvZ3Jlc3MoKSB7XG4gICAgICAgIGlmIChfdGhpczMuZWxfLmN1cnJlbnRUaW1lID4gMCkge1xuICAgICAgICAgIC8vIFRyaWdnZXIgZHVyYXRpb25jaGFuZ2UgZm9yIGdlbnVpbmVseSBsaXZlIHZpZGVvXG4gICAgICAgICAgaWYgKF90aGlzMy5lbF8uZHVyYXRpb24gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICBfdGhpczMudHJpZ2dlcignZHVyYXRpb25jaGFuZ2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMzLm9mZigndGltZXVwZGF0ZScsIGNoZWNrUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9uKCd0aW1ldXBkYXRlJywgY2hlY2tQcm9ncmVzcyk7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbF8uZHVyYXRpb24gfHwgTmFOO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIEhUTUw1IG1lZGlhIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgd2lkdGggb2YgdGhlIEhUTUw1IG1lZGlhIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfLm9mZnNldFdpZHRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGhlaWd0aCBvZiB0aGUgSFRNTDUgbWVkaWEgZWxlbWVudC5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmVsXy5vZmZzZXRIZWlnaHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3h5IGlPUyBgd2Via2l0YmVnaW5mdWxsc2NyZWVuYCBhbmQgYHdlYmtpdGVuZGZ1bGxzY3JlZW5gIGludG9cbiAgICogYGZ1bGxzY3JlZW5jaGFuZ2VgIGV2ZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZmlyZXMgZnVsbHNjcmVlbmNoYW5nZVxuICAgKiBAbGlzdGVucyB3ZWJraXRlbmRmdWxsc2NyZWVuXG4gICAqIEBsaXN0ZW5zIHdlYmtpdGJlZ2luZnVsbHNjcmVlblxuICAgKiBAbGlzdGVucyB3ZWJraXRiZWdpbmZ1bGxzY3JlZW5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUucHJveHlXZWJraXRGdWxsc2NyZWVuXyA9IGZ1bmN0aW9uIHByb3h5V2Via2l0RnVsbHNjcmVlbl8oKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAoISgnd2Via2l0RGlzcGxheWluZ0Z1bGxzY3JlZW4nIGluIHRoaXMuZWxfKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbmRGbiA9IGZ1bmN0aW9uIGVuZEZuKCkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJywgeyBpc0Z1bGxzY3JlZW46IGZhbHNlIH0pO1xuICAgIH07XG5cbiAgICB2YXIgYmVnaW5GbiA9IGZ1bmN0aW9uIGJlZ2luRm4oKSB7XG4gICAgICBpZiAoJ3dlYmtpdFByZXNlbnRhdGlvbk1vZGUnIGluIHRoaXMuZWxfICYmIHRoaXMuZWxfLndlYmtpdFByZXNlbnRhdGlvbk1vZGUgIT09ICdwaWN0dXJlLWluLXBpY3R1cmUnKSB7XG4gICAgICAgIHRoaXMub25lKCd3ZWJraXRlbmRmdWxsc2NyZWVuJywgZW5kRm4pO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScsIHsgaXNGdWxsc2NyZWVuOiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uKCd3ZWJraXRiZWdpbmZ1bGxzY3JlZW4nLCBiZWdpbkZuKTtcbiAgICB0aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXM0Lm9mZignd2Via2l0YmVnaW5mdWxsc2NyZWVuJywgYmVnaW5Gbik7XG4gICAgICBfdGhpczQub2ZmKCd3ZWJraXRlbmRmdWxsc2NyZWVuJywgZW5kRm4pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBmdWxsc2NyZWVuIGlzIHN1cHBvcnRlZCBvbiB0aGUgY3VycmVudCBwbGF5YmFjayBkZXZpY2UuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSBUcnVlIGlmIGZ1bGxzY3JlZW4gaXMgc3VwcG9ydGVkLlxuICAgKiAgICAgICAgIC0gRmFsc2UgaWYgZnVsbHNjcmVlbiBpcyBub3Qgc3VwcG9ydGVkLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5zdXBwb3J0c0Z1bGxTY3JlZW4gPSBmdW5jdGlvbiBzdXBwb3J0c0Z1bGxTY3JlZW4oKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmVsXy53ZWJraXRFbnRlckZ1bGxTY3JlZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xuXG4gICAgICAvLyBTZWVtcyB0byBiZSBicm9rZW4gaW4gQ2hyb21pdW0vQ2hyb21lICYmIFNhZmFyaSBpbiBMZW9wYXJkXG4gICAgICBpZiAoL0FuZHJvaWQvLnRlc3QodXNlckFnZW50KSB8fCAhL0Nocm9tZXxNYWMgT1MgWCAxMC41Ly50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVxdWVzdCB0aGF0IHRoZSBgSFRNTDVgIFRlY2ggZW50ZXIgZnVsbHNjcmVlbi5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuZW50ZXJGdWxsU2NyZWVuID0gZnVuY3Rpb24gZW50ZXJGdWxsU2NyZWVuKCkge1xuICAgIHZhciB2aWRlbyA9IHRoaXMuZWxfO1xuXG4gICAgaWYgKHZpZGVvLnBhdXNlZCAmJiB2aWRlby5uZXR3b3JrU3RhdGUgPD0gdmlkZW8uSEFWRV9NRVRBREFUQSkge1xuICAgICAgLy8gYXR0ZW1wdCB0byBwcmltZSB0aGUgdmlkZW8gZWxlbWVudCBmb3IgcHJvZ3JhbW1hdGljIGFjY2Vzc1xuICAgICAgLy8gdGhpcyBpc24ndCBuZWNlc3Nhcnkgb24gdGhlIGRlc2t0b3AgYnV0IHNob3VsZG4ndCBodXJ0XG4gICAgICB0aGlzLmVsXy5wbGF5KCk7XG5cbiAgICAgIC8vIHBsYXlpbmcgYW5kIHBhdXNpbmcgc3luY2hyb25vdXNseSBkdXJpbmcgdGhlIHRyYW5zaXRpb24gdG8gZnVsbHNjcmVlblxuICAgICAgLy8gY2FuIGdldCBpT1MgfjYuMSBkZXZpY2VzIGludG8gYSBwbGF5L3BhdXNlIGxvb3BcbiAgICAgIHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZpZGVvLnBhdXNlKCk7XG4gICAgICAgIHZpZGVvLndlYmtpdEVudGVyRnVsbFNjcmVlbigpO1xuICAgICAgfSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvLndlYmtpdEVudGVyRnVsbFNjcmVlbigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVxdWVzdCB0aGF0IHRoZSBgSFRNTDVgIFRlY2ggZXhpdCBmdWxsc2NyZWVuLlxuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5leGl0RnVsbFNjcmVlbiA9IGZ1bmN0aW9uIGV4aXRGdWxsU2NyZWVuKCkge1xuICAgIHRoaXMuZWxfLndlYmtpdEV4aXRGdWxsU2NyZWVuKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBIdG1sNWAgVGVjaCdzIHNvdXJjZSBvYmplY3QuXG4gICAqID4gTm90ZTogUGxlYXNlIHVzZSB7QGxpbmsgSHRtbDUjc2V0U291cmNlfVxuICAgKlxuICAgKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBbc3JjXVxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3QgeW91IHdhbnQgdG8gc2V0IG9uIHRoZSBgSFRNTDVgIHRlY2hzIGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge1RlY2h+U291cmNlT2JqZWN0fHVuZGVmaW5lZH1cbiAgICogICAgICAgICAtIFRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3Qgd2hlbiBhIHNvdXJjZSBpcyBub3QgcGFzc2VkIGluLlxuICAgKiAgICAgICAgIC0gdW5kZWZpbmVkIHdoZW4gc2V0dGluZ1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBTaW5jZSB2ZXJzaW9uIDUuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uIHNyYyhfc3JjKSB7XG4gICAgaWYgKF9zcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxfLnNyYztcbiAgICB9XG5cbiAgICAvLyBTZXR0aW5nIHNyYyB0aHJvdWdoIGBzcmNgIGluc3RlYWQgb2YgYHNldFNyY2Agd2lsbCBiZSBkZXByZWNhdGVkXG4gICAgdGhpcy5zZXRTcmMoX3NyYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSB0ZWNoIGJ5IHJlbW92aW5nIGFsbCBzb3VyY2VzIGFuZCB0aGVuIGNhbGxpbmdcbiAgICoge0BsaW5rIEh0bWw1LnJlc2V0TWVkaWFFbGVtZW50fS5cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBIdG1sNS5yZXNldE1lZGlhRWxlbWVudCh0aGlzLmVsXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzb3VyY2Ugb24gdGhlIGBIVE1MNWAgVGVjaC4gRmFsbHMgYmFjayB0byByZXR1cm5pbmcgdGhlIHNvdXJjZSBmcm9tXG4gICAqIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0IGZyb20gdGhlIEhUTUw1IHRlY2guIFdpdGggYSBmYWxsYmFjayB0byB0aGVcbiAgICogICAgICAgICBlbGVtZW50cyBzb3VyY2UuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmN1cnJlbnRTcmMgPSBmdW5jdGlvbiBjdXJyZW50U3JjKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTb3VyY2VfKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50U291cmNlXy5zcmM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVsXy5jdXJyZW50U3JjO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgY29udHJvbHMgYXR0cmlidXRlIGZvciB0aGUgSFRNTDUgbWVkaWEgRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICAgKiAgICAgICAgVmFsdWUgdG8gc2V0IHRoZSBjb250cm9scyBhdHRyaWJ1dGUgdG9cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuc2V0Q29udHJvbHMgPSBmdW5jdGlvbiBzZXRDb250cm9scyh2YWwpIHtcbiAgICB0aGlzLmVsXy5jb250cm9scyA9ICEhdmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJldHVybnMgYSByZW1vdGUge0BsaW5rIFRleHRUcmFja30gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2luZFxuICAgKiAgICAgICAgYFRleHRUcmFja2Aga2luZCAoc3VidGl0bGVzLCBjYXB0aW9ucywgZGVzY3JpcHRpb25zLCBjaGFwdGVycywgb3IgbWV0YWRhdGEpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdXG4gICAqICAgICAgICBMYWJlbCB0byBpZGVudGlmeSB0aGUgdGV4dCB0cmFja1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlXVxuICAgKiAgICAgICAgVHdvIGxldHRlciBsYW5ndWFnZSBhYmJyZXZpYXRpb25cbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrfVxuICAgKiAgICAgICAgIFRoZSBUZXh0VHJhY2sgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmFkZFRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XG4gICAgICByZXR1cm4gX1RlY2gucHJvdG90eXBlLmFkZFRleHRUcmFjay5jYWxsKHRoaXMsIGtpbmQsIGxhYmVsLCBsYW5ndWFnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZWxfLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGVpdGhlciBuYXRpdmUgVGV4dFRyYWNrIG9yIGFuIGVtdWxhdGVkIFRleHRUcmFjayBkZXBlbmRpbmdcbiAgICogb24gdGhlIHZhbHVlIG9mIGBmZWF0dXJlc05hdGl2ZVRleHRUcmFja3NgXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgICAgICBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIHRoZSBvcHRpb25zIHRvIGludGlhbGl6ZSB0aGUgVGV4dFRyYWNrIHdpdGguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5raW5kXVxuICAgKiAgICAgICAgYFRleHRUcmFja2Aga2luZCAoc3VidGl0bGVzLCBjYXB0aW9ucywgZGVzY3JpcHRpb25zLCBjaGFwdGVycywgb3IgbWV0YWRhdGEpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWxdLlxuICAgKiAgICAgICAgTGFiZWwgdG8gaWRlbnRpZnkgdGhlIHRleHQgdHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlXVxuICAgKiAgICAgICAgVHdvIGxldHRlciBsYW5ndWFnZSBhYmJyZXZpYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVmYXVsdF1cbiAgICogICAgICAgIERlZmF1bHQgdGhpcyB0cmFjayB0byBvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkXVxuICAgKiAgICAgICAgVGhlIGludGVybmFsIGlkIHRvIGFzc2lnbiB0aGlzIHRyYWNrLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3JjXVxuICAgKiAgICAgICAgQSBzb3VyY2UgdXJsIGZvciB0aGUgdHJhY2suXG4gICAqXG4gICAqIEByZXR1cm4ge0hUTUxUcmFja0VsZW1lbnR9XG4gICAqICAgICAgICAgVGhlIHRyYWNrIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmNyZWF0ZVJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGNyZWF0ZVJlbW90ZVRleHRUcmFjayhvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xuICAgICAgcmV0dXJuIF9UZWNoLnByb3RvdHlwZS5jcmVhdGVSZW1vdGVUZXh0VHJhY2suY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdmFyIGh0bWxUcmFja0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cmFjaycpO1xuXG4gICAgaWYgKG9wdGlvbnMua2luZCkge1xuICAgICAgaHRtbFRyYWNrRWxlbWVudC5raW5kID0gb3B0aW9ucy5raW5kO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sYWJlbCkge1xuICAgICAgaHRtbFRyYWNrRWxlbWVudC5sYWJlbCA9IG9wdGlvbnMubGFiZWw7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxhbmd1YWdlIHx8IG9wdGlvbnMuc3JjbGFuZykge1xuICAgICAgaHRtbFRyYWNrRWxlbWVudC5zcmNsYW5nID0gb3B0aW9ucy5sYW5ndWFnZSB8fCBvcHRpb25zLnNyY2xhbmc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zWydkZWZhdWx0J10pIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnRbJ2RlZmF1bHQnXSA9IG9wdGlvbnNbJ2RlZmF1bHQnXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQuaWQgPSBvcHRpb25zLmlkO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zcmMpIHtcbiAgICAgIGh0bWxUcmFja0VsZW1lbnQuc3JjID0gb3B0aW9ucy5zcmM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWxUcmFja0VsZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZW1vdGUgdGV4dCB0cmFjayBvYmplY3QgYW5kIHJldHVybnMgYW4gaHRtbCB0cmFjayBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIHZhbHVlcyBmb3JcbiAgICoga2luZCwgbGFuZ3VhZ2UsIGxhYmVsLCBhbmQgc3JjIChsb2NhdGlvbiBvZiB0aGUgV2ViVlRUIGZpbGUpXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hbnVhbENsZWFudXA9dHJ1ZV0gaWYgc2V0IHRvIGZhbHNlLCB0aGUgVGV4dFRyYWNrIHdpbGwgYmVcbiAgICogYXV0b21hdGljYWxseSByZW1vdmVkIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQgd2hlbmV2ZXIgdGhlIHNvdXJjZSBjaGFuZ2VzXG4gICAqIEByZXR1cm4ge0hUTUxUcmFja0VsZW1lbnR9IEFuIEh0bWwgVHJhY2sgRWxlbWVudC5cbiAgICogVGhpcyBjYW4gYmUgYW4gZW11bGF0ZWQge0BsaW5rIEhUTUxUcmFja0VsZW1lbnR9IG9yIGEgbmF0aXZlIG9uZS5cbiAgICogQGRlcHJlY2F0ZWQgVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIFwibWFudWFsQ2xlYW51cFwiIHBhcmFtZXRlciB3aWxsIGRlZmF1bHRcbiAgICogdG8gXCJmYWxzZVwiIGluIHVwY29taW5nIHZlcnNpb25zIG9mIFZpZGVvLmpzXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLmFkZFJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFJlbW90ZVRleHRUcmFjayhvcHRpb25zLCBtYW51YWxDbGVhbnVwKSB7XG4gICAgdmFyIGh0bWxUcmFja0VsZW1lbnQgPSBfVGVjaC5wcm90b3R5cGUuYWRkUmVtb3RlVGV4dFRyYWNrLmNhbGwodGhpcywgb3B0aW9ucywgbWFudWFsQ2xlYW51cCk7XG5cbiAgICBpZiAodGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgIHRoaXMuZWwoKS5hcHBlbmRDaGlsZChodG1sVHJhY2tFbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbFRyYWNrRWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHJlbW90ZSBgVGV4dFRyYWNrYCBmcm9tIGBUZXh0VHJhY2tMaXN0YCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t9IHRyYWNrXG4gICAqICAgICAgICBgVGV4dFRyYWNrYCBvYmplY3QgdG8gcmVtb3ZlXG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnJlbW92ZVJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjaykge1xuICAgIF9UZWNoLnByb3RvdHlwZS5yZW1vdmVSZW1vdGVUZXh0VHJhY2suY2FsbCh0aGlzLCB0cmFjayk7XG5cbiAgICBpZiAodGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcbiAgICAgIHZhciB0cmFja3MgPSB0aGlzLiQkKCd0cmFjaycpO1xuXG4gICAgICB2YXIgaSA9IHRyYWNrcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKHRyYWNrID09PSB0cmFja3NbaV0gfHwgdHJhY2sgPT09IHRyYWNrc1tpXS50cmFjaykge1xuICAgICAgICAgIHRoaXMuZWwoKS5yZW1vdmVDaGlsZCh0cmFja3NbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIGBwbGF5c2lubGluZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHBsYXlzaW5saW5lYCBpbmRpY2F0ZXNcbiAgICogdG8gdGhlIGJyb3dzZXIgdGhhdCBub24tZnVsbHNjcmVlbiBwbGF5YmFjayBpcyBwcmVmZXJyZWQgd2hlbiBmdWxsc2NyZWVuXG4gICAqIHBsYXliYWNrIGlzIHRoZSBuYXRpdmUgZGVmYXVsdCwgc3VjaCBhcyBpbiBpT1MgU2FmYXJpLlxuICAgKlxuICAgKiBAbWV0aG9kIEh0bWw1I3BsYXlzaW5saW5lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYHBsYXlzaW5saW5lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICAgKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHBsYXkgaW5saW5lLlxuICAgKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBub3QgcGxheSBpbmxpbmUuXG4gICAqXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2F0dHItdmlkZW8tcGxheXNpbmxpbmV9XG4gICAqL1xuXG5cbiAgSHRtbDUucHJvdG90eXBlLnBsYXlzaW5saW5lID0gZnVuY3Rpb24gcGxheXNpbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxfLmhhc0F0dHJpYnV0ZSgncGxheXNpbmxpbmUnKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB2YWx1ZSBvZiBgcGxheXNpbmxpbmVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwbGF5c2lubGluZWAgaW5kaWNhdGVzXG4gICAqIHRvIHRoZSBicm93c2VyIHRoYXQgbm9uLWZ1bGxzY3JlZW4gcGxheWJhY2sgaXMgcHJlZmVycmVkIHdoZW4gZnVsbHNjcmVlblxuICAgKiBwbGF5YmFjayBpcyB0aGUgbmF0aXZlIGRlZmF1bHQsIHN1Y2ggYXMgaW4gaU9TIFNhZmFyaS5cbiAgICpcbiAgICogQG1ldGhvZCBIdG1sNSNzZXRQbGF5c2lubGluZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBsYXlzaW5saW5lXG4gICAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgcGxheSBpbmxpbmUuXG4gICAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBwbGF5IGlubGluZS5cbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jYXR0ci12aWRlby1wbGF5c2lubGluZX1cbiAgICovXG5cblxuICBIdG1sNS5wcm90b3R5cGUuc2V0UGxheXNpbmxpbmUgPSBmdW5jdGlvbiBzZXRQbGF5c2lubGluZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICdwbGF5c2lubGluZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsXy5yZW1vdmVBdHRyaWJ1dGUoJ3BsYXlzaW5saW5lJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGF2YWlsYWJsZSBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBXM0MncyBNZWRpYVxuICAgKiBQbGF5YmFjayBRdWFsaXR5IEFQSS5cbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9tZWRpYS1wbGF5YmFjay1xdWFsaXR5fVxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgQW4gb2JqZWN0IHdpdGggc3VwcG9ydGVkIG1lZGlhIHBsYXliYWNrIHF1YWxpdHkgbWV0cmljc1xuICAgKi9cblxuXG4gIEh0bWw1LnByb3RvdHlwZS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9IGZ1bmN0aW9uIGdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5lbCgpLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbCgpLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7XG4gICAgfVxuXG4gICAgdmFyIHZpZGVvUGxheWJhY2tRdWFsaXR5ID0ge307XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuZWwoKS53ZWJraXREcm9wcGVkRnJhbWVDb3VudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRoaXMuZWwoKS53ZWJraXREZWNvZGVkRnJhbWVDb3VudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5LmRyb3BwZWRWaWRlb0ZyYW1lcyA9IHRoaXMuZWwoKS53ZWJraXREcm9wcGVkRnJhbWVDb3VudDtcbiAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMgPSB0aGlzLmVsKCkud2Via2l0RGVjb2RlZEZyYW1lQ291bnQ7XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB0eXBlb2Ygd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmlkZW9QbGF5YmFja1F1YWxpdHkuY3JlYXRpb25UaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH0gZWxzZSBpZiAod2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS50aW1pbmcgJiYgdHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgdmlkZW9QbGF5YmFja1F1YWxpdHkuY3JlYXRpb25UaW1lID0gd2luZG93LkRhdGUubm93KCkgLSB3aW5kb3cucGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlkZW9QbGF5YmFja1F1YWxpdHk7XG4gIH07XG5cbiAgcmV0dXJuIEh0bWw1O1xufShUZWNoKTtcblxuLyogSFRNTDUgU3VwcG9ydCBUZXN0aW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuaWYgKGlzUmVhbCgpKSB7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgZm9yIHRlc3RpbmcgYnJvd3NlciBIVE1MNSBtZWRpYSBjYXBhYmlsaXRpZXNcbiAgICpcbiAgICogQHR5cGUge0VsZW1lbnR9XG4gICAqIEBjb25zdGFudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSHRtbDUuVEVTVF9WSUQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICB2YXIgdHJhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cmFjaycpO1xuXG4gIHRyYWNrLmtpbmQgPSAnY2FwdGlvbnMnO1xuICB0cmFjay5zcmNsYW5nID0gJ2VuJztcbiAgdHJhY2subGFiZWwgPSAnRW5nbGlzaCc7XG4gIEh0bWw1LlRFU1RfVklELmFwcGVuZENoaWxkKHRyYWNrKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBIVE1MNSBtZWRpYSBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyL2RldmljZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRydWUgaWYgSFRNTDUgbWVkaWEgaXMgc3VwcG9ydGVkLlxuICogICAgICAgICAtIEZhbHNlIGlmIEhUTUw1IG1lZGlhIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKi9cbkh0bWw1LmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAvLyBJRTkgd2l0aCBubyBNZWRpYSBQbGF5ZXIgaXMgYSBMSUFSISAoIzk4NClcbiAgdHJ5IHtcbiAgICBIdG1sNS5URVNUX1ZJRC52b2x1bWUgPSAwLjU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gISEoSHRtbDUuVEVTVF9WSUQgJiYgSHRtbDUuVEVTVF9WSUQuY2FuUGxheVR5cGUpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gdHlwZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gKi9cbkh0bWw1LmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgcmV0dXJuIEh0bWw1LlRFU1RfVklELmNhblBsYXlUeXBlKHR5cGUpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gc291cmNlXG4gKiBAcGFyYW0ge09iamVjdH0gc3JjT2JqXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSB0ZWNoXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXG4gKi9cbkh0bWw1LmNhblBsYXlTb3VyY2UgPSBmdW5jdGlvbiAoc3JjT2JqLCBvcHRpb25zKSB7XG4gIHJldHVybiBIdG1sNS5jYW5QbGF5VHlwZShzcmNPYmoudHlwZSk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB2b2x1bWUgY2FuIGJlIGNoYW5nZWQgaW4gdGhpcyBicm93c2VyL2RldmljZS5cbiAqIFZvbHVtZSBjYW5ub3QgYmUgY2hhbmdlZCBpbiBhIGxvdCBvZiBtb2JpbGUgZGV2aWNlcy5cbiAqIFNwZWNpZmljYWxseSwgaXQgY2FuJ3QgYmUgY2hhbmdlZCBmcm9tIDEgb24gaU9TLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiB2b2x1bWUgY2FuIGJlIGNvbnRyb2xsZWRcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuY2FuQ29udHJvbFZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gSUUgd2lsbCBlcnJvciBpZiBXaW5kb3dzIE1lZGlhIFBsYXllciBub3QgaW5zdGFsbGVkICMzMzE1XG4gIHRyeSB7XG4gICAgdmFyIHZvbHVtZSA9IEh0bWw1LlRFU1RfVklELnZvbHVtZTtcblxuICAgIEh0bWw1LlRFU1RfVklELnZvbHVtZSA9IHZvbHVtZSAvIDIgKyAwLjE7XG4gICAgcmV0dXJuIHZvbHVtZSAhPT0gSHRtbDUuVEVTVF9WSUQudm9sdW1lO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBwbGF5YmFjayByYXRlIGNhbiBiZSBjaGFuZ2VkIGluIHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIHBsYXliYWNrIHJhdGUgY2FuIGJlIGNvbnRyb2xsZWRcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuY2FuQ29udHJvbFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUGxheWJhY2sgcmF0ZSBBUEkgaXMgaW1wbGVtZW50ZWQgaW4gQW5kcm9pZCBDaHJvbWUsIGJ1dCBkb2Vzbid0IGRvIGFueXRoaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8zMTgwXG4gIGlmIChJU19BTkRST0lEICYmIElTX0NIUk9NRSAmJiBDSFJPTUVfVkVSU0lPTiA8IDU4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIElFIHdpbGwgZXJyb3IgaWYgV2luZG93cyBNZWRpYSBQbGF5ZXIgbm90IGluc3RhbGxlZCAjMzMxNVxuICB0cnkge1xuICAgIHZhciBwbGF5YmFja1JhdGUgPSBIdG1sNS5URVNUX1ZJRC5wbGF5YmFja1JhdGU7XG5cbiAgICBIdG1sNS5URVNUX1ZJRC5wbGF5YmFja1JhdGUgPSBwbGF5YmFja1JhdGUgLyAyICsgMC4xO1xuICAgIHJldHVybiBwbGF5YmFja1JhdGUgIT09IEh0bWw1LlRFU1RfVklELnBsYXliYWNrUmF0ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayB0byBzZWUgaWYgbmF0aXZlIGBUZXh0VHJhY2tgcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2UuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUcnVlIGlmIG5hdGl2ZSBgVGV4dFRyYWNrYHMgYXJlIHN1cHBvcnRlZC5cbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuc3VwcG9ydHNOYXRpdmVUZXh0VHJhY2tzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gSVNfQU5ZX1NBRkFSSTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIG5hdGl2ZSBgVmlkZW9UcmFja2BzIGFyZSBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyL2RldmljZVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgLSBUcnVlIGlmIG5hdGl2ZSBgVmlkZW9UcmFja2BzIGFyZSBzdXBwb3J0ZWQuXG4gKiAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuc3VwcG9ydHNOYXRpdmVWaWRlb1RyYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhKEh0bWw1LlRFU1RfVklEICYmIEh0bWw1LlRFU1RfVklELnZpZGVvVHJhY2tzKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIG5hdGl2ZSBgQXVkaW9UcmFja2BzIGFyZSBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyL2RldmljZVxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgLSBUcnVlIGlmIG5hdGl2ZSBgQXVkaW9UcmFja2BzIGFyZSBzdXBwb3J0ZWQuXG4gKiAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcbiAqL1xuSHRtbDUuc3VwcG9ydHNOYXRpdmVBdWRpb1RyYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhKEh0bWw1LlRFU1RfVklEICYmIEh0bWw1LlRFU1RfVklELmF1ZGlvVHJhY2tzKTtcbn07XG5cbi8qKlxuICogQW4gYXJyYXkgb2YgZXZlbnRzIGF2YWlsYWJsZSBvbiB0aGUgSHRtbDUgdGVjaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge0FycmF5fVxuICovXG5IdG1sNS5FdmVudHMgPSBbJ2xvYWRzdGFydCcsICdzdXNwZW5kJywgJ2Fib3J0JywgJ2Vycm9yJywgJ2VtcHRpZWQnLCAnc3RhbGxlZCcsICdsb2FkZWRtZXRhZGF0YScsICdsb2FkZWRkYXRhJywgJ2NhbnBsYXknLCAnY2FucGxheXRocm91Z2gnLCAncGxheWluZycsICd3YWl0aW5nJywgJ3NlZWtpbmcnLCAnc2Vla2VkJywgJ2VuZGVkJywgJ2R1cmF0aW9uY2hhbmdlJywgJ3RpbWV1cGRhdGUnLCAncHJvZ3Jlc3MnLCAncGxheScsICdwYXVzZScsICdyYXRlY2hhbmdlJywgJ3Jlc2l6ZScsICd2b2x1bWVjaGFuZ2UnXTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIHZvbHVtZSBjb250cm9sLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LmNhbkNvbnRyb2xWb2x1bWV9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wgPSBIdG1sNS5jYW5Db250cm9sVm9sdW1lKCk7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyBjaGFuZ2luZyB0aGUgc3BlZWQgYXQgd2hpY2ggdGhlIG1lZGlhXG4gKiBwbGF5cy4gRXhhbXBsZXM6XG4gKiAgIC0gU2V0IHBsYXllciB0byBwbGF5IDJ4ICh0d2ljZSkgYXMgZmFzdFxuICogICAtIFNldCBwbGF5ZXIgdG8gcGxheSAwLjV4IChoYWxmKSBhcyBmYXN0XG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAZGVmYXVsdCB7QGxpbmsgSHRtbDUuY2FuQ29udHJvbFBsYXliYWNrUmF0ZX1cbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzUGxheWJhY2tSYXRlID0gSHRtbDUuY2FuQ29udHJvbFBsYXliYWNrUmF0ZSgpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIHRoZSBtZWRpYSBlbGVtZW50XG4gKiBtb3ZpbmcgaW4gdGhlIERPTS4gaU9TIGJyZWFrcyBpZiB5b3UgbW92ZSB0aGUgbWVkaWEgZWxlbWVudCwgc28gdGhpcyBpcyBzZXQgdGhpcyB0b1xuICogZmFsc2UgdGhlcmUuIEV2ZXJ5d2hlcmUgZWxzZSB0aGlzIHNob3VsZCBiZSB0cnVlLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuSHRtbDUucHJvdG90eXBlLm1vdmluZ01lZGlhRWxlbWVudEluRE9NID0gIUlTX0lPUztcblxuLy8gVE9ETzogUHJldmlvdXMgY29tbWVudDogTm8gbG9uZ2VyIGFwcGVhcnMgdG8gYmUgdXNlZC4gQ2FuIHByb2JhYmx5IGJlIHJlbW92ZWQuXG4vLyAgICAgICBJcyB0aGlzIHRydWU/XG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIGF1dG9tYXRpYyBtZWRpYSByZXNpemVcbiAqIHdoZW4gZ29pbmcgaW50byBmdWxsc2NyZWVuLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHRcbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzRnVsbHNjcmVlblJlc2l6ZSA9IHRydWU7XG5cbi8qKlxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBIVE1MNWAgdGVjaCBjdXJyZW50bHkgc3VwcG9ydHMgdGhlIHByb2dyZXNzIGV2ZW50LlxuICogSWYgdGhpcyBpcyBmYWxzZSwgbWFudWFsIGBwcm9ncmVzc2AgZXZlbnRzIHdpbGwgYmUgdHJpZ2dyZWQgaW5zdGVhZC5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBkZWZhdWx0XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc1Byb2dyZXNzRXZlbnRzID0gdHJ1ZTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyB0aGUgdGltZXVwZGF0ZSBldmVudC5cbiAqIElmIHRoaXMgaXMgZmFsc2UsIG1hbnVhbCBgdGltZXVwZGF0ZWAgZXZlbnRzIHdpbGwgYmUgdHJpZ2dyZWQgaW5zdGVhZC5cbiAqXG4gKiBAZGVmYXVsdFxuICovXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNUaW1ldXBkYXRlRXZlbnRzID0gdHJ1ZTtcblxuLyoqXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyBuYXRpdmUgYFRleHRUcmFja2BzLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LnN1cHBvcnRzTmF0aXZlVGV4dFRyYWNrc31cbiAqL1xuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyA9IEh0bWw1LnN1cHBvcnRzTmF0aXZlVGV4dFRyYWNrcygpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIG5hdGl2ZSBgVmlkZW9UcmFja2BzLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LnN1cHBvcnRzTmF0aXZlVmlkZW9UcmFja3N9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc05hdGl2ZVZpZGVvVHJhY2tzID0gSHRtbDUuc3VwcG9ydHNOYXRpdmVWaWRlb1RyYWNrcygpO1xuXG4vKipcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIG5hdGl2ZSBgQXVkaW9UcmFja2BzLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LnN1cHBvcnRzTmF0aXZlQXVkaW9UcmFja3N9XG4gKi9cbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc05hdGl2ZUF1ZGlvVHJhY2tzID0gSHRtbDUuc3VwcG9ydHNOYXRpdmVBdWRpb1RyYWNrcygpO1xuXG4vLyBIVE1MNSBGZWF0dXJlIGRldGVjdGlvbiBhbmQgRGV2aWNlIEZpeGVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xudmFyIGNhblBsYXlUeXBlID0gSHRtbDUuVEVTVF9WSUQgJiYgSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlO1xudmFyIG1wZWd1cmxSRSA9IC9eYXBwbGljYXRpb25cXC8oPzp4LXx2bmRcXC5hcHBsZVxcLiltcGVndXJsL2k7XG52YXIgbXA0UkUgPSAvXnZpZGVvXFwvbXA0L2k7XG5cbkh0bWw1LnBhdGNoQ2FuUGxheVR5cGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLy8gQW5kcm9pZCA0LjAgYW5kIGFib3ZlIGNhbiBwbGF5IEhMUyB0byBzb21lIGV4dGVudCBidXQgaXQgcmVwb3J0cyBiZWluZyB1bmFibGUgdG8gZG8gc29cbiAgaWYgKEFORFJPSURfVkVSU0lPTiA+PSA0LjAgJiYgIUlTX0ZJUkVGT1gpIHtcbiAgICBIdG1sNS5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgaWYgKHR5cGUgJiYgbXBlZ3VybFJFLnRlc3QodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuICdtYXliZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FuUGxheVR5cGUuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICB9O1xuXG4gICAgLy8gT3ZlcnJpZGUgQW5kcm9pZCAyLjIgYW5kIGxlc3MgY2FuUGxheVR5cGUgbWV0aG9kIHdoaWNoIGlzIGJyb2tlblxuICB9IGVsc2UgaWYgKElTX09MRF9BTkRST0lEKSB7XG4gICAgSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlICYmIG1wNFJFLnRlc3QodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuICdtYXliZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FuUGxheVR5cGUuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICB9O1xuICB9XG59O1xuXG5IdG1sNS51bnBhdGNoQ2FuUGxheVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByID0gSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlO1xuXG4gIEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGNhblBsYXlUeXBlO1xuICByZXR1cm4gcjtcbn07XG5cbi8vIGJ5IGRlZmF1bHQsIHBhdGNoIHRoZSBtZWRpYSBlbGVtZW50XG5IdG1sNS5wYXRjaENhblBsYXlUeXBlKCk7XG5cbkh0bWw1LmRpc3Bvc2VNZWRpYUVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgaWYgKCFlbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gIH1cblxuICAvLyByZW1vdmUgYW55IGNoaWxkIHRyYWNrIG9yIHNvdXJjZSBub2RlcyB0byBwcmV2ZW50IHRoZWlyIGxvYWRpbmdcbiAgd2hpbGUgKGVsLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFueSBzcmMgcmVmZXJlbmNlLiBub3Qgc2V0dGluZyBgc3JjPScnYCBiZWNhdXNlIHRoYXQgY2F1c2VzIGEgd2FybmluZ1xuICAvLyBpbiBmaXJlZm94XG4gIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG5cbiAgLy8gZm9yY2UgdGhlIG1lZGlhIGVsZW1lbnQgdG8gdXBkYXRlIGl0cyBsb2FkaW5nIHN0YXRlIGJ5IGNhbGxpbmcgbG9hZCgpXG4gIC8vIGhvd2V2ZXIgSUUgb24gV2luZG93cyA3TiBoYXMgYSBidWcgdGhhdCB0aHJvd3MgYW4gZXJyb3Igc28gbmVlZCBhIHRyeS9jYXRjaCAoIzc5MylcbiAgaWYgKHR5cGVvZiBlbC5sb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gd3JhcHBpbmcgaW4gYW4gaWlmZSBzbyBpdCdzIG5vdCBkZW9wdGltaXplZCAoIzEwNjAjZGlzY3Vzc2lvbl9yMTAzMjQ0NzMpXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsLmxvYWQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZFxuICAgICAgfVxuICAgIH0pKCk7XG4gIH1cbn07XG5cbkh0bWw1LnJlc2V0TWVkaWFFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gIGlmICghZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc291cmNlcyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NvdXJjZScpO1xuICB2YXIgaSA9IHNvdXJjZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBlbC5yZW1vdmVDaGlsZChzb3VyY2VzW2ldKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBhbnkgc3JjIHJlZmVyZW5jZS5cbiAgLy8gbm90IHNldHRpbmcgYHNyYz0nJ2AgYmVjYXVzZSB0aGF0IHRocm93cyBhbiBlcnJvclxuICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gIGlmICh0eXBlb2YgZWwubG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIHdyYXBwaW5nIGluIGFuIGlpZmUgc28gaXQncyBub3QgZGVvcHRpbWl6ZWQgKCMxMDYwI2Rpc2N1c3Npb25fcjEwMzI0NDczKVxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBlbC5sb2FkKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHNhdGlzZnkgbGludGVyXG4gICAgICB9XG4gICAgfSkoKTtcbiAgfVxufTtcblxuLyogTmF0aXZlIEhUTUw1IGVsZW1lbnQgcHJvcGVydHkgd3JhcHBpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbi8vIFdyYXAgbmF0aXZlIHByb3BlcnRpZXMgd2l0aCBhIGdldHRlclxuW1xuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwYXVzZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwYXVzZWRgIGluZGljYXRlcyB3aGV0aGVyIHRoZSBtZWRpYSBlbGVtZW50XG4gKiBpcyBjdXJyZW50bHkgcGF1c2VkIG9yIG5vdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3BhdXNlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwYXVzZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wYXVzZWR9XG4gKi9cbidwYXVzZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGN1cnJlbnRUaW1lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgY3VycmVudFRpbWVgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgc2Vjb25kIHRoYXQgdGhlIG1lZGlhIGlzIGF0IGluIHBsYXliYWNrLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjY3VycmVudFRpbWVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBjdXJyZW50VGltZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWN1cnJlbnR0aW1lfVxuICovXG4nY3VycmVudFRpbWUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGJ1ZmZlcmVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgYnVmZmVyZWRgIGlzIGEgYFRpbWVSYW5nZWBcbiAqIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhcnRzIG9mIHRoZSBtZWRpYSB0aGF0IGFyZSBhbHJlYWR5IGRvd25sb2FkZWQgYW5kXG4gKiBhdmFpbGFibGUgZm9yIHBsYXliYWNrLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjYnVmZmVyZWRcbiAqIEByZXR1cm4ge1RpbWVSYW5nZX1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBidWZmZXJlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWJ1ZmZlcmVkfVxuICovXG4nYnVmZmVyZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHZvbHVtZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHZvbHVtZWAgaW5kaWNhdGVzXG4gKiB0aGUgY3VycmVudCBwbGF5YmFjayB2b2x1bWUgb2YgYXVkaW8gZm9yIGEgbWVkaWEuIGB2b2x1bWVgIHdpbGwgYmUgYSB2YWx1ZSBmcm9tIDBcbiAqIChzaWxlbnQpIHRvIDEgKGxvdWRlc3QgYW5kIGRlZmF1bHQpLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjdm9sdW1lXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBWYWx1ZSB3aWxsIGJlIGJldHdlZW4gMC0xLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tYS12b2x1bWV9XG4gKi9cbid2b2x1bWUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYG11dGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgbXV0ZWRgIGluZGljYXRlc1xuICogdGhhdCB0aGUgdm9sdW1lIGZvciB0aGUgbWVkaWEgc2hvdWxkIGJlIHNldCB0byBzaWxlbnQuIFRoaXMgZG9lcyBub3QgYWN0dWFsbHkgY2hhbmdlXG4gKiB0aGUgYHZvbHVtZWAgYXR0cmlidXRlLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjbXV0ZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgdmFsdWUgb2YgYHZvbHVtZWAgc2hvdWxkIGJlIGlnbm9yZWQgYW5kIHRoZSBhdWRpbyBzZXQgdG8gc2lsZW50LlxuICogICAgICAgICAtIEZhbHNlIGlmIHRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBzaG91bGQgYmUgdXNlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLW11dGVkfVxuICovXG4nbXV0ZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRNdXRlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGRlZmF1bHRNdXRlZGAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSB2b2x1bWUgZm9yIHRoZSBtZWRpYSBzaG91bGQgYmUgc2V0IHRvIHNpbGVudCB3aGVuIHRoZSB2aWRlbyBmaXJzdCBzdGFydHMuXG4gKiBUaGlzIGRvZXMgbm90IGFjdHVhbGx5IGNoYW5nZSB0aGUgYHZvbHVtZWAgYXR0cmlidXRlLiBBZnRlciBwbGF5YmFjayBoYXMgc3RhcnRlZCBgbXV0ZWRgXG4gKiB3aWxsIGluZGljYXRlIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgdm9sdW1lIGFuZCBgZGVmYXVsdE11dGVkYCB3aWxsIG5vdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1LnByb3RvdHlwZS5kZWZhdWx0TXV0ZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGUgdmFsdWUgb2YgYHZvbHVtZWAgc2hvdWxkIGJlIGlnbm9yZWQgYW5kIHRoZSBhdWRpbyBzZXQgdG8gc2lsZW50LlxuICogICAgICAgICAtIEZhbHNlIGlmIHRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBzaG91bGQgYmUgdXNlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWRlZmF1bHRtdXRlZH1cbiAqL1xuJ2RlZmF1bHRNdXRlZCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcG9zdGVyYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcG9zdGVyYCBpbmRpY2F0ZXNcbiAqIHRoYXQgdGhlIHVybCBvZiBhbiBpbWFnZSBmaWxlIHRoYXQgY2FuL3dpbGwgYmUgc2hvd24gd2hlbiBubyBtZWRpYSBkYXRhIGlzIGF2YWlsYWJsZS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3Bvc3RlclxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHBvc3RlcmAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gVmFsdWUgd2lsbCBiZSBhIHVybCB0byBhblxuICogICAgICAgICBpbWFnZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci12aWRlby1wb3N0ZXJ9XG4gKi9cbidwb3N0ZXInLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHByZWxvYWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwcmVsb2FkYCBpbmRpY2F0ZXNcbiAqIHdoYXQgc2hvdWxkIGRvd25sb2FkIGJlZm9yZSB0aGUgbWVkaWEgaXMgaW50ZXJhY3RlZCB3aXRoLiBJdCBjYW4gaGF2ZSB0aGUgZm9sbG93aW5nXG4gKiB2YWx1ZXM6XG4gKiAtIG5vbmU6IG5vdGhpbmcgc2hvdWxkIGJlIGRvd25sb2FkZWRcbiAqIC0gbWV0YWRhdGE6IHBvc3RlciBhbmQgdGhlIGZpcnN0IGZldyBmcmFtZXMgb2YgdGhlIG1lZGlhIG1heSBiZSBkb3dubG9hZGVkIHRvIGdldFxuICogICBtZWRpYSBkaW1lbnNpb25zIGFuZCBvdGhlciBtZXRhZGF0YVxuICogLSBhdXRvOiBhbGxvdyB0aGUgbWVkaWEgYW5kIG1ldGFkYXRhIGZvciB0aGUgbWVkaWEgdG8gYmUgZG93bmxvYWRlZCBiZWZvcmVcbiAqICAgIGludGVyYWN0aW9uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwcmVsb2FkXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcHJlbG9hZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gV2lsbCBiZSAnbm9uZScsICdtZXRhZGF0YScsXG4gKiAgICAgICAgIG9yICdhdXRvJy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1wcmVsb2FkfVxuICovXG4ncHJlbG9hZCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgYXV0b3BsYXlgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBhdXRvcGxheWAgaW5kaWNhdGVzXG4gKiB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgdG8gcGxheSBhcyBzb29uIGFzIHRoZSBwYWdlIGlzIHJlYWR5LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjYXV0b3BsYXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBhdXRvcGxheWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgYXMgc29vbiBhcyB0aGUgcGFnZSBsb2Fkcy5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBzdGFydCBhcyBzb29uIGFzIHRoZSBwYWdlIGxvYWRzLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLWF1dG9wbGF5fVxuICovXG4nYXV0b3BsYXknLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGNvbnRyb2xzYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgY29udHJvbHNgIGluZGljYXRlc1xuICogd2hldGhlciB0aGUgbmF0aXZlIG1lZGlhIGNvbnRyb2xzIHNob3VsZCBiZSBzaG93biBvciBoaWRkZW4uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNjb250cm9sc1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGNvbnRyb2xzYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgbmF0aXZlIGNvbnRyb2xzIHNob3VsZCBiZSBzaG93aW5nLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IG5hdGl2ZSBjb250cm9scyBzaG91bGQgYmUgaGlkZGVuLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLWNvbnRyb2xzfVxuICovXG4nY29udHJvbHMnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGxvb3BgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBsb29wYCBpbmRpY2F0ZXNcbiAqIHRoYXQgdGhlIG1lZGlhIHNob3VsZCByZXR1cm4gdG8gdGhlIHN0YXJ0IG9mIHRoZSBtZWRpYSBhbmQgY29udGludWUgcGxheWluZyBvbmNlXG4gKiBpdCByZWFjaGVzIHRoZSBlbmQuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNsb29wXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgbG9vcGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHBsYXliYWNrIHNob3VsZCBzZWVrIGJhY2sgdG8gc3RhcnQgb25jZVxuICogICAgICAgICAgIHRoZSBlbmQgb2YgYSBtZWRpYSBpcyByZWFjaGVkLlxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHBsYXliYWNrIHNob3VsZCBub3QgbG9vcCBiYWNrIHRvIHRoZSBzdGFydCB3aGVuIHRoZVxuICogICAgICAgICAgIGVuZCBvZiB0aGUgbWVkaWEgaXMgcmVhY2hlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1sb29wfVxuICovXG4nbG9vcCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgYGVycm9yYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgZXJyb3JgIGluZGljYXRlcyBhbnlcbiAqIE1lZGlhRXJyb3IgdGhhdCBtYXkgaGF2ZSBvY2N1cmVkIGR1cmluZyBwbGF5YmFjay4gSWYgZXJyb3IgcmV0dXJucyBudWxsIHRoZXJlIGlzIG5vXG4gKiBjdXJyZW50IGVycm9yLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjZXJyb3JcbiAqIEByZXR1cm4ge01lZGlhRXJyb3J8bnVsbH1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBlcnJvcmAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gV2lsbCBiZSBgTWVkaWFFcnJvcmAgaWYgdGhlcmVcbiAqICAgICAgICAgaXMgYSBjdXJyZW50IGVycm9yIGFuZCBudWxsIG90aGVyd2lzZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWVycm9yfVxuICovXG4nZXJyb3InLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHNlZWtpbmdgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBzZWVraW5nYCBpbmRpY2F0ZXMgd2hldGhlciB0aGVcbiAqIG1lZGlhIGlzIGN1cnJlbnRseSBzZWVraW5nIHRvIGEgbmV3IHBvc2l0aW9uIG9yIG5vdC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NlZWtpbmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBzZWVraW5nYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBzZWVraW5nIHRvIGEgbmV3IHBvc2l0aW9uLlxuICogICAgICAgICAtIEZsYXNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBpcyBub3Qgc2Vla2luZyB0byBhIG5ldyBwb3NpdGlvbiBhdCB0aGlzIHRpbWUuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1zZWVraW5nfVxuICovXG4nc2Vla2luZycsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgc2Vla2FibGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBzZWVrYWJsZWAgcmV0dXJucyBhXG4gKiBgVGltZVJhbmdlYCBvYmplY3QgaW5kaWNhdGluZyByYW5nZXMgb2YgdGltZSB0aGF0IGNhbiBjdXJyZW50bHkgYmUgYHNlZWtlZGAgdG8uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZWVrYWJsZVxuICogQHJldHVybiB7VGltZVJhbmdlfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHNlZWthYmxlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIGBUaW1lUmFuZ2VgIG9iamVjdFxuICogICAgICAgICBpbmRpY2F0aW5nIHRoZSBjdXJyZW50IHJhbmdlcyBvZiB0aW1lIHRoYXQgY2FuIGJlIHNlZWtlZCB0by5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXNlZWthYmxlfVxuICovXG4nc2Vla2FibGUnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGVuZGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgZW5kZWRgIGluZGljYXRlcyB3aGV0aGVyXG4gKiB0aGUgbWVkaWEgaGFzIHJlYWNoZWQgdGhlIGVuZCBvciBub3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNlbmRlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGVuZGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIGhhcyBlbmRlZC5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgaGFzIG5vdCBlbmRlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWVuZGVkfVxuICovXG4nZW5kZWQnLFxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRNdXRlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGRlZmF1bHRNdXRlZGAgaW5kaWNhdGVzXG4gKiB3aGV0aGVyIHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgbXV0ZWQgb3Igbm90LiBPbmx5IGNoYW5nZXMgdGhlIGRlZmF1bHQgc3RhdGUgb2YgdGhlXG4gKiBtZWRpYS4gYG11dGVkYCBhbmQgYGRlZmF1bHRNdXRlZGAgY2FuIGhhdmUgZGlmZmVyZW50IHZhbHVlcy4ge0BsaW5rIEh0bWw1I211dGVkfSBpbmRpY2F0ZXMgdGhlXG4gKiBjdXJyZW50IHN0YXRlLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjZGVmYXVsdE11dGVkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgZGVmYXVsdE11dGVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBzdGFydCBtdXRlZC5cbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBzdGFydCBtdXRlZFxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtZGVmYXVsdG11dGVkfVxuICovXG4nZGVmYXVsdE11dGVkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwbGF5YmFja1JhdGVgIGluZGljYXRlc1xuICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBwbGF5aW5nIGJhY2suIEV4YW1wbGVzOlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMiwgbWVkaWEgd2lsbCBwbGF5IHR3aWNlIGFzIGZhc3QuXG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAwLjUsIG1lZGlhIHdpbGwgcGxheSBoYWxmIGFzIGZhc3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNwbGF5YmFja1JhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIEEgbnVtYmVyIGluZGljYXRpbmdcbiAqICAgICAgICAgdGhlIGN1cnJlbnQgcGxheWJhY2sgc3BlZWQgb2YgdGhlIG1lZGlhLCB3aGVyZSAxIGlzIG5vcm1hbCBzcGVlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXBsYXliYWNrcmF0ZX1cbiAqL1xuJ3BsYXliYWNrUmF0ZScsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgZGVmYXVsdFBsYXliYWNrUmF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGRlZmF1bHRQbGF5YmFja1JhdGVgIGluZGljYXRlc1xuICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBwbGF5aW5nIGJhY2suIFRoaXMgdmFsdWUgd2lsbCBub3QgaW5kaWNhdGUgdGhlIGN1cnJlbnRcbiAqIGBwbGF5YmFja1JhdGVgIGFmdGVyIHBsYXliYWNrIGhhcyBzdGFydGVkLCB1c2Uge0BsaW5rIEh0bWw1I3BsYXliYWNrUmF0ZX0gZm9yIHRoYXQuXG4gKlxuICogRXhhbXBsZXM6XG4gKiAgIC0gaWYgZGVmYXVsdFBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMiwgbWVkaWEgd2lsbCBwbGF5IHR3aWNlIGFzIGZhc3QuXG4gKiAgIC0gaWYgZGVmYXVsdFBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMC41LCBtZWRpYSB3aWxsIHBsYXkgaGFsZiBhcyBmYXN0LlxuICpcbiAqIEBtZXRob2QgSHRtbDUucHJvdG90eXBlLmRlZmF1bHRQbGF5YmFja1JhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIG51bWJlciBpbmRpY2F0aW5nXG4gKiAgICAgICAgIHRoZSBjdXJyZW50IHBsYXliYWNrIHNwZWVkIG9mIHRoZSBtZWRpYSwgd2hlcmUgMSBpcyBub3JtYWwgc3BlZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5YmFja3JhdGV9XG4gKi9cbidkZWZhdWx0UGxheWJhY2tSYXRlJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwbGF5ZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwbGF5ZWRgIHJldHVybnMgYSBgVGltZVJhbmdlYFxuICogb2JqZWN0IHJlcHJlc2VudGluZyBwb2ludHMgaW4gdGhlIG1lZGlhIHRpbWVsaW5lIHRoYXQgaGF2ZSBiZWVuIHBsYXllZC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3BsYXllZFxuICogQHJldHVybiB7VGltZVJhbmdlfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHBsYXllZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gQSBgVGltZVJhbmdlYCBvYmplY3QgaW5kaWNhdGluZ1xuICogICAgICAgICB0aGUgcmFuZ2VzIG9mIHRpbWUgdGhhdCBoYXZlIGJlZW4gcGxheWVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtcGxheWVkfVxuICovXG4ncGxheWVkJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBuZXR3b3JrU3RhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBuZXR3b3JrU3RhdGVgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgbmV0d29yayBzdGF0ZS4gSXQgcmV0dXJucyBhbiBlbnVtZXJhdGlvbiBmcm9tIHRoZSBmb2xsb3dpbmcgbGlzdDpcbiAqIC0gMDogTkVUV09SS19FTVBUWVxuICogLSAxOiBORVdPUktfSURMRVxuICogLSAyOiBORVRXT1JLX0xPQURJTkdcbiAqIC0gMzogTkVUV09SS19OT19TT1VSQ0VcbiAqXG4gKiBAbWV0aG9kIEh0bWw1I25ldHdvcmtTdGF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYG5ldHdvcmtTdGF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gVGhpcyB3aWxsIGJlIGEgbnVtYmVyXG4gKiAgICAgICAgIGZyb20gdGhlIGxpc3QgaW4gdGhlIGRlc2NyaXB0aW9uLlxuICpcbiAqIEBzZWUgW1NwZWNdIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLW5ldHdvcmtzdGF0ZX1cbiAqL1xuJ25ldHdvcmtTdGF0ZScsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcmVhZHlTdGF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHJlYWR5U3RhdGVgIGluZGljYXRlc1xuICogdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIG1lZGlhIGVsZW1lbnQuIEl0IHJldHVybnMgYW4gZW51bWVyYXRpb24gZnJvbSB0aGVcbiAqIGZvbGxvd2luZyBsaXN0OlxuICogLSAwOiBIQVZFX05PVEhJTkdcbiAqIC0gMTogSEFWRV9NRVRBREFUQVxuICogLSAyOiBIQVZFX0NVUlJFTlRfREFUQVxuICogLSAzOiBIQVZFX0ZVVFVSRV9EQVRBXG4gKiAtIDQ6IEhBVkVfRU5PVUdIX0RBVEFcbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3JlYWR5U3RhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGByZWFkeVN0YXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBUaGlzIHdpbGwgYmUgYSBudW1iZXJcbiAqICAgICAgICAgZnJvbSB0aGUgbGlzdCBpbiB0aGUgZGVzY3JpcHRpb24uXG4gKlxuICogQHNlZSBbU3BlY10ge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNyZWFkeS1zdGF0ZXN9XG4gKi9cbidyZWFkeVN0YXRlJyxcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGB2aWRlb1dpZHRoYCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LiBgdmlkZW9XaWR0aGAgaW5kaWNhdGVzXG4gKiB0aGUgY3VycmVudCB3aWR0aCBvZiB0aGUgdmlkZW8gaW4gY3NzIHBpeGVscy5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3ZpZGVvV2lkdGhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGB2aWRlb1dpZHRoYCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LiBUaGlzIHdpbGwgYmUgYSBudW1iZXJcbiAqICAgICAgICAgaW4gY3NzIHBpeGVscy5cbiAqXG4gKiBAc2VlIFtTcGVjXSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS12aWRlby12aWRlb3dpZHRofVxuICovXG4ndmlkZW9XaWR0aCcsXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBgdmlkZW9IZWlnaHRgIGZyb20gdGhlIHZpZGVvIGVsZW1lbnQuIGB2aWRlb0hlaWd0aGAgaW5kaWNhdGVzXG4gKiB0aGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIHZpZGVvIGluIGNzcyBwaXhlbHMuXG4gKlxuICogQG1ldGhvZCBIdG1sNSN2aWRlb0hlaWdodFxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHZpZGVvSGVpZ2h0YCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LiBUaGlzIHdpbGwgYmUgYSBudW1iZXJcbiAqICAgICAgICAgaW4gY3NzIHBpeGVscy5cbiAqXG4gKiBAc2VlIFtTcGVjXSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS12aWRlby12aWRlb3dpZHRofVxuICovXG4ndmlkZW9IZWlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIEh0bWw1LnByb3RvdHlwZVtwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbF9bcHJvcF07XG4gIH07XG59KTtcblxuLy8gV3JhcCBuYXRpdmUgcHJvcGVydGllcyB3aXRoIGEgc2V0dGVyIGluIHRoaXMgZm9ybWF0OlxuLy8gc2V0ICsgdG9UaXRsZUNhc2UobmFtZSlcbltcbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYHZvbHVtZWAgaW5kaWNhdGVzIHRoZSBjdXJyZW50XG4gKiBhdWRpbyBsZXZlbCBhcyBhIHBlcmNlbnRhZ2UgaW4gZGVjaW1hbCBmb3JtLiBUaGlzIG1lYW5zIHRoYXQgMSBpcyAxMDAlLCAwLjUgaXMgNTAlLCBhbmRcbiAqIHNvIG9uLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0Vm9sdW1lXG4gKiBAcGFyYW0ge251bWJlcn0gcGVyY2VudEFzRGVjaW1hbFxuICogICAgICAgIFRoZSB2b2x1bWUgcGVyY2VudCBhcyBhIGRlY2ltYWwuIFZhbGlkIHJhbmdlIGlzIGZyb20gMC0xLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tYS12b2x1bWV9XG4gKi9cbid2b2x1bWUnLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYG11dGVkYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYG11dGVkYCBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudFxuICogYXVkaW8gbGV2ZWwgc2hvdWxkIGJlIHNpbGVudC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldE11dGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG11dGVkXG4gKiAgICAgICAgLSBUcnVlIGlmIHRoZSBhdWRpbyBzaG91bGQgYmUgc2V0IHRvIHNpbGVudFxuICogICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1tdXRlZH1cbiAqL1xuJ211dGVkJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBkZWZhdWx0TXV0ZWRgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgZGVmYXVsdE11dGVkYCBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudFxuICogYXVkaW8gbGV2ZWwgc2hvdWxkIGJlIHNpbGVudCwgYnV0IHdpbGwgb25seSBlZmZlY3QgdGhlIG11dGVkIGxldmVsIG9uIGludGlhbCBwbGF5YmFjay4uXG4gKlxuICogQG1ldGhvZCBIdG1sNS5wcm90b3R5cGUuc2V0RGVmYXVsdE11dGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRlZmF1bHRNdXRlZFxuICogICAgICAgIC0gVHJ1ZSBpZiB0aGUgYXVkaW8gc2hvdWxkIGJlIHNldCB0byBzaWxlbnRcbiAqICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtZGVmYXVsdG11dGVkfVxuICovXG4nZGVmYXVsdE11dGVkJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBzcmNgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgc3JjYCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnRcbiAqIHtAbGluayBUZWNoflNvdXJjZU9iamVjdH0gZm9yIHRoZSBtZWRpYS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldFNyY1xuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc3JjXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3QgdG8gc2V0IGFzIHRoZSBjdXJyZW50IHNvdXJjZS5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXNyY31cbiAqL1xuJ3NyYycsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgcG9zdGVyYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYHBvc3RlcmAgaXMgdGhlIHVybCB0b1xuICogYW4gaW1hZ2UgZmlsZSB0aGF0IGNhbi93aWxsIGJlIHNob3duIHdoZW4gbm8gbWVkaWEgZGF0YSBpcyBhdmFpbGFibGUuXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZXRQb3N0ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3N0ZXJcbiAqICAgICAgICBUaGUgdXJsIHRvIGFuIGltYWdlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIGBwb3N0ZXJgIGZvciB0aGUgbWVkaWFcbiAqICAgICAgICBlbGVtZW50LlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLXBvc3Rlcn1cbiAqL1xuJ3Bvc3RlcicsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgcHJlbG9hZGAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBwcmVsb2FkYCBpbmRpY2F0ZXNcbiAqIHdoYXQgc2hvdWxkIGRvd25sb2FkIGJlZm9yZSB0aGUgbWVkaWEgaXMgaW50ZXJhY3RlZCB3aXRoLiBJdCBjYW4gaGF2ZSB0aGUgZm9sbG93aW5nXG4gKiB2YWx1ZXM6XG4gKiAtIG5vbmU6IG5vdGhpbmcgc2hvdWxkIGJlIGRvd25sb2FkZWRcbiAqIC0gbWV0YWRhdGE6IHBvc3RlciBhbmQgdGhlIGZpcnN0IGZldyBmcmFtZXMgb2YgdGhlIG1lZGlhIG1heSBiZSBkb3dubG9hZGVkIHRvIGdldFxuICogICBtZWRpYSBkaW1lbnNpb25zIGFuZCBvdGhlciBtZXRhZGF0YVxuICogLSBhdXRvOiBhbGxvdyB0aGUgbWVkaWEgYW5kIG1ldGFkYXRhIGZvciB0aGUgbWVkaWEgdG8gYmUgZG93bmxvYWRlZCBiZWZvcmVcbiAqICAgIGludGVyYWN0aW9uXG4gKlxuICogQG1ldGhvZCBIdG1sNSNzZXRQcmVsb2FkXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlbG9hZFxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHByZWxvYWRgIHRvIHNldCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gTXVzdCBiZSAnbm9uZScsICdtZXRhZGF0YScsXG4gKiAgICAgICAgIG9yICdhdXRvJy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1wcmVsb2FkfVxuICovXG4ncHJlbG9hZCcsXG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgYXV0b3BsYXlgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgYXV0b3BsYXlgIGluZGljYXRlc1xuICogdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IHRvIHBsYXkgYXMgc29vbiBhcyB0aGUgcGFnZSBpcyByZWFkeS5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldEF1dG9wbGF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGF1dG9wbGF5XG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IGFzIHNvb24gYXMgdGhlIHBhZ2UgbG9hZHMuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBub3Qgc3RhcnQgYXMgc29vbiBhcyB0aGUgcGFnZSBsb2Fkcy5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1hdXRvcGxheX1cbiAqL1xuJ2F1dG9wbGF5JyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBsb29wYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYGxvb3BgIGluZGljYXRlc1xuICogdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHJldHVybiB0byB0aGUgc3RhcnQgb2YgdGhlIG1lZGlhIGFuZCBjb250aW51ZSBwbGF5aW5nIG9uY2VcbiAqIGl0IHJlYWNoZXMgdGhlIGVuZC5cbiAqXG4gKiBAbWV0aG9kIEh0bWw1I3NldExvb3BcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgcGxheWJhY2sgc2hvdWxkIHNlZWsgYmFjayB0byBzdGFydCBvbmNlXG4gKiAgICAgICAgICAgdGhlIGVuZCBvZiBhIG1lZGlhIGlzIHJlYWNoZWQuXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgcGxheWJhY2sgc2hvdWxkIG5vdCBsb29wIGJhY2sgdG8gdGhlIHN0YXJ0IHdoZW4gdGhlXG4gKiAgICAgICAgICAgZW5kIG9mIHRoZSBtZWRpYSBpcyByZWFjaGVkLlxuICpcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLWxvb3B9XG4gKi9cbidsb29wJyxcblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBwbGF5YmFja1JhdGVgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheWJhY2tSYXRlYCBpbmRpY2F0ZXNcbiAqIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBtZWRpYSBzaG91bGQgcGxheSBiYWNrLiBFeGFtcGxlczpcbiAqICAgLSBpZiBwbGF5YmFja1JhdGUgaXMgc2V0IHRvIDIsIG1lZGlhIHdpbGwgcGxheSB0d2ljZSBhcyBmYXN0LlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMC41LCBtZWRpYSB3aWxsIHBsYXkgaGFsZiBhcyBmYXN0LlxuICpcbiAqIEBtZXRob2QgSHRtbDUjc2V0UGxheWJhY2tSYXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIG51bWJlciBpbmRpY2F0aW5nXG4gKiAgICAgICAgIHRoZSBjdXJyZW50IHBsYXliYWNrIHNwZWVkIG9mIHRoZSBtZWRpYSwgd2hlcmUgMSBpcyBub3JtYWwgc3BlZWQuXG4gKlxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5YmFja3JhdGV9XG4gKi9cbidwbGF5YmFja1JhdGUnLFxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRQbGF5YmFja1JhdGVgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgZGVmYXVsdFBsYXliYWNrUmF0ZWAgaW5kaWNhdGVzXG4gKiB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgbWVkaWEgc2hvdWxkIHBsYXkgYmFjayB1cG9uIGluaXRpYWwgc3RhcnR1cC4gQ2hhbmdpbmcgdGhpcyB2YWx1ZVxuICogYWZ0ZXIgYSB2aWRlbyBoYXMgc3RhcnRlZCB3aWxsIGRvIG5vdGhpbmcuIEluc3RlYWQgeW91IHNob3VsZCB1c2VkIHtAbGluayBIdG1sNSNzZXRQbGF5YmFja1JhdGV9LlxuICpcbiAqIEV4YW1wbGUgVmFsdWVzOlxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMiwgbWVkaWEgd2lsbCBwbGF5IHR3aWNlIGFzIGZhc3QuXG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAwLjUsIG1lZGlhIHdpbGwgcGxheSBoYWxmIGFzIGZhc3QuXG4gKlxuICogQG1ldGhvZCBIdG1sNS5wcm90b3R5cGUuc2V0RGVmYXVsdFBsYXliYWNrUmF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYGRlZmF1bHRQbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIEEgbnVtYmVyIGluZGljYXRpbmdcbiAqICAgICAgICAgdGhlIGN1cnJlbnQgcGxheWJhY2sgc3BlZWQgb2YgdGhlIG1lZGlhLCB3aGVyZSAxIGlzIG5vcm1hbCBzcGVlZC5cbiAqXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWRlZmF1bHRwbGF5YmFja3JhdGV9XG4gKi9cbidkZWZhdWx0UGxheWJhY2tSYXRlJ10uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBIdG1sNS5wcm90b3R5cGVbJ3NldCcgKyB0b1RpdGxlQ2FzZShwcm9wKV0gPSBmdW5jdGlvbiAodikge1xuICAgIHRoaXMuZWxfW3Byb3BdID0gdjtcbiAgfTtcbn0pO1xuXG4vLyB3cmFwIG5hdGl2ZSBmdW5jdGlvbnMgd2l0aCBhIGZ1bmN0aW9uXG5bXG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgdGhlIG1lZGlhIGVsZW1lbnRzIGBwYXVzZWAgZnVuY3Rpb24uIFRoaXMgd2lsbCBjYWxsIHRoZSBgSFRNTDVgXG4gKiBtZWRpYSBlbGVtZW50cyBgcGF1c2VgIGZ1bmN0aW9uLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjcGF1c2VcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtcGF1c2V9XG4gKi9cbidwYXVzZScsXG5cbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgbWVkaWEgZWxlbWVudHMgYGxvYWRgIGZ1bmN0aW9uLiBUaGlzIHdpbGwgY2FsbCB0aGUgYEhUTUw1YHNcbiAqIG1lZGlhIGVsZW1lbnQgYGxvYWRgIGZ1bmN0aW9uLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjbG9hZFxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1sb2FkfVxuICovXG4nbG9hZCcsXG5cbi8qKlxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgbWVkaWEgZWxlbWVudHMgYHBsYXlgIGZ1bmN0aW9uLiBUaGlzIHdpbGwgY2FsbCB0aGUgYEhUTUw1YHNcbiAqIG1lZGlhIGVsZW1lbnQgYHBsYXlgIGZ1bmN0aW9uLlxuICpcbiAqIEBtZXRob2QgSHRtbDUjcGxheVxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5fVxuICovXG4ncGxheSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgSHRtbDUucHJvdG90eXBlW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVsX1twcm9wXSgpO1xuICB9O1xufSk7XG5cblRlY2gud2l0aFNvdXJjZUhhbmRsZXJzKEh0bWw1KTtcblxuLyoqXG4gKiBOYXRpdmUgc291cmNlIGhhbmRsZXIgZm9yIEh0bWw1LCBzaW1wbHkgcGFzc2VzIHRoZSBzb3VyY2UgdG8gdGhlIG1lZGlhIGVsZW1lbnQuXG4gKlxuICogQHByb3ByZXR5IHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqXG4gKiBAcHJvcHJldHkge0h0bWw1fSB0ZWNoXG4gKiAgICAgICAgVGhlIGluc3RhbmNlIG9mIHRoZSBIVE1MNSB0ZWNoLlxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyID0ge307XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIG1lZGlhIGVsZW1lbnQgY2FuIHBsYXkgdGhlIGdpdmVuIG1pbWUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogICAgICAgIFRoZSBtaW1ldHlwZSB0byBjaGVja1xuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcbiAqL1xuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIC8vIElFOSBvbiBXaW5kb3dzIDcgd2l0aG91dCBNZWRpYVBsYXllciB0aHJvd3MgYW4gZXJyb3IgaGVyZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvNTE5XG4gIHRyeSB7XG4gICAgcmV0dXJuIEh0bWw1LlRFU1RfVklELmNhblBsYXlUeXBlKHR5cGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBtZWRpYSBlbGVtZW50IGNhbiBoYW5kbGUgYSBzb3VyY2UgbmF0aXZlbHkuXG4gKlxuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gKiAgICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgICBPcHRpb25zIHRvIGJlIHBhc3NlZCB0byB0aGUgdGVjaC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpLlxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmNhbkhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAvLyBJZiBhIHR5cGUgd2FzIHByb3ZpZGVkIHdlIHNob3VsZCByZWx5IG9uIHRoYXRcbiAgaWYgKHNvdXJjZS50eXBlKSB7XG4gICAgcmV0dXJuIEh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuY2FuUGxheVR5cGUoc291cmNlLnR5cGUpO1xuXG4gICAgLy8gSWYgbm8gdHlwZSwgZmFsbCBiYWNrIHRvIGNoZWNraW5nICd2aWRlby9bRVhURU5TSU9OXSdcbiAgfSBlbHNlIGlmIChzb3VyY2Uuc3JjKSB7XG4gICAgdmFyIGV4dCA9IGdldEZpbGVFeHRlbnNpb24oc291cmNlLnNyYyk7XG5cbiAgICByZXR1cm4gSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5jYW5QbGF5VHlwZSgndmlkZW8vJyArIGV4dCk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59O1xuXG4vKipcbiAqIFBhc3MgdGhlIHNvdXJjZSB0byB0aGUgbmF0aXZlIG1lZGlhIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge0h0bWw1fSB0ZWNoXG4gKiAgICAgICAgVGhlIGluc3RhbmNlIG9mIHRoZSBIdG1sNSB0ZWNoXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZVxuICovXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRlY2gsIG9wdGlvbnMpIHtcbiAgdGVjaC5zZXRTcmMoc291cmNlLnNyYyk7XG59O1xuXG4vKipcbiAqIEEgbm9vcCBmb3IgdGhlIG5hdGl2ZSBkaXNwb3NlIGZ1bmN0aW9uLCBhcyBjbGVhbnVwIGlzIG5vdCBuZWVkZWQuXG4gKi9cbkh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBSZWdpc3RlciB0aGUgbmF0aXZlIHNvdXJjZSBoYW5kbGVyXG5IdG1sNS5yZWdpc3RlclNvdXJjZUhhbmRsZXIoSHRtbDUubmF0aXZlU291cmNlSGFuZGxlcik7XG5cblRlY2gucmVnaXN0ZXJUZWNoKCdIdG1sNScsIEh0bWw1KTtcblxudmFyIF90ZW1wbGF0ZU9iamVjdCQxID0gdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UoWydcXG4gICAgICAgIFVzaW5nIHRoZSB0ZWNoIGRpcmVjdGx5IGNhbiBiZSBkYW5nZXJvdXMuIEkgaG9wZSB5b3Uga25vdyB3aGF0IHlvdVxcJ3JlIGRvaW5nLlxcbiAgICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8yNjE3IGZvciBtb3JlIGluZm8uXFxuICAgICAgJ10sIFsnXFxuICAgICAgICBVc2luZyB0aGUgdGVjaCBkaXJlY3RseSBjYW4gYmUgZGFuZ2Vyb3VzLiBJIGhvcGUgeW91IGtub3cgd2hhdCB5b3VcXCdyZSBkb2luZy5cXG4gICAgICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvMjYxNyBmb3IgbW9yZSBpbmZvLlxcbiAgICAgICddKTtcblxuLyoqXG4gKiBAZmlsZSBwbGF5ZXIuanNcbiAqL1xuLy8gU3ViY2xhc3NlcyBDb21wb25lbnRcbi8vIFRoZSBmb2xsb3dpbmcgaW1wb3J0cyBhcmUgdXNlZCBvbmx5IHRvIGVuc3VyZSB0aGF0IHRoZSBjb3JyZXNwb25kaW5nIG1vZHVsZXNcbi8vIGFyZSBhbHdheXMgaW5jbHVkZWQgaW4gdGhlIHZpZGVvLmpzIHBhY2thZ2UuIEltcG9ydGluZyB0aGUgbW9kdWxlcyB3aWxsXG4vLyBleGVjdXRlIHRoZW0gYW5kIHRoZXkgd2lsbCByZWdpc3RlciB0aGVtc2VsdmVzIHdpdGggdmlkZW8uanMuXG4vLyBJbXBvcnQgSHRtbDUgdGVjaCwgYXQgbGVhc3QgZm9yIGRpc3Bvc2luZyB0aGUgb3JpZ2luYWwgdmlkZW8gdGFnLlxuLy8gVGhlIGZvbGxvd2luZyB0ZWNoIGV2ZW50cyBhcmUgc2ltcGx5IHJlLXRyaWdnZXJlZFxuLy8gb24gdGhlIHBsYXllciB3aGVuIHRoZXkgaGFwcGVuXG52YXIgVEVDSF9FVkVOVFNfUkVUUklHR0VSID0gW1xuLyoqXG4gKiBGaXJlZCB3aGlsZSB0aGUgdXNlciBhZ2VudCBpcyBkb3dubG9hZGluZyBtZWRpYSBkYXRhLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjcHJvZ3Jlc3NcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGBwcm9ncmVzc2AgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hQcm9ncmVzc19cbiAqIEBmaXJlcyBQbGF5ZXIjcHJvZ3Jlc3NcbiAqIEBsaXN0ZW5zIFRlY2gjcHJvZ3Jlc3NcbiAqL1xuJ3Byb2dyZXNzJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBsb2FkaW5nIG9mIGFuIGF1ZGlvL3ZpZGVvIGlzIGFib3J0ZWQuXG4gKlxuICogQGV2ZW50IFBsYXllciNhYm9ydFxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYGFib3J0YCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaEFib3J0X1xuICogQGZpcmVzIFBsYXllciNhYm9ydFxuICogQGxpc3RlbnMgVGVjaCNhYm9ydFxuICovXG4nYWJvcnQnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaXMgaW50ZW50aW9uYWxseSBub3QgZ2V0dGluZyBtZWRpYSBkYXRhLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjc3VzcGVuZFxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHN1c3BlbmRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoU3VzcGVuZF9cbiAqIEBmaXJlcyBQbGF5ZXIjc3VzcGVuZFxuICogQGxpc3RlbnMgVGVjaCNzdXNwZW5kXG4gKi9cbidzdXNwZW5kJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBjdXJyZW50IHBsYXlsaXN0IGlzIGVtcHR5LlxuICpcbiAqIEBldmVudCBQbGF5ZXIjZW1wdGllZFxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYGVtcHRpZWRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoRW1wdGllZF9cbiAqIEBmaXJlcyBQbGF5ZXIjZW1wdGllZFxuICogQGxpc3RlbnMgVGVjaCNlbXB0aWVkXG4gKi9cbidlbXB0aWVkJyxcbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgYnJvd3NlciBpcyB0cnlpbmcgdG8gZ2V0IG1lZGlhIGRhdGEsIGJ1dCBkYXRhIGlzIG5vdCBhdmFpbGFibGUuXG4gKlxuICogQGV2ZW50IFBsYXllciNzdGFsbGVkXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgc3RhbGxlZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hTdGFsbGVkX1xuICogQGZpcmVzIFBsYXllciNzdGFsbGVkXG4gKiBAbGlzdGVucyBUZWNoI3N0YWxsZWRcbiAqL1xuJ3N0YWxsZWQnLFxuXG4vKipcbiAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaGFzIGxvYWRlZCBtZXRhIGRhdGEgZm9yIHRoZSBhdWRpby92aWRlby5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI2xvYWRlZG1ldGFkYXRhXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgc3RhbGxlZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hMb2FkZWRtZXRhZGF0YV9cbiAqIEBmaXJlcyBQbGF5ZXIjbG9hZGVkbWV0YWRhdGFcbiAqIEBsaXN0ZW5zIFRlY2gjbG9hZGVkbWV0YWRhdGFcbiAqL1xuJ2xvYWRlZG1ldGFkYXRhJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSBicm93c2VyIGhhcyBsb2FkZWQgdGhlIGN1cnJlbnQgZnJhbWUgb2YgdGhlIGF1ZGlvL3ZpZGVvLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjbG9hZGVkZGF0YVxuICogQHR5cGUge2V2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYGxvYWRlZGRhdGFgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoTG9hZGRlZGRhdGFfXG4gKiBAZmlyZXMgUGxheWVyI2xvYWRlZGRhdGFcbiAqIEBsaXN0ZW5zIFRlY2gjbG9hZGVkZGF0YVxuICovXG4nbG9hZGVkZGF0YScsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiBoYXMgY2hhbmdlZC5cbiAqXG4gKiBAZXZlbnQgUGxheWVyI3RpbWV1cGRhdGVcbiAqIEB0eXBlIHtldmVudH1cbiAqL1xuLyoqXG4gKiBSZXRyaWdnZXIgdGhlIGB0aW1ldXBkYXRlYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFRpbWVVcGRhdGVfXG4gKiBAZmlyZXMgUGxheWVyI3RpbWV1cGRhdGVcbiAqIEBsaXN0ZW5zIFRlY2gjdGltZXVwZGF0ZVxuICovXG4ndGltZXVwZGF0ZScsXG5cbi8qKlxuICogRmlyZXMgd2hlbiB0aGUgcGxheWluZyBzcGVlZCBvZiB0aGUgYXVkaW8vdmlkZW8gaXMgY2hhbmdlZFxuICpcbiAqIEBldmVudCBQbGF5ZXIjcmF0ZWNoYW5nZVxuICogQHR5cGUge2V2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHJhdGVjaGFuZ2VgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoUmF0ZWNoYW5nZV9cbiAqIEBmaXJlcyBQbGF5ZXIjcmF0ZWNoYW5nZVxuICogQGxpc3RlbnMgVGVjaCNyYXRlY2hhbmdlXG4gKi9cbidyYXRlY2hhbmdlJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSB2aWRlbydzIGludHJpbnNpYyBkaW1lbnNpb25zIGNoYW5nZVxuICpcbiAqIEBldmVudCBQbGF5ZXIjcmVzaXplXG4gKiBAdHlwZSB7ZXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgcmVzaXplYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFJlc2l6ZV9cbiAqIEBmaXJlcyBQbGF5ZXIjcmVzaXplXG4gKiBAbGlzdGVucyBUZWNoI3Jlc2l6ZVxuICovXG4ncmVzaXplJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSB2b2x1bWUgaGFzIGJlZW4gY2hhbmdlZFxuICpcbiAqIEBldmVudCBQbGF5ZXIjdm9sdW1lY2hhbmdlXG4gKiBAdHlwZSB7ZXZlbnR9XG4gKi9cbi8qKlxuICogUmV0cmlnZ2VyIHRoZSBgdm9sdW1lY2hhbmdlYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFZvbHVtZWNoYW5nZV9cbiAqIEBmaXJlcyBQbGF5ZXIjdm9sdW1lY2hhbmdlXG4gKiBAbGlzdGVucyBUZWNoI3ZvbHVtZWNoYW5nZVxuICovXG4ndm9sdW1lY2hhbmdlJyxcblxuLyoqXG4gKiBGaXJlcyB3aGVuIHRoZSB0ZXh0IHRyYWNrIGhhcyBiZWVuIGNoYW5nZWRcbiAqXG4gKiBAZXZlbnQgUGxheWVyI3RleHR0cmFja2NoYW5nZVxuICogQHR5cGUge2V2ZW50fVxuICovXG4vKipcbiAqIFJldHJpZ2dlciB0aGUgYHRleHR0cmFja2NoYW5nZWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hUZXh0dHJhY2tjaGFuZ2VfXG4gKiBAZmlyZXMgUGxheWVyI3RleHR0cmFja2NoYW5nZVxuICogQGxpc3RlbnMgVGVjaCN0ZXh0dHJhY2tjaGFuZ2VcbiAqL1xuJ3RleHR0cmFja2NoYW5nZSddO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBgUGxheWVyYCBjbGFzcyBpcyBjcmVhdGVkIHdoZW4gYW55IG9mIHRoZSBWaWRlby5qcyBzZXR1cCBtZXRob2RzXG4gKiBhcmUgdXNlZCB0byBpbml0aWFsaXplIGEgdmlkZW8uXG4gKlxuICogQWZ0ZXIgYW4gaW5zdGFuY2UgaGFzIGJlZW4gY3JlYXRlZCBpdCBjYW4gYmUgYWNjZXNzZWQgZ2xvYmFsbHkgaW4gdHdvIHdheXM6XG4gKiAxLiBCeSBjYWxsaW5nIGB2aWRlb2pzKCdleGFtcGxlX3ZpZGVvXzEnKTtgXG4gKiAyLiBCeSB1c2luZyBpdCBkaXJlY3RseSB2aWEgIGB2aWRlb2pzLnBsYXllcnMuZXhhbXBsZV92aWRlb18xO2BcbiAqXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcbiAqL1xuXG52YXIgUGxheWVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoUGxheWVyLCBfQ29tcG9uZW50KTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFnXG4gICAqICAgICAgICBUaGUgb3JpZ2luYWwgdmlkZW8gRE9NIGVsZW1lbnQgdXNlZCBmb3IgY29uZmlndXJpbmcgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgICAgICAgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gICAqICAgICAgICBSZWFkeSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIFBsYXllcih0YWcsIG9wdGlvbnMsIHJlYWR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxheWVyKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0YWcgSUQgZXhpc3RzXG4gICAgdGFnLmlkID0gdGFnLmlkIHx8ICd2anNfdmlkZW9fJyArIG5ld0dVSUQoKTtcblxuICAgIC8vIFNldCBPcHRpb25zXG4gICAgLy8gVGhlIG9wdGlvbnMgYXJndW1lbnQgb3ZlcnJpZGVzIG9wdGlvbnMgc2V0IGluIHRoZSB2aWRlbyB0YWdcbiAgICAvLyB3aGljaCBvdmVycmlkZXMgZ2xvYmFsbHkgc2V0IG9wdGlvbnMuXG4gICAgLy8gVGhpcyBsYXR0ZXIgcGFydCBjb2luY2lkZXMgd2l0aCB0aGUgbG9hZCBvcmRlclxuICAgIC8vICh0YWcgbXVzdCBleGlzdCBiZWZvcmUgUGxheWVyKVxuICAgIG9wdGlvbnMgPSBhc3NpZ24oUGxheWVyLmdldFRhZ1NldHRpbmdzKHRhZyksIG9wdGlvbnMpO1xuXG4gICAgLy8gRGVsYXkgdGhlIGluaXRpYWxpemF0aW9uIG9mIGNoaWxkcmVuIGJlY2F1c2Ugd2UgbmVlZCB0byBzZXQgdXBcbiAgICAvLyBwbGF5ZXIgcHJvcGVydGllcyBmaXJzdCwgYW5kIGNhbid0IHVzZSBgdGhpc2AgYmVmb3JlIGBzdXBlcigpYFxuICAgIG9wdGlvbnMuaW5pdENoaWxkcmVuID0gZmFsc2U7XG5cbiAgICAvLyBTYW1lIHdpdGggY3JlYXRpbmcgdGhlIGVsZW1lbnRcbiAgICBvcHRpb25zLmNyZWF0ZUVsID0gZmFsc2U7XG5cbiAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBwbGF5ZXIgdG8gcmVwb3J0IHRvdWNoIGFjdGl2aXR5IG9uIGl0c2VsZlxuICAgIC8vIHNlZSBlbmFibGVUb3VjaEFjdGl2aXR5IGluIENvbXBvbmVudFxuICAgIG9wdGlvbnMucmVwb3J0VG91Y2hBY3Rpdml0eSA9IGZhbHNlO1xuXG4gICAgLy8gSWYgbGFuZ3VhZ2UgaXMgbm90IHNldCwgZ2V0IHRoZSBjbG9zZXN0IGxhbmcgYXR0cmlidXRlXG4gICAgaWYgKCFvcHRpb25zLmxhbmd1YWdlKSB7XG4gICAgICBpZiAodHlwZW9mIHRhZy5jbG9zZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjbG9zZXN0ID0gdGFnLmNsb3Nlc3QoJ1tsYW5nXScpO1xuXG4gICAgICAgIGlmIChjbG9zZXN0KSB7XG4gICAgICAgICAgb3B0aW9ucy5sYW5ndWFnZSA9IGNsb3Nlc3QuZ2V0QXR0cmlidXRlKCdsYW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGFnO1xuXG4gICAgICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICBpZiAoZ2V0QXR0cmlidXRlcyhlbGVtZW50KS5oYXNPd25Qcm9wZXJ0eSgnbGFuZycpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmxhbmd1YWdlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2xhbmcnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUnVuIGJhc2UgY29tcG9uZW50IGluaXRpYWxpemluZyB3aXRoIG5ldyBvcHRpb25zXG5cbiAgICAvLyBUdXJuIG9mZiBBUEkgYWNjZXNzIGJlY2F1c2Ugd2UncmUgbG9hZGluZyBhIG5ldyB0ZWNoIHRoYXQgbWlnaHQgbG9hZCBhc3luY2hyb25vdXNseVxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIG51bGwsIG9wdGlvbnMsIHJlYWR5KSk7XG5cbiAgICBfdGhpcy5pc1JlYWR5XyA9IGZhbHNlO1xuXG4gICAgLy8gaWYgdGhlIGdsb2JhbCBvcHRpb24gb2JqZWN0IHdhcyBhY2NpZGVudGFsbHkgYmxvd24gYXdheSBieVxuICAgIC8vIHNvbWVvbmUsIGJhaWwgZWFybHkgd2l0aCBhbiBpbmZvcm1hdGl2ZSBlcnJvclxuICAgIGlmICghX3RoaXMub3B0aW9uc18gfHwgIV90aGlzLm9wdGlvbnNfLnRlY2hPcmRlciB8fCAhX3RoaXMub3B0aW9uc18udGVjaE9yZGVyLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0ZWNoT3JkZXIgc3BlY2lmaWVkLiBEaWQgeW91IG92ZXJ3cml0ZSAnICsgJ3ZpZGVvanMub3B0aW9ucyBpbnN0ZWFkIG9mIGp1c3QgY2hhbmdpbmcgdGhlICcgKyAncHJvcGVydGllcyB5b3Ugd2FudCB0byBvdmVycmlkZT8nKTtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgdGFnIHVzZWQgdG8gc2V0IG9wdGlvbnNcbiAgICBfdGhpcy50YWcgPSB0YWc7XG5cbiAgICAvLyBTdG9yZSB0aGUgdGFnIGF0dHJpYnV0ZXMgdXNlZCB0byByZXN0b3JlIGh0bWw1IGVsZW1lbnRcbiAgICBfdGhpcy50YWdBdHRyaWJ1dGVzID0gdGFnICYmIGdldEF0dHJpYnV0ZXModGFnKTtcblxuICAgIC8vIFVwZGF0ZSBjdXJyZW50IGxhbmd1YWdlXG4gICAgX3RoaXMubGFuZ3VhZ2UoX3RoaXMub3B0aW9uc18ubGFuZ3VhZ2UpO1xuXG4gICAgLy8gVXBkYXRlIFN1cHBvcnRlZCBMYW5ndWFnZXNcbiAgICBpZiAob3B0aW9ucy5sYW5ndWFnZXMpIHtcbiAgICAgIC8vIE5vcm1hbGlzZSBwbGF5ZXIgb3B0aW9uIGxhbmd1YWdlcyB0byBsb3dlcmNhc2VcbiAgICAgIHZhciBsYW5ndWFnZXNUb0xvd2VyID0ge307XG5cbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9wdGlvbnMubGFuZ3VhZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XG4gICAgICAgIGxhbmd1YWdlc1RvTG93ZXJbbmFtZSQkMS50b0xvd2VyQ2FzZSgpXSA9IG9wdGlvbnMubGFuZ3VhZ2VzW25hbWUkJDFdO1xuICAgICAgfSk7XG4gICAgICBfdGhpcy5sYW5ndWFnZXNfID0gbGFuZ3VhZ2VzVG9Mb3dlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMubGFuZ3VhZ2VzXyA9IFBsYXllci5wcm90b3R5cGUub3B0aW9uc18ubGFuZ3VhZ2VzO1xuICAgIH1cblxuICAgIC8vIENhY2hlIGZvciB2aWRlbyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgX3RoaXMuY2FjaGVfID0ge307XG5cbiAgICAvLyBTZXQgcG9zdGVyXG4gICAgX3RoaXMucG9zdGVyXyA9IG9wdGlvbnMucG9zdGVyIHx8ICcnO1xuXG4gICAgLy8gU2V0IGNvbnRyb2xzXG4gICAgX3RoaXMuY29udHJvbHNfID0gISFvcHRpb25zLmNvbnRyb2xzO1xuXG4gICAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIGZvciBsYXN0Vm9sdW1lXG4gICAgX3RoaXMuY2FjaGVfLmxhc3RWb2x1bWUgPSAxO1xuXG4gICAgLy8gT3JpZ2luYWwgdGFnIHNldHRpbmdzIHN0b3JlZCBpbiBvcHRpb25zXG4gICAgLy8gbm93IHJlbW92ZSBpbW1lZGlhdGVseSBzbyBuYXRpdmUgY29udHJvbHMgZG9uJ3QgZmxhc2guXG4gICAgLy8gTWF5IGJlIHR1cm5lZCBiYWNrIG9uIGJ5IEhUTUw1IHRlY2ggaWYgbmF0aXZlQ29udHJvbHNGb3JUb3VjaCBpcyB0cnVlXG4gICAgdGFnLmNvbnRyb2xzID0gZmFsc2U7XG5cbiAgICAvKlxuICAgICAqIFN0b3JlIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBzY3J1YmJpbmdcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdXNlciBpcyBzY3J1YmJpbmdcbiAgICAgKi9cbiAgICBfdGhpcy5zY3J1YmJpbmdfID0gZmFsc2U7XG5cbiAgICBfdGhpcy5lbF8gPSBfdGhpcy5jcmVhdGVFbCgpO1xuXG4gICAgLy8gTWFrZSB0aGlzIGFuIGV2ZW50ZWQgb2JqZWN0IGFuZCB1c2UgYGVsX2AgYXMgaXRzIGV2ZW50IGJ1cy5cbiAgICBldmVudGVkKF90aGlzLCB7IGV2ZW50QnVzS2V5OiAnZWxfJyB9KTtcblxuICAgIC8vIFdlIGFsc28gd2FudCB0byBwYXNzIHRoZSBvcmlnaW5hbCBwbGF5ZXIgb3B0aW9ucyB0byBlYWNoIGNvbXBvbmVudCBhbmQgcGx1Z2luXG4gICAgLy8gYXMgd2VsbCBzbyB0aGV5IGRvbid0IG5lZWQgdG8gcmVhY2ggYmFjayBpbnRvIHRoZSBwbGF5ZXIgZm9yIG9wdGlvbnMgbGF0ZXIuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIGRvIGFub3RoZXIgY29weSBvZiB0aGlzLm9wdGlvbnNfIHNvIHdlIGRvbid0IGVuZCB1cCB3aXRoXG4gICAgLy8gYW4gaW5maW5pdGUgbG9vcC5cbiAgICB2YXIgcGxheWVyT3B0aW9uc0NvcHkgPSBtZXJnZU9wdGlvbnMoX3RoaXMub3B0aW9uc18pO1xuXG4gICAgLy8gTG9hZCBwbHVnaW5zXG4gICAgaWYgKG9wdGlvbnMucGx1Z2lucykge1xuICAgICAgdmFyIHBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnM7XG5cbiAgICAgIE9iamVjdC5rZXlzKHBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUkJDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzW25hbWUkJDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpc1tuYW1lJCQxXShwbHVnaW5zW25hbWUkJDFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BsdWdpbiBcIicgKyBuYW1lJCQxICsgJ1wiIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sIF90aGlzKTtcbiAgICB9XG5cbiAgICBfdGhpcy5vcHRpb25zXy5wbGF5ZXJPcHRpb25zID0gcGxheWVyT3B0aW9uc0NvcHk7XG5cbiAgICBfdGhpcy5taWRkbGV3YXJlXyA9IFtdO1xuXG4gICAgX3RoaXMuaW5pdENoaWxkcmVuKCk7XG5cbiAgICAvLyBTZXQgaXNBdWRpbyBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCBhbiBhdWRpbyB0YWcgd2FzIHVzZWRcbiAgICBfdGhpcy5pc0F1ZGlvKHRhZy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYXVkaW8nKTtcblxuICAgIC8vIFVwZGF0ZSBjb250cm9scyBjbGFzc05hbWUuIENhbid0IGRvIHRoaXMgd2hlbiB0aGUgY29udHJvbHMgYXJlIGluaXRpYWxseVxuICAgIC8vIHNldCBiZWNhdXNlIHRoZSBlbGVtZW50IGRvZXNuJ3QgZXhpc3QgeWV0LlxuICAgIGlmIChfdGhpcy5jb250cm9scygpKSB7XG4gICAgICBfdGhpcy5hZGRDbGFzcygndmpzLWNvbnRyb2xzLWVuYWJsZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy1jb250cm9scy1kaXNhYmxlZCcpO1xuICAgIH1cblxuICAgIC8vIFNldCBBUklBIGxhYmVsIGFuZCByZWdpb24gcm9sZSBkZXBlbmRpbmcgb24gcGxheWVyIHR5cGVcbiAgICBfdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdyb2xlJywgJ3JlZ2lvbicpO1xuICAgIGlmIChfdGhpcy5pc0F1ZGlvKCkpIHtcbiAgICAgIF90aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBfdGhpcy5sb2NhbGl6ZSgnQXVkaW8gUGxheWVyJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgX3RoaXMubG9jYWxpemUoJ1ZpZGVvIFBsYXllcicpKTtcbiAgICB9XG5cbiAgICBpZiAoX3RoaXMuaXNBdWRpbygpKSB7XG4gICAgICBfdGhpcy5hZGRDbGFzcygndmpzLWF1ZGlvJyk7XG4gICAgfVxuXG4gICAgaWYgKF90aGlzLmZsZXhOb3RTdXBwb3J0ZWRfKCkpIHtcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtbm8tZmxleCcpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IE1ha2UgdGhpcyBzbWFydGVyLiBUb2dnbGUgdXNlciBzdGF0ZSBiZXR3ZWVuIHRvdWNoaW5nL21vdXNpbmdcbiAgICAvLyB1c2luZyBldmVudHMsIHNpbmNlIGRldmljZXMgY2FuIGhhdmUgYm90aCB0b3VjaCBhbmQgbW91c2UgZXZlbnRzLlxuICAgIC8vIGlmIChicm93c2VyLlRPVUNIX0VOQUJMRUQpIHtcbiAgICAvLyAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy10b3VjaC1lbmFibGVkJyk7XG4gICAgLy8gfVxuXG4gICAgLy8gaU9TIFNhZmFyaSBoYXMgYnJva2VuIGhvdmVyIGhhbmRsaW5nXG4gICAgaWYgKCFJU19JT1MpIHtcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtd29ya2luZ2hvdmVyJyk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBwbGF5ZXIgZWFzaWx5IGZpbmRhYmxlIGJ5IElEXG4gICAgUGxheWVyLnBsYXllcnNbX3RoaXMuaWRfXSA9IF90aGlzO1xuXG4gICAgLy8gQWRkIGEgbWFqb3IgdmVyc2lvbiBjbGFzcyB0byBhaWQgY3NzIGluIHBsdWdpbnNcbiAgICB2YXIgbWFqb3JWZXJzaW9uID0gdmVyc2lvbi5zcGxpdCgnLicpWzBdO1xuXG4gICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy12JyArIG1ham9yVmVyc2lvbik7XG5cbiAgICAvLyBXaGVuIHRoZSBwbGF5ZXIgaXMgZmlyc3QgaW5pdGlhbGl6ZWQsIHRyaWdnZXIgYWN0aXZpdHkgc28gY29tcG9uZW50c1xuICAgIC8vIGxpa2UgdGhlIGNvbnRyb2wgYmFyIHNob3cgdGhlbXNlbHZlcyBpZiBuZWVkZWRcbiAgICBfdGhpcy51c2VyQWN0aXZlKHRydWUpO1xuICAgIF90aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSgpO1xuICAgIF90aGlzLmxpc3RlbkZvclVzZXJBY3Rpdml0eV8oKTtcblxuICAgIF90aGlzLm9uKCdmdWxsc2NyZWVuY2hhbmdlJywgX3RoaXMuaGFuZGxlRnVsbHNjcmVlbkNoYW5nZV8pO1xuICAgIF90aGlzLm9uKCdzdGFnZWNsaWNrJywgX3RoaXMuaGFuZGxlU3RhZ2VDbGlja18pO1xuXG4gICAgX3RoaXMuY2hhbmdpbmdTcmNfID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSB2aWRlbyBwbGF5ZXIgYW5kIGRvZXMgYW55IG5lY2Vzc2FyeSBjbGVhbnVwLlxuICAgKlxuICAgKiBUaGlzIGlzIGVzcGVjaWFsbHkgaGVscGZ1bCBpZiB5b3UgYXJlIGR5bmFtaWNhbGx5IGFkZGluZyBhbmQgcmVtb3ZpbmcgdmlkZW9zXG4gICAqIHRvL2Zyb20gdGhlIERPTS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNkaXNwb3NlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgcGxheWVyIGlzIGJlaW5nIGRpc3Bvc2VkIG9mLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNkaXNwb3NlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignZGlzcG9zZScpO1xuICAgIC8vIHByZXZlbnQgZGlzcG9zZSBmcm9tIGJlaW5nIGNhbGxlZCB0d2ljZVxuICAgIHRoaXMub2ZmKCdkaXNwb3NlJyk7XG5cbiAgICBpZiAodGhpcy5zdHlsZUVsXyAmJiB0aGlzLnN0eWxlRWxfLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuc3R5bGVFbF8ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnN0eWxlRWxfKTtcbiAgICB9XG5cbiAgICAvLyBLaWxsIHJlZmVyZW5jZSB0byB0aGlzIHBsYXllclxuICAgIFBsYXllci5wbGF5ZXJzW3RoaXMuaWRfXSA9IG51bGw7XG5cbiAgICBpZiAodGhpcy50YWcgJiYgdGhpcy50YWcucGxheWVyKSB7XG4gICAgICB0aGlzLnRhZy5wbGF5ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVsXyAmJiB0aGlzLmVsXy5wbGF5ZXIpIHtcbiAgICAgIHRoaXMuZWxfLnBsYXllciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHRoaXMudGVjaF8uZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIF9Db21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBgUGxheWVyYCdzIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKiAgICAgICAgIFRoZSBET00gZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnO1xuICAgIHZhciBlbCA9IHZvaWQgMDtcbiAgICB2YXIgcGxheWVyRWxJbmdlc3QgPSB0aGlzLnBsYXllckVsSW5nZXN0XyA9IHRhZy5wYXJlbnROb2RlICYmIHRhZy5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSAmJiB0YWcucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtdmpzLXBsYXllcicpO1xuXG4gICAgaWYgKHBsYXllckVsSW5nZXN0KSB7XG4gICAgICBlbCA9IHRoaXMuZWxfID0gdGFnLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsID0gdGhpcy5lbF8gPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgdGFiaW5kZXggdG8gLTEgc28gd2UgY291bGQgZm9jdXMgb24gdGhlIHBsYXllciBlbGVtZW50XG4gICAgdGFnLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcblxuICAgIC8vIFJlbW92ZSB3aWR0aC9oZWlnaHQgYXR0cnMgZnJvbSB0YWcgc28gQ1NTIGNhbiBtYWtlIGl0IDEwMCUgd2lkdGgvaGVpZ2h0XG4gICAgdGFnLnJlbW92ZUF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICB0YWcucmVtb3ZlQXR0cmlidXRlKCdoZWlnaHQnKTtcblxuICAgIC8vIENvcHkgb3ZlciBhbGwgdGhlIGF0dHJpYnV0ZXMgZnJvbSB0aGUgdGFnLCBpbmNsdWRpbmcgSUQgYW5kIGNsYXNzXG4gICAgLy8gSUQgd2lsbCBub3cgcmVmZXJlbmNlIHBsYXllciBib3gsIG5vdCB0aGUgdmlkZW8gdGFnXG4gICAgdmFyIGF0dHJzID0gZ2V0QXR0cmlidXRlcyh0YWcpO1xuXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgc28gd2UgZG9uJ3QgdG90YWxseSBicmVhayBJRTdcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzY1MzQ0NC9jc3Mtc3R5bGVzLW5vdC1hcHBsaWVkLW9uLWR5bmFtaWMtZWxlbWVudHMtaW4taW50ZXJuZXQtZXhwbG9yZXItN1xuICAgICAgaWYgKGF0dHIgPT09ICdjbGFzcycpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lICs9ICcgJyArIGF0dHJzW2F0dHJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSB0YWcgaWQvY2xhc3MgZm9yIHVzZSBhcyBIVE1MNSBwbGF5YmFjayB0ZWNoXG4gICAgLy8gTWlnaHQgdGhpbmsgd2Ugc2hvdWxkIGRvIHRoaXMgYWZ0ZXIgZW1iZWRkaW5nIGluIGNvbnRhaW5lciBzbyAudmpzLXRlY2ggY2xhc3NcbiAgICAvLyBkb2Vzbid0IGZsYXNoIDEwMCUgd2lkdGgvaGVpZ2h0LCBidXQgY2xhc3Mgb25seSBhcHBsaWVzIHdpdGggLnZpZGVvLWpzIHBhcmVudFxuICAgIHRhZy5wbGF5ZXJJZCA9IHRhZy5pZDtcbiAgICB0YWcuaWQgKz0gJ19odG1sNV9hcGknO1xuICAgIHRhZy5jbGFzc05hbWUgPSAndmpzLXRlY2gnO1xuXG4gICAgLy8gTWFrZSBwbGF5ZXIgZmluZGFibGUgb24gZWxlbWVudHNcbiAgICB0YWcucGxheWVyID0gZWwucGxheWVyID0gdGhpcztcbiAgICAvLyBEZWZhdWx0IHN0YXRlIG9mIHZpZGVvIGlzIHBhdXNlZFxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcblxuICAgIC8vIEFkZCBhIHN0eWxlIGVsZW1lbnQgaW4gdGhlIHBsYXllciB0aGF0IHdlJ2xsIHVzZSB0byBzZXQgdGhlIHdpZHRoL2hlaWdodFxuICAgIC8vIG9mIHRoZSBwbGF5ZXIgaW4gYSB3YXkgdGhhdCdzIHN0aWxsIG92ZXJyaWRlYWJsZSBieSBDU1MsIGp1c3QgbGlrZSB0aGVcbiAgICAvLyB2aWRlbyBlbGVtZW50XG4gICAgaWYgKHdpbmRvdy5WSURFT0pTX05PX0RZTkFNSUNfU1RZTEUgIT09IHRydWUpIHtcbiAgICAgIHRoaXMuc3R5bGVFbF8gPSBjcmVhdGVTdHlsZUVsZW1lbnQoJ3Zqcy1zdHlsZXMtZGltZW5zaW9ucycpO1xuICAgICAgdmFyIGRlZmF1bHRzU3R5bGVFbCA9ICQoJy52anMtc3R5bGVzLWRlZmF1bHRzJyk7XG4gICAgICB2YXIgaGVhZCA9ICQoJ2hlYWQnKTtcblxuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUodGhpcy5zdHlsZUVsXywgZGVmYXVsdHNTdHlsZUVsID8gZGVmYXVsdHNTdHlsZUVsLm5leHRTaWJsaW5nIDogaGVhZC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICAvLyBQYXNzIGluIHRoZSB3aWR0aC9oZWlnaHQvYXNwZWN0UmF0aW8gb3B0aW9ucyB3aGljaCB3aWxsIHVwZGF0ZSB0aGUgc3R5bGUgZWxcbiAgICB0aGlzLndpZHRoKHRoaXMub3B0aW9uc18ud2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0KHRoaXMub3B0aW9uc18uaGVpZ2h0KTtcbiAgICB0aGlzLmZsdWlkKHRoaXMub3B0aW9uc18uZmx1aWQpO1xuICAgIHRoaXMuYXNwZWN0UmF0aW8odGhpcy5vcHRpb25zXy5hc3BlY3RSYXRpbyk7XG5cbiAgICAvLyBIaWRlIGFueSBsaW5rcyB3aXRoaW4gdGhlIHZpZGVvL2F1ZGlvIHRhZywgYmVjYXVzZSBJRSBkb2Vzbid0IGhpZGUgdGhlbSBjb21wbGV0ZWx5LlxuICAgIHZhciBsaW5rcyA9IHRhZy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmtFbCA9IGxpbmtzLml0ZW0oaSk7XG5cbiAgICAgIGFkZENsYXNzKGxpbmtFbCwgJ3Zqcy1oaWRkZW4nKTtcbiAgICAgIGxpbmtFbC5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICdoaWRkZW4nKTtcbiAgICB9XG5cbiAgICAvLyBpbnNlcnRFbEZpcnN0IHNlZW1zIHRvIGNhdXNlIHRoZSBuZXR3b3JrU3RhdGUgdG8gZmxpY2tlciBmcm9tIDMgdG8gMiwgc29cbiAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBvcmlnaW5hbCBmb3IgbGF0ZXIgc28gd2UgY2FuIGtub3cgaWYgdGhlIHNvdXJjZSBvcmlnaW5hbGx5IGZhaWxlZFxuICAgIHRhZy5pbml0TmV0d29ya1N0YXRlXyA9IHRhZy5uZXR3b3JrU3RhdGU7XG5cbiAgICAvLyBXcmFwIHZpZGVvIHRhZyBpbiBkaXYgKGVsL2JveCkgY29udGFpbmVyXG4gICAgaWYgKHRhZy5wYXJlbnROb2RlICYmICFwbGF5ZXJFbEluZ2VzdCkge1xuICAgICAgdGFnLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCB0YWcpO1xuICAgIH1cblxuICAgIC8vIGluc2VydCB0aGUgdGFnIGFzIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgcGxheWVyIGVsZW1lbnRcbiAgICAvLyB0aGVuIG1hbnVhbGx5IGFkZCBpdCB0byB0aGUgY2hpbGRyZW4gYXJyYXkgc28gdGhhdCB0aGlzLmFkZENoaWxkXG4gICAgLy8gd2lsbCB3b3JrIHByb3Blcmx5IGZvciBvdGhlciBjb21wb25lbnRzXG4gICAgLy9cbiAgICAvLyBCcmVha3MgaVBob25lLCBmaXhlZCBpbiBIVE1MNSBzZXR1cC5cbiAgICBwcmVwZW5kVG8odGFnLCBlbCk7XG4gICAgdGhpcy5jaGlsZHJlbl8udW5zaGlmdCh0YWcpO1xuXG4gICAgLy8gU2V0IGxhbmcgYXR0ciBvbiBwbGF5ZXIgdG8gZW5zdXJlIENTUyA6bGFuZygpIGluIGNvbnNpc3RlbnQgd2l0aCBwbGF5ZXJcbiAgICAvLyBpZiBpdCdzIGJlZW4gc2V0IHRvIHNvbWV0aGluZyBkaWZmZXJlbnQgdG8gdGhlIGRvY1xuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnbGFuZycsIHRoaXMubGFuZ3VhZ2VfKTtcblxuICAgIHRoaXMuZWxfID0gZWw7XG5cbiAgICByZXR1cm4gZWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBQbGF5ZXJgJ3Mgd2lkdGguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWVdXG4gICAqICAgICAgICBUaGUgdmFsdWUgdG8gc2V0IHRoZSBgUGxheWVyJ3Mgd2lkdGggdG8uXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB3aWR0aCBvZiB0aGUgYFBsYXllcmAgd2hlbiBnZXR0aW5nLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbiB3aWR0aCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbignd2lkdGgnLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBQbGF5ZXJgJ3MgaGVpZ2h0LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ZhbHVlXVxuICAgKiAgICAgICAgVGhlIHZhbHVlIHRvIHNldCB0aGUgYFBsYXllcidzIGhlaWd0aCB0by5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgYFBsYXllcmAgd2hlbiBnZXR0aW5nLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gaGVpZ2h0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGltZW5zaW9uKCdoZWlnaHQnLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBQbGF5ZXJgJ3Mgd2lkdGggJiBoZWlnaHQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaW1lbnNpb25cbiAgICogICAgICAgIFRoaXMgc3RyaW5nIGNhbiBiZTpcbiAgICogICAgICAgIC0gJ3dpZHRoJ1xuICAgKiAgICAgICAgLSAnaGVpZ2h0J1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ZhbHVlXVxuICAgKiAgICAgICAgVmFsdWUgZm9yIGRpbWVuc2lvbiBzcGVjaWZpZWQgaW4gdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgVGhlIGRpbWVuc2lvbiBhcmd1bWVudHMgdmFsdWUgd2hlbiBnZXR0aW5nICh3aWR0aC9oZWlnaHQpLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gZGltZW5zaW9uKF9kaW1lbnNpb24sIHZhbHVlKSB7XG4gICAgdmFyIHByaXZEaW1lbnNpb24gPSBfZGltZW5zaW9uICsgJ18nO1xuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzW3ByaXZEaW1lbnNpb25dIHx8IDA7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgLy8gSWYgYW4gZW1wdHkgc3RyaW5nIGlzIGdpdmVuLCByZXNldCB0aGUgZGltZW5zaW9uIHRvIGJlIGF1dG9tYXRpY1xuICAgICAgdGhpc1twcml2RGltZW5zaW9uXSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnNlZFZhbCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgICBpZiAoaXNOYU4ocGFyc2VkVmFsKSkge1xuICAgICAgICBsb2ckMS5lcnJvcignSW1wcm9wZXIgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgc3VwcGxpZWQgZm9yIGZvciAnICsgX2RpbWVuc2lvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpc1twcml2RGltZW5zaW9uXSA9IHBhcnNlZFZhbDtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVN0eWxlRWxfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlci90b2dnbGVyIGZvciB0aGUgdmpzLWZsdWlkIGBjbGFzc05hbWVgIG9uIHRoZSBgUGxheWVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbF1cbiAgICogICAgICAgIC0gQSB2YWx1ZSBvZiB0cnVlIGFkZHMgdGhlIGNsYXNzLlxuICAgKiAgICAgICAgLSBBIHZhbHVlIG9mIGZhbHNlIHJlbW92ZXMgdGhlIGNsYXNzLlxuICAgKiAgICAgICAgLSBObyB2YWx1ZSB3aWxsIHRvZ2dsZSB0aGUgZmx1aWQgY2xhc3MuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGZsdWlkIHdoZW4gZ2V0dGluZy5cbiAgICogICAgICAgICAtIGB1bmRlZmluZWRgIHdoZW4gc2V0dGluZy5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmZsdWlkID0gZnVuY3Rpb24gZmx1aWQoYm9vbCkge1xuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuZmx1aWRfO1xuICAgIH1cblxuICAgIHRoaXMuZmx1aWRfID0gISFib29sO1xuXG4gICAgaWYgKGJvb2wpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1mbHVpZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZmx1aWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVN0eWxlRWxfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldC9TZXQgdGhlIGFzcGVjdCByYXRpb1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JhdGlvXVxuICAgKiAgICAgICAgQXNwZWN0IHJhdGlvIGZvciBwbGF5ZXJcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICogICAgICAgICByZXR1cm5zIHRoZSBjdXJyZW50IGFzcGVjdCByYXRpbyB3aGVuIGdldHRpbmdcbiAgICovXG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBQbGF5ZXJgJ3MgYXNwZWN0IHJhdGlvLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JhdGlvXVxuICAgKiAgICAgICAgVGhlIHZhbHVlIHRvIHNldCB0aGUgYFBsYXllcidzIGFzcGVjdCByYXRpbyB0by5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICogICAgICAgICAtIFRoZSBjdXJyZW50IGFzcGVjdCByYXRpbyBvZiB0aGUgYFBsYXllcmAgd2hlbiBnZXR0aW5nLlxuICAgKiAgICAgICAgIC0gdW5kZWZpbmVkIHdoZW4gc2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYXNwZWN0UmF0aW8gPSBmdW5jdGlvbiBhc3BlY3RSYXRpbyhyYXRpbykge1xuICAgIGlmIChyYXRpbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5hc3BlY3RSYXRpb187XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHdpZHRoOmhlaWdodCBmb3JtYXRcbiAgICBpZiAoIS9eXFxkK1xcOlxcZCskLy50ZXN0KHJhdGlvKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXByb3BlciB2YWx1ZSBzdXBwbGllZCBmb3IgYXNwZWN0IHJhdGlvLiBUaGUgZm9ybWF0IHNob3VsZCBiZSB3aWR0aDpoZWlnaHQsIGZvciBleGFtcGxlIDE2OjkuJyk7XG4gICAgfVxuICAgIHRoaXMuYXNwZWN0UmF0aW9fID0gcmF0aW87XG5cbiAgICAvLyBXZSdyZSBhc3N1bWluZyBpZiB5b3Ugc2V0IGFuIGFzcGVjdCByYXRpbyB5b3Ugd2FudCBmbHVpZCBtb2RlLFxuICAgIC8vIGJlY2F1c2UgaW4gZml4ZWQgbW9kZSB5b3UgY291bGQgY2FsY3VsYXRlIHdpZHRoIGFuZCBoZWlnaHQgeW91cnNlbGYuXG4gICAgdGhpcy5mbHVpZCh0cnVlKTtcblxuICAgIHRoaXMudXBkYXRlU3R5bGVFbF8oKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHN0eWxlcyBvZiB0aGUgYFBsYXllcmAgZWxlbWVudCAoaGVpZ2h0LCB3aWR0aCBhbmQgYXNwZWN0IHJhdGlvKS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGxpc3RlbnMgVGVjaCNsb2FkZWRtZXRhZGF0YVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudXBkYXRlU3R5bGVFbF8gPSBmdW5jdGlvbiB1cGRhdGVTdHlsZUVsXygpIHtcbiAgICBpZiAod2luZG93LlZJREVPSlNfTk9fRFlOQU1JQ19TVFlMRSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIF93aWR0aCA9IHR5cGVvZiB0aGlzLndpZHRoXyA9PT0gJ251bWJlcicgPyB0aGlzLndpZHRoXyA6IHRoaXMub3B0aW9uc18ud2lkdGg7XG4gICAgICB2YXIgX2hlaWdodCA9IHR5cGVvZiB0aGlzLmhlaWdodF8gPT09ICdudW1iZXInID8gdGhpcy5oZWlnaHRfIDogdGhpcy5vcHRpb25zXy5oZWlnaHQ7XG4gICAgICB2YXIgdGVjaEVsID0gdGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLmVsKCk7XG5cbiAgICAgIGlmICh0ZWNoRWwpIHtcbiAgICAgICAgaWYgKF93aWR0aCA+PSAwKSB7XG4gICAgICAgICAgdGVjaEVsLndpZHRoID0gX3dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfaGVpZ2h0ID49IDApIHtcbiAgICAgICAgICB0ZWNoRWwuaGVpZ2h0ID0gX2hlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdpZHRoID0gdm9pZCAwO1xuICAgIHZhciBoZWlnaHQgPSB2b2lkIDA7XG4gICAgdmFyIGFzcGVjdFJhdGlvID0gdm9pZCAwO1xuICAgIHZhciBpZENsYXNzID0gdm9pZCAwO1xuXG4gICAgLy8gVGhlIGFzcGVjdCByYXRpbyBpcyBlaXRoZXIgdXNlZCBkaXJlY3RseSBvciB0byBjYWxjdWxhdGUgd2lkdGggYW5kIGhlaWdodC5cbiAgICBpZiAodGhpcy5hc3BlY3RSYXRpb18gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmFzcGVjdFJhdGlvXyAhPT0gJ2F1dG8nKSB7XG4gICAgICAvLyBVc2UgYW55IGFzcGVjdFJhdGlvIHRoYXQncyBiZWVuIHNwZWNpZmljYWxseSBzZXRcbiAgICAgIGFzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpb187XG4gICAgfSBlbHNlIGlmICh0aGlzLnZpZGVvV2lkdGgoKSA+IDApIHtcbiAgICAgIC8vIE90aGVyd2lzZSB0cnkgdG8gZ2V0IHRoZSBhc3BlY3QgcmF0aW8gZnJvbSB0aGUgdmlkZW8gbWV0YWRhdGFcbiAgICAgIGFzcGVjdFJhdGlvID0gdGhpcy52aWRlb1dpZHRoKCkgKyAnOicgKyB0aGlzLnZpZGVvSGVpZ2h0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9yIHVzZSBhIGRlZmF1bHQuIFRoZSB2aWRlbyBlbGVtZW50J3MgaXMgMjoxLCBidXQgMTY6OSBpcyBtb3JlIGNvbW1vbi5cbiAgICAgIGFzcGVjdFJhdGlvID0gJzE2OjknO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgcmF0aW8gYXMgYSBkZWNpbWFsIHdlIGNhbiB1c2UgdG8gY2FsY3VsYXRlIGRpbWVuc2lvbnNcbiAgICB2YXIgcmF0aW9QYXJ0cyA9IGFzcGVjdFJhdGlvLnNwbGl0KCc6Jyk7XG4gICAgdmFyIHJhdGlvTXVsdGlwbGllciA9IHJhdGlvUGFydHNbMV0gLyByYXRpb1BhcnRzWzBdO1xuXG4gICAgaWYgKHRoaXMud2lkdGhfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFVzZSBhbnkgd2lkdGggdGhhdCdzIGJlZW4gc3BlY2lmaWNhbGx5IHNldFxuICAgICAgd2lkdGggPSB0aGlzLndpZHRoXztcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGVpZ2h0XyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBPciBjYWx1bGF0ZSB0aGUgd2lkdGggZnJvbSB0aGUgYXNwZWN0IHJhdGlvIGlmIGEgaGVpZ2h0IGhhcyBiZWVuIHNldFxuICAgICAgd2lkdGggPSB0aGlzLmhlaWdodF8gLyByYXRpb011bHRpcGxpZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9yIHVzZSB0aGUgdmlkZW8ncyBtZXRhZGF0YSwgb3IgdXNlIHRoZSB2aWRlbyBlbCdzIGRlZmF1bHQgb2YgMzAwXG4gICAgICB3aWR0aCA9IHRoaXMudmlkZW9XaWR0aCgpIHx8IDMwMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oZWlnaHRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFVzZSBhbnkgaGVpZ2h0IHRoYXQncyBiZWVuIHNwZWNpZmljYWxseSBzZXRcbiAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0XztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IGZyb20gdGhlIHJhdGlvIGFuZCB0aGUgd2lkdGhcbiAgICAgIGhlaWdodCA9IHdpZHRoICogcmF0aW9NdWx0aXBsaWVyO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGUgQ1NTIGNsYXNzIGlzIHZhbGlkIGJ5IHN0YXJ0aW5nIHdpdGggYW4gYWxwaGEgY2hhcmFjdGVyXG4gICAgaWYgKC9eW15hLXpBLVpdLy50ZXN0KHRoaXMuaWQoKSkpIHtcbiAgICAgIGlkQ2xhc3MgPSAnZGltZW5zaW9ucy0nICsgdGhpcy5pZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZENsYXNzID0gdGhpcy5pZCgpICsgJy1kaW1lbnNpb25zJztcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhlIHJpZ2h0IGNsYXNzIGlzIHN0aWxsIG9uIHRoZSBwbGF5ZXIgZm9yIHRoZSBzdHlsZSBlbGVtZW50XG4gICAgdGhpcy5hZGRDbGFzcyhpZENsYXNzKTtcblxuICAgIHNldFRleHRDb250ZW50KHRoaXMuc3R5bGVFbF8sICdcXG4gICAgICAuJyArIGlkQ2xhc3MgKyAnIHtcXG4gICAgICAgIHdpZHRoOiAnICsgd2lkdGggKyAncHg7XFxuICAgICAgICBoZWlnaHQ6ICcgKyBoZWlnaHQgKyAncHg7XFxuICAgICAgfVxcblxcbiAgICAgIC4nICsgaWRDbGFzcyArICcudmpzLWZsdWlkIHtcXG4gICAgICAgIHBhZGRpbmctdG9wOiAnICsgcmF0aW9NdWx0aXBsaWVyICogMTAwICsgJyU7XFxuICAgICAgfVxcbiAgICAnKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9hZC9DcmVhdGUgYW4gaW5zdGFuY2Ugb2YgcGxheWJhY2sge0BsaW5rIFRlY2h9IGluY2x1ZGluZyBlbGVtZW50XG4gICAqIGFuZCBBUEkgbWV0aG9kcy4gVGhlbiBhcHBlbmQgdGhlIGBUZWNoYCBlbGVtZW50IGluIGBQbGF5ZXJgIGFzIGEgY2hpbGQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZWNoTmFtZVxuICAgKiAgICAgICAgbmFtZSBvZiB0aGUgcGxheWJhY2sgdGVjaG5vbG9neVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlXG4gICAqICAgICAgICB2aWRlbyBzb3VyY2VcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmxvYWRUZWNoXyA9IGZ1bmN0aW9uIGxvYWRUZWNoXyh0ZWNoTmFtZSwgc291cmNlKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBQYXVzZSBhbmQgcmVtb3ZlIGN1cnJlbnQgcGxheWJhY2sgdGVjaG5vbG9neVxuICAgIGlmICh0aGlzLnRlY2hfKSB7XG4gICAgICB0aGlzLnVubG9hZFRlY2hfKCk7XG4gICAgfVxuXG4gICAgdmFyIHRpdGxlVGVjaE5hbWUgPSB0b1RpdGxlQ2FzZSh0ZWNoTmFtZSk7XG4gICAgdmFyIGNhbWVsVGVjaE5hbWUgPSB0ZWNoTmFtZS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHRlY2hOYW1lLnNsaWNlKDEpO1xuXG4gICAgLy8gZ2V0IHJpZCBvZiB0aGUgSFRNTDUgdmlkZW8gdGFnIGFzIHNvb24gYXMgd2UgYXJlIHVzaW5nIGFub3RoZXIgdGVjaFxuICAgIGlmICh0aXRsZVRlY2hOYW1lICE9PSAnSHRtbDUnICYmIHRoaXMudGFnKSB7XG4gICAgICBUZWNoLmdldFRlY2goJ0h0bWw1JykuZGlzcG9zZU1lZGlhRWxlbWVudCh0aGlzLnRhZyk7XG4gICAgICB0aGlzLnRhZy5wbGF5ZXIgPSBudWxsO1xuICAgICAgdGhpcy50YWcgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMudGVjaE5hbWVfID0gdGl0bGVUZWNoTmFtZTtcblxuICAgIC8vIFR1cm4gb2ZmIEFQSSBhY2Nlc3MgYmVjYXVzZSB3ZSdyZSBsb2FkaW5nIGEgbmV3IHRlY2ggdGhhdCBtaWdodCBsb2FkIGFzeW5jaHJvbm91c2x5XG4gICAgdGhpcy5pc1JlYWR5XyA9IGZhbHNlO1xuXG4gICAgLy8gR3JhYiB0ZWNoLXNwZWNpZmljIG9wdGlvbnMgZnJvbSBwbGF5ZXIgb3B0aW9ucyBhbmQgYWRkIHNvdXJjZSBhbmQgcGFyZW50IGVsZW1lbnQgdG8gdXNlLlxuICAgIHZhciB0ZWNoT3B0aW9ucyA9IHtcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgJ25hdGl2ZUNvbnRyb2xzRm9yVG91Y2gnOiB0aGlzLm9wdGlvbnNfLm5hdGl2ZUNvbnRyb2xzRm9yVG91Y2gsXG4gICAgICAncGxheWVySWQnOiB0aGlzLmlkKCksXG4gICAgICAndGVjaElkJzogdGhpcy5pZCgpICsgJ18nICsgdGl0bGVUZWNoTmFtZSArICdfYXBpJyxcbiAgICAgICdhdXRvcGxheSc6IHRoaXMub3B0aW9uc18uYXV0b3BsYXksXG4gICAgICAncGxheXNpbmxpbmUnOiB0aGlzLm9wdGlvbnNfLnBsYXlzaW5saW5lLFxuICAgICAgJ3ByZWxvYWQnOiB0aGlzLm9wdGlvbnNfLnByZWxvYWQsXG4gICAgICAnbG9vcCc6IHRoaXMub3B0aW9uc18ubG9vcCxcbiAgICAgICdtdXRlZCc6IHRoaXMub3B0aW9uc18ubXV0ZWQsXG4gICAgICAncG9zdGVyJzogdGhpcy5wb3N0ZXIoKSxcbiAgICAgICdsYW5ndWFnZSc6IHRoaXMubGFuZ3VhZ2UoKSxcbiAgICAgICdwbGF5ZXJFbEluZ2VzdCc6IHRoaXMucGxheWVyRWxJbmdlc3RfIHx8IGZhbHNlLFxuICAgICAgJ3Z0dC5qcyc6IHRoaXMub3B0aW9uc19bJ3Z0dC5qcyddXG4gICAgfTtcblxuICAgIEFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XG4gICAgICB2YXIgcHJvcHMgPSBBTExbbmFtZSQkMV07XG5cbiAgICAgIHRlY2hPcHRpb25zW3Byb3BzLmdldHRlck5hbWVdID0gX3RoaXMyW3Byb3BzLnByaXZhdGVOYW1lXTtcbiAgICB9KTtcblxuICAgIGFzc2lnbih0ZWNoT3B0aW9ucywgdGhpcy5vcHRpb25zX1t0aXRsZVRlY2hOYW1lXSk7XG4gICAgYXNzaWduKHRlY2hPcHRpb25zLCB0aGlzLm9wdGlvbnNfW2NhbWVsVGVjaE5hbWVdKTtcbiAgICBhc3NpZ24odGVjaE9wdGlvbnMsIHRoaXMub3B0aW9uc19bdGVjaE5hbWUudG9Mb3dlckNhc2UoKV0pO1xuXG4gICAgaWYgKHRoaXMudGFnKSB7XG4gICAgICB0ZWNoT3B0aW9ucy50YWcgPSB0aGlzLnRhZztcbiAgICB9XG5cbiAgICBpZiAoc291cmNlICYmIHNvdXJjZS5zcmMgPT09IHRoaXMuY2FjaGVfLnNyYyAmJiB0aGlzLmNhY2hlXy5jdXJyZW50VGltZSA+IDApIHtcbiAgICAgIHRlY2hPcHRpb25zLnN0YXJ0VGltZSA9IHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdGVjaCBpbnN0YW5jZVxuICAgIHZhciBUZWNoQ2xhc3MgPSBUZWNoLmdldFRlY2godGVjaE5hbWUpO1xuXG4gICAgaWYgKCFUZWNoQ2xhc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gVGVjaCBuYW1lZCBcXCcnICsgdGl0bGVUZWNoTmFtZSArICdcXCcgZXhpc3RzISBcXCcnICsgdGl0bGVUZWNoTmFtZSArICdcXCcgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgdXNpbmcgdmlkZW9qcy5yZWdpc3RlclRlY2goKVxcJycpO1xuICAgIH1cblxuICAgIHRoaXMudGVjaF8gPSBuZXcgVGVjaENsYXNzKHRlY2hPcHRpb25zKTtcblxuICAgIC8vIHBsYXllci50cmlnZ2VyUmVhZHkgaXMgYWx3YXlzIGFzeW5jLCBzbyBkb24ndCBuZWVkIHRoaXMgdG8gYmUgYXN5bmNcbiAgICB0aGlzLnRlY2hfLnJlYWR5KGJpbmQodGhpcywgdGhpcy5oYW5kbGVUZWNoUmVhZHlfKSwgdHJ1ZSk7XG5cbiAgICB0ZXh0VHJhY2tDb252ZXJ0ZXIuanNvblRvVGV4dFRyYWNrcyh0aGlzLnRleHRUcmFja3NKc29uXyB8fCBbXSwgdGhpcy50ZWNoXyk7XG5cbiAgICAvLyBMaXN0ZW4gdG8gYWxsIEhUTUw1LWRlZmluZWQgZXZlbnRzIGFuZCB0cmlnZ2VyIHRoZW0gb24gdGhlIHBsYXllclxuICAgIFRFQ0hfRVZFTlRTX1JFVFJJR0dFUi5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgX3RoaXMyLm9uKF90aGlzMi50ZWNoXywgZXZlbnQsIF90aGlzMlsnaGFuZGxlVGVjaCcgKyB0b1RpdGxlQ2FzZShldmVudCkgKyAnXyddKTtcbiAgICB9KTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdsb2Fkc3RhcnQnLCB0aGlzLmhhbmRsZVRlY2hMb2FkU3RhcnRfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd3YWl0aW5nJywgdGhpcy5oYW5kbGVUZWNoV2FpdGluZ18pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2NhbnBsYXknLCB0aGlzLmhhbmRsZVRlY2hDYW5QbGF5Xyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnY2FucGxheXRocm91Z2gnLCB0aGlzLmhhbmRsZVRlY2hDYW5QbGF5VGhyb3VnaF8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3BsYXlpbmcnLCB0aGlzLmhhbmRsZVRlY2hQbGF5aW5nXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZW5kZWQnLCB0aGlzLmhhbmRsZVRlY2hFbmRlZF8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3NlZWtpbmcnLCB0aGlzLmhhbmRsZVRlY2hTZWVraW5nXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnc2Vla2VkJywgdGhpcy5oYW5kbGVUZWNoU2Vla2VkXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAncGxheScsIHRoaXMuaGFuZGxlVGVjaFBsYXlfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdmaXJzdHBsYXknLCB0aGlzLmhhbmRsZVRlY2hGaXJzdFBsYXlfKTtcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdwYXVzZScsIHRoaXMuaGFuZGxlVGVjaFBhdXNlXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZHVyYXRpb25jaGFuZ2UnLCB0aGlzLmhhbmRsZVRlY2hEdXJhdGlvbkNoYW5nZV8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2Z1bGxzY3JlZW5jaGFuZ2UnLCB0aGlzLmhhbmRsZVRlY2hGdWxsc2NyZWVuQ2hhbmdlXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnZXJyb3InLCB0aGlzLmhhbmRsZVRlY2hFcnJvcl8pO1xuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2xvYWRlZG1ldGFkYXRhJywgdGhpcy51cGRhdGVTdHlsZUVsXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAncG9zdGVyY2hhbmdlJywgdGhpcy5oYW5kbGVUZWNoUG9zdGVyQ2hhbmdlXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndGV4dGRhdGEnLCB0aGlzLmhhbmRsZVRlY2hUZXh0RGF0YV8pO1xuXG4gICAgdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKHRoaXMudGVjaEdldF8oJ2NvbnRyb2xzJykpO1xuXG4gICAgaWYgKHRoaXMuY29udHJvbHMoKSAmJiAhdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKCkpIHtcbiAgICAgIHRoaXMuYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgdGVjaCBlbGVtZW50IGluIHRoZSBET00gaWYgaXQgd2FzIG5vdCBhbHJlYWR5IHRoZXJlXG4gICAgLy8gTWFrZSBzdXJlIHRvIG5vdCBpbnNlcnQgdGhlIG9yaWdpbmFsIHZpZGVvIGVsZW1lbnQgaWYgdXNpbmcgSHRtbDVcbiAgICBpZiAodGhpcy50ZWNoXy5lbCgpLnBhcmVudE5vZGUgIT09IHRoaXMuZWwoKSAmJiAodGl0bGVUZWNoTmFtZSAhPT0gJ0h0bWw1JyB8fCAhdGhpcy50YWcpKSB7XG4gICAgICBwcmVwZW5kVG8odGhpcy50ZWNoXy5lbCgpLCB0aGlzLmVsKCkpO1xuICAgIH1cblxuICAgIC8vIEdldCByaWQgb2YgdGhlIG9yaWdpbmFsIHZpZGVvIHRhZyByZWZlcmVuY2UgYWZ0ZXIgdGhlIGZpcnN0IHRlY2ggaXMgbG9hZGVkXG4gICAgaWYgKHRoaXMudGFnKSB7XG4gICAgICB0aGlzLnRhZy5wbGF5ZXIgPSBudWxsO1xuICAgICAgdGhpcy50YWcgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVW5sb2FkIGFuZCBkaXNwb3NlIG9mIHRoZSBjdXJyZW50IHBsYXliYWNrIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnVubG9hZFRlY2hfID0gZnVuY3Rpb24gdW5sb2FkVGVjaF8oKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHRleHQgdHJhY2tzIHNvIHRoYXQgd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRleHQgdHJhY2tzIHdpdGggdGhlIG5leHQgdGVjaFxuICAgIEFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XG4gICAgICB2YXIgcHJvcHMgPSBBTExbbmFtZSQkMV07XG5cbiAgICAgIF90aGlzM1twcm9wcy5wcml2YXRlTmFtZV0gPSBfdGhpczNbcHJvcHMuZ2V0dGVyTmFtZV0oKTtcbiAgICB9KTtcbiAgICB0aGlzLnRleHRUcmFja3NKc29uXyA9IHRleHRUcmFja0NvbnZlcnRlci50ZXh0VHJhY2tzVG9Kc29uKHRoaXMudGVjaF8pO1xuXG4gICAgdGhpcy5pc1JlYWR5XyA9IGZhbHNlO1xuXG4gICAgdGhpcy50ZWNoXy5kaXNwb3NlKCk7XG5cbiAgICB0aGlzLnRlY2hfID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCB7QGxpbmsgVGVjaH0uXG4gICAqIEl0IHdpbGwgcHJpbnQgYSB3YXJuaW5nIGJ5IGRlZmF1bHQgYWJvdXQgdGhlIGRhbmdlciBvZiB1c2luZyB0aGUgdGVjaCBkaXJlY3RseVxuICAgKiBidXQgYW55IGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIGluIHdpbGwgc2lsZW5jZSB0aGUgd2FybmluZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBbc2FmZXR5XVxuICAgKiAgICAgICAgQW55dGhpbmcgcGFzc2VkIGluIHRvIHNpbGVuY2UgdGhlIHdhcm5pbmdcbiAgICpcbiAgICogQHJldHVybiB7VGVjaH1cbiAgICogICAgICAgICBUaGUgVGVjaFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudGVjaCA9IGZ1bmN0aW9uIHRlY2goc2FmZXR5KSB7XG4gICAgaWYgKHNhZmV0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2ckMS53YXJuKHRzbWwoX3RlbXBsYXRlT2JqZWN0JDEpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50ZWNoXztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHVwIGNsaWNrIGFuZCB0b3VjaCBsaXN0ZW5lcnMgZm9yIHRoZSBwbGF5YmFjayBlbGVtZW50XG4gICAqXG4gICAqIC0gT24gZGVza3RvcHM6IGEgY2xpY2sgb24gdGhlIHZpZGVvIGl0c2VsZiB3aWxsIHRvZ2dsZSBwbGF5YmFja1xuICAgKiAtIE9uIG1vYmlsZSBkZXZpY2VzOiBhIGNsaWNrIG9uIHRoZSB2aWRlbyB0b2dnbGVzIGNvbnRyb2xzXG4gICAqICAgd2hpY2ggaXMgZG9uZSBieSB0b2dnbGluZyB0aGUgdXNlciBzdGF0ZSBiZXR3ZWVuIGFjdGl2ZSBhbmRcbiAgICogICBpbmFjdGl2ZVxuICAgKiAtIEEgdGFwIGNhbiBzaWduYWwgdGhhdCBhIHVzZXIgaGFzIGJlY29tZSBhY3RpdmUgb3IgaGFzIGJlY29tZSBpbmFjdGl2ZVxuICAgKiAgIGUuZy4gYSBxdWljayB0YXAgb24gYW4gaVBob25lIG1vdmllIHNob3VsZCByZXZlYWwgdGhlIGNvbnRyb2xzLiBBbm90aGVyXG4gICAqICAgcXVpY2sgdGFwIHNob3VsZCBoaWRlIHRoZW0gYWdhaW4gKHNpZ25hbGluZyB0aGUgdXNlciBpcyBpbiBhbiBpbmFjdGl2ZVxuICAgKiAgIHZpZXdpbmcgc3RhdGUpXG4gICAqIC0gSW4gYWRkaXRpb24gdG8gdGhpcywgd2Ugc3RpbGwgd2FudCB0aGUgdXNlciB0byBiZSBjb25zaWRlcmVkIGluYWN0aXZlIGFmdGVyXG4gICAqICAgYSBmZXcgc2Vjb25kcyBvZiBpbmFjdGl2aXR5LlxuICAgKlxuICAgKiA+IE5vdGU6IHRoZSBvbmx5IHBhcnQgb2YgaU9TIGludGVyYWN0aW9uIHdlIGNhbid0IG1pbWljIHdpdGggdGhpcyBzZXR1cFxuICAgKiBpcyBhIHRvdWNoIGFuZCBob2xkIG9uIHRoZSB2aWRlbyBlbGVtZW50IGNvdW50aW5nIGFzIGFjdGl2aXR5IGluIG9yZGVyIHRvXG4gICAqIGtlZXAgdGhlIGNvbnRyb2xzIHNob3dpbmcsIGJ1dCB0aGF0IHNob3VsZG4ndCBiZSBhbiBpc3N1ZS4gQSB0b3VjaCBhbmQgaG9sZFxuICAgKiBvbiBhbnkgY29udHJvbHMgd2lsbCBzdGlsbCBrZWVwIHRoZSB1c2VyIGFjdGl2ZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzXyA9IGZ1bmN0aW9uIGFkZFRlY2hDb250cm9sc0xpc3RlbmVyc18oKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRvIHJlbW92ZSBhbGwgdGhlIHByZXZpb3VzIGxpc3RlbmVycyBpbiBjYXNlIHdlIGFyZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gICAgdGhpcy5yZW1vdmVUZWNoQ29udHJvbHNMaXN0ZW5lcnNfKCk7XG5cbiAgICAvLyBTb21lIGJyb3dzZXJzIChDaHJvbWUgJiBJRSkgZG9uJ3QgdHJpZ2dlciBhIGNsaWNrIG9uIGEgZmxhc2ggc3dmLCBidXQgZG9cbiAgICAvLyB0cmlnZ2VyIG1vdXNlZG93bi91cC5cbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0NDQ1NjIvamF2YXNjcmlwdC1vbmNsaWNrLWV2ZW50LW92ZXItZmxhc2gtb2JqZWN0XG4gICAgLy8gQW55IHRvdWNoIGV2ZW50cyBhcmUgc2V0IHRvIGJsb2NrIHRoZSBtb3VzZWRvd24gZXZlbnQgZnJvbSBoYXBwZW5pbmdcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZVRlY2hDbGlja18pO1xuXG4gICAgLy8gSWYgdGhlIGNvbnRyb2xzIHdlcmUgaGlkZGVuIHdlIGRvbid0IHdhbnQgdGhhdCB0byBjaGFuZ2Ugd2l0aG91dCBhIHRhcCBldmVudFxuICAgIC8vIHNvIHdlJ2xsIGNoZWNrIGlmIHRoZSBjb250cm9scyB3ZXJlIGFscmVhZHkgc2hvd2luZyBiZWZvcmUgcmVwb3J0aW5nIHVzZXJcbiAgICAvLyBhY3Rpdml0eVxuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaFN0YXJ0Xyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUZWNoVG91Y2hNb3ZlXyk7XG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaEVuZF8pO1xuXG4gICAgLy8gVGhlIHRhcCBsaXN0ZW5lciBuZWVkcyB0byBjb21lIGFmdGVyIHRoZSB0b3VjaGVuZCBsaXN0ZW5lciBiZWNhdXNlIHRoZSB0YXBcbiAgICAvLyBsaXN0ZW5lciBjYW5jZWxzIG91dCBhbnkgcmVwb3J0ZWRVc2VyQWN0aXZpdHkgd2hlbiBzZXR0aW5nIHVzZXJBY3RpdmUoZmFsc2UpXG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndGFwJywgdGhpcy5oYW5kbGVUZWNoVGFwXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIHVzZWQgZm9yIGNsaWNrIGFuZCB0YXAgY29udHJvbHMuIFRoaXMgaXMgbmVlZGVkIGZvclxuICAgKiB0b2dnbGluZyB0byBjb250cm9scyBkaXNhYmxlZCwgd2hlcmUgYSB0YXAvdG91Y2ggc2hvdWxkIGRvIG5vdGhpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZW1vdmVUZWNoQ29udHJvbHNMaXN0ZW5lcnNfID0gZnVuY3Rpb24gcmVtb3ZlVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpIHtcbiAgICAvLyBXZSBkb24ndCB3YW50IHRvIGp1c3QgdXNlIGB0aGlzLm9mZigpYCBiZWNhdXNlIHRoZXJlIG1pZ2h0IGJlIG90aGVyIG5lZWRlZFxuICAgIC8vIGxpc3RlbmVycyBhZGRlZCBieSB0ZWNocyB0aGF0IGV4dGVuZCB0aGlzLlxuICAgIHRoaXMub2ZmKHRoaXMudGVjaF8sICd0YXAnLCB0aGlzLmhhbmRsZVRlY2hUYXBfKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVGVjaFRvdWNoU3RhcnRfKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUZWNoVG91Y2hNb3ZlXyk7XG4gICAgdGhpcy5vZmYodGhpcy50ZWNoXywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUZWNoVG91Y2hFbmRfKTtcbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAnbW91c2Vkb3duJywgdGhpcy5oYW5kbGVUZWNoQ2xpY2tfKTtcbiAgfTtcblxuICAvKipcbiAgICogUGxheWVyIHdhaXRzIGZvciB0aGUgdGVjaCB0byBiZSByZWFkeVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFJlYWR5XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hSZWFkeV8oKSB7XG4gICAgdGhpcy50cmlnZ2VyUmVhZHkoKTtcblxuICAgIC8vIEtlZXAgdGhlIHNhbWUgdm9sdW1lIGFzIGJlZm9yZVxuICAgIGlmICh0aGlzLmNhY2hlXy52b2x1bWUpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRWb2x1bWUnLCB0aGlzLmNhY2hlXy52b2x1bWUpO1xuICAgIH1cblxuICAgIC8vIExvb2sgaWYgdGhlIHRlY2ggZm91bmQgYSBoaWdoZXIgcmVzb2x1dGlvbiBwb3N0ZXIgd2hpbGUgbG9hZGluZ1xuICAgIHRoaXMuaGFuZGxlVGVjaFBvc3RlckNoYW5nZV8oKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgZHVyYXRpb24gaWYgYXZhaWxhYmxlXG4gICAgdGhpcy5oYW5kbGVUZWNoRHVyYXRpb25DaGFuZ2VfKCk7XG5cbiAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaSBib3RoIGhhdmUgaXNzdWVzIHdpdGggYXV0b3BsYXkuXG4gICAgLy8gSW4gU2FmYXJpICg1LjEuMSksIHdoZW4gd2UgbW92ZSB0aGUgdmlkZW8gZWxlbWVudCBpbnRvIHRoZSBjb250YWluZXIgZGl2LCBhdXRvcGxheSBkb2Vzbid0IHdvcmsuXG4gICAgLy8gSW4gQ2hyb21lICgxNSksIGlmIHlvdSBoYXZlIGF1dG9wbGF5ICsgYSBwb3N0ZXIgKyBubyBjb250cm9scywgdGhlIHZpZGVvIGdldHMgaGlkZGVuIChidXQgYXVkaW8gcGxheXMpXG4gICAgLy8gVGhpcyBmaXhlcyBib3RoIGlzc3Vlcy4gTmVlZCB0byB3YWl0IGZvciBBUEksIHNvIGl0IHVwZGF0ZXMgZGlzcGxheXMgY29ycmVjdGx5XG4gICAgaWYgKCh0aGlzLnNyYygpIHx8IHRoaXMuY3VycmVudFNyYygpKSAmJiB0aGlzLnRhZyAmJiB0aGlzLm9wdGlvbnNfLmF1dG9wbGF5ICYmIHRoaXMucGF1c2VkKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENocm9tZSBGaXguIEZpeGVkIGluIENocm9tZSB2MTYuXG4gICAgICAgIGRlbGV0ZSB0aGlzLnRhZy5wb3N0ZXI7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZyQxKCdkZWxldGluZyB0YWcucG9zdGVyIHRocm93cyBpbiBzb21lIGJyb3dzZXJzJywgZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYGxvYWRzdGFydGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uIFRoaXNcbiAgICogZnVuY3Rpb24gd2lsbCBhbHNvIHRyaWdnZXIge0BsaW5rIFBsYXllciNmaXJzdHBsYXl9IGlmIGl0IGlzIHRoZSBmaXJzdCBsb2Fkc3RhcnRcbiAgICogZm9yIGEgdmlkZW8uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjbG9hZHN0YXJ0XG4gICAqIEBmaXJlcyBQbGF5ZXIjZmlyc3RwbGF5XG4gICAqIEBsaXN0ZW5zIFRlY2gjbG9hZHN0YXJ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoTG9hZFN0YXJ0XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hMb2FkU3RhcnRfKCkge1xuICAgIC8vIFRPRE86IFVwZGF0ZSB0byB1c2UgYGVtcHRpZWRgIGV2ZW50IGluc3RlYWQuIFNlZSAjMTI3Ny5cblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zZWVraW5nJyk7XG5cbiAgICAvLyByZXNldCB0aGUgZXJyb3Igc3RhdGVcbiAgICB0aGlzLmVycm9yKG51bGwpO1xuXG4gICAgLy8gSWYgaXQncyBhbHJlYWR5IHBsYXlpbmcgd2Ugd2FudCB0byB0cmlnZ2VyIGEgZmlyc3RwbGF5IGV2ZW50IG5vdy5cbiAgICAvLyBUaGUgZmlyc3RwbGF5IGV2ZW50IHJlbGllcyBvbiBib3RoIHRoZSBwbGF5IGFuZCBsb2Fkc3RhcnQgZXZlbnRzXG4gICAgLy8gd2hpY2ggY2FuIGhhcHBlbiBpbiBhbnkgb3JkZXIgZm9yIGEgbmV3IHNvdXJjZVxuICAgIGlmICghdGhpcy5wYXVzZWQoKSkge1xuICAgICAgLyoqXG4gICAgICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGFnZW50IGJlZ2lucyBsb29raW5nIGZvciBtZWRpYSBkYXRhXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IFBsYXllciNsb2Fkc3RhcnRcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICAgIHRoaXMudHJpZ2dlcignZmlyc3RwbGF5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlc2V0IHRoZSBoYXNTdGFydGVkIHN0YXRlXG4gICAgICB0aGlzLmhhc1N0YXJ0ZWQoZmFsc2UpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZC9yZW1vdmUgdGhlIHZqcy1oYXMtc3RhcnRlZCBjbGFzc1xuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2ZpcnN0cGxheVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1N0YXJ0ZWRcbiAgICogICAgICAgIC0gdHJ1ZTogYWRkcyB0aGUgY2xhc3NcbiAgICogICAgICAgIC0gZmFsc2U6IHJlbW92ZSB0aGUgY2xhc3NcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICB0aGUgYm9vbGVhbiB2YWx1ZSBvZiBoYXNTdGFydGVkXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYXNTdGFydGVkID0gZnVuY3Rpb24gaGFzU3RhcnRlZChfaGFzU3RhcnRlZCkge1xuICAgIGlmIChfaGFzU3RhcnRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBvbmx5IHVwZGF0ZSBpZiB0aGlzIGlzIGEgbmV3IHZhbHVlXG4gICAgICBpZiAodGhpcy5oYXNTdGFydGVkXyAhPT0gX2hhc1N0YXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5oYXNTdGFydGVkXyA9IF9oYXNTdGFydGVkO1xuICAgICAgICBpZiAoX2hhc1N0YXJ0ZWQpIHtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcbiAgICAgICAgICAvLyB0cmlnZ2VyIHRoZSBmaXJzdHBsYXkgZXZlbnQgaWYgdGhpcyBuZXdseSBoYXMgcGxheWVkXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdmaXJzdHBsYXknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLmhhc1N0YXJ0ZWRfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgbWVkaWEgYmVnaW5zIG9yIHJlc3VtZXMgcGxheWJhY2tcbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS1tZWRpYS1wbGF5fVxuICAgKiBAZmlyZXMgUGxheWVyI3BsYXlcbiAgICogQGxpc3RlbnMgVGVjaCNwbGF5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoUGxheV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoUGxheV8oKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVuZGVkJyk7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBhdXNlZCcpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XG5cbiAgICAvLyBoaWRlIHRoZSBwb3N0ZXIgd2hlbiB0aGUgdXNlciBoaXRzIHBsYXlcbiAgICB0aGlzLmhhc1N0YXJ0ZWQodHJ1ZSk7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW5ldmVyIGFuIHtAbGluayBUZWNoI3BsYXl9IGV2ZW50IGhhcHBlbnMuIEluZGljYXRlcyB0aGF0XG4gICAgICogcGxheWJhY2sgaGFzIHN0YXJ0ZWQgb3IgcmVzdW1lZC5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjcGxheVxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3BsYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgd2FpdGluZ2AgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjd2FpdGluZ1xuICAgKiBAbGlzdGVucyBUZWNoI3dhaXRpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hXYWl0aW5nXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hXYWl0aW5nXygpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgLyoqXG4gICAgICogQSByZWFkeVN0YXRlIGNoYW5nZSBvbiB0aGUgRE9NIGVsZW1lbnQgaGFzIGNhdXNlZCBwbGF5YmFjayB0byBzdG9wLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciN3YWl0aW5nXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignd2FpdGluZycpO1xuICAgIHRoaXMub25lKCd0aW1ldXBkYXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzNC5yZW1vdmVDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgY2FucGxheWAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqID4gTm90ZTogVGhpcyBpcyBub3QgY29uc2lzdGVudCBiZXR3ZWVuIGJyb3dzZXJzLiBTZWUgIzEzNTFcbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNjYW5wbGF5XG4gICAqIEBsaXN0ZW5zIFRlY2gjY2FucGxheVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaENhblBsYXlfID0gZnVuY3Rpb24gaGFuZGxlVGVjaENhblBsYXlfKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XG4gICAgLyoqXG4gICAgICogVGhlIG1lZGlhIGhhcyBhIHJlYWR5U3RhdGUgb2YgSEFWRV9GVVRVUkVfREFUQSBvciBncmVhdGVyLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNjYW5wbGF5XG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignY2FucGxheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBjYW5wbGF5dGhyb3VnaGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjY2FucGxheXRocm91Z2hcbiAgICogQGxpc3RlbnMgVGVjaCNjYW5wbGF5dGhyb3VnaFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaENhblBsYXlUaHJvdWdoXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hDYW5QbGF5VGhyb3VnaF8oKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWVkaWEgaGFzIGEgcmVhZHlTdGF0ZSBvZiBIQVZFX0VOT1VHSF9EQVRBIG9yIGdyZWF0ZXIuIFRoaXMgbWVhbnMgdGhhdCB0aGVcbiAgICAgKiBlbnRpcmUgbWVkaWEgZmlsZSBjYW4gYmUgcGxheWVkIHdpdGhvdXQgYnVmZmVyaW5nLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNjYW5wbGF5dGhyb3VnaFxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2NhbnBsYXl0aHJvdWdoJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYHBsYXlpbmdgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3BsYXlpbmdcbiAgICogQGxpc3RlbnMgVGVjaCNwbGF5aW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoUGxheWluZ18gPSBmdW5jdGlvbiBoYW5kbGVUZWNoUGxheWluZ18oKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXdhaXRpbmcnKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWVkaWEgaXMgbm8gbG9uZ2VyIGJsb2NrZWQgZnJvbSBwbGF5YmFjaywgYW5kIGhhcyBzdGFydGVkIHBsYXlpbmcuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3BsYXlpbmdcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdwbGF5aW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYHNlZWtpbmdgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3NlZWtpbmdcbiAgICogQGxpc3RlbnMgVGVjaCNzZWVraW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoU2Vla2luZ18gPSBmdW5jdGlvbiBoYW5kbGVUZWNoU2Vla2luZ18oKSB7XG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXNlZWtpbmcnKTtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgcGxheWVyIGlzIGp1bXBpbmcgdG8gYSBuZXcgdGltZVxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNzZWVraW5nXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignc2Vla2luZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBzZWVrZWRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3NlZWtlZFxuICAgKiBAbGlzdGVucyBUZWNoI3NlZWtlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFNlZWtlZF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoU2Vla2VkXygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2Vla2luZycpO1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBoYXMgZmluaXNoZWQganVtcGluZyB0byBhIG5ldyB0aW1lXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3NlZWtlZFxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ3NlZWtlZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWdnZXIgdGhlIGBmaXJzdHBsYXlgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2ZpcnN0cGxheVxuICAgKiBAbGlzdGVucyBUZWNoI2ZpcnN0cGxheVxuICAgKiBAZGVwcmVjYXRlZCBBcyBvZiA2LjAgZmlyc3RwbGF5IGV2ZW50IGlzIGRlcHJlY2F0ZWQuXG4gICAqIEBkZXByZWNhdGVkIEFzIG9mIDYuMCBwYXNzaW5nIHRoZSBgc3RhcnR0aW1lYCBvcHRpb24gdG8gdGhlIHBsYXllciBhbmQgdGhlIGZpcnN0cGxheSBldmVudCBhcmUgZGVwcmVjYXRlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hGaXJzdFBsYXlfID0gZnVuY3Rpb24gaGFuZGxlVGVjaEZpcnN0UGxheV8oKSB7XG4gICAgLy8gSWYgdGhlIGZpcnN0IHN0YXJ0dGltZSBhdHRyaWJ1dGUgaXMgc3BlY2lmaWVkXG4gICAgLy8gdGhlbiB3ZSB3aWxsIHN0YXJ0IGF0IHRoZSBnaXZlbiBvZmZzZXQgaW4gc2Vjb25kc1xuICAgIGlmICh0aGlzLm9wdGlvbnNfLnN0YXJ0dGltZSkge1xuICAgICAgbG9nJDEud2FybignUGFzc2luZyB0aGUgYHN0YXJ0dGltZWAgb3B0aW9uIHRvIHRoZSBwbGF5ZXIgd2lsbCBiZSBkZXByZWNhdGVkIGluIDYuMCcpO1xuICAgICAgdGhpcy5jdXJyZW50VGltZSh0aGlzLm9wdGlvbnNfLnN0YXJ0dGltZSk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWhhcy1zdGFydGVkJyk7XG4gICAgLyoqXG4gICAgICogRmlyZWQgdGhlIGZpcnN0IHRpbWUgYSB2aWRlbyBpcyBwbGF5ZWQuIE5vdCBwYXJ0IG9mIHRoZSBITFMgc3BlYywgYW5kIHRoaXMgaXNcbiAgICAgKiBwcm9iYWJseSBub3QgdGhlIGJlc3QgaW1wbGVtZW50YXRpb24geWV0LCBzbyB1c2Ugc3BhcmluZ2x5LiBJZiB5b3UgZG9uJ3QgaGF2ZSBhXG4gICAgICogcmVhc29uIHRvIHByZXZlbnQgcGxheWJhY2ssIHVzZSBgbXlQbGF5ZXIub25lKCdwbGF5Jyk7YCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNmaXJzdHBsYXlcbiAgICAgKiBAZGVwcmVjYXRlZCBBcyBvZiA2LjAgZmlyc3RwbGF5IGV2ZW50IGlzIGRlcHJlY2F0ZWQuXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignZmlyc3RwbGF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYHBhdXNlYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNwYXVzZVxuICAgKiBAbGlzdGVucyBUZWNoI3BhdXNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoUGF1c2VfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFBhdXNlXygpIHtcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtcGxheWluZycpO1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgbWVkaWEgaGFzIGJlZW4gcGF1c2VkXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGxheWVyI3BhdXNlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcigncGF1c2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlnZ2VyIHRoZSBgZW5kZWRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2VuZGVkXG4gICAqIEBsaXN0ZW5zIFRlY2gjZW5kZWRcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hFbmRlZF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoRW5kZWRfKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xuICAgIGlmICh0aGlzLm9wdGlvbnNfLmxvb3ApIHtcbiAgICAgIHRoaXMuY3VycmVudFRpbWUoMCk7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnBhdXNlZCgpKSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgZW5kIG9mIHRoZSBtZWRpYSByZXNvdXJjZSBpcyByZWFjaGVkIChjdXJyZW50VGltZSA9PSBkdXJhdGlvbilcbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjZW5kZWRcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdlbmRlZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBkdXJhdGlvbiBvZiB0aGUgbWVkaWEgcmVzb3VyY2UgaXMgZmlyc3Qga25vd24gb3IgY2hhbmdlZFxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI2R1cmF0aW9uY2hhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoRHVyYXRpb25DaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlVGVjaER1cmF0aW9uQ2hhbmdlXygpIHtcbiAgICB0aGlzLmR1cmF0aW9uKHRoaXMudGVjaEdldF8oJ2R1cmF0aW9uJykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBjbGljayBvbiB0aGUgbWVkaWEgZWxlbWVudCB0byBwbGF5L3BhdXNlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICB0aGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byB0cmlnZ2VyXG4gICAqXG4gICAqIEBsaXN0ZW5zIFRlY2gjbW91c2Vkb3duXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoQ2xpY2tfID0gZnVuY3Rpb24gaGFuZGxlVGVjaENsaWNrXyhldmVudCkge1xuICAgIC8vIFdlJ3JlIHVzaW5nIG1vdXNlZG93biB0byBkZXRlY3QgY2xpY2tzIHRoYW5rcyB0byBGbGFzaCwgYnV0IG1vdXNlZG93blxuICAgIC8vIHdpbGwgYWxzbyBiZSB0cmlnZ2VyZWQgd2l0aCByaWdodC1jbGlja3MsIHNvIHdlIG5lZWQgdG8gcHJldmVudCB0aGF0XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdoZW4gY29udHJvbHMgYXJlIGRpc2FibGVkIGEgY2xpY2sgc2hvdWxkIG5vdCB0b2dnbGUgcGxheWJhY2sgYmVjYXVzZVxuICAgIC8vIHRoZSBjbGljayBpcyBjb25zaWRlcmVkIGEgY29udHJvbFxuICAgIGlmICh0aGlzLmNvbnRyb2xzKCkpIHtcbiAgICAgIGlmICh0aGlzLnBhdXNlZCgpKSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGEgdGFwIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBJdCB3aWxsIHRvZ2dsZSB0aGUgdXNlclxuICAgKiBhY3Rpdml0eSBzdGF0ZSwgd2hpY2ggaGlkZXMgYW5kIHNob3dzIHRoZSBjb250cm9scy5cbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCN0YXBcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hUYXBfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRhcF8oKSB7XG4gICAgdGhpcy51c2VyQWN0aXZlKCF0aGlzLnVzZXJBY3RpdmUoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0b3VjaCB0byBzdGFydFxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI3RvdWNoc3RhcnRcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hUb3VjaFN0YXJ0XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hUb3VjaFN0YXJ0XygpIHtcbiAgICB0aGlzLnVzZXJXYXNBY3RpdmUgPSB0aGlzLnVzZXJBY3RpdmUoKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRvdWNoIHRvIG1vdmVcbiAgICpcbiAgICogQGxpc3RlbnMgVGVjaCN0b3VjaG1vdmVcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hUb3VjaE1vdmVfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRvdWNoTW92ZV8oKSB7XG4gICAgaWYgKHRoaXMudXNlcldhc0FjdGl2ZSkge1xuICAgICAgdGhpcy5yZXBvcnRVc2VyQWN0aXZpdHkoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSB0b3VjaCB0byBlbmRcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcbiAgICogICAgICAgIHRoZSB0b3VjaGVuZCBldmVudCB0aGF0IHRyaWdnZXJlZFxuICAgKiAgICAgICAgdGhpcyBmdW5jdGlvblxuICAgKlxuICAgKiBAbGlzdGVucyBUZWNoI3RvdWNoZW5kXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVG91Y2hFbmRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRvdWNoRW5kXyhldmVudCkge1xuICAgIC8vIFN0b3AgdGhlIG1vdXNlIGV2ZW50cyBmcm9tIGFsc28gaGFwcGVuaW5nXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIHN3aXRjaGVzIGluIG9yIG91dCBvZiBmdWxsc2NyZWVuIG1vZGVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGxpc3RlbnMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlRnVsbHNjcmVlbkNoYW5nZV8oKSB7XG4gICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1mdWxsc2NyZWVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1mdWxsc2NyZWVuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBuYXRpdmUgY2xpY2sgZXZlbnRzIG9uIHRoZSBTV0YgYXJlbid0IHRyaWdnZXJlZCBvbiBJRTExLCBXaW44LjFSVFxuICAgKiB1c2Ugc3RhZ2VjbGljayBldmVudHMgdHJpZ2dlcmVkIGZyb20gaW5zaWRlIHRoZSBTV0YgaW5zdGVhZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbGlzdGVucyBzdGFnZWNsaWNrXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVTdGFnZUNsaWNrXyA9IGZ1bmN0aW9uIGhhbmRsZVN0YWdlQ2xpY2tfKCkge1xuICAgIHRoaXMucmVwb3J0VXNlckFjdGl2aXR5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBUZWNoIEZ1bGxzY3JlZW4gQ2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XG4gICAqICAgICAgICB0aGUgZnVsbHNjcmVlbmNoYW5nZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqICAgICAgICB0aGUgZGF0YSB0aGF0IHdhcyBzZW50IHdpdGggdGhlIGV2ZW50XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBsaXN0ZW5zIFRlY2gjZnVsbHNjcmVlbmNoYW5nZVxuICAgKiBAZmlyZXMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hGdWxsc2NyZWVuQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hGdWxsc2NyZWVuQ2hhbmdlXyhldmVudCwgZGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLmlzRnVsbHNjcmVlbihkYXRhLmlzRnVsbHNjcmVlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gZ29pbmcgaW4gYW5kIG91dCBvZiBmdWxsc2NyZWVuLlxuICAgICAqXG4gICAgICogQGV2ZW50IFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgbG9hZGluZyBvZiBhbiBhdWRpby92aWRlby5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGxpc3RlbnMgVGVjaCNlcnJvclxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaEVycm9yXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hFcnJvcl8oKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy50ZWNoXy5lcnJvcigpO1xuXG4gICAgdGhpcy5lcnJvcihlcnJvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZ2dlciB0aGUgYHRleHRkYXRhYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciN0ZXh0ZGF0YVxuICAgKiBAbGlzdGVucyBUZWNoI3RleHRkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVGV4dERhdGFfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRleHREYXRhXygpIHtcbiAgICB2YXIgZGF0YSA9IG51bGw7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGRhdGEgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgd2hlbiB3ZSBnZXQgYSB0ZXh0ZGF0YSBldmVudCBmcm9tIHRlY2hcbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjdGV4dGRhdGFcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCd0ZXh0ZGF0YScsIGRhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb2JqZWN0IGZvciBjYWNoZWQgdmFsdWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgZ2V0IHRoZSBjdXJyZW50IG9iamVjdCBjYWNoZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZ2V0Q2FjaGUgPSBmdW5jdGlvbiBnZXRDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhc3MgdmFsdWVzIHRvIHRoZSBwbGF5YmFjayB0ZWNoXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kXVxuICAgKiAgICAgICAgdGhlIG1ldGhvZCB0byBjYWxsXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdcbiAgICogICAgICAgIHRoZSBhcmd1bWVudCB0byBwYXNzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS50ZWNoQ2FsbF8gPSBmdW5jdGlvbiB0ZWNoQ2FsbF8obWV0aG9kLCBhcmcpIHtcbiAgICAvLyBJZiBpdCdzIG5vdCByZWFkeSB5ZXQsIGNhbGwgbWV0aG9kIHdoZW4gaXQgaXNcblxuICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1ldGhvZCBpbiBhbGxvd2VkU2V0dGVycykge1xuICAgICAgICByZXR1cm4gc2V0JDEodGhpcy5taWRkbGV3YXJlXywgdGhpcy50ZWNoXywgbWV0aG9kLCBhcmcpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgICAgIHRoaXMudGVjaF9bbWV0aG9kXShhcmcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZyQxKGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0sIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgY2FsbHMgY2FuJ3Qgd2FpdCBmb3IgdGhlIHRlY2gsIGFuZCBzb21ldGltZXMgZG9uJ3QgbmVlZCB0by5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICAgKiAgICAgICAgVGVjaCBtZXRob2RcbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIHRoZSBtZXRob2Qgb3IgdW5kZWZpbmVkXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS50ZWNoR2V0XyA9IGZ1bmN0aW9uIHRlY2hHZXRfKG1ldGhvZCkge1xuICAgIGlmICh0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8uaXNSZWFkeV8pIHtcblxuICAgICAgaWYgKG1ldGhvZCBpbiBhbGxvd2VkR2V0dGVycykge1xuICAgICAgICByZXR1cm4gZ2V0JDEodGhpcy5taWRkbGV3YXJlXywgdGhpcy50ZWNoXywgbWV0aG9kKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmxhc2ggbGlrZXMgdG8gZGllIGFuZCByZWxvYWQgd2hlbiB5b3UgaGlkZSBvciByZXBvc2l0aW9uIGl0LlxuICAgICAgLy8gSW4gdGhlc2UgY2FzZXMgdGhlIG9iamVjdCBtZXRob2RzIGdvIGF3YXkgYW5kIHdlIGdldCBlcnJvcnMuXG4gICAgICAvLyBXaGVuIHRoYXQgaGFwcGVucyB3ZSdsbCBjYXRjaCB0aGUgZXJyb3JzIGFuZCBpbmZvcm0gdGVjaCB0aGF0IGl0J3Mgbm90IHJlYWR5IGFueSBtb3JlLlxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVjaF9bbWV0aG9kXSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBXaGVuIGJ1aWxkaW5nIGFkZGl0aW9uYWwgdGVjaCBsaWJzLCBhbiBleHBlY3RlZCBtZXRob2QgbWF5IG5vdCBiZSBkZWZpbmVkIHlldFxuICAgICAgICBpZiAodGhpcy50ZWNoX1ttZXRob2RdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsb2ckMSgnVmlkZW8uanM6ICcgKyBtZXRob2QgKyAnIG1ldGhvZCBub3QgZGVmaW5lZCBmb3IgJyArIHRoaXMudGVjaE5hbWVfICsgJyBwbGF5YmFjayB0ZWNobm9sb2d5LicsIGUpO1xuXG4gICAgICAgICAgLy8gV2hlbiBhIG1ldGhvZCBpc24ndCBhdmFpbGFibGUgb24gdGhlIG9iamVjdCBpdCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAgICAgICAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgICAgbG9nJDEoJ1ZpZGVvLmpzOiAnICsgbWV0aG9kICsgJyB1bmF2YWlsYWJsZSBvbiAnICsgdGhpcy50ZWNoTmFtZV8gKyAnIHBsYXliYWNrIHRlY2hub2xvZ3kgZWxlbWVudC4nLCBlKTtcbiAgICAgICAgICB0aGlzLnRlY2hfLmlzUmVhZHlfID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nJDEoZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH07XG5cbiAgLyoqXG4gICAqIHN0YXJ0IG1lZGlhIHBsYXliYWNrXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIFJldHVybnMgYSBgUHJvbWlzZWAgaWYgdGhlIGJyb3dzZXIgcmV0dXJucyBvbmUsIGZvciBtb3N0IGJyb3dzZXJzIHRoaXMgd2lsbFxuICAgKiAgICAgICAgIHJldHVybiB1bmRlZmluZWQuXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gcGxheSgpIHtcbiAgICBpZiAodGhpcy5jaGFuZ2luZ1NyY18pIHtcbiAgICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmV0dmFsID0gdGhpcy50ZWNoR2V0XygncGxheScpO1xuXG4gICAgICAgIC8vIHNpbGVuY2UgZXJyb3JzICh1bmhhbmRsZWQgcHJvbWlzZSBmcm9tIHBsYXkpXG4gICAgICAgIGlmIChyZXR2YWwgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcmV0dmFsLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR2YWwudGhlbihudWxsLCBmdW5jdGlvbiAoZSkge30pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gT25seSBjYWxscyB0aGUgdGVjaCdzIHBsYXkgaWYgd2UgYWxyZWFkeSBoYXZlIGEgc3JjIGxvYWRlZFxuICAgIH0gZWxzZSBpZiAodGhpcy5pc1JlYWR5XyAmJiAodGhpcy5zcmMoKSB8fCB0aGlzLmN1cnJlbnRTcmMoKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdwbGF5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRlY2hfLm9uZSgnbG9hZHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXR2YWwgPSB0aGlzLnBsYXkoKTtcblxuICAgICAgICAgIC8vIHNpbGVuY2UgZXJyb3JzICh1bmhhbmRsZWQgcHJvbWlzZSBmcm9tIHBsYXkpXG4gICAgICAgICAgaWYgKHJldHZhbCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXR2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dmFsLnRoZW4obnVsbCwgZnVuY3Rpb24gKGUpIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQYXVzZSB0aGUgdmlkZW8gcGxheWJhY2tcbiAgICpcbiAgICogQHJldHVybiB7UGxheWVyfVxuICAgKiAgICAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSBwbGF5ZXIgb2JqZWN0IHRoaXMgZnVuY3Rpb24gd2FzIGNhbGxlZCBvblxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICB0aGlzLnRlY2hDYWxsXygncGF1c2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHBsYXllciBpcyBwYXVzZWQgb3IgaGFzIHlldCB0byBwbGF5XG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSBmYWxzZTogaWYgdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBwbGF5aW5nXG4gICAqICAgICAgICAgLSB0cnVlOiBpZiBtZWRpYSBpcyBub3QgY3VycmVudGx5IHBsYXlpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnBhdXNlZCA9IGZ1bmN0aW9uIHBhdXNlZCgpIHtcbiAgICAvLyBUaGUgaW5pdGlhbCBzdGF0ZSBvZiBwYXVzZWQgc2hvdWxkIGJlIHRydWUgKGluIFNhZmFyaSBpdCdzIGFjdHVhbGx5IGZhbHNlKVxuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdwYXVzZWQnKSA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIFRpbWVSYW5nZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHJhbmdlcyBvZiB0aW1lIHRoYXQgdGhlIHVzZXJcbiAgICogaGFzIHBsYXllZC5cbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgKiAgICAgICAgIEEgdGltZSByYW5nZSBvYmplY3QgdGhhdCByZXByZXNlbnRzIGFsbCB0aGUgaW5jcmVtZW50cyBvZiB0aW1lIHRoYXQgaGF2ZVxuICAgKiAgICAgICAgIGJlZW4gcGxheWVkLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucGxheWVkID0gZnVuY3Rpb24gcGxheWVkKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdwbGF5ZWQnKSB8fCBjcmVhdGVUaW1lUmFuZ2VzKDAsIDApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIGlzIFwic2NydWJiaW5nXCIuIFNjcnViYmluZyBpc1xuICAgKiB3aGVuIHRoZSB1c2VyIGhhcyBjbGlja2VkIHRoZSBwcm9ncmVzcyBiYXIgaGFuZGxlIGFuZCBpc1xuICAgKiBkcmFnZ2luZyBpdCBhbG9uZyB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NjcnViYmluZ11cbiAgICogICAgICAgIHdldGhlciB0aGUgdXNlciBpcyBvciBpcyBub3Qgc2NydWJiaW5nXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgVGhlIHZhbHVlIG9mIHNjcnViYmluZyB3aGVuIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnNjcnViYmluZyA9IGZ1bmN0aW9uIHNjcnViYmluZyhpc1NjcnViYmluZykge1xuICAgIGlmICh0eXBlb2YgaXNTY3J1YmJpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3J1YmJpbmdfO1xuICAgIH1cbiAgICB0aGlzLnNjcnViYmluZ18gPSAhIWlzU2NydWJiaW5nO1xuXG4gICAgaWYgKGlzU2NydWJiaW5nKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2NydWJiaW5nJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zY3J1YmJpbmcnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGN1cnJlbnQgdGltZSAoaW4gc2Vjb25kcylcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbc2Vjb25kc11cbiAgICogICAgICAgIFRoZSB0aW1lIHRvIHNlZWsgdG8gaW4gc2Vjb25kc1xuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgLSB0aGUgY3VycmVudCB0aW1lIGluIHNlY29uZHMgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jdXJyZW50VGltZSA9IGZ1bmN0aW9uIGN1cnJlbnRUaW1lKHNlY29uZHMpIHtcbiAgICBpZiAodHlwZW9mIHNlY29uZHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0Q3VycmVudFRpbWUnLCBzZWNvbmRzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjYWNoZSBsYXN0IGN1cnJlbnRUaW1lIGFuZCByZXR1cm4uIGRlZmF1bHQgdG8gMCBzZWNvbmRzXG4gICAgLy9cbiAgICAvLyBDYWNoaW5nIHRoZSBjdXJyZW50VGltZSBpcyBtZWFudCB0byBwcmV2ZW50IGEgbWFzc2l2ZSBhbW91bnQgb2YgcmVhZHMgb24gdGhlIHRlY2gnc1xuICAgIC8vIGN1cnJlbnRUaW1lIHdoZW4gc2NydWJiaW5nLCBidXQgbWF5IG5vdCBwcm92aWRlIG11Y2ggcGVyZm9ybWFuY2UgYmVuZWZpdCBhZnRlcmFsbC5cbiAgICAvLyBTaG91bGQgYmUgdGVzdGVkLiBBbHNvIHNvbWV0aGluZyBoYXMgdG8gcmVhZCB0aGUgYWN0dWFsIGN1cnJlbnQgdGltZSBvciB0aGUgY2FjaGUgd2lsbFxuICAgIC8vIG5ldmVyIGdldCB1cGRhdGVkLlxuICAgIHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lID0gdGhpcy50ZWNoR2V0XygnY3VycmVudFRpbWUnKSB8fCAwO1xuICAgIHJldHVybiB0aGlzLmNhY2hlXy5jdXJyZW50VGltZTtcbiAgfTtcblxuICAvKipcbiAgICogTm9ybWFsbHkgZ2V0cyB0aGUgbGVuZ3RoIGluIHRpbWUgb2YgdGhlIHZpZGVvIGluIHNlY29uZHM7XG4gICAqIGluIGFsbCBidXQgdGhlIHJhcmVzdCB1c2UgY2FzZXMgYW4gYXJndW1lbnQgd2lsbCBOT1QgYmUgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAgICpcbiAgICogPiAqKk5PVEUqKjogVGhlIHZpZGVvIG11c3QgaGF2ZSBzdGFydGVkIGxvYWRpbmcgYmVmb3JlIHRoZSBkdXJhdGlvbiBjYW4gYmVcbiAgICoga25vd24sIGFuZCBpbiB0aGUgY2FzZSBvZiBGbGFzaCwgbWF5IG5vdCBiZSBrbm93biB1bnRpbCB0aGUgdmlkZW8gc3RhcnRzXG4gICAqIHBsYXlpbmcuXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmRzXVxuICAgKiAgICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSB2aWRlbyB0byBzZXQgaW4gc2Vjb25kc1xuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgLSBUaGUgZHVyYXRpb24gb2YgdGhlIHZpZGVvIGluIHNlY29uZHMgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uIGR1cmF0aW9uKHNlY29uZHMpIHtcbiAgICBpZiAoc2Vjb25kcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gTmFOIGlmIHRoZSBkdXJhdGlvbiBpcyBub3Qga25vd25cbiAgICAgIHJldHVybiB0aGlzLmNhY2hlXy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy5jYWNoZV8uZHVyYXRpb24gOiBOYU47XG4gICAgfVxuXG4gICAgc2Vjb25kcyA9IHBhcnNlRmxvYXQoc2Vjb25kcyk7XG5cbiAgICAvLyBTdGFuZGFyZGl6ZSBvbiBJbmlmaXR5IGZvciBzaWduYWxpbmcgdmlkZW8gaXMgbGl2ZVxuICAgIGlmIChzZWNvbmRzIDwgMCkge1xuICAgICAgc2Vjb25kcyA9IEluZmluaXR5O1xuICAgIH1cblxuICAgIGlmIChzZWNvbmRzICE9PSB0aGlzLmNhY2hlXy5kdXJhdGlvbikge1xuICAgICAgLy8gQ2FjaGUgdGhlIGxhc3Qgc2V0IHZhbHVlIGZvciBvcHRpbWl6ZWQgc2NydWJiaW5nIChlc3AuIEZsYXNoKVxuICAgICAgdGhpcy5jYWNoZV8uZHVyYXRpb24gPSBzZWNvbmRzO1xuXG4gICAgICBpZiAoc2Vjb25kcyA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWxpdmUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1saXZlJyk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgICAqL1xuICAgICAgdGhpcy50cmlnZ2VyKCdkdXJhdGlvbmNoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBob3cgbXVjaCB0aW1lIGlzIGxlZnQgaW4gdGhlIHZpZGVvLiBOb3QgcGFydFxuICAgKiBvZiB0aGUgbmF0aXZlIHZpZGVvIEFQSS5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSB0aW1lIHJlbWFpbmluZyBpbiBzZWNvbmRzXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZW1haW5pbmdUaW1lID0gZnVuY3Rpb24gcmVtYWluaW5nVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kdXJhdGlvbigpIC0gdGhpcy5jdXJyZW50VGltZSgpO1xuICB9O1xuXG4gIC8vXG4gIC8vIEtpbmQgb2YgbGlrZSBhbiBhcnJheSBvZiBwb3J0aW9ucyBvZiB0aGUgdmlkZW8gdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZC5cblxuICAvKipcbiAgICogR2V0IGEgVGltZVJhbmdlIG9iamVjdCB3aXRoIGFuIGFycmF5IG9mIHRoZSB0aW1lcyBvZiB0aGUgdmlkZW9cbiAgICogdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZC4gSWYgeW91IGp1c3Qgd2FudCB0aGUgcGVyY2VudCBvZiB0aGVcbiAgICogdmlkZW8gdGhhdCdzIGJlZW4gZG93bmxvYWRlZCwgdXNlIGJ1ZmZlcmVkUGVyY2VudC5cbiAgICpcbiAgICogQHNlZSBbQnVmZmVyZWQgU3BlY117QGxpbmsgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvc3BlYy92aWRlby5odG1sI2RvbS1tZWRpYS1idWZmZXJlZH1cbiAgICpcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxuICAgKiAgICAgICAgIEEgbW9jayBUaW1lUmFuZ2Ugb2JqZWN0IChmb2xsb3dpbmcgSFRNTCBzcGVjKVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYnVmZmVyZWQgPSBmdW5jdGlvbiBidWZmZXJlZCgpIHtcbiAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLnRlY2hHZXRfKCdidWZmZXJlZCcpO1xuXG4gICAgaWYgKCFidWZmZXJlZCB8fCAhYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICBidWZmZXJlZCA9IGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBlcmNlbnQgKGFzIGEgZGVjaW1hbCkgb2YgdGhlIHZpZGVvIHRoYXQncyBiZWVuIGRvd25sb2FkZWQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBhIHBhcnQgb2YgdGhlIG5hdGl2ZSBIVE1MIHZpZGVvIEFQSS5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIEEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDEgcmVwcmVzZW50aW5nIHRoZSBwZXJjZW50XG4gICAqICAgICAgICAgdGhhdCBpcyBidWZmZXJyZWQgMCBiZWluZyAwJSBhbmQgMSBiZWluZyAxMDAlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5idWZmZXJlZFBlcmNlbnQgPSBmdW5jdGlvbiBidWZmZXJlZFBlcmNlbnQkJDEoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcmVkUGVyY2VudCh0aGlzLmJ1ZmZlcmVkKCksIHRoaXMuZHVyYXRpb24oKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZW5kaW5nIHRpbWUgb2YgdGhlIGxhc3QgYnVmZmVyZWQgdGltZSByYW5nZVxuICAgKiBUaGlzIGlzIHVzZWQgaW4gdGhlIHByb2dyZXNzIGJhciB0byBlbmNhcHN1bGF0ZSBhbGwgdGltZSByYW5nZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgZW5kIG9mIHRoZSBsYXN0IGJ1ZmZlcmVkIHRpbWUgcmFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmJ1ZmZlcmVkRW5kID0gZnVuY3Rpb24gYnVmZmVyZWRFbmQoKSB7XG4gICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy5idWZmZXJlZCgpO1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKTtcbiAgICB2YXIgZW5kID0gYnVmZmVyZWQuZW5kKGJ1ZmZlcmVkLmxlbmd0aCAtIDEpO1xuXG4gICAgaWYgKGVuZCA+IGR1cmF0aW9uKSB7XG4gICAgICBlbmQgPSBkdXJhdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgbWVkaWFcbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbcGVyY2VudEFzRGVjaW1hbF1cbiAgICogICAgICAgICBUaGUgbmV3IHZvbHVtZSBhcyBhIGRlY2ltYWwgcGVyY2VudDpcbiAgICogICAgICAgICAtIDAgaXMgbXV0ZWQvMCUvb2ZmXG4gICAqICAgICAgICAgLSAxLjAgaXMgMTAwJS9mdWxsXG4gICAqICAgICAgICAgLSAwLjUgaXMgaGFsZiB2b2x1bWUgb3IgNTAlXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2b2x1bWUgYXMgYSBwZXJjZW50IHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24gdm9sdW1lKHBlcmNlbnRBc0RlY2ltYWwpIHtcbiAgICB2YXIgdm9sID0gdm9pZCAwO1xuXG4gICAgaWYgKHBlcmNlbnRBc0RlY2ltYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRm9yY2UgdmFsdWUgdG8gYmV0d2VlbiAwIGFuZCAxXG4gICAgICB2b2wgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwYXJzZUZsb2F0KHBlcmNlbnRBc0RlY2ltYWwpKSk7XG4gICAgICB0aGlzLmNhY2hlXy52b2x1bWUgPSB2b2w7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0Vm9sdW1lJywgdm9sKTtcblxuICAgICAgaWYgKHZvbCA+IDApIHtcbiAgICAgICAgdGhpcy5sYXN0Vm9sdW1lXyh2b2wpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byAxIHdoZW4gcmV0dXJuaW5nIGN1cnJlbnQgdm9sdW1lLlxuICAgIHZvbCA9IHBhcnNlRmxvYXQodGhpcy50ZWNoR2V0Xygndm9sdW1lJykpO1xuICAgIHJldHVybiBpc05hTih2b2wpID8gMSA6IHZvbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IG11dGVkIHN0YXRlLCBvciB0dXJuIG11dGUgb24gb3Igb2ZmXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211dGVkXVxuICAgKiAgICAgICAgLSB0cnVlIHRvIG11dGVcbiAgICogICAgICAgIC0gZmFsc2UgdG8gdW5tdXRlXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgLSB0cnVlIGlmIG11dGUgaXMgb24gYW5kIGdldHRpbmdcbiAgICogICAgICAgICAtIGZhbHNlIGlmIG11dGUgaXMgb2ZmIGFuZCBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5tdXRlZCA9IGZ1bmN0aW9uIG11dGVkKF9tdXRlZCkge1xuICAgIGlmIChfbXV0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldE11dGVkJywgX211dGVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ211dGVkJykgfHwgZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBkZWZhdWx0TXV0ZWQgc3RhdGUsIG9yIHR1cm4gZGVmYXVsdE11dGVkIG9uIG9yIG9mZi4gZGVmYXVsdE11dGVkXG4gICAqIGluZGljYXRlcyB0aGUgc3RhdGUgb2YgbXV0ZWQgb24gaW50aWFsIHBsYXliYWNrLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAgIHZhciBteVBsYXllciA9IHZpZGVvanMoJ3NvbWUtcGxheWVyLWlkJyk7XG4gICAqXG4gICAqICAgbXlQbGF5ZXIuc3JjKFwiaHR0cDovL3d3dy5leGFtcGxlLmNvbS9wYXRoL3RvL3ZpZGVvLm1wNFwiKTtcbiAgICpcbiAgICogICAvLyBnZXQsIHNob3VsZCBiZSBmYWxzZVxuICAgKiAgIGNvbnNvbGUubG9nKG15UGxheWVyLmRlZmF1bHRNdXRlZCgpKTtcbiAgICogICAvLyBzZXQgdG8gdHJ1ZVxuICAgKiAgIG15UGxheWVyLmRlZmF1bHRNdXRlZCh0cnVlKTtcbiAgICogICAvLyBnZXQgc2hvdWxkIGJlIHRydWVcbiAgICogICBjb25zb2xlLmxvZyhteVBsYXllci5kZWZhdWx0TXV0ZWQoKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWZhdWx0TXV0ZWRdXG4gICAqICAgICAgICAtIHRydWUgdG8gbXV0ZVxuICAgKiAgICAgICAgLSBmYWxzZSB0byB1bm11dGVcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbnxQbGF5ZXJ9XG4gICAqICAgICAgICAgLSB0cnVlIGlmIGRlZmF1bHRNdXRlZCBpcyBvbiBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gZmFsc2UgaWYgZGVmYXVsdE11dGVkIGlzIG9mZiBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZGVmYXVsdE11dGVkID0gZnVuY3Rpb24gZGVmYXVsdE11dGVkKF9kZWZhdWx0TXV0ZWQpIHtcbiAgICBpZiAoX2RlZmF1bHRNdXRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoQ2FsbF8oJ3NldERlZmF1bHRNdXRlZCcsIF9kZWZhdWx0TXV0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnZGVmYXVsdE11dGVkJykgfHwgZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGFzdCB2b2x1bWUsIG9yIHNldCBpdFxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtwZXJjZW50QXNEZWNpbWFsXVxuICAgKiAgICAgICAgIFRoZSBuZXcgbGFzdCB2b2x1bWUgYXMgYSBkZWNpbWFsIHBlcmNlbnQ6XG4gICAqICAgICAgICAgLSAwIGlzIG11dGVkLzAlL29mZlxuICAgKiAgICAgICAgIC0gMS4wIGlzIDEwMCUvZnVsbFxuICAgKiAgICAgICAgIC0gMC41IGlzIGhhbGYgdm9sdW1lIG9yIDUwJVxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgbGFzdFZvbHVtZSBhcyBhIHBlcmNlbnQgd2hlbiBnZXR0aW5nXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sYXN0Vm9sdW1lXyA9IGZ1bmN0aW9uIGxhc3RWb2x1bWVfKHBlcmNlbnRBc0RlY2ltYWwpIHtcbiAgICBpZiAocGVyY2VudEFzRGVjaW1hbCAhPT0gdW5kZWZpbmVkICYmIHBlcmNlbnRBc0RlY2ltYWwgIT09IDApIHtcbiAgICAgIHRoaXMuY2FjaGVfLmxhc3RWb2x1bWUgPSBwZXJjZW50QXNEZWNpbWFsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZV8ubGFzdFZvbHVtZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgY3VycmVudCB0ZWNoIGNhbiBzdXBwb3J0IG5hdGl2ZSBmdWxsc2NyZWVuXG4gICAqIChlLmcuIHdpdGggYnVpbHQgaW4gY29udHJvbHMgbGlrZSBpT1MsIHNvIG5vdCBvdXIgZmxhc2ggc3dmKVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIGlmIG5hdGl2ZSBmdWxsc2NyZWVuIGlzIHN1cHBvcnRlZFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc3VwcG9ydHNGdWxsU2NyZWVuID0gZnVuY3Rpb24gc3VwcG9ydHNGdWxsU2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdzdXBwb3J0c0Z1bGxTY3JlZW4nKSB8fCBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHBsYXllciBpcyBpbiBmdWxsc2NyZWVuIG1vZGUgb3IgdGVsbCB0aGUgcGxheWVyIHRoYXQgaXRcbiAgICogaXMgb3IgaXMgbm90IGluIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICpcbiAgICogPiBOT1RFOiBBcyBvZiB0aGUgbGF0ZXN0IEhUTUw1IHNwZWMsIGlzRnVsbHNjcmVlbiBpcyBubyBsb25nZXIgYW4gb2ZmaWNpYWxcbiAgICogcHJvcGVydHkgYW5kIGluc3RlYWQgZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgaXMgdXNlZC4gQnV0IGlzRnVsbHNjcmVlbiBpc1xuICAgKiBzdGlsbCBhIHZhbHVhYmxlIHByb3BlcnR5IGZvciBpbnRlcm5hbCBwbGF5ZXIgd29ya2luZ3MuXG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFtpc0ZTXVxuICAgKiAgICAgICAgIFNldCB0aGUgcGxheWVycyBjdXJyZW50IGZ1bGxzY3JlZW4gc3RhdGVcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIHRydWUgaWYgZnVsbHNjcmVlbiBpcyBvbiBhbmQgZ2V0dGluZ1xuICAgKiAgICAgICAgIC0gZmFsc2UgaWYgZnVsbHNjcmVlbiBpcyBvZmYgYW5kIGdldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmlzRnVsbHNjcmVlbiA9IGZ1bmN0aW9uIGlzRnVsbHNjcmVlbihpc0ZTKSB7XG4gICAgaWYgKGlzRlMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pc0Z1bGxzY3JlZW5fID0gISFpc0ZTO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gISF0aGlzLmlzRnVsbHNjcmVlbl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlIHRoZSBzaXplIG9mIHRoZSB2aWRlbyB0byBmdWxsIHNjcmVlblxuICAgKiBJbiBzb21lIGJyb3dzZXJzLCBmdWxsIHNjcmVlbiBpcyBub3Qgc3VwcG9ydGVkIG5hdGl2ZWx5LCBzbyBpdCBlbnRlcnNcbiAgICogXCJmdWxsIHdpbmRvdyBtb2RlXCIsIHdoZXJlIHRoZSB2aWRlbyBmaWxscyB0aGUgYnJvd3NlciB3aW5kb3cuXG4gICAqIEluIGJyb3dzZXJzIGFuZCBkZXZpY2VzIHRoYXQgc3VwcG9ydCBuYXRpdmUgZnVsbCBzY3JlZW4sIHNvbWV0aW1lcyB0aGVcbiAgICogYnJvd3NlcidzIGRlZmF1bHQgY29udHJvbHMgd2lsbCBiZSBzaG93biwgYW5kIG5vdCB0aGUgVmlkZW8uanMgY3VzdG9tIHNraW4uXG4gICAqIFRoaXMgaW5jbHVkZXMgbW9zdCBtb2JpbGUgZGV2aWNlcyAoaU9TLCBBbmRyb2lkKSBhbmQgb2xkZXIgdmVyc2lvbnMgb2ZcbiAgICogU2FmYXJpLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlcXVlc3RGdWxsc2NyZWVuID0gZnVuY3Rpb24gcmVxdWVzdEZ1bGxzY3JlZW4oKSB7XG4gICAgdmFyIGZzQXBpID0gRnVsbHNjcmVlbkFwaTtcblxuICAgIHRoaXMuaXNGdWxsc2NyZWVuKHRydWUpO1xuXG4gICAgaWYgKGZzQXBpLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAvLyB0aGUgYnJvd3NlciBzdXBwb3J0cyBnb2luZyBmdWxsc2NyZWVuIGF0IHRoZSBlbGVtZW50IGxldmVsIHNvIHdlIGNhblxuICAgICAgLy8gdGFrZSB0aGUgY29udHJvbHMgZnVsbHNjcmVlbiBhcyB3ZWxsIGFzIHRoZSB2aWRlb1xuXG4gICAgICAvLyBUcmlnZ2VyIGZ1bGxzY3JlZW5jaGFuZ2UgZXZlbnQgYWZ0ZXIgY2hhbmdlXG4gICAgICAvLyBXZSBoYXZlIHRvIHNwZWNpZmljYWxseSBhZGQgdGhpcyBlYWNoIHRpbWUsIGFuZCByZW1vdmVcbiAgICAgIC8vIHdoZW4gY2FuY2VsaW5nIGZ1bGxzY3JlZW4uIE90aGVyd2lzZSBpZiB0aGVyZSdzIG11bHRpcGxlXG4gICAgICAvLyBwbGF5ZXJzIG9uIGEgcGFnZSwgdGhleSB3b3VsZCBhbGwgYmUgcmVhY3RpbmcgdG8gdGhlIHNhbWUgZnVsbHNjcmVlblxuICAgICAgLy8gZXZlbnRzXG4gICAgICBvbihkb2N1bWVudCwgZnNBcGkuZnVsbHNjcmVlbmNoYW5nZSwgYmluZCh0aGlzLCBmdW5jdGlvbiBkb2N1bWVudEZ1bGxzY3JlZW5DaGFuZ2UoZSkge1xuICAgICAgICB0aGlzLmlzRnVsbHNjcmVlbihkb2N1bWVudFtmc0FwaS5mdWxsc2NyZWVuRWxlbWVudF0pO1xuXG4gICAgICAgIC8vIElmIGNhbmNlbGxpbmcgZnVsbHNjcmVlbiwgcmVtb3ZlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4oKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsIGZzQXBpLmZ1bGxzY3JlZW5jaGFuZ2UsIGRvY3VtZW50RnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICAgIH0pKTtcblxuICAgICAgdGhpcy5lbF9bZnNBcGkucmVxdWVzdEZ1bGxzY3JlZW5dKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRlY2hfLnN1cHBvcnRzRnVsbFNjcmVlbigpKSB7XG4gICAgICAvLyB3ZSBjYW4ndCB0YWtlIHRoZSB2aWRlby5qcyBjb250cm9scyBmdWxsc2NyZWVuIGJ1dCB3ZSBjYW4gZ28gZnVsbHNjcmVlblxuICAgICAgLy8gd2l0aCBuYXRpdmUgY29udHJvbHNcbiAgICAgIHRoaXMudGVjaENhbGxfKCdlbnRlckZ1bGxTY3JlZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZnVsbHNjcmVlbiBpc24ndCBzdXBwb3J0ZWQgc28gd2UnbGwganVzdCBzdHJldGNoIHRoZSB2aWRlbyBlbGVtZW50IHRvXG4gICAgICAvLyBmaWxsIHRoZSB2aWV3cG9ydFxuICAgICAgdGhpcy5lbnRlckZ1bGxXaW5kb3coKTtcbiAgICAgIC8qKlxuICAgICAgICogQGV2ZW50IFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgKi9cbiAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB2aWRlbyB0byBpdHMgbm9ybWFsIHNpemUgYWZ0ZXIgaGF2aW5nIGJlZW4gaW4gZnVsbCBzY3JlZW4gbW9kZVxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmV4aXRGdWxsc2NyZWVuID0gZnVuY3Rpb24gZXhpdEZ1bGxzY3JlZW4oKSB7XG4gICAgdmFyIGZzQXBpID0gRnVsbHNjcmVlbkFwaTtcblxuICAgIHRoaXMuaXNGdWxsc2NyZWVuKGZhbHNlKTtcblxuICAgIC8vIENoZWNrIGZvciBicm93c2VyIGVsZW1lbnQgZnVsbHNjcmVlbiBzdXBwb3J0XG4gICAgaWYgKGZzQXBpLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICBkb2N1bWVudFtmc0FwaS5leGl0RnVsbHNjcmVlbl0oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudGVjaF8uc3VwcG9ydHNGdWxsU2NyZWVuKCkpIHtcbiAgICAgIHRoaXMudGVjaENhbGxfKCdleGl0RnVsbFNjcmVlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4aXRGdWxsV2luZG93KCk7XG4gICAgICAvKipcbiAgICAgICAqIEBldmVudCBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gZnVsbHNjcmVlbiBpc24ndCBzdXBwb3J0ZWQgd2UgY2FuIHN0cmV0Y2ggdGhlXG4gICAqIHZpZGVvIGNvbnRhaW5lciB0byBhcyB3aWRlIGFzIHRoZSBicm93c2VyIHdpbGwgbGV0IHVzLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2VudGVyRnVsbFdpbmRvd1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZW50ZXJGdWxsV2luZG93ID0gZnVuY3Rpb24gZW50ZXJGdWxsV2luZG93KCkge1xuICAgIHRoaXMuaXNGdWxsV2luZG93ID0gdHJ1ZTtcblxuICAgIC8vIFN0b3Jpbmcgb3JpZ2luYWwgZG9jIG92ZXJmbG93IHZhbHVlIHRvIHJldHVybiB0byB3aGVuIGZ1bGxzY3JlZW4gaXMgb2ZmXG4gICAgdGhpcy5kb2NPcmlnT3ZlcmZsb3cgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3c7XG5cbiAgICAvLyBBZGQgbGlzdGVuZXIgZm9yIGVzYyBrZXkgdG8gZXhpdCBmdWxsc2NyZWVuXG4gICAgb24oZG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmZ1bGxXaW5kb3dPbkVzY0tleSkpO1xuXG4gICAgLy8gSGlkZSBhbnkgc2Nyb2xsIGJhcnNcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICAgIC8vIEFwcGx5IGZ1bGxzY3JlZW4gc3R5bGVzXG4gICAgYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ3Zqcy1mdWxsLXdpbmRvdycpO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFBsYXllciNlbnRlckZ1bGxXaW5kb3dcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdlbnRlckZ1bGxXaW5kb3cnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgZm9yIGNhbGwgdG8gZWl0aGVyIGV4aXQgZnVsbCB3aW5kb3cgb3JcbiAgICogZnVsbCBzY3JlZW4gb24gRVNDIGtleVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogICAgICAgIEV2ZW50IHRvIGNoZWNrIGZvciBrZXkgcHJlc3NcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmZ1bGxXaW5kb3dPbkVzY0tleSA9IGZ1bmN0aW9uIGZ1bGxXaW5kb3dPbkVzY0tleShldmVudCkge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuICAgICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leGl0RnVsbFdpbmRvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXhpdCBmdWxsIHdpbmRvd1xuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2V4aXRGdWxsV2luZG93XG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5leGl0RnVsbFdpbmRvdyA9IGZ1bmN0aW9uIGV4aXRGdWxsV2luZG93KCkge1xuICAgIHRoaXMuaXNGdWxsV2luZG93ID0gZmFsc2U7XG4gICAgb2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuZnVsbFdpbmRvd09uRXNjS2V5KTtcblxuICAgIC8vIFVuaGlkZSBzY3JvbGwgYmFycy5cbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSB0aGlzLmRvY09yaWdPdmVyZmxvdztcblxuICAgIC8vIFJlbW92ZSBmdWxsc2NyZWVuIHN0eWxlc1xuICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICd2anMtZnVsbC13aW5kb3cnKTtcblxuICAgIC8vIFJlc2l6ZSB0aGUgYm94LCBjb250cm9sbGVyLCBhbmQgcG9zdGVyIHRvIG9yaWdpbmFsIHNpemVzXG4gICAgLy8gdGhpcy5wb3NpdGlvbkFsbCgpO1xuICAgIC8qKlxuICAgICAqIEBldmVudCBQbGF5ZXIjZXhpdEZ1bGxXaW5kb3dcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKCdleGl0RnVsbFdpbmRvdycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBwbGF5ZXIgY2FuIHBsYXkgYSBnaXZlbiBtaW1ldHlwZVxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwMTEzL3ZpZGVvLmh0bWwjZG9tLW5hdmlnYXRvci1jYW5wbGF5dHlwZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiAgICAgICAgVGhlIG1pbWV0eXBlIHRvIGNoZWNrXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiBjYW5QbGF5VHlwZSh0eXBlKSB7XG4gICAgdmFyIGNhbiA9IHZvaWQgMDtcblxuICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIHBsYXliYWNrIHRlY2hub2xvZ3kgaW4gdGhlIG9wdGlvbnMgb3JkZXJcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMub3B0aW9uc18udGVjaE9yZGVyOyBpIDwgai5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRlY2hOYW1lID0galtpXTtcbiAgICAgIHZhciB0ZWNoID0gVGVjaC5nZXRUZWNoKHRlY2hOYW1lKTtcblxuICAgICAgLy8gU3VwcG9ydCBvbGQgYmVoYXZpb3Igb2YgdGVjaHMgYmVpbmcgcmVnaXN0ZXJlZCBhcyBjb21wb25lbnRzLlxuICAgICAgLy8gUmVtb3ZlIG9uY2UgdGhhdCBkZXByZWNhdGVkIGJlaGF2aW9yIGlzIHJlbW92ZWQuXG4gICAgICBpZiAoIXRlY2gpIHtcbiAgICAgICAgdGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQodGVjaE5hbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCB0ZWNoIGlzIGRlZmluZWQgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgIGlmICghdGVjaCkge1xuICAgICAgICBsb2ckMS5lcnJvcignVGhlIFwiJyArIHRlY2hOYW1lICsgJ1wiIHRlY2ggaXMgdW5kZWZpbmVkLiBTa2lwcGVkIGJyb3dzZXIgc3VwcG9ydCBjaGVjayBmb3IgdGhhdCB0ZWNoLicpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyB0ZWNobm9sb2d5XG4gICAgICBpZiAodGVjaC5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgIGNhbiA9IHRlY2guY2FuUGxheVR5cGUodHlwZSk7XG5cbiAgICAgICAgaWYgKGNhbikge1xuICAgICAgICAgIHJldHVybiBjYW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBzb3VyY2UgYmFzZWQgb24gdGVjaC1vcmRlciBvciBzb3VyY2Utb3JkZXJcbiAgICogVXNlcyBzb3VyY2Utb3JkZXIgc2VsZWN0aW9uIGlmIGBvcHRpb25zLnNvdXJjZU9yZGVyYCBpcyB0cnV0aHkuIE90aGVyd2lzZSxcbiAgICogZGVmYXVsdHMgdG8gdGVjaC1vcmRlciBzZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gc291cmNlc1xuICAgKiAgICAgICAgVGhlIHNvdXJjZXMgZm9yIGEgbWVkaWEgYXNzZXRcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fGJvb2xlYW59XG4gICAqICAgICAgICAgT2JqZWN0IG9mIHNvdXJjZSBhbmQgdGVjaCBvcmRlciBvciBmYWxzZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc2VsZWN0U291cmNlID0gZnVuY3Rpb24gc2VsZWN0U291cmNlKHNvdXJjZXMpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIC8vIEdldCBvbmx5IHRoZSB0ZWNocyBzcGVjaWZpZWQgaW4gYHRlY2hPcmRlcmAgdGhhdCBleGlzdCBhbmQgYXJlIHN1cHBvcnRlZCBieSB0aGVcbiAgICAvLyBjdXJyZW50IHBsYXRmb3JtXG4gICAgdmFyIHRlY2hzID0gdGhpcy5vcHRpb25zXy50ZWNoT3JkZXIubWFwKGZ1bmN0aW9uICh0ZWNoTmFtZSkge1xuICAgICAgcmV0dXJuIFt0ZWNoTmFtZSwgVGVjaC5nZXRUZWNoKHRlY2hOYW1lKV07XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgdGVjaE5hbWUgPSBfcmVmWzBdLFxuICAgICAgICAgIHRlY2ggPSBfcmVmWzFdO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCB0ZWNoIGlzIGRlZmluZWQgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgIGlmICh0ZWNoKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoaXMgdGVjaG5vbG9neVxuICAgICAgICByZXR1cm4gdGVjaC5pc1N1cHBvcnRlZCgpO1xuICAgICAgfVxuXG4gICAgICBsb2ckMS5lcnJvcignVGhlIFwiJyArIHRlY2hOYW1lICsgJ1wiIHRlY2ggaXMgdW5kZWZpbmVkLiBTa2lwcGVkIGJyb3dzZXIgc3VwcG9ydCBjaGVjayBmb3IgdGhhdCB0ZWNoLicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGVhY2ggYGlubmVyQXJyYXlgIGVsZW1lbnQgb25jZSBwZXIgYG91dGVyQXJyYXlgIGVsZW1lbnQgYW5kIGV4ZWN1dGVcbiAgICAvLyBgdGVzdGVyYCB3aXRoIGJvdGguIElmIGB0ZXN0ZXJgIHJldHVybnMgYSBub24tZmFsc3kgdmFsdWUsIGV4aXQgZWFybHkgYW5kIHJldHVyblxuICAgIC8vIHRoYXQgdmFsdWUuXG4gICAgdmFyIGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpciA9IGZ1bmN0aW9uIGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpcihvdXRlckFycmF5LCBpbm5lckFycmF5LCB0ZXN0ZXIpIHtcbiAgICAgIHZhciBmb3VuZCA9IHZvaWQgMDtcblxuICAgICAgb3V0ZXJBcnJheS5zb21lKGZ1bmN0aW9uIChvdXRlckNob2ljZSkge1xuICAgICAgICByZXR1cm4gaW5uZXJBcnJheS5zb21lKGZ1bmN0aW9uIChpbm5lckNob2ljZSkge1xuICAgICAgICAgIGZvdW5kID0gdGVzdGVyKG91dGVyQ2hvaWNlLCBpbm5lckNob2ljZSk7XG5cbiAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH07XG5cbiAgICB2YXIgZm91bmRTb3VyY2VBbmRUZWNoID0gdm9pZCAwO1xuICAgIHZhciBmbGlwID0gZnVuY3Rpb24gZmxpcChmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBmbihiLCBhKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZmluZGVyID0gZnVuY3Rpb24gZmluZGVyKF9yZWYyLCBzb3VyY2UpIHtcbiAgICAgIHZhciB0ZWNoTmFtZSA9IF9yZWYyWzBdLFxuICAgICAgICAgIHRlY2ggPSBfcmVmMlsxXTtcblxuICAgICAgaWYgKHRlY2guY2FuUGxheVNvdXJjZShzb3VyY2UsIF90aGlzNS5vcHRpb25zX1t0ZWNoTmFtZS50b0xvd2VyQ2FzZSgpXSkpIHtcbiAgICAgICAgcmV0dXJuIHsgc291cmNlOiBzb3VyY2UsIHRlY2g6IHRlY2hOYW1lIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIERlcGVuZGluZyBvbiB0aGUgdHJ1dGhpbmVzcyBvZiBgb3B0aW9ucy5zb3VyY2VPcmRlcmAsIHdlIHN3YXAgdGhlIG9yZGVyIG9mIHRlY2hzIGFuZCBzb3VyY2VzXG4gICAgLy8gdG8gc2VsZWN0IGZyb20gdGhlbSBiYXNlZCBvbiB0aGVpciBwcmlvcml0eS5cbiAgICBpZiAodGhpcy5vcHRpb25zXy5zb3VyY2VPcmRlcikge1xuICAgICAgLy8gU291cmNlLWZpcnN0IG9yZGVyaW5nXG4gICAgICBmb3VuZFNvdXJjZUFuZFRlY2ggPSBmaW5kRmlyc3RQYXNzaW5nVGVjaFNvdXJjZVBhaXIoc291cmNlcywgdGVjaHMsIGZsaXAoZmluZGVyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRlY2gtZmlyc3Qgb3JkZXJpbmdcbiAgICAgIGZvdW5kU291cmNlQW5kVGVjaCA9IGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpcih0ZWNocywgc291cmNlcywgZmluZGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm91bmRTb3VyY2VBbmRUZWNoIHx8IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSB2aWRlbyBzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R8VGVjaH5Tb3VyY2VPYmplY3RbXXxzdHJpbmd9IFtzb3VyY2VdXG4gICAqICAgICAgICBBIFNvdXJjZU9iamVjdCwgYW4gYXJyYXkgb2YgU291cmNlT2JqZWN0cywgb3IgYSBzdHJpbmcgcmVmZXJlbmNpbmdcbiAgICogICAgICAgIGEgVVJMIHRvIGEgbWVkaWEgc291cmNlLiBJdCBpcyBfaGlnaGx5IHJlY29tbWVuZGVkXyB0aGF0IGFuIG9iamVjdFxuICAgKiAgICAgICAgb3IgYXJyYXkgb2Ygb2JqZWN0cyBpcyB1c2VkIGhlcmUsIHNvIHRoYXQgc291cmNlIHNlbGVjdGlvblxuICAgKiAgICAgICAgYWxnb3JpdGhtcyBjYW4gdGFrZSB0aGUgYHR5cGVgIGludG8gYWNjb3VudC5cbiAgICpcbiAgICogICAgICAgIElmIG5vdCBwcm92aWRlZCwgdGhpcyBtZXRob2QgYWN0cyBhcyBhIGdldHRlci5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICogICAgICAgICBJZiB0aGUgYHNvdXJjZWAgYXJndW1lbnQgaXMgbWlzc2luZywgcmV0dXJucyB0aGUgY3VycmVudCBzb3VyY2VcbiAgICogICAgICAgICBVUkwuIE90aGVyd2lzZSwgcmV0dXJucyBub3RoaW5nL3VuZGVmaW5lZC5cbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnNyYyA9IGZ1bmN0aW9uIHNyYyhzb3VyY2UpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIC8vIGdldHRlciB1c2FnZVxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVfLnNyYztcbiAgICB9XG4gICAgLy8gZmlsdGVyIG91dCBpbnZhbGlkIHNvdXJjZXMgYW5kIHR1cm4gb3VyIHNvdXJjZSBpbnRvXG4gICAgLy8gYW4gYXJyYXkgb2Ygc291cmNlIG9iamVjdHNcbiAgICB2YXIgc291cmNlcyA9IGZpbHRlclNvdXJjZShzb3VyY2UpO1xuXG4gICAgLy8gaWYgYSBzb3VyY2Ugd2FzIHBhc3NlZCBpbiB0aGVuIGl0IGlzIGludmFsaWQgYmVjYXVzZVxuICAgIC8vIGl0IHdhcyBmaWx0ZXJlZCB0byBhIHplcm8gbGVuZ3RoIEFycmF5LiBTbyB3ZSBoYXZlIHRvXG4gICAgLy8gc2hvdyBhbiBlcnJvclxuICAgIGlmICghc291cmNlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXJyb3IoeyBjb2RlOiA0LCBtZXNzYWdlOiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubm90U3VwcG9ydGVkTWVzc2FnZSkgfSk7XG4gICAgICB9LCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpbnRpYWwgc291cmNlc1xuICAgIHRoaXMuY2FjaGVfLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgIHRoaXMuY2hhbmdpbmdTcmNfID0gdHJ1ZTtcblxuICAgIC8vIGludGlhbCBzb3VyY2VcbiAgICB0aGlzLmNhY2hlXy5zb3VyY2UgPSBzb3VyY2VzWzBdO1xuXG4gICAgLy8gbWlkZGxld2FyZVNvdXJjZSBpcyB0aGUgc291cmNlIGFmdGVyIGl0IGhhcyBiZWVuIGNoYW5nZWQgYnkgbWlkZGxld2FyZVxuICAgIHNldFNvdXJjZSh0aGlzLCBzb3VyY2VzWzBdLCBmdW5jdGlvbiAobWlkZGxld2FyZVNvdXJjZSwgbXdzKSB7XG4gICAgICBfdGhpczYubWlkZGxld2FyZV8gPSBtd3M7XG5cbiAgICAgIHZhciBlcnIgPSBfdGhpczYuc3JjXyhtaWRkbGV3YXJlU291cmNlKTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoc291cmNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNi5zcmMoc291cmNlcy5zbGljZSgxKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiBhIHRpbWVvdXQgdG8gZ2l2ZSBmb2xrcyBhIGNoYW5jZSB0byBhZGQgZXJyb3IgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgX3RoaXM2LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuZXJyb3IoeyBjb2RlOiA0LCBtZXNzYWdlOiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubm90U3VwcG9ydGVkTWVzc2FnZSkgfSk7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIC8vIHdlIGNvdWxkIG5vdCBmaW5kIGFuIGFwcHJvcHJpYXRlIHRlY2gsIGJ1dCBsZXQncyBzdGlsbCBub3RpZnkgdGhlIGRlbGVnYXRlIHRoYXQgdGhpcyBpcyBpdFxuICAgICAgICAvLyB0aGlzIG5lZWRzIGEgYmV0dGVyIGNvbW1lbnQgYWJvdXQgd2h5IHRoaXMgaXMgbmVlZGVkXG4gICAgICAgIF90aGlzNi50cmlnZ2VyUmVhZHkoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzNi5jaGFuZ2luZ1NyY18gPSBmYWxzZTtcbiAgICAgIC8vIHZpZGVvIGVsZW1lbnQgbGlzdGVkIHNvdXJjZVxuICAgICAgX3RoaXM2LmNhY2hlXy5zcmMgPSBtaWRkbGV3YXJlU291cmNlLnNyYztcblxuICAgICAgc2V0VGVjaChtd3MsIF90aGlzNi50ZWNoXyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIG9iamVjdCBvbiB0aGUgdGVjaCwgcmV0dXJucyBhIGJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgd2V0aGVyXG4gICAqIHRoZXJlIGlzIGEgdGVjaCB0aGF0IGNhbiBwbGF5IHRoZSBzb3VyY2Ugb3Igbm90XG4gICAqXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNvdXJjZVxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3QgdG8gc2V0IG9uIHRoZSBUZWNoXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqICAgICAgICAgLSBUcnVlIGlmIHRoZXJlIGlzIG5vIFRlY2ggdG8gcGxheWJhY2sgdGhpcyBzb3VyY2VcbiAgICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuc3JjXyA9IGZ1bmN0aW9uIHNyY18oc291cmNlKSB7XG4gICAgdmFyIHNvdXJjZVRlY2ggPSB0aGlzLnNlbGVjdFNvdXJjZShbc291cmNlXSk7XG5cbiAgICBpZiAoIXNvdXJjZVRlY2gpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGl0bGVDYXNlRXF1YWxzKHNvdXJjZVRlY2gudGVjaCwgdGhpcy50ZWNoTmFtZV8pKSB7XG4gICAgICB0aGlzLmNoYW5naW5nU3JjXyA9IHRydWU7XG5cbiAgICAgIC8vIGxvYWQgdGhpcyB0ZWNobm9sb2d5IHdpdGggdGhlIGNob3NlbiBzb3VyY2VcbiAgICAgIHRoaXMubG9hZFRlY2hfKHNvdXJjZVRlY2gudGVjaCwgc291cmNlVGVjaC5zb3VyY2UpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHdhaXQgdW50aWwgdGhlIHRlY2ggaXMgcmVhZHkgdG8gc2V0IHRoZSBzb3VyY2VcbiAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gVGhlIHNldFNvdXJjZSB0ZWNoIG1ldGhvZCB3YXMgYWRkZWQgd2l0aCBzb3VyY2UgaGFuZGxlcnNcbiAgICAgIC8vIHNvIG9sZGVyIHRlY2hzIHdvbid0IHN1cHBvcnQgaXRcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgdGhlIGRpcmVjdCBwcm90b3R5cGUgZm9yIHRoZSBjYXNlIHdoZXJlIHN1YmNsYXNzZXNcbiAgICAgIC8vIG9mIHRoZSB0ZWNoIGRvIG5vdCBzdXBwb3J0IHNvdXJjZSBoYW5kbGVyc1xuICAgICAgaWYgKHRoaXMudGVjaF8uY29uc3RydWN0b3IucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdzZXRTb3VyY2UnKSkge1xuICAgICAgICB0aGlzLnRlY2hDYWxsXygnc2V0U291cmNlJywgc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGVjaENhbGxfKCdzcmMnLCBzb3VyY2Uuc3JjKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9uc18ucHJlbG9hZCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zXy5hdXRvcGxheSkge1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHRoZSBzb3VyY2Ugc3luY2hyb25vdXNseSBpZiBwb3NzaWJsZSAoIzIzMjYpXG4gICAgfSwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJlZ2luIGxvYWRpbmcgdGhlIHNyYyBkYXRhLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgdGhpcy50ZWNoQ2FsbF8oJ2xvYWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVzZXQgdGhlIHBsYXllci4gTG9hZHMgdGhlIGZpcnN0IHRlY2ggaW4gdGhlIHRlY2hPcmRlcixcbiAgICogYW5kIGNhbGxzIGByZXNldGAgb24gdGhlIHRlY2hgLlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLmxvYWRUZWNoXyh0aGlzLm9wdGlvbnNfLnRlY2hPcmRlclswXSwgbnVsbCk7XG4gICAgdGhpcy50ZWNoQ2FsbF8oJ3Jlc2V0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIG9mIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3RzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdFtdfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3RzXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jdXJyZW50U291cmNlcyA9IGZ1bmN0aW9uIGN1cnJlbnRTb3VyY2VzKCkge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLmN1cnJlbnRTb3VyY2UoKTtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuXG4gICAgLy8gYXNzdW1lIGB7fWAgb3IgYHsgc3JjIH1gXG4gICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jYWNoZV8uc291cmNlcyB8fCBzb3VyY2VzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge1RlY2h+U291cmNlT2JqZWN0fVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3RcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmN1cnJlbnRTb3VyY2UgPSBmdW5jdGlvbiBjdXJyZW50U291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlXy5zb3VyY2UgfHwge307XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZ1bGx5IHF1YWxpZmllZCBVUkwgb2YgdGhlIGN1cnJlbnQgc291cmNlIHZhbHVlIGUuZy4gaHR0cDovL215c2l0ZS5jb20vdmlkZW8ubXA0XG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBgY3VycmVudFR5cGVgIHRvIGFzc2lzdCBpbiByZWJ1aWxkaW5nIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgY3VycmVudCBzb3VyY2VcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmN1cnJlbnRTcmMgPSBmdW5jdGlvbiBjdXJyZW50U3JjKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTb3VyY2UoKSAmJiB0aGlzLmN1cnJlbnRTb3VyY2UoKS5zcmMgfHwgJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBzb3VyY2UgdHlwZSBlLmcuIHZpZGVvL21wNFxuICAgKiBUaGlzIGNhbiBhbGxvdyB5b3UgcmVidWlsZCB0aGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0IHNvIHRoYXQgeW91IGNvdWxkIGxvYWQgdGhlIHNhbWVcbiAgICogc291cmNlIGFuZCB0ZWNoIGxhdGVyXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgc291cmNlIE1JTUUgdHlwZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuY3VycmVudFR5cGUgPSBmdW5jdGlvbiBjdXJyZW50VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U291cmNlKCkgJiYgdGhpcy5jdXJyZW50U291cmNlKCkudHlwZSB8fCAnJztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgcHJlbG9hZCBhdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbdmFsdWVdXG4gICAqICAgICAgICAtIHRydWUgbWVhbnMgdGhhdCB3ZSBzaG91bGQgcHJlbG9hZFxuICAgKiAgICAgICAgLSBmYWxzZSBtYWVucyB0aGF0IHdlIHNob3VsZCBub3QgcHJlbG9hZFxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqICAgICAgICAgVGhlIHByZWxvYWQgYXR0cmlidXRlIHZhbHVlIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucHJlbG9hZCA9IGZ1bmN0aW9uIHByZWxvYWQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFByZWxvYWQnLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfLnByZWxvYWQgPSB2YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3ByZWxvYWQnKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgYXV0b3BsYXkgYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgIC0gdHJ1ZSBtZWFucyB0aGF0IHdlIHNob3VsZCBhdXRvcGxheVxuICAgKiAgICAgICAgLSBmYWxzZSBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgYXV0b3BsYXlcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIGF1dG9wbGF5IHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuYXV0b3BsYXkgPSBmdW5jdGlvbiBhdXRvcGxheSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0QXV0b3BsYXknLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfLmF1dG9wbGF5ID0gdmFsdWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdhdXRvcGxheScsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IG9yIHVuc2V0IHRoZSBwbGF5c2lubGluZSBhdHRyaWJ1dGUuXG4gICAqIFBsYXlzaW5saW5lIHRlbGxzIHRoZSBicm93c2VyIHRoYXQgbm9uLWZ1bGxzY3JlZW4gcGxheWJhY2sgaXMgcHJlZmVycmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgIC0gdHJ1ZSBtZWFucyB0aGF0IHdlIHNob3VsZCB0cnkgdG8gcGxheSBpbmxpbmUgYnkgZGVmYXVsdFxuICAgKiAgICAgICAgLSBmYWxzZSBtZWFucyB0aGF0IHdlIHNob3VsZCB1c2UgdGhlIGJyb3dzZXIncyBkZWZhdWx0IHBsYXliYWNrIG1vZGUsXG4gICAqICAgICAgICAgIHdoaWNoIGluIG1vc3QgY2FzZXMgaXMgaW5saW5lLiBpT1MgU2FmYXJpIGlzIGEgbm90YWJsZSBleGNlcHRpb25cbiAgICogICAgICAgICAgYW5kIHBsYXlzIGZ1bGxzY3JlZW4gYnkgZGVmYXVsdC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfFBsYXllcn1cbiAgICogICAgICAgICAtIHRoZSBjdXJyZW50IHZhbHVlIG9mIHBsYXlzaW5saW5lXG4gICAqICAgICAgICAgLSB0aGUgcGxheWVyIHdoZW4gc2V0dGluZ1xuICAgKlxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNhdHRyLXZpZGVvLXBsYXlzaW5saW5lfVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucGxheXNpbmxpbmUgPSBmdW5jdGlvbiBwbGF5c2lubGluZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0UGxheXNpbmxpbmUnLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNfLnBsYXlzaW5saW5lID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BsYXlzaW5saW5lJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGxvb3AgYXR0cmlidXRlIG9uIHRoZSB2aWRlbyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogICAgICAgIC0gdHJ1ZSBtZWFucyB0aGF0IHdlIHNob3VsZCBsb29wIHRoZSB2aWRlb1xuICAgKiAgICAgICAgLSBmYWxzZSBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbG9vcCB0aGUgdmlkZW9cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIGxvb3Agd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sb29wID0gZnVuY3Rpb24gbG9vcCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0TG9vcCcsIHZhbHVlKTtcbiAgICAgIHRoaXMub3B0aW9uc18ubG9vcCA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnbG9vcCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHRoZSBwb3N0ZXIgaW1hZ2Ugc291cmNlIHVybFxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3Bvc3RlcmNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NyY11cbiAgICogICAgICAgIFBvc3RlciBpbWFnZSBzb3VyY2UgVVJMXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBwb3N0ZXIgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5wb3N0ZXIgPSBmdW5jdGlvbiBwb3N0ZXIoc3JjKSB7XG4gICAgaWYgKHNyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3N0ZXJfO1xuICAgIH1cblxuICAgIC8vIFRoZSBjb3JyZWN0IHdheSB0byByZW1vdmUgYSBwb3N0ZXIgaXMgdG8gc2V0IGFzIGFuIGVtcHR5IHN0cmluZ1xuICAgIC8vIG90aGVyIGZhbHNleSB2YWx1ZXMgd2lsbCB0aHJvdyBlcnJvcnNcbiAgICBpZiAoIXNyYykge1xuICAgICAgc3JjID0gJyc7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHRoZSBpbnRlcm5hbCBwb3N0ZXIgdmFyaWFibGVcbiAgICB0aGlzLnBvc3Rlcl8gPSBzcmM7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHRlY2gncyBwb3N0ZXJcbiAgICB0aGlzLnRlY2hDYWxsXygnc2V0UG9zdGVyJywgc3JjKTtcblxuICAgIC8vIGFsZXJ0IGNvbXBvbmVudHMgdGhhdCB0aGUgcG9zdGVyIGhhcyBiZWVuIHNldFxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgZmlyZXMgd2hlbiB0aGUgcG9zdGVyIGltYWdlIGlzIGNoYW5nZWQgb24gdGhlIHBsYXllci5cbiAgICAgKlxuICAgICAqIEBldmVudCBQbGF5ZXIjcG9zdGVyY2hhbmdlXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcigncG9zdGVyY2hhbmdlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNvbWUgdGVjaHMgKGUuZy4gWW91VHViZSkgY2FuIHByb3ZpZGUgYSBwb3N0ZXIgc291cmNlIGluIGFuXG4gICAqIGFzeW5jaHJvbm91cyB3YXkuIFdlIHdhbnQgdGhlIHBvc3RlciBjb21wb25lbnQgdG8gdXNlIHRoaXNcbiAgICogcG9zdGVyIHNvdXJjZSBzbyB0aGF0IGl0IGNvdmVycyB1cCB0aGUgdGVjaCdzIGNvbnRyb2xzLlxuICAgKiAoWW91VHViZSdzIHBsYXkgYnV0dG9uKS4gSG93ZXZlciB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoaXNcbiAgICogc291cmNlIGlmIHRoZSBwbGF5ZXIgdXNlciBoYXNuJ3Qgc2V0IGEgcG9zdGVyIHRocm91Z2hcbiAgICogdGhlIG5vcm1hbCBBUElzLlxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI3Bvc3RlcmNoYW5nZVxuICAgKiBAbGlzdGVucyBUZWNoI3Bvc3RlcmNoYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFBvc3RlckNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoUG9zdGVyQ2hhbmdlXygpIHtcbiAgICBpZiAoIXRoaXMucG9zdGVyXyAmJiB0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8ucG9zdGVyKSB7XG4gICAgICB0aGlzLnBvc3Rlcl8gPSB0aGlzLnRlY2hfLnBvc3RlcigpIHx8ICcnO1xuXG4gICAgICAvLyBMZXQgY29tcG9uZW50cyBrbm93IHRoZSBwb3N0ZXIgaGFzIGNoYW5nZWRcbiAgICAgIHRoaXMudHJpZ2dlcigncG9zdGVyY2hhbmdlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3Igc2V0IHdoZXRoZXIgb3Igbm90IHRoZSBjb250cm9scyBhcmUgc2hvd2luZy5cbiAgICpcbiAgICogQGZpcmVzIFBsYXllciNjb250cm9sc2VuYWJsZWRcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbF1cbiAgICogICAgICAgIC0gdHJ1ZSB0byB0dXJuIGNvbnRyb2xzIG9uXG4gICAqICAgICAgICAtIGZhbHNlIHRvIHR1cm4gY29udHJvbHMgb2ZmXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgY29udHJvbHMgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5jb250cm9scyA9IGZ1bmN0aW9uIGNvbnRyb2xzKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBib29sID0gISFib29sO1xuXG4gICAgICAvLyBEb24ndCB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IHVubGVzcyBpdCBhY3R1YWxseSBjaGFuZ2VkXG4gICAgICBpZiAodGhpcy5jb250cm9sc18gIT09IGJvb2wpIHtcbiAgICAgICAgdGhpcy5jb250cm9sc18gPSBib29sO1xuXG4gICAgICAgIGlmICh0aGlzLnVzaW5nTmF0aXZlQ29udHJvbHMoKSkge1xuICAgICAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRDb250cm9scycsIGJvb2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtY29udHJvbHMtZGlzYWJsZWQnKTtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZW5hYmxlZCcpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBldmVudCBQbGF5ZXIjY29udHJvbHNlbmFibGVkXG4gICAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY29udHJvbHNlbmFibGVkJyk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRlY2hDb250cm9sc0xpc3RlbmVyc18oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWNvbnRyb2xzLWVuYWJsZWQnKTtcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZGlzYWJsZWQnKTtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAZXZlbnQgUGxheWVyI2NvbnRyb2xzZGlzYWJsZWRcbiAgICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdjb250cm9sc2Rpc2FibGVkJyk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRlY2hDb250cm9sc0xpc3RlbmVyc18oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuICEhdGhpcy5jb250cm9sc187XG4gIH07XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSBuYXRpdmUgY29udHJvbHMgb24vb2ZmLiBOYXRpdmUgY29udHJvbHMgYXJlIHRoZSBjb250cm9scyBidWlsdCBpbnRvXG4gICAqIGRldmljZXMgKGUuZy4gZGVmYXVsdCBpUGhvbmUgY29udHJvbHMpLCBGbGFzaCwgb3Igb3RoZXIgdGVjaHNcbiAgICogKGUuZy4gVmltZW8gQ29udHJvbHMpXG4gICAqICoqVGhpcyBzaG91bGQgb25seSBiZSBzZXQgYnkgdGhlIGN1cnJlbnQgdGVjaCwgYmVjYXVzZSBvbmx5IHRoZSB0ZWNoIGtub3dzXG4gICAqIGlmIGl0IGNhbiBzdXBwb3J0IG5hdGl2ZSBjb250cm9scyoqXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjdXNpbmduYXRpdmVjb250cm9sc1xuICAgKiBAZmlyZXMgUGxheWVyI3VzaW5nY3VzdG9tY29udHJvbHNcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbF1cbiAgICogICAgICAgIC0gdHJ1ZSB0byB0dXJuIG5hdGl2ZSBjb250cm9scyBvblxuICAgKiAgICAgICAgLSBmYWxzZSB0byB0dXJuIG5hdGl2ZSBjb250cm9scyBvZmZcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBuYXRpdmUgY29udHJvbHMgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS51c2luZ05hdGl2ZUNvbnRyb2xzID0gZnVuY3Rpb24gdXNpbmdOYXRpdmVDb250cm9scyhib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYm9vbCA9ICEhYm9vbDtcblxuICAgICAgLy8gRG9uJ3QgdHJpZ2dlciBhIGNoYW5nZSBldmVudCB1bmxlc3MgaXQgYWN0dWFsbHkgY2hhbmdlZFxuICAgICAgaWYgKHRoaXMudXNpbmdOYXRpdmVDb250cm9sc18gIT09IGJvb2wpIHtcbiAgICAgICAgdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzXyA9IGJvb2w7XG4gICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXVzaW5nLW5hdGl2ZS1jb250cm9scycpO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogcGxheWVyIGlzIHVzaW5nIHRoZSBuYXRpdmUgZGV2aWNlIGNvbnRyb2xzXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAZXZlbnQgUGxheWVyI3VzaW5nbmF0aXZlY29udHJvbHNcbiAgICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd1c2luZ25hdGl2ZWNvbnRyb2xzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXVzaW5nLW5hdGl2ZS1jb250cm9scycpO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogcGxheWVyIGlzIHVzaW5nIHRoZSBjdXN0b20gSFRNTCBjb250cm9sc1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGV2ZW50IFBsYXllciN1c2luZ2N1c3RvbWNvbnRyb2xzXG4gICAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMudHJpZ2dlcigndXNpbmdjdXN0b21jb250cm9scycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMudXNpbmdOYXRpdmVDb250cm9sc187XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBvciBnZXQgdGhlIGN1cnJlbnQgTWVkaWFFcnJvclxuICAgKlxuICAgKiBAZmlyZXMgUGxheWVyI2Vycm9yXG4gICAqXG4gICAqIEBwYXJhbSAge01lZGlhRXJyb3J8c3RyaW5nfG51bWJlcn0gW2Vycl1cbiAgICogICAgICAgICBBIE1lZGlhRXJyb3Igb3IgYSBzdHJpbmcvbnVtYmVyIHRvIGJlIHR1cm5lZFxuICAgKiAgICAgICAgIGludG8gYSBNZWRpYUVycm9yXG4gICAqXG4gICAqIEByZXR1cm4ge01lZGlhRXJyb3J8bnVsbH1cbiAgICogICAgICAgICBUaGUgY3VycmVudCBNZWRpYUVycm9yIHdoZW4gZ2V0dGluZyAob3IgbnVsbClcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGVyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcnJvcl8gfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZXN0b3JpbmcgdG8gZGVmYXVsdFxuICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZXJyb3JfID0gZXJyO1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWVycm9yJyk7XG4gICAgICBpZiAodGhpcy5lcnJvckRpc3BsYXkpIHtcbiAgICAgICAgdGhpcy5lcnJvckRpc3BsYXkuY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVycm9yXyA9IG5ldyBNZWRpYUVycm9yKGVycik7XG5cbiAgICAvLyBhZGQgdGhlIHZqcy1lcnJvciBjbGFzc25hbWUgdG8gdGhlIHBsYXllclxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1lcnJvcicpO1xuXG4gICAgLy8gbG9nIHRoZSBuYW1lIG9mIHRoZSBlcnJvciB0eXBlIGFuZCBhbnkgbWVzc2FnZVxuICAgIC8vIGllOCBqdXN0IGxvZ3MgXCJbb2JqZWN0IG9iamVjdF1cIiBpZiB5b3UganVzdCBsb2cgdGhlIGVycm9yIG9iamVjdFxuICAgIGxvZyQxLmVycm9yKCcoQ09ERTonICsgdGhpcy5lcnJvcl8uY29kZSArICcgJyArIE1lZGlhRXJyb3IuZXJyb3JUeXBlc1t0aGlzLmVycm9yXy5jb2RlXSArICcpJywgdGhpcy5lcnJvcl8ubWVzc2FnZSwgdGhpcy5lcnJvcl8pO1xuXG4gICAgLyoqXG4gICAgICogQGV2ZW50IFBsYXllciNlcnJvclxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJyk7XG5cbiAgICByZXR1cm47XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcG9ydCB1c2VyIGFjdGl2aXR5XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgICAgICAgRXZlbnQgb2JqZWN0XG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5yZXBvcnRVc2VyQWN0aXZpdHkgPSBmdW5jdGlvbiByZXBvcnRVc2VyQWN0aXZpdHkoZXZlbnQpIHtcbiAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IGlmIHVzZXIgaXMgYWN0aXZlXG4gICAqXG4gICAqIEBmaXJlcyBQbGF5ZXIjdXNlcmFjdGl2ZVxuICAgKiBAZmlyZXMgUGxheWVyI3VzZXJpbmFjdGl2ZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtib29sXVxuICAgKiAgICAgICAgLSB0cnVlIGlmIHRoZSB1c2VyIGlzIGFjdGl2ZVxuICAgKiAgICAgICAgLSBmYWxzZSBpZiB0aGUgdXNlciBpcyBpbmFjdGl2ZVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIHVzZXJBY3RpdmUgd2hlbiBnZXR0aW5nXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS51c2VyQWN0aXZlID0gZnVuY3Rpb24gdXNlckFjdGl2ZShib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYm9vbCA9ICEhYm9vbDtcbiAgICAgIGlmIChib29sICE9PSB0aGlzLnVzZXJBY3RpdmVfKSB7XG4gICAgICAgIHRoaXMudXNlckFjdGl2ZV8gPSBib29sO1xuICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHdhcyBpbmFjdGl2ZSBhbmQgaXMgbm93IGFjdGl2ZSB3ZSB3YW50IHRvIHJlc2V0IHRoZVxuICAgICAgICAgIC8vIGluYWN0aXZpdHkgdGltZXJcbiAgICAgICAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSB0cnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy11c2VyLWluYWN0aXZlJyk7XG4gICAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXVzZXItYWN0aXZlJyk7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQGV2ZW50IFBsYXllciN1c2VyYWN0aXZlXG4gICAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMudHJpZ2dlcigndXNlcmFjdGl2ZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdlJ3JlIHN3aXRjaGluZyB0aGUgc3RhdGUgdG8gaW5hY3RpdmUgbWFudWFsbHksIHNvIGVyYXNlIGFueSBvdGhlclxuICAgICAgICAgIC8vIGFjdGl2aXR5XG4gICAgICAgICAgdGhpcy51c2VyQWN0aXZpdHlfID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBDaHJvbWUvU2FmYXJpL0lFIGhhdmUgYnVncyB3aGVyZSB3aGVuIHlvdSBjaGFuZ2UgdGhlIGN1cnNvciBpdCBjYW5cbiAgICAgICAgICAvLyB0cmlnZ2VyIGEgbW91c2Vtb3ZlIGV2ZW50LiBUaGlzIGNhdXNlcyBhbiBpc3N1ZSB3aGVuIHlvdSdyZSBoaWRpbmdcbiAgICAgICAgICAvLyB0aGUgY3Vyc29yIHdoZW4gdGhlIHVzZXIgaXMgaW5hY3RpdmUsIGFuZCBhIG1vdXNlbW92ZSBzaWduYWxzIHVzZXJcbiAgICAgICAgICAvLyBhY3Rpdml0eS4gTWFraW5nIGl0IGltcG9zc2libGUgdG8gZ28gaW50byBpbmFjdGl2ZSBtb2RlLiBTcGVjaWZpY2FsbHlcbiAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgaW4gZnVsbHNjcmVlbiB3aGVuIHdlIHJlYWxseSBuZWVkIHRvIGhpZGUgdGhlIGN1cnNvci5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFdoZW4gdGhpcyBnZXRzIHJlc29sdmVkIGluIEFMTCBicm93c2VycyBpdCBjYW4gYmUgcmVtb3ZlZFxuICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDMwNDFcbiAgICAgICAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgICAgICAgdGhpcy50ZWNoXy5vbmUoJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy11c2VyLWFjdGl2ZScpO1xuICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy11c2VyLWluYWN0aXZlJyk7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQGV2ZW50IFBsYXllciN1c2VyaW5hY3RpdmVcbiAgICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd1c2VyaW5hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51c2VyQWN0aXZlXztcbiAgfTtcblxuICAvKipcbiAgICogTGlzdGVuIGZvciB1c2VyIGFjdGl2aXR5IGJhc2VkIG9uIHRpbWVvdXQgdmFsdWVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmxpc3RlbkZvclVzZXJBY3Rpdml0eV8gPSBmdW5jdGlvbiBsaXN0ZW5Gb3JVc2VyQWN0aXZpdHlfKCkge1xuICAgIHZhciBtb3VzZUluUHJvZ3Jlc3MgPSB2b2lkIDA7XG4gICAgdmFyIGxhc3RNb3ZlWCA9IHZvaWQgMDtcbiAgICB2YXIgbGFzdE1vdmVZID0gdm9pZCAwO1xuICAgIHZhciBoYW5kbGVBY3Rpdml0eSA9IGJpbmQodGhpcywgdGhpcy5yZXBvcnRVc2VyQWN0aXZpdHkpO1xuXG4gICAgdmFyIGhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShlKSB7XG4gICAgICAvLyAjMTA2OCAtIFByZXZlbnQgbW91c2Vtb3ZlIHNwYW1taW5nXG4gICAgICAvLyBDaHJvbWUgQnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzY2OTcwXG4gICAgICBpZiAoZS5zY3JlZW5YICE9PSBsYXN0TW92ZVggfHwgZS5zY3JlZW5ZICE9PSBsYXN0TW92ZVkpIHtcbiAgICAgICAgbGFzdE1vdmVYID0gZS5zY3JlZW5YO1xuICAgICAgICBsYXN0TW92ZVkgPSBlLnNjcmVlblk7XG4gICAgICAgIGhhbmRsZUFjdGl2aXR5KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBoYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oKSB7XG4gICAgICBoYW5kbGVBY3Rpdml0eSgpO1xuICAgICAgLy8gRm9yIGFzIGxvbmcgYXMgdGhlIHRoZXkgYXJlIHRvdWNoaW5nIHRoZSBkZXZpY2Ugb3IgaGF2ZSB0aGVpciBtb3VzZSBkb3duLFxuICAgICAgLy8gd2UgY29uc2lkZXIgdGhlbSBhY3RpdmUgZXZlbiBpZiB0aGV5J3JlIG5vdCBtb3ZpbmcgdGhlaXIgZmluZ2VyIG9yIG1vdXNlLlxuICAgICAgLy8gU28gd2Ugd2FudCB0byBjb250aW51ZSB0byB1cGRhdGUgdGhhdCB0aGV5IGFyZSBhY3RpdmVcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbChtb3VzZUluUHJvZ3Jlc3MpO1xuICAgICAgLy8gU2V0dGluZyB1c2VyQWN0aXZpdHk9dHJ1ZSBub3cgYW5kIHNldHRpbmcgdGhlIGludGVydmFsIHRvIHRoZSBzYW1lIHRpbWVcbiAgICAgIC8vIGFzIHRoZSBhY3Rpdml0eUNoZWNrIGludGVydmFsICgyNTApIHNob3VsZCBlbnN1cmUgd2UgbmV2ZXIgbWlzcyB0aGVcbiAgICAgIC8vIG5leHQgYWN0aXZpdHlDaGVja1xuICAgICAgbW91c2VJblByb2dyZXNzID0gdGhpcy5zZXRJbnRlcnZhbChoYW5kbGVBY3Rpdml0eSwgMjUwKTtcbiAgICB9O1xuXG4gICAgdmFyIGhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGV2ZW50KSB7XG4gICAgICBoYW5kbGVBY3Rpdml0eSgpO1xuICAgICAgLy8gU3RvcCB0aGUgaW50ZXJ2YWwgdGhhdCBtYWludGFpbnMgYWN0aXZpdHkgaWYgdGhlIG1vdXNlL3RvdWNoIGlzIGRvd25cbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbChtb3VzZUluUHJvZ3Jlc3MpO1xuICAgIH07XG5cbiAgICAvLyBBbnkgbW91c2UgbW92ZW1lbnQgd2lsbCBiZSBjb25zaWRlcmVkIHVzZXIgYWN0aXZpdHlcbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCBoYW5kbGVNb3VzZURvd24pO1xuICAgIHRoaXMub24oJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgdGhpcy5vbignbW91c2V1cCcsIGhhbmRsZU1vdXNlVXApO1xuXG4gICAgLy8gTGlzdGVuIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uXG4gICAgLy8gU2hvdWxkbid0IG5lZWQgdG8gdXNlIGluUHJvZ3Jlc3MgaW50ZXJ2YWwgYmVjYXVzZSBvZiBrZXkgcmVwZWF0XG4gICAgdGhpcy5vbigna2V5ZG93bicsIGhhbmRsZUFjdGl2aXR5KTtcbiAgICB0aGlzLm9uKCdrZXl1cCcsIGhhbmRsZUFjdGl2aXR5KTtcblxuICAgIC8vIFJ1biBhbiBpbnRlcnZhbCBldmVyeSAyNTAgbWlsbGlzZWNvbmRzIGluc3RlYWQgb2Ygc3R1ZmZpbmcgZXZlcnl0aGluZyBpbnRvXG4gICAgLy8gdGhlIG1vdXNlbW92ZS90b3VjaG1vdmUgZnVuY3Rpb24gaXRzZWxmLCB0byBwcmV2ZW50IHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uLlxuICAgIC8vIGB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eWAgc2ltcGx5IHNldHMgdGhpcy51c2VyQWN0aXZpdHlfIHRvIHRydWUsIHdoaWNoXG4gICAgLy8gdGhlbiBnZXRzIHBpY2tlZCB1cCBieSB0aGlzIGxvb3BcbiAgICAvLyBodHRwOi8vZWpvaG4ub3JnL2Jsb2cvbGVhcm5pbmctZnJvbS10d2l0dGVyL1xuICAgIHZhciBpbmFjdGl2aXR5VGltZW91dCA9IHZvaWQgMDtcblxuICAgIHRoaXMuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIG1vdXNlL3RvdWNoIGFjdGl2aXR5IGhhcyBoYXBwZW5lZFxuICAgICAgaWYgKHRoaXMudXNlckFjdGl2aXR5Xykge1xuICAgICAgICAvLyBSZXNldCB0aGUgYWN0aXZpdHkgdHJhY2tlclxuICAgICAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSBmYWxzZTtcblxuICAgICAgICAvLyBJZiB0aGUgdXNlciBzdGF0ZSB3YXMgaW5hY3RpdmUsIHNldCB0aGUgc3RhdGUgdG8gYWN0aXZlXG4gICAgICAgIHRoaXMudXNlckFjdGl2ZSh0cnVlKTtcblxuICAgICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgaW5hY3Rpdml0eSB0aW1lb3V0IHRvIHN0YXJ0IHRoZSB0aW1lciBvdmVyXG4gICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KGluYWN0aXZpdHlUaW1lb3V0KTtcblxuICAgICAgICB2YXIgdGltZW91dCA9IHRoaXMub3B0aW9uc18uaW5hY3Rpdml0eVRpbWVvdXQ7XG5cbiAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgLy8gSW4gPHRpbWVvdXQ+IG1pbGxpc2Vjb25kcywgaWYgbm8gbW9yZSBhY3Rpdml0eSBoYXMgb2NjdXJyZWQgdGhlXG4gICAgICAgICAgLy8gdXNlciB3aWxsIGJlIGNvbnNpZGVyZWQgaW5hY3RpdmVcbiAgICAgICAgICBpbmFjdGl2aXR5VGltZW91dCA9IHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBQcm90ZWN0IGFnYWluc3QgdGhlIGNhc2Ugd2hlcmUgdGhlIGluYWN0aXZpdHlUaW1lb3V0IGNhbiB0cmlnZ2VyIGp1c3RcbiAgICAgICAgICAgIC8vIGJlZm9yZSB0aGUgbmV4dCB1c2VyIGFjdGl2aXR5IGlzIHBpY2tlZCB1cCBieSB0aGUgYWN0aXZpdHkgY2hlY2sgbG9vcFxuICAgICAgICAgICAgLy8gY2F1c2luZyBhIGZsaWNrZXJcbiAgICAgICAgICAgIGlmICghdGhpcy51c2VyQWN0aXZpdHlfKSB7XG4gICAgICAgICAgICAgIHRoaXMudXNlckFjdGl2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCAyNTApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZS4gQSBwbGF5YmFjayByYXRlIG9mXG4gICAqIDEuMCByZXByZXNlbnRzIG5vcm1hbCBzcGVlZCBhbmQgMC41IHdvdWxkIGluZGljYXRlIGhhbGYtc3BlZWRcbiAgICogcGxheWJhY2ssIGZvciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLXBsYXliYWNrcmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JhdGVdXG4gICAqICAgICAgIE5ldyBwbGF5YmFjayByYXRlIHRvIHNldC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHBsYXliYWNrIHJhdGUgd2hlbiBnZXR0aW5nIG9yIDEuMFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUucGxheWJhY2tSYXRlID0gZnVuY3Rpb24gcGxheWJhY2tSYXRlKHJhdGUpIHtcbiAgICBpZiAocmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0UGxheWJhY2tSYXRlJywgcmF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoXy5mZWF0dXJlc1BsYXliYWNrUmF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BsYXliYWNrUmF0ZScpO1xuICAgIH1cbiAgICByZXR1cm4gMS4wO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgZGVmYXVsdCBwbGF5YmFjayByYXRlLiBBIGRlZmF1bHQgcGxheWJhY2sgcmF0ZSBvZlxuICAgKiAxLjAgcmVwcmVzZW50cyBub3JtYWwgc3BlZWQgYW5kIDAuNSB3b3VsZCBpbmRpY2F0ZSBoYWxmLXNwZWVkIHBsYXliYWNrLCBmb3IgaW5zdGFuY2UuXG4gICAqIGRlZmF1bHRQbGF5YmFja1JhdGUgd2lsbCBvbmx5IHJlcHJlc2VudCB3aGF0IHRoZSBpbnRpYWwgcGxheWJhY2tSYXRlIG9mIGEgdmlkZW8gd2FzLCBub3RcbiAgICogbm90IHRoZSBjdXJyZW50IHBsYXliYWNrUmF0ZS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLWRlZmF1bHRwbGF5YmFja3JhdGVcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtyYXRlXVxuICAgKiAgICAgICBOZXcgZGVmYXVsdCBwbGF5YmFjayByYXRlIHRvIHNldC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfFBsYXllcn1cbiAgICogICAgICAgICAtIFRoZSBkZWZhdWx0IHBsYXliYWNrIHJhdGUgd2hlbiBnZXR0aW5nIG9yIDEuMFxuICAgKiAgICAgICAgIC0gdGhlIHBsYXllciB3aGVuIHNldHRpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmRlZmF1bHRQbGF5YmFja1JhdGUgPSBmdW5jdGlvbiBkZWZhdWx0UGxheWJhY2tSYXRlKHJhdGUpIHtcbiAgICBpZiAocmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoQ2FsbF8oJ3NldERlZmF1bHRQbGF5YmFja1JhdGUnLCByYXRlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLmZlYXR1cmVzUGxheWJhY2tSYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnZGVmYXVsdFBsYXliYWNrUmF0ZScpO1xuICAgIH1cbiAgICByZXR1cm4gMS4wO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGF1ZGlvIGZsYWdcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBib29sXG4gICAqICAgICAgICAtIHRydWUgc2lnbmFscyB0aGF0IHRoaXMgaXMgYW4gYXVkaW8gcGxheWVyXG4gICAqICAgICAgICAtIGZhbHNlIHNpZ25hbHMgdGhhdCB0aGlzIGlzIG5vdCBhbiBhdWRpbyBwbGF5ZXJcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICBUaGUgY3VycmVudCB2YWx1ZSBvZiBpc0F1ZGlvIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuaXNBdWRpbyA9IGZ1bmN0aW9uIGlzQXVkaW8oYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaXNBdWRpb18gPSAhIWJvb2w7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuICEhdGhpcy5pc0F1ZGlvXztcbiAgfTtcblxuICAvKipcbiAgICogQSBoZWxwZXIgbWV0aG9kIGZvciBhZGRpbmcgYSB7QGxpbmsgVGV4dFRyYWNrfSB0byBvdXJcbiAgICoge0BsaW5rIFRleHRUcmFja0xpc3R9LlxuICAgKlxuICAgKiBJbiBhZGRpdGlvbiB0byB0aGUgVzNDIHNldHRpbmdzIHdlIGFsbG93IGFkZGluZyBhZGRpdGlvbmFsIGluZm8gdGhyb3VnaCBvcHRpb25zLlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1hZGR0ZXh0dHJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtraW5kXVxuICAgKiAgICAgICAgdGhlIGtpbmQgb2YgVGV4dFRyYWNrIHlvdSBhcmUgYWRkaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdXG4gICAqICAgICAgICB0aGUgbGFiZWwgdG8gZ2l2ZSB0aGUgVGV4dFRyYWNrIGxhYmVsXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2VdXG4gICAqICAgICAgICB0aGUgbGFuZ3VhZ2UgdG8gc2V0IG9uIHRoZSBUZXh0VHJhY2tcbiAgICpcbiAgICogQHJldHVybiB7VGV4dFRyYWNrfHVuZGVmaW5lZH1cbiAgICogICAgICAgICB0aGUgVGV4dFRyYWNrIHRoYXQgd2FzIGFkZGVkIG9yIHVuZGVmaW5lZFxuICAgKiAgICAgICAgIGlmIHRoZXJlIGlzIG5vIHRlY2hcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmFkZFRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaF8uYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5ndWFnZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByZW1vdGUge0BsaW5rIFRleHRUcmFja30gYW5kIGFuIHtAbGluayBIVE1MVHJhY2tFbGVtZW50fS4gSXQgd2lsbFxuICAgKiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgZnJvbSB0aGUgdmlkZW8gZWxlbWVudCB3aGVuZXZlciB0aGUgc291cmNlIGNoYW5nZXMsIHVubGVzc1xuICAgKiBtYW51YWxDbGVhbnVwIGlzIHNldCB0byBmYWxzZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIE9wdGlvbnMgdG8gcGFzcyB0byB7QGxpbmsgSFRNTFRyYWNrRWxlbWVudH0gZHVyaW5nIGNyZWF0aW9uLiBTZWVcbiAgICogICAgICAgIHtAbGluayBIVE1MVHJhY2tFbGVtZW50fSBmb3Igb2JqZWN0IHByb3BlcnRpZXMgdGhhdCB5b3Ugc2hvdWxkIHVzZS5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbbWFudWFsQ2xlYW51cD10cnVlXSBpZiBzZXQgdG8gZmFsc2UsIHRoZSBUZXh0VHJhY2sgd2lsbCBiZVxuICAgKlxuICAgKiBAcmV0dXJuIHtIdG1sVHJhY2tFbGVtZW50fVxuICAgKiAgICAgICAgIHRoZSBIVE1MVHJhY2tFbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQgYW5kIGFkZGVkXG4gICAqICAgICAgICAgdG8gdGhlIEh0bWxUcmFja0VsZW1lbnRMaXN0IGFuZCB0aGUgcmVtb3RlXG4gICAqICAgICAgICAgVGV4dFRyYWNrTGlzdFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBUaGUgZGVmYXVsdCB2YWx1ZSBvZiB0aGUgXCJtYW51YWxDbGVhbnVwXCIgcGFyYW1ldGVyIHdpbGwgZGVmYXVsdFxuICAgKiAgICAgICAgICAgICB0byBcImZhbHNlXCIgaW4gdXBjb21pbmcgdmVyc2lvbnMgb2YgVmlkZW8uanNcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmFkZFJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFJlbW90ZVRleHRUcmFjayhvcHRpb25zLCBtYW51YWxDbGVhbnVwKSB7XG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hfLmFkZFJlbW90ZVRleHRUcmFjayhvcHRpb25zLCBtYW51YWxDbGVhbnVwKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrfSBmcm9tIHRoZSByZXNwZWN0aXZlXG4gICAqIHtAbGluayBUZXh0VHJhY2tMaXN0fSBhbmQge0BsaW5rIEh0bWxUcmFja0VsZW1lbnRMaXN0fS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYWNrXG4gICAqICAgICAgICBSZW1vdGUge0BsaW5rIFRleHRUcmFja30gdG8gcmVtb3ZlXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICogICAgICAgICBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmdcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnJlbW92ZVJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVJlbW90ZVRleHRUcmFjaygpIHtcbiAgICB2YXIgX3JlZjMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBfcmVmMyR0cmFjayA9IF9yZWYzLnRyYWNrLFxuICAgICAgICB0cmFjayA9IF9yZWYzJHRyYWNrID09PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBfcmVmMyR0cmFjaztcblxuICAgIC8vIGRlc3RydWN0dXJlIHRoZSBpbnB1dCBpbnRvIGFuIG9iamVjdCB3aXRoIGEgdHJhY2sgYXJndW1lbnQsIGRlZmF1bHRpbmcgdG8gYXJndW1lbnRzWzBdXG4gICAgLy8gZGVmYXVsdCB0aGUgd2hvbGUgYXJndW1lbnQgdG8gYW4gZW1wdHkgb2JqZWN0IGlmIG5vdGhpbmcgd2FzIHBhc3NlZCBpblxuXG4gICAgaWYgKHRoaXMudGVjaF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnRlY2hfLnJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjayk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGF2YWlsYWJsZSBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBXM0MncyBNZWRpYVxuICAgKiBQbGF5YmFjayBRdWFsaXR5IEFQSS5cbiAgICpcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9tZWRpYS1wbGF5YmFjay1xdWFsaXR5fVxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICAgKiAgICAgICAgIEFuIG9iamVjdCB3aXRoIHN1cHBvcnRlZCBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3Mgb3IgdW5kZWZpbmVkIGlmIHRoZXJlXG4gICAqICAgICAgICAgaXMgbm8gdGVjaCBvciB0aGUgdGVjaCBkb2VzIG5vdCBzdXBwb3J0IGl0LlxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPSBmdW5jdGlvbiBnZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygnZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHknKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHZpZGVvIHdpZHRoXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogICAgICAgICBjdXJyZW50IHZpZGVvIHdpZHRoXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS52aWRlb1dpZHRoID0gZnVuY3Rpb24gdmlkZW9XaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLnZpZGVvV2lkdGggJiYgdGhpcy50ZWNoXy52aWRlb1dpZHRoKCkgfHwgMDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHZpZGVvIGhlaWdodFxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqICAgICAgICAgY3VycmVudCB2aWRlbyBoZWlnaHRcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLnZpZGVvSGVpZ2h0ID0gZnVuY3Rpb24gdmlkZW9IZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoXy52aWRlb0hlaWdodCAmJiB0aGlzLnRlY2hfLnZpZGVvSGVpZ2h0KCkgfHwgMDtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHBsYXllcidzIGxhbmd1YWdlIGNvZGVcbiAgICogTk9URTogVGhlIGxhbmd1YWdlIHNob3VsZCBiZSBzZXQgaW4gdGhlIHBsYXllciBvcHRpb25zIGlmIHlvdSB3YW50IHRoZVxuICAgKiB0aGUgY29udHJvbHMgdG8gYmUgYnVpbHQgd2l0aCBhIHNwZWNpZmljIGxhbmd1YWdlLiBDaGFuZ2luZyB0aGUgbGFudWdhZ2VcbiAgICogbGF0ZXIgd2lsbCBub3QgdXBkYXRlIGNvbnRyb2xzIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV1cbiAgICogICAgICAgIHRoZSBsYW5ndWFnZSBjb2RlIHRvIHNldCB0aGUgcGxheWVyIHRvXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogICAgICAgICBUaGUgY3VycmVudCBsYW5ndWFnZSBjb2RlIHdoZW4gZ2V0dGluZ1xuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUubGFuZ3VhZ2UgPSBmdW5jdGlvbiBsYW5ndWFnZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMubGFuZ3VhZ2VfO1xuICAgIH1cblxuICAgIHRoaXMubGFuZ3VhZ2VfID0gU3RyaW5nKGNvZGUpLnRvTG93ZXJDYXNlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGxheWVyJ3MgbGFuZ3VhZ2UgZGljdGlvbmFyeVxuICAgKiBNZXJnZSBldmVyeSB0aW1lLCBiZWNhdXNlIGEgbmV3bHkgYWRkZWQgcGx1Z2luIG1pZ2h0IGNhbGwgdmlkZW9qcy5hZGRMYW5ndWFnZSgpIGF0IGFueSB0aW1lXG4gICAqIExhbmd1YWdlcyBzcGVjaWZpZWQgZGlyZWN0bHkgaW4gdGhlIHBsYXllciBvcHRpb25zIGhhdmUgcHJlY2VkZW5jZVxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogICAgICAgICBBbiBhcnJheSBvZiBvZiBzdXBwb3J0ZWQgbGFuZ3VhZ2VzXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS5sYW5ndWFnZXMgPSBmdW5jdGlvbiBsYW5ndWFnZXMoKSB7XG4gICAgcmV0dXJuIG1lcmdlT3B0aW9ucyhQbGF5ZXIucHJvdG90eXBlLm9wdGlvbnNfLmxhbmd1YWdlcywgdGhpcy5sYW5ndWFnZXNfKTtcbiAgfTtcblxuICAvKipcbiAgICogcmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0IHJlcGVyZXNlbnRpbmcgdGhlIGN1cnJlbnQgdHJhY2tcbiAgICogaW5mb3JtYXRpb24uICoqRE9FUyBub3QgcmV0dXJuIGl0IGFzIEpTT04qKlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgT2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBvZiB0cmFjayBpbmZvXG4gICAqL1xuXG5cbiAgUGxheWVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zXyk7XG4gICAgdmFyIHRyYWNrcyA9IG9wdGlvbnMudHJhY2tzO1xuXG4gICAgb3B0aW9ucy50cmFja3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XG5cbiAgICAgIC8vIGRlZXAgbWVyZ2UgdHJhY2tzIGFuZCBudWxsIG91dCBwbGF5ZXIgc28gbm8gY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgICAgdHJhY2sgPSBtZXJnZU9wdGlvbnModHJhY2spO1xuICAgICAgdHJhY2sucGxheWVyID0gdW5kZWZpbmVkO1xuICAgICAgb3B0aW9ucy50cmFja3NbaV0gPSB0cmFjaztcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNpbXBsZSBtb2RhbCBkaWFsb2cgKGFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgTW9kYWxEaWFsb2d9XG4gICAqIGNvbXBvbmVudCkgdGhhdCBpbW1lZGlhdGVseSBvdmVybGF5cyB0aGUgcGxheWVyIHdpdGggYXJiaXRyYXJ5XG4gICAqIGNvbnRlbnQgYW5kIHJlbW92ZXMgaXRzZWxmIHdoZW4gY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbnxFbGVtZW50fEFycmF5fG51bGx9IGNvbnRlbnRcbiAgICogICAgICAgIFNhbWUgYXMge0BsaW5rIE1vZGFsRGlhbG9nI2NvbnRlbnR9J3MgcGFyYW0gb2YgdGhlIHNhbWUgbmFtZS5cbiAgICogICAgICAgIFRoZSBtb3N0IHN0cmFpZ2h0LWZvcndhcmQgdXNhZ2UgaXMgdG8gcHJvdmlkZSBhIHN0cmluZyBvciBET01cbiAgICogICAgICAgIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgIEV4dHJhIG9wdGlvbnMgd2hpY2ggd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIHtAbGluayBNb2RhbERpYWxvZ30uXG4gICAqXG4gICAqIEByZXR1cm4ge01vZGFsRGlhbG9nfVxuICAgKiAgICAgICAgIHRoZSB7QGxpbmsgTW9kYWxEaWFsb2d9IHRoYXQgd2FzIGNyZWF0ZWRcbiAgICovXG5cblxuICBQbGF5ZXIucHJvdG90eXBlLmNyZWF0ZU1vZGFsID0gZnVuY3Rpb24gY3JlYXRlTW9kYWwoY29udGVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5jb250ZW50ID0gY29udGVudCB8fCAnJztcblxuICAgIHZhciBtb2RhbCA9IG5ldyBNb2RhbERpYWxvZyh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuYWRkQ2hpbGQobW9kYWwpO1xuICAgIG1vZGFsLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXM3LnJlbW92ZUNoaWxkKG1vZGFsKTtcbiAgICB9KTtcblxuICAgIG1vZGFsLm9wZW4oKTtcbiAgICByZXR1cm4gbW9kYWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgdGFnIHNldHRpbmdzXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFnXG4gICAqICAgICAgICBUaGUgcGxheWVyIHRhZ1xuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBzZXR0aW5nc1xuICAgKiAgICAgICAgIGZvciBhIHBsYXllciB0YWdcbiAgICovXG5cblxuICBQbGF5ZXIuZ2V0VGFnU2V0dGluZ3MgPSBmdW5jdGlvbiBnZXRUYWdTZXR0aW5ncyh0YWcpIHtcbiAgICB2YXIgYmFzZU9wdGlvbnMgPSB7XG4gICAgICBzb3VyY2VzOiBbXSxcbiAgICAgIHRyYWNrczogW11cbiAgICB9O1xuXG4gICAgdmFyIHRhZ09wdGlvbnMgPSBnZXRBdHRyaWJ1dGVzKHRhZyk7XG4gICAgdmFyIGRhdGFTZXR1cCA9IHRhZ09wdGlvbnNbJ2RhdGEtc2V0dXAnXTtcblxuICAgIGlmIChoYXNDbGFzcyh0YWcsICd2anMtZmx1aWQnKSkge1xuICAgICAgdGFnT3B0aW9ucy5mbHVpZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgZGF0YS1zZXR1cCBhdHRyIGV4aXN0cy5cbiAgICBpZiAoZGF0YVNldHVwICE9PSBudWxsKSB7XG4gICAgICAvLyBQYXJzZSBvcHRpb25zIEpTT05cbiAgICAgIC8vIElmIGVtcHR5IHN0cmluZywgbWFrZSBpdCBhIHBhcnNhYmxlIGpzb24gb2JqZWN0LlxuICAgICAgdmFyIF9zYWZlUGFyc2VUdXBsZSA9IHNhZmVQYXJzZVR1cGxlKGRhdGFTZXR1cCB8fCAne30nKSxcbiAgICAgICAgICBlcnIgPSBfc2FmZVBhcnNlVHVwbGVbMF0sXG4gICAgICAgICAgZGF0YSA9IF9zYWZlUGFyc2VUdXBsZVsxXTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICBsb2ckMS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgYXNzaWduKHRhZ09wdGlvbnMsIGRhdGEpO1xuICAgIH1cblxuICAgIGFzc2lnbihiYXNlT3B0aW9ucywgdGFnT3B0aW9ucyk7XG5cbiAgICAvLyBHZXQgdGFnIGNoaWxkcmVuIHNldHRpbmdzXG4gICAgaWYgKHRhZy5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRhZy5jaGlsZE5vZGVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgLy8gQ2hhbmdlIGNhc2UgbmVlZGVkOiBodHRwOi8vZWpvaG4ub3JnL2Jsb2cvbm9kZW5hbWUtY2FzZS1zZW5zaXRpdml0eS9cbiAgICAgICAgdmFyIGNoaWxkTmFtZSA9IGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKGNoaWxkTmFtZSA9PT0gJ3NvdXJjZScpIHtcbiAgICAgICAgICBiYXNlT3B0aW9ucy5zb3VyY2VzLnB1c2goZ2V0QXR0cmlidXRlcyhjaGlsZCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkTmFtZSA9PT0gJ3RyYWNrJykge1xuICAgICAgICAgIGJhc2VPcHRpb25zLnRyYWNrcy5wdXNoKGdldEF0dHJpYnV0ZXMoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiYXNlT3B0aW9ucztcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdldGhlciBvciBub3QgZmxleGJveCBpcyBzdXBwb3J0ZWRcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogICAgICAgICAtIHRydWUgaWYgZmxleGJveCBpcyBzdXBwb3J0ZWRcbiAgICogICAgICAgICAtIGZhbHNlIGlmIGZsZXhib3ggaXMgbm90IHN1cHBvcnRlZFxuICAgKi9cblxuXG4gIFBsYXllci5wcm90b3R5cGUuZmxleE5vdFN1cHBvcnRlZF8gPSBmdW5jdGlvbiBmbGV4Tm90U3VwcG9ydGVkXygpIHtcbiAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2knKTtcblxuICAgIC8vIE5vdGU6IFdlIGRvbid0IGFjdHVhbGx5IHVzZSBmbGV4QmFzaXMgKG9yIGZsZXhPcmRlciksIGJ1dCBpdCdzIG9uZSBvZiB0aGUgbW9yZVxuICAgIC8vIGNvbW1vbiBmbGV4IGZlYXR1cmVzIHRoYXQgd2UgY2FuIHJlbHkgb24gd2hlbiBjaGVja2luZyBmb3IgZmxleCBzdXBwb3J0LlxuICAgIHJldHVybiAhKCdmbGV4QmFzaXMnIGluIGVsZW0uc3R5bGUgfHwgJ3dlYmtpdEZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSB8fCAnbW96RmxleEJhc2lzJyBpbiBlbGVtLnN0eWxlIHx8ICdtc0ZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSB8fFxuICAgIC8vIElFMTAtc3BlY2lmaWMgKDIwMTIgZmxleCBzcGVjKVxuICAgICdtc0ZsZXhPcmRlcicgaW4gZWxlbS5zdHlsZSk7XG4gIH07XG5cbiAgcmV0dXJuIFBsYXllcjtcbn0oQ29tcG9uZW50KTtcblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBWaWRlb1RyYWNrTGlzdH1cbiAqIEBsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN2aWRlb3RyYWNrbGlzdFxuICpcbiAqIEByZXR1cm4ge1ZpZGVvVHJhY2tMaXN0fVxuICogICAgICAgICB0aGUgY3VycmVudCB2aWRlbyB0cmFjayBsaXN0XG4gKlxuICogQG1ldGhvZCBQbGF5ZXIucHJvdG90eXBlLnZpZGVvVHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBBdWRpb1RyYWNrTGlzdH1cbiAqIEBsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNhdWRpb3RyYWNrbGlzdFxuICpcbiAqIEByZXR1cm4ge0F1ZGlvVHJhY2tMaXN0fVxuICogICAgICAgICB0aGUgY3VycmVudCBhdWRpbyB0cmFjayBsaXN0XG4gKlxuICogQG1ldGhvZCBQbGF5ZXIucHJvdG90eXBlLmF1ZGlvVHJhY2tzXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICpcbiAqIEBsaW5rIGh0dHA6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS10ZXh0dHJhY2tzXG4gKlxuICogQHJldHVybiB7VGV4dFRyYWNrTGlzdH1cbiAqICAgICAgICAgdGhlIGN1cnJlbnQgdGV4dCB0cmFjayBsaXN0XG4gKlxuICogQG1ldGhvZCBQbGF5ZXIucHJvdG90eXBlLnRleHRUcmFja3NcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgcmVtb3RlIHtAbGluayBUZXh0VHJhY2tMaXN0fVxuICpcbiAqIEByZXR1cm4ge1RleHRUcmFja0xpc3R9XG4gKiAgICAgICAgIFRoZSBjdXJyZW50IHJlbW90ZSB0ZXh0IHRyYWNrIGxpc3RcbiAqXG4gKiBAbWV0aG9kIFBsYXllci5wcm90b3R5cGUucmVtb3RlVGV4dFRyYWNrc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSByZW1vdGUge0BsaW5rIEh0bWxUcmFja0VsZW1lbnRMaXN0fSB0cmFja3MuXG4gKlxuICogQHJldHVybiB7SHRtbFRyYWNrRWxlbWVudExpc3R9XG4gKiAgICAgICAgIFRoZSBjdXJyZW50IHJlbW90ZSB0ZXh0IHRyYWNrIGVsZW1lbnQgbGlzdFxuICpcbiAqIEBtZXRob2QgUGxheWVyLnByb3RvdHlwZS5yZW1vdGVUZXh0VHJhY2tFbHNcbiAqL1xuXG5BTEwubmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSQkMSkge1xuICB2YXIgcHJvcHMgPSBBTExbbmFtZSQkMV07XG5cbiAgUGxheWVyLnByb3RvdHlwZVtwcm9wcy5nZXR0ZXJOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50ZWNoXykge1xuICAgICAgcmV0dXJuIHRoaXMudGVjaF9bcHJvcHMuZ2V0dGVyTmFtZV0oKTtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIG5vdCB5ZXQgbG9hZFRlY2hfLCB3ZSBjcmVhdGUge3ZpZGVvLGF1ZGlvLHRleHR9VHJhY2tzX1xuICAgIC8vIHRoZXNlIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB0ZWNoIGR1cmluZyBsb2FkaW5nXG4gICAgdGhpc1twcm9wcy5wcml2YXRlTmFtZV0gPSB0aGlzW3Byb3BzLnByaXZhdGVOYW1lXSB8fCBuZXcgcHJvcHMuTGlzdENsYXNzKCk7XG4gICAgcmV0dXJuIHRoaXNbcHJvcHMucHJpdmF0ZU5hbWVdO1xuICB9O1xufSk7XG5cbi8qKlxuICogR2xvYmFsIHBsYXllciBsaXN0XG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuUGxheWVyLnBsYXllcnMgPSB7fTtcblxudmFyIG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3I7XG5cbi8qXG4gKiBQbGF5ZXIgaW5zdGFuY2Ugb3B0aW9ucywgc3VyZmFjZWQgdXNpbmcgb3B0aW9uc1xuICogb3B0aW9ucyA9IFBsYXllci5wcm90b3R5cGUub3B0aW9uc19cbiAqIE1ha2UgY2hhbmdlcyBpbiBvcHRpb25zLCBub3QgaGVyZS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuUGxheWVyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcbiAgLy8gRGVmYXVsdCBvcmRlciBvZiBmYWxsYmFjayB0ZWNobm9sb2d5XG4gIHRlY2hPcmRlcjogVGVjaC5kZWZhdWx0VGVjaE9yZGVyXyxcblxuICBodG1sNToge30sXG4gIGZsYXNoOiB7fSxcblxuICAvLyBkZWZhdWx0IGluYWN0aXZpdHkgdGltZW91dFxuICBpbmFjdGl2aXR5VGltZW91dDogMjAwMCxcblxuICAvLyBkZWZhdWx0IHBsYXliYWNrIHJhdGVzXG4gIHBsYXliYWNrUmF0ZXM6IFtdLFxuICAvLyBBZGQgcGxheWJhY2sgcmF0ZSBzZWxlY3Rpb24gYnkgYWRkaW5nIHJhdGVzXG4gIC8vICdwbGF5YmFja1JhdGVzJzogWzAuNSwgMSwgMS41LCAyXSxcblxuICAvLyBJbmNsdWRlZCBjb250cm9sIHNldHNcbiAgY2hpbGRyZW46IFsnbWVkaWFMb2FkZXInLCAncG9zdGVySW1hZ2UnLCAndGV4dFRyYWNrRGlzcGxheScsICdsb2FkaW5nU3Bpbm5lcicsICdiaWdQbGF5QnV0dG9uJywgJ2NvbnRyb2xCYXInLCAnZXJyb3JEaXNwbGF5JywgJ3RleHRUcmFja1NldHRpbmdzJ10sXG5cbiAgbGFuZ3VhZ2U6IG5hdmlnYXRvciAmJiAobmF2aWdhdG9yLmxhbmd1YWdlcyAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdIHx8IG5hdmlnYXRvci51c2VyTGFuZ3VhZ2UgfHwgbmF2aWdhdG9yLmxhbmd1YWdlKSB8fCAnZW4nLFxuXG4gIC8vIGxvY2FsZXMgYW5kIHRoZWlyIGxhbmd1YWdlIHRyYW5zbGF0aW9uc1xuICBsYW5ndWFnZXM6IHt9LFxuXG4gIC8vIERlZmF1bHQgbWVzc2FnZSB0byBzaG93IHdoZW4gYSB2aWRlbyBjYW5ub3QgYmUgcGxheWVkLlxuICBub3RTdXBwb3J0ZWRNZXNzYWdlOiAnTm8gY29tcGF0aWJsZSBzb3VyY2Ugd2FzIGZvdW5kIGZvciB0aGlzIG1lZGlhLidcbn07XG5cbltcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGxheWVyIGlzIGluIHRoZSBcImVuZGVkXCIgc3RhdGUuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGxheWVyIGlzIGluIHRoZSBlbmRlZCBzdGF0ZSwgZmFsc2UgaWYgbm90LlxuICogQG1ldGhvZCBQbGF5ZXIjZW5kZWRcbiAqL1xuJ2VuZGVkJyxcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGxheWVyIGlzIGluIHRoZSBcInNlZWtpbmdcIiBzdGF0ZS5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwbGF5ZXIgaXMgaW4gdGhlIHNlZWtpbmcgc3RhdGUsIGZhbHNlIGlmIG5vdC5cbiAqIEBtZXRob2QgUGxheWVyI3NlZWtpbmdcbiAqL1xuJ3NlZWtpbmcnLFxuLyoqXG4gKiBSZXR1cm5zIHRoZSBUaW1lUmFuZ2VzIG9mIHRoZSBtZWRpYSB0aGF0IGFyZSBjdXJyZW50bHkgYXZhaWxhYmxlXG4gKiBmb3Igc2Vla2luZyB0by5cbiAqXG4gKiBAcmV0dXJuIHtUaW1lUmFuZ2VzfSB0aGUgc2Vla2FibGUgaW50ZXJ2YWxzIG9mIHRoZSBtZWRpYSB0aW1lbGluZVxuICogQG1ldGhvZCBQbGF5ZXIjc2Vla2FibGVcbiAqL1xuJ3NlZWthYmxlJyxcbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZSBvZiBuZXR3b3JrIGFjdGl2aXR5IGZvciB0aGUgZWxlbWVudCwgZnJvbVxuICogdGhlIGNvZGVzIGluIHRoZSBsaXN0IGJlbG93LlxuICogLSBORVRXT1JLX0VNUFRZIChudW1lcmljIHZhbHVlIDApXG4gKiAgIFRoZSBlbGVtZW50IGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGlzZWQuIEFsbCBhdHRyaWJ1dGVzIGFyZSBpblxuICogICB0aGVpciBpbml0aWFsIHN0YXRlcy5cbiAqIC0gTkVUV09SS19JRExFIChudW1lcmljIHZhbHVlIDEpXG4gKiAgIFRoZSBlbGVtZW50J3MgcmVzb3VyY2Ugc2VsZWN0aW9uIGFsZ29yaXRobSBpcyBhY3RpdmUgYW5kIGhhc1xuICogICBzZWxlY3RlZCBhIHJlc291cmNlLCBidXQgaXQgaXMgbm90IGFjdHVhbGx5IHVzaW5nIHRoZSBuZXR3b3JrIGF0XG4gKiAgIHRoaXMgdGltZS5cbiAqIC0gTkVUV09SS19MT0FESU5HIChudW1lcmljIHZhbHVlIDIpXG4gKiAgIFRoZSB1c2VyIGFnZW50IGlzIGFjdGl2ZWx5IHRyeWluZyB0byBkb3dubG9hZCBkYXRhLlxuICogLSBORVRXT1JLX05PX1NPVVJDRSAobnVtZXJpYyB2YWx1ZSAzKVxuICogICBUaGUgZWxlbWVudCdzIHJlc291cmNlIHNlbGVjdGlvbiBhbGdvcml0aG0gaXMgYWN0aXZlLCBidXQgaXQgaGFzXG4gKiAgIG5vdCB5ZXQgZm91bmQgYSByZXNvdXJjZSB0byB1c2UuXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjbmV0d29yay1zdGF0ZXNcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGN1cnJlbnQgbmV0d29yayBhY3Rpdml0eSBzdGF0ZVxuICogQG1ldGhvZCBQbGF5ZXIjbmV0d29ya1N0YXRlXG4gKi9cbiduZXR3b3JrU3RhdGUnLFxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWUgdGhhdCBleHByZXNzZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnRcbiAqIHdpdGggcmVzcGVjdCB0byByZW5kZXJpbmcgdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24sIGZyb20gdGhlXG4gKiBjb2RlcyBpbiB0aGUgbGlzdCBiZWxvdy5cbiAqIC0gSEFWRV9OT1RISU5HIChudW1lcmljIHZhbHVlIDApXG4gKiAgIE5vIGluZm9ybWF0aW9uIHJlZ2FyZGluZyB0aGUgbWVkaWEgcmVzb3VyY2UgaXMgYXZhaWxhYmxlLlxuICogLSBIQVZFX01FVEFEQVRBIChudW1lcmljIHZhbHVlIDEpXG4gKiAgIEVub3VnaCBvZiB0aGUgcmVzb3VyY2UgaGFzIGJlZW4gb2J0YWluZWQgdGhhdCB0aGUgZHVyYXRpb24gb2YgdGhlXG4gKiAgIHJlc291cmNlIGlzIGF2YWlsYWJsZS5cbiAqIC0gSEFWRV9DVVJSRU5UX0RBVEEgKG51bWVyaWMgdmFsdWUgMilcbiAqICAgRGF0YSBmb3IgdGhlIGltbWVkaWF0ZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGlzIGF2YWlsYWJsZS5cbiAqIC0gSEFWRV9GVVRVUkVfREFUQSAobnVtZXJpYyB2YWx1ZSAzKVxuICogICBEYXRhIGZvciB0aGUgaW1tZWRpYXRlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaXMgYXZhaWxhYmxlLCBhc1xuICogICB3ZWxsIGFzIGVub3VnaCBkYXRhIGZvciB0aGUgdXNlciBhZ2VudCB0byBhZHZhbmNlIHRoZSBjdXJyZW50XG4gKiAgIHBsYXliYWNrIHBvc2l0aW9uIGluIHRoZSBkaXJlY3Rpb24gb2YgcGxheWJhY2suXG4gKiAtIEhBVkVfRU5PVUdIX0RBVEEgKG51bWVyaWMgdmFsdWUgNClcbiAqICAgVGhlIHVzZXIgYWdlbnQgZXN0aW1hdGVzIHRoYXQgZW5vdWdoIGRhdGEgaXMgYXZhaWxhYmxlIGZvclxuICogICBwbGF5YmFjayB0byBwcm9jZWVkIHVuaW50ZXJydXB0ZWQuXG4gKlxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLW1lZGlhLXJlYWR5c3RhdGVcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGN1cnJlbnQgcGxheWJhY2sgcmVuZGVyaW5nIHN0YXRlXG4gKiBAbWV0aG9kIFBsYXllciNyZWFkeVN0YXRlXG4gKi9cbidyZWFkeVN0YXRlJ10uZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgUGxheWVyLnByb3RvdHlwZVtmbl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oZm4pO1xuICB9O1xufSk7XG5cblRFQ0hfRVZFTlRTX1JFVFJJR0dFUi5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICBQbGF5ZXIucHJvdG90eXBlWydoYW5kbGVUZWNoJyArIHRvVGl0bGVDYXNlKGV2ZW50KSArICdfJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJpZ2dlcihldmVudCk7XG4gIH07XG59KTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBwbGF5ZXIgaGFzIGluaXRpYWwgZHVyYXRpb24gYW5kIGRpbWVuc2lvbiBpbmZvcm1hdGlvblxuICpcbiAqIEBldmVudCBQbGF5ZXIjbG9hZGVkbWV0YWRhdGFcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cbiAqL1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBoYXMgZG93bmxvYWRlZCBkYXRhIGF0IHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uXG4gKlxuICogQGV2ZW50IFBsYXllciNsb2FkZWRkYXRhXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XG4gKi9cblxuLyoqXG4gKiBGaXJlZCB3aGVuIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGhhcyBjaGFuZ2VkICpcbiAqIER1cmluZyBwbGF5YmFjayB0aGlzIGlzIGZpcmVkIGV2ZXJ5IDE1LTI1MCBtaWxsaXNlY29uZHMsIGRlcGVuZGluZyBvbiB0aGVcbiAqIHBsYXliYWNrIHRlY2hub2xvZ3kgaW4gdXNlLlxuICpcbiAqIEBldmVudCBQbGF5ZXIjdGltZXVwZGF0ZVxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgdm9sdW1lIGNoYW5nZXNcbiAqXG4gKiBAZXZlbnQgUGxheWVyI3ZvbHVtZWNoYW5nZVxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICovXG5cbi8qKlxuICogUmVwb3J0cyB3aGV0aGVyIG9yIG5vdCBhIHBsYXllciBoYXMgYSBwbHVnaW4gYXZhaWxhYmxlLlxuICpcbiAqIFRoaXMgZG9lcyBub3QgcmVwb3J0IHdoZXRoZXIgb3Igbm90IHRoZSBwbHVnaW4gaGFzIGV2ZXIgYmVlbiBpbml0aWFsaXplZFxuICogb24gdGhpcyBwbGF5ZXIuIEZvciB0aGF0LCBbdXNpbmdQbHVnaW5de0BsaW5rIFBsYXllciN1c2luZ1BsdWdpbn0uXG4gKlxuICogQG1ldGhvZCBQbGF5ZXIjaGFzUGx1Z2luXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoaXMgcGxheWVyIGhhcyB0aGUgcmVxdWVzdGVkIHBsdWdpbiBhdmFpbGFibGUuXG4gKi9cblxuLyoqXG4gKiBSZXBvcnRzIHdoZXRoZXIgb3Igbm90IGEgcGxheWVyIGlzIHVzaW5nIGEgcGx1Z2luIGJ5IG5hbWUuXG4gKlxuICogRm9yIGJhc2ljIHBsdWdpbnMsIHRoaXMgb25seSByZXBvcnRzIHdoZXRoZXIgdGhlIHBsdWdpbiBoYXMgX2V2ZXJfIGJlZW5cbiAqIGluaXRpYWxpemVkIG9uIHRoaXMgcGxheWVyLlxuICpcbiAqIEBtZXRob2QgUGxheWVyI3VzaW5nUGx1Z2luXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqICAgICAgICAgV2hldGhlciBvciBub3QgdGhpcyBwbGF5ZXIgaXMgdXNpbmcgdGhlIHJlcXVlc3RlZCBwbHVnaW4uXG4gKi9cblxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5ZXInLCBQbGF5ZXIpO1xuXG4vKipcbiAqIEBmaWxlIHBsdWdpbi5qc1xuICovXG4vKipcbiAqIFRoZSBiYXNlIHBsdWdpbiBuYW1lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciBCQVNFX1BMVUdJTl9OQU1FID0gJ3BsdWdpbic7XG5cbi8qKlxuICogVGhlIGtleSBvbiB3aGljaCBhIHBsYXllcidzIGFjdGl2ZSBwbHVnaW5zIGNhY2hlIGlzIHN0b3JlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0YW50XG4gKiBAdHlwZSAgICAge3N0cmluZ31cbiAqL1xudmFyIFBMVUdJTl9DQUNIRV9LRVkgPSAnYWN0aXZlUGx1Z2luc18nO1xuXG4vKipcbiAqIFN0b3JlcyByZWdpc3RlcmVkIHBsdWdpbnMgaW4gYSBwcml2YXRlIHNwYWNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSAgICB7T2JqZWN0fVxuICovXG52YXIgcGx1Z2luU3RvcmFnZSA9IHt9O1xuXG4vKipcbiAqIFJlcG9ydHMgd2hldGhlciBvciBub3QgYSBwbHVnaW4gaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICogICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiAgICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgcGx1Z2luIGhhcyBiZWVuIHJlZ2lzdGVyZWQuXG4gKi9cbnZhciBwbHVnaW5FeGlzdHMgPSBmdW5jdGlvbiBwbHVnaW5FeGlzdHMobmFtZSkge1xuICByZXR1cm4gcGx1Z2luU3RvcmFnZS5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbn07XG5cbi8qKlxuICogR2V0IGEgc2luZ2xlIHJlZ2lzdGVyZWQgcGx1Z2luIGJ5IG5hbWUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKiAgICAgICAgICBUaGUgcGx1Z2luIChvciB1bmRlZmluZWQpLlxuICovXG52YXIgZ2V0UGx1Z2luID0gZnVuY3Rpb24gZ2V0UGx1Z2luKG5hbWUpIHtcbiAgcmV0dXJuIHBsdWdpbkV4aXN0cyhuYW1lKSA/IHBsdWdpblN0b3JhZ2VbbmFtZV0gOiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIE1hcmtzIGEgcGx1Z2luIGFzIFwiYWN0aXZlXCIgb24gYSBwbGF5ZXIuXG4gKlxuICogQWxzbywgZW5zdXJlcyB0aGF0IHRoZSBwbGF5ZXIgaGFzIGFuIG9iamVjdCBmb3IgdHJhY2tpbmcgYWN0aXZlIHBsdWdpbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgIHtQbGF5ZXJ9IHBsYXllclxuICogICAgICAgICAgQSBWaWRlby5qcyBwbGF5ZXIgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICogICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKi9cbnZhciBtYXJrUGx1Z2luQXNBY3RpdmUgPSBmdW5jdGlvbiBtYXJrUGx1Z2luQXNBY3RpdmUocGxheWVyLCBuYW1lKSB7XG4gIHBsYXllcltQTFVHSU5fQ0FDSEVfS0VZXSA9IHBsYXllcltQTFVHSU5fQ0FDSEVfS0VZXSB8fCB7fTtcbiAgcGxheWVyW1BMVUdJTl9DQUNIRV9LRVldW25hbWVdID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogVHJpZ2dlcnMgYSBwYWlyIG9mIHBsdWdpbiBzZXR1cCBldmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1BsYXllcn0gcGxheWVyXG4gKiAgICAgICAgIEEgVmlkZW8uanMgcGxheWVyIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSAge1BsdWdpbn5QbHVnaW5FdmVudEhhc2h9IGhhc2hcbiAqICAgICAgICAgQSBwbHVnaW4gZXZlbnQgaGFzaC5cbiAqXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbYmVmb3JlXVxuICogICAgICAgICBJZiB0cnVlLCBwcmVmaXhlcyB0aGUgZXZlbnQgbmFtZSB3aXRoIFwiYmVmb3JlXCIuIEluIG90aGVyIHdvcmRzLFxuICogICAgICAgICB1c2UgdGhpcyB0byB0cmlnZ2VyIFwiYmVmb3JlcGx1Z2luc2V0dXBcIiBpbnN0ZWFkIG9mIFwicGx1Z2luc2V0dXBcIi5cbiAqL1xudmFyIHRyaWdnZXJTZXR1cEV2ZW50ID0gZnVuY3Rpb24gdHJpZ2dlclNldHVwRXZlbnQocGxheWVyLCBoYXNoLCBiZWZvcmUpIHtcbiAgdmFyIGV2ZW50TmFtZSA9IChiZWZvcmUgPyAnYmVmb3JlJyA6ICcnKSArICdwbHVnaW5zZXR1cCc7XG5cbiAgcGxheWVyLnRyaWdnZXIoZXZlbnROYW1lLCBoYXNoKTtcbiAgcGxheWVyLnRyaWdnZXIoZXZlbnROYW1lICsgJzonICsgaGFzaC5uYW1lLCBoYXNoKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYSBiYXNpYyBwbHVnaW4gZnVuY3Rpb24gYW5kIHJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHdoaWNoIG1hcmtzXG4gKiBvbiB0aGUgcGxheWVyIHRoYXQgdGhlIHBsdWdpbiBoYXMgYmVlbiBhY3RpdmF0ZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXG4gKlxuICogQHBhcmFtICAge0Z1bmN0aW9ufSBwbHVnaW5cbiAqICAgICAgICAgIFRoZSBiYXNpYyBwbHVnaW4uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICogICAgICAgICAgQSB3cmFwcGVyIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gcGx1Z2luLlxuICovXG52YXIgY3JlYXRlQmFzaWNQbHVnaW4gPSBmdW5jdGlvbiBjcmVhdGVCYXNpY1BsdWdpbihuYW1lLCBwbHVnaW4pIHtcbiAgdmFyIGJhc2ljUGx1Z2luV3JhcHBlciA9IGZ1bmN0aW9uIGJhc2ljUGx1Z2luV3JhcHBlcigpIHtcblxuICAgIC8vIFdlIHRyaWdnZXIgdGhlIFwiYmVmb3JlcGx1Z2luc2V0dXBcIiBhbmQgXCJwbHVnaW5zZXR1cFwiIGV2ZW50cyBvbiB0aGUgcGxheWVyXG4gICAgLy8gcmVnYXJkbGVzcywgYnV0IHdlIHdhbnQgdGhlIGhhc2ggdG8gYmUgY29uc2lzdGVudCB3aXRoIHRoZSBoYXNoIHByb3ZpZGVkXG4gICAgLy8gZm9yIGFkdmFuY2VkIHBsdWdpbnMuXG4gICAgLy9cbiAgICAvLyBUaGUgb25seSBwb3RlbnRpYWxseSBjb3VudGVyLWludHVpdGl2ZSB0aGluZyBoZXJlIGlzIHRoZSBgaW5zdGFuY2VgIGluXG4gICAgLy8gdGhlIFwicGx1Z2luc2V0dXBcIiBldmVudCBpcyB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGBwbHVnaW5gIGZ1bmN0aW9uLlxuICAgIHRyaWdnZXJTZXR1cEV2ZW50KHRoaXMsIHsgbmFtZTogbmFtZSwgcGx1Z2luOiBwbHVnaW4sIGluc3RhbmNlOiBudWxsIH0sIHRydWUpO1xuXG4gICAgdmFyIGluc3RhbmNlID0gcGx1Z2luLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBtYXJrUGx1Z2luQXNBY3RpdmUodGhpcywgbmFtZSk7XG4gICAgdHJpZ2dlclNldHVwRXZlbnQodGhpcywgeyBuYW1lOiBuYW1lLCBwbHVnaW46IHBsdWdpbiwgaW5zdGFuY2U6IGluc3RhbmNlIH0pO1xuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIE9iamVjdC5rZXlzKHBsdWdpbikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIGJhc2ljUGx1Z2luV3JhcHBlcltwcm9wXSA9IHBsdWdpbltwcm9wXTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJhc2ljUGx1Z2luV3JhcHBlcjtcbn07XG5cbi8qKlxuICogVGFrZXMgYSBwbHVnaW4gc3ViLWNsYXNzIGFuZCByZXR1cm5zIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZ1xuICogaW5zdGFuY2VzIG9mIGl0LlxuICpcbiAqIFRoaXMgZmFjdG9yeSBmdW5jdGlvbiB3aWxsIHJlcGxhY2UgaXRzZWxmIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhlIHJlcXVlc3RlZFxuICogc3ViLWNsYXNzIG9mIFBsdWdpbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICogICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0gICB7UGx1Z2lufSBQbHVnaW5TdWJDbGFzc1xuICogICAgICAgICAgVGhlIGFkdmFuY2VkIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbnZhciBjcmVhdGVQbHVnaW5GYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlUGx1Z2luRmFjdG9yeShuYW1lLCBQbHVnaW5TdWJDbGFzcykge1xuXG4gIC8vIEFkZCBhIGBuYW1lYCBwcm9wZXJ0eSB0byB0aGUgcGx1Z2luIHByb3RvdHlwZSBzbyB0aGF0IGVhY2ggcGx1Z2luIGNhblxuICAvLyByZWZlciB0byBpdHNlbGYgYnkgbmFtZS5cbiAgUGx1Z2luU3ViQ2xhc3MucHJvdG90eXBlLm5hbWUgPSBuYW1lO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdHJpZ2dlclNldHVwRXZlbnQodGhpcywgeyBuYW1lOiBuYW1lLCBwbHVnaW46IFBsdWdpblN1YkNsYXNzLCBpbnN0YW5jZTogbnVsbCB9LCB0cnVlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoUGx1Z2luU3ViQ2xhc3MsIFtudWxsXS5jb25jYXQoW3RoaXNdLmNvbmNhdChhcmdzKSkpKSgpO1xuXG4gICAgLy8gVGhlIHBsdWdpbiBpcyByZXBsYWNlZCBieSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICB0aGlzW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG5cbiAgICB0cmlnZ2VyU2V0dXBFdmVudCh0aGlzLCBpbnN0YW5jZS5nZXRFdmVudEhhc2goKSk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59O1xuXG4vKipcbiAqIFBhcmVudCBjbGFzcyBmb3IgYWxsIGFkdmFuY2VkIHBsdWdpbnMuXG4gKlxuICogQG1peGVzICAgbW9kdWxlOmV2ZW50ZWR+RXZlbnRlZE1peGluXG4gKiBAbWl4ZXMgICBtb2R1bGU6c3RhdGVmdWx+U3RhdGVmdWxNaXhpblxuICogQGZpcmVzICAgUGxheWVyI2JlZm9yZXBsdWdpbnNldHVwXG4gKiBAZmlyZXMgICBQbGF5ZXIjYmVmb3JlcGx1Z2luc2V0dXA6JG5hbWVcbiAqIEBmaXJlcyAgIFBsYXllciNwbHVnaW5zZXR1cFxuICogQGZpcmVzICAgUGxheWVyI3BsdWdpbnNldHVwOiRuYW1lXG4gKiBAbGlzdGVucyBQbGF5ZXIjZGlzcG9zZVxuICogQHRocm93cyAge0Vycm9yfVxuICogICAgICAgICAgSWYgYXR0ZW1wdGluZyB0byBpbnN0YW50aWF0ZSB0aGUgYmFzZSB7QGxpbmsgUGx1Z2lufSBjbGFzc1xuICogICAgICAgICAgZGlyZWN0bHkgaW5zdGVhZCBvZiB2aWEgYSBzdWItY2xhc3MuXG4gKi9cblxudmFyIFBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICAgKlxuICAgKiBTdWItY2xhc3NlcyBzaG91bGQgY2FsbCBgc3VwZXJgIHRvIGVuc3VyZSBwbHVnaW5zIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZC5cbiAgICpcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxuICAgKiAgICAgICAgQSBWaWRlby5qcyBwbGF5ZXIgaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBQbHVnaW4ocGxheWVyKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGx1Z2luKTtcblxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBQbHVnaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGx1Z2luIG11c3QgYmUgc3ViLWNsYXNzZWQ7IG5vdCBkaXJlY3RseSBpbnN0YW50aWF0ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5wbGF5ZXIgPSBwbGF5ZXI7XG5cbiAgICAvLyBNYWtlIHRoaXMgb2JqZWN0IGV2ZW50ZWQsIGJ1dCByZW1vdmUgdGhlIGFkZGVkIGB0cmlnZ2VyYCBtZXRob2Qgc28gd2VcbiAgICAvLyB1c2UgdGhlIHByb3RvdHlwZSB2ZXJzaW9uIGluc3RlYWQuXG4gICAgZXZlbnRlZCh0aGlzKTtcbiAgICBkZWxldGUgdGhpcy50cmlnZ2VyO1xuXG4gICAgc3RhdGVmdWwodGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0U3RhdGUpO1xuICAgIG1hcmtQbHVnaW5Bc0FjdGl2ZShwbGF5ZXIsIHRoaXMubmFtZSk7XG5cbiAgICAvLyBBdXRvLWJpbmQgdGhlIGRpc3Bvc2UgbWV0aG9kIHNvIHdlIGNhbiB1c2UgaXQgYXMgYSBsaXN0ZW5lciBhbmQgdW5iaW5kXG4gICAgLy8gaXQgbGF0ZXIgZWFzaWx5LlxuICAgIHRoaXMuZGlzcG9zZSA9IGJpbmQodGhpcywgdGhpcy5kaXNwb3NlKTtcblxuICAgIC8vIElmIHRoZSBwbGF5ZXIgaXMgZGlzcG9zZWQsIGRpc3Bvc2UgdGhlIHBsdWdpbi5cbiAgICBwbGF5ZXIub24oJ2Rpc3Bvc2UnLCB0aGlzLmRpc3Bvc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVhY2ggZXZlbnQgdHJpZ2dlcmVkIGJ5IHBsdWdpbnMgaW5jbHVkZXMgYSBoYXNoIG9mIGFkZGl0aW9uYWwgZGF0YSB3aXRoXG4gICAqIGNvbnZlbnRpb25hbCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBUaGlzIHJldHVybnMgdGhhdCBvYmplY3Qgb3IgbXV0YXRlcyBhbiBleGlzdGluZyBoYXNoLlxuICAgKlxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSBbaGFzaD17fV1cbiAgICogICAgICAgICAgQW4gb2JqZWN0IHRvIGJlIHVzZWQgYXMgZXZlbnQgYW4gZXZlbnQgaGFzaC5cbiAgICpcbiAgICogQHJldHVybnMge1BsdWdpbn5QbHVnaW5FdmVudEhhc2h9XG4gICAqICAgICAgICAgIEFuIGV2ZW50IGhhc2ggb2JqZWN0IHdpdGggcHJvdmlkZWQgcHJvcGVydGllcyBtaXhlZC1pbi5cbiAgICovXG5cblxuICBQbHVnaW4ucHJvdG90eXBlLmdldEV2ZW50SGFzaCA9IGZ1bmN0aW9uIGdldEV2ZW50SGFzaCgpIHtcbiAgICB2YXIgaGFzaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBoYXNoLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgaGFzaC5wbHVnaW4gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIGhhc2guaW5zdGFuY2UgPSB0aGlzO1xuICAgIHJldHVybiBoYXNoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhbiBldmVudCBvbiB0aGUgcGx1Z2luIG9iamVjdCBhbmQgb3ZlcnJpZGVzXG4gICAqIHtAbGluayBtb2R1bGU6ZXZlbnRlZH5FdmVudGVkTWl4aW4udHJpZ2dlcnxFdmVudGVkTWl4aW4udHJpZ2dlcn0uXG4gICAqXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd8T2JqZWN0fSBldmVudFxuICAgKiAgICAgICAgICBBbiBldmVudCB0eXBlIG9yIGFuIG9iamVjdCB3aXRoIGEgdHlwZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtICAge09iamVjdH0gW2hhc2g9e31dXG4gICAqICAgICAgICAgIEFkZGl0aW9uYWwgZGF0YSBoYXNoIHRvIG1lcmdlIHdpdGggYVxuICAgKiAgICAgICAgICB7QGxpbmsgUGx1Z2luflBsdWdpbkV2ZW50SGFzaHxQbHVnaW5FdmVudEhhc2h9LlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICogICAgICAgICAgV2hldGhlciBvciBub3QgZGVmYXVsdCB3YXMgcHJldmVudGVkLlxuICAgKi9cblxuXG4gIFBsdWdpbi5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIkJDEoZXZlbnQpIHtcbiAgICB2YXIgaGFzaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICByZXR1cm4gdHJpZ2dlcih0aGlzLmV2ZW50QnVzRWxfLCBldmVudCwgdGhpcy5nZXRFdmVudEhhc2goaGFzaCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIFwic3RhdGVjaGFuZ2VkXCIgZXZlbnRzIG9uIHRoZSBwbHVnaW4uIE5vLW9wIGJ5IGRlZmF1bHQsIG92ZXJyaWRlIGJ5XG4gICAqIHN1YmNsYXNzaW5nLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtICAgIHtFdmVudH0gZVxuICAgKiAgICAgICAgICAgQW4gZXZlbnQgb2JqZWN0IHByb3ZpZGVkIGJ5IGEgXCJzdGF0ZWNoYW5nZWRcIiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICAgIHtPYmplY3R9IGUuY2hhbmdlc1xuICAgKiAgICAgICAgICAgQW4gb2JqZWN0IGRlc2NyaWJpbmcgY2hhbmdlcyB0aGF0IG9jY3VycmVkIHdpdGggdGhlIFwic3RhdGVjaGFuZ2VkXCJcbiAgICogICAgICAgICAgIGV2ZW50LlxuICAgKi9cblxuXG4gIFBsdWdpbi5wcm90b3R5cGUuaGFuZGxlU3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24gaGFuZGxlU3RhdGVDaGFuZ2VkKGUpIHt9O1xuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyBhIHBsdWdpbi5cbiAgICpcbiAgICogU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyBpZiB0aGV5IHdhbnQsIGJ1dCBmb3IgdGhlIHNha2Ugb2Ygc2FmZXR5LFxuICAgKiBpdCdzIHByb2JhYmx5IGJlc3QgdG8gc3Vic2NyaWJlIHRoZSBcImRpc3Bvc2VcIiBldmVudC5cbiAgICpcbiAgICogQGZpcmVzIFBsdWdpbiNkaXNwb3NlXG4gICAqL1xuXG5cbiAgUGx1Z2luLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB2YXIgbmFtZSA9IHRoaXMubmFtZSxcbiAgICAgICAgcGxheWVyID0gdGhpcy5wbGF5ZXI7XG5cbiAgICAvKipcbiAgICAgKiBTaWduYWxzIHRoYXQgYSBhZHZhbmNlZCBwbHVnaW4gaXMgYWJvdXQgdG8gYmUgZGlzcG9zZWQuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgUGx1Z2luI2Rpc3Bvc2VcbiAgICAgKiBAdHlwZSAge0V2ZW50VGFyZ2V0fkV2ZW50fVxuICAgICAqL1xuXG4gICAgdGhpcy50cmlnZ2VyKCdkaXNwb3NlJyk7XG4gICAgdGhpcy5vZmYoKTtcbiAgICBwbGF5ZXIub2ZmKCdkaXNwb3NlJywgdGhpcy5kaXNwb3NlKTtcblxuICAgIC8vIEVsaW1pbmF0ZSBhbnkgcG9zc2libGUgc291cmNlcyBvZiBsZWFraW5nIG1lbW9yeSBieSBjbGVhcmluZyB1cFxuICAgIC8vIHJlZmVyZW5jZXMgYmV0d2VlbiB0aGUgcGxheWVyIGFuZCB0aGUgcGx1Z2luIGluc3RhbmNlIGFuZCBudWxsaW5nIG91dFxuICAgIC8vIHRoZSBwbHVnaW4ncyBzdGF0ZSBhbmQgcmVwbGFjaW5nIG1ldGhvZHMgd2l0aCBhIGZ1bmN0aW9uIHRoYXQgdGhyb3dzLlxuICAgIHBsYXllcltQTFVHSU5fQ0FDSEVfS0VZXVtuYW1lXSA9IGZhbHNlO1xuICAgIHRoaXMucGxheWVyID0gdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICAvLyBGaW5hbGx5LCByZXBsYWNlIHRoZSBwbHVnaW4gbmFtZSBvbiB0aGUgcGxheWVyIHdpdGggYSBuZXcgZmFjdG9yeVxuICAgIC8vIGZ1bmN0aW9uLCBzbyB0aGF0IHRoZSBwbHVnaW4gaXMgcmVhZHkgdG8gYmUgc2V0IHVwIGFnYWluLlxuICAgIHBsYXllcltuYW1lXSA9IGNyZWF0ZVBsdWdpbkZhY3RvcnkobmFtZSwgcGx1Z2luU3RvcmFnZVtuYW1lXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgYSBwbHVnaW4gaXMgYSBiYXNpYyBwbHVnaW4gKGkuZS4gbm90IGEgc3ViLWNsYXNzIG9mIGBQbHVnaW5gKS5cbiAgICpcbiAgICogQHBhcmFtICAge3N0cmluZ3xGdW5jdGlvbn0gcGx1Z2luXG4gICAqICAgICAgICAgIElmIGEgc3RyaW5nLCBtYXRjaGVzIHRoZSBuYW1lIG9mIGEgcGx1Z2luLiBJZiBhIGZ1bmN0aW9uLCB3aWxsIGJlXG4gICAqICAgICAgICAgIHRlc3RlZCBkaXJlY3RseS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqICAgICAgICAgIFdoZXRoZXIgb3Igbm90IGEgcGx1Z2luIGlzIGEgYmFzaWMgcGx1Z2luLlxuICAgKi9cblxuXG4gIFBsdWdpbi5pc0Jhc2ljID0gZnVuY3Rpb24gaXNCYXNpYyhwbHVnaW4pIHtcbiAgICB2YXIgcCA9IHR5cGVvZiBwbHVnaW4gPT09ICdzdHJpbmcnID8gZ2V0UGx1Z2luKHBsdWdpbikgOiBwbHVnaW47XG5cbiAgICByZXR1cm4gdHlwZW9mIHAgPT09ICdmdW5jdGlvbicgJiYgIVBsdWdpbi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihwLnByb3RvdHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgVmlkZW8uanMgcGx1Z2luLlxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdG8gYmUgcmVnaXN0ZXJlZC4gTXVzdCBiZSBhIHN0cmluZyBhbmRcbiAgICogICAgICAgICAgbXVzdCBub3QgbWF0Y2ggYW4gZXhpc3RpbmcgcGx1Z2luIG9yIGEgbWV0aG9kIG9uIHRoZSBgUGxheWVyYFxuICAgKiAgICAgICAgICBwcm90b3R5cGUuXG4gICAqXG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gcGx1Z2luXG4gICAqICAgICAgICAgIEEgc3ViLWNsYXNzIG9mIGBQbHVnaW5gIG9yIGEgZnVuY3Rpb24gZm9yIGJhc2ljIHBsdWdpbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICogICAgICAgICAgRm9yIGFkdmFuY2VkIHBsdWdpbnMsIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgdGhhdCBwbHVnaW4uIEZvclxuICAgKiAgICAgICAgICBiYXNpYyBwbHVnaW5zLCBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyB0aGUgcGx1Z2luLlxuICAgKi9cblxuXG4gIFBsdWdpbi5yZWdpc3RlclBsdWdpbiA9IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKG5hbWUsIHBsdWdpbikge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBwbHVnaW4gbmFtZSwgXCInICsgbmFtZSArICdcIiwgbXVzdCBiZSBhIHN0cmluZywgd2FzICcgKyAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSArICcuJyk7XG4gICAgfVxuXG4gICAgaWYgKHBsdWdpbkV4aXN0cyhuYW1lKSkge1xuICAgICAgbG9nJDEud2FybignQSBwbHVnaW4gbmFtZWQgXCInICsgbmFtZSArICdcIiBhbHJlYWR5IGV4aXN0cy4gWW91IG1heSB3YW50IHRvIGF2b2lkIHJlLXJlZ2lzdGVyaW5nIHBsdWdpbnMhJyk7XG4gICAgfSBlbHNlIGlmIChQbGF5ZXIucHJvdG90eXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgcGx1Z2luIG5hbWUsIFwiJyArIG5hbWUgKyAnXCIsIGNhbm5vdCBzaGFyZSBhIG5hbWUgd2l0aCBhbiBleGlzdGluZyBwbGF5ZXIgbWV0aG9kIScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGx1Z2luICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgcGx1Z2luIGZvciBcIicgKyBuYW1lICsgJ1wiLCBtdXN0IGJlIGEgZnVuY3Rpb24sIHdhcyAnICsgKHR5cGVvZiBwbHVnaW4gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBsdWdpbikpICsgJy4nKTtcbiAgICB9XG5cbiAgICBwbHVnaW5TdG9yYWdlW25hbWVdID0gcGx1Z2luO1xuXG4gICAgLy8gQWRkIGEgcGxheWVyIHByb3RvdHlwZSBtZXRob2QgZm9yIGFsbCBzdWItY2xhc3NlZCBwbHVnaW5zIChidXQgbm90IGZvclxuICAgIC8vIHRoZSBiYXNlIFBsdWdpbiBjbGFzcykuXG4gICAgaWYgKG5hbWUgIT09IEJBU0VfUExVR0lOX05BTUUpIHtcbiAgICAgIGlmIChQbHVnaW4uaXNCYXNpYyhwbHVnaW4pKSB7XG4gICAgICAgIFBsYXllci5wcm90b3R5cGVbbmFtZV0gPSBjcmVhdGVCYXNpY1BsdWdpbihuYW1lLCBwbHVnaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUGxheWVyLnByb3RvdHlwZVtuYW1lXSA9IGNyZWF0ZVBsdWdpbkZhY3RvcnkobmFtZSwgcGx1Z2luKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGx1Z2luO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZS1yZWdpc3RlciBhIFZpZGVvLmpzIHBsdWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdG8gYmUgZGVyZWdpc3RlcmVkLlxuICAgKi9cblxuXG4gIFBsdWdpbi5kZXJlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24gZGVyZWdpc3RlclBsdWdpbihuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09IEJBU0VfUExVR0lOX05BTUUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlLXJlZ2lzdGVyIGJhc2UgcGx1Z2luLicpO1xuICAgIH1cbiAgICBpZiAocGx1Z2luRXhpc3RzKG5hbWUpKSB7XG4gICAgICBkZWxldGUgcGx1Z2luU3RvcmFnZVtuYW1lXTtcbiAgICAgIGRlbGV0ZSBQbGF5ZXIucHJvdG90eXBlW25hbWVdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3QgY29udGFpbmluZyBtdWx0aXBsZSBWaWRlby5qcyBwbHVnaW5zLlxuICAgKlxuICAgKiBAcGFyYW0gICB7QXJyYXl9IFtuYW1lc11cbiAgICogICAgICAgICAgSWYgcHJvdmlkZWQsIHNob3VsZCBiZSBhbiBhcnJheSBvZiBwbHVnaW4gbmFtZXMuIERlZmF1bHRzIHRvIF9hbGxfXG4gICAqICAgICAgICAgIHBsdWdpbiBuYW1lcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9XG4gICAqICAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHBsdWdpbihzKSBhc3NvY2lhdGVkIHdpdGggdGhlaXIgbmFtZShzKSBvclxuICAgKiAgICAgICAgICBgdW5kZWZpbmVkYCBpZiBubyBtYXRjaGluZyBwbHVnaW5zIGV4aXN0KS5cbiAgICovXG5cblxuICBQbHVnaW4uZ2V0UGx1Z2lucyA9IGZ1bmN0aW9uIGdldFBsdWdpbnMoKSB7XG4gICAgdmFyIG5hbWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBPYmplY3Qua2V5cyhwbHVnaW5TdG9yYWdlKTtcblxuICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG5cbiAgICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgcGx1Z2luID0gZ2V0UGx1Z2luKG5hbWUpO1xuXG4gICAgICBpZiAocGx1Z2luKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB7fTtcbiAgICAgICAgcmVzdWx0W25hbWVdID0gcGx1Z2luO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhIHBsdWdpbidzIHZlcnNpb24sIGlmIGF2YWlsYWJsZVxuICAgKlxuICAgKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gICAqICAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiAgICAgICAgICBUaGUgcGx1Z2luJ3MgdmVyc2lvbiBvciBhbiBlbXB0eSBzdHJpbmcuXG4gICAqL1xuXG5cbiAgUGx1Z2luLmdldFBsdWdpblZlcnNpb24gPSBmdW5jdGlvbiBnZXRQbHVnaW5WZXJzaW9uKG5hbWUpIHtcbiAgICB2YXIgcGx1Z2luID0gZ2V0UGx1Z2luKG5hbWUpO1xuXG4gICAgcmV0dXJuIHBsdWdpbiAmJiBwbHVnaW4uVkVSU0lPTiB8fCAnJztcbiAgfTtcblxuICByZXR1cm4gUGx1Z2luO1xufSgpO1xuXG4vKipcbiAqIEdldHMgYSBwbHVnaW4gYnkgbmFtZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCAgIGdldFBsdWdpblxuICogQG1lbWJlck9mIFBsdWdpblxuICogQHBhcmFtICAgIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJucyAge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqICAgICAgICAgICBUaGUgcGx1Z2luIChvciBgdW5kZWZpbmVkYCkuXG4gKi9cblxuXG5QbHVnaW4uZ2V0UGx1Z2luID0gZ2V0UGx1Z2luO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBiYXNlIHBsdWdpbiBjbGFzcyBhcyBpdCBpcyByZWdpc3RlcmVkLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblBsdWdpbi5CQVNFX1BMVUdJTl9OQU1FID0gQkFTRV9QTFVHSU5fTkFNRTtcblxuUGx1Z2luLnJlZ2lzdGVyUGx1Z2luKEJBU0VfUExVR0lOX05BTUUsIFBsdWdpbik7XG5cbi8qKlxuICogRG9jdW1lbnRlZCBpbiBwbGF5ZXIuanNcbiAqXG4gKiBAaWdub3JlXG4gKi9cblBsYXllci5wcm90b3R5cGUudXNpbmdQbHVnaW4gPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gISF0aGlzW1BMVUdJTl9DQUNIRV9LRVldICYmIHRoaXNbUExVR0lOX0NBQ0hFX0tFWV1bbmFtZV0gPT09IHRydWU7XG59O1xuXG4vKipcbiAqIERvY3VtZW50ZWQgaW4gcGxheWVyLmpzXG4gKlxuICogQGlnbm9yZVxuICovXG5QbGF5ZXIucHJvdG90eXBlLmhhc1BsdWdpbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAhIXBsdWdpbkV4aXN0cyhuYW1lKTtcbn07XG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGEgcGx1Z2luIGlzIGFib3V0IHRvIGJlIHNldCB1cCBvbiBhIHBsYXllci5cbiAqXG4gKiBAZXZlbnQgICAgUGxheWVyI2JlZm9yZXBsdWdpbnNldHVwXG4gKiBAdHlwZSAgICAge1BsdWdpbn5QbHVnaW5FdmVudEhhc2h9XG4gKi9cblxuLyoqXG4gKiBTaWduYWxzIHRoYXQgYSBwbHVnaW4gaXMgYWJvdXQgdG8gYmUgc2V0IHVwIG9uIGEgcGxheWVyIC0gYnkgbmFtZS4gVGhlIG5hbWVcbiAqIGlzIHRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXG4gKlxuICogQGV2ZW50ICAgIFBsYXllciNiZWZvcmVwbHVnaW5zZXR1cDokbmFtZVxuICogQHR5cGUgICAgIHtQbHVnaW5+UGx1Z2luRXZlbnRIYXNofVxuICovXG5cbi8qKlxuICogU2lnbmFscyB0aGF0IGEgcGx1Z2luIGhhcyBqdXN0IGJlZW4gc2V0IHVwIG9uIGEgcGxheWVyLlxuICpcbiAqIEBldmVudCAgICBQbGF5ZXIjcGx1Z2luc2V0dXBcbiAqIEB0eXBlICAgICB7UGx1Z2luflBsdWdpbkV2ZW50SGFzaH1cbiAqL1xuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIHBsdWdpbiBoYXMganVzdCBiZWVuIHNldCB1cCBvbiBhIHBsYXllciAtIGJ5IG5hbWUuIFRoZSBuYW1lXG4gKiBpcyB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICpcbiAqIEBldmVudCAgICBQbGF5ZXIjcGx1Z2luc2V0dXA6JG5hbWVcbiAqIEB0eXBlICAgICB7UGx1Z2luflBsdWdpbkV2ZW50SGFzaH1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmICB7T2JqZWN0fSBQbHVnaW5+UGx1Z2luRXZlbnRIYXNoXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGluc3RhbmNlXG4gKiAgICAgICAgICAgRm9yIGJhc2ljIHBsdWdpbnMsIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHBsdWdpbiBmdW5jdGlvbi4gRm9yXG4gKiAgICAgICAgICAgYWR2YW5jZWQgcGx1Z2lucywgdGhlIHBsdWdpbiBpbnN0YW5jZSBvbiB3aGljaCB0aGUgZXZlbnQgaXMgZmlyZWQuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwbHVnaW5cbiAqICAgICAgICAgICBGb3IgYmFzaWMgcGx1Z2lucywgdGhlIHBsdWdpbiBmdW5jdGlvbi4gRm9yIGFkdmFuY2VkIHBsdWdpbnMsIHRoZVxuICogICAgICAgICAgIHBsdWdpbiBjbGFzcy9jb25zdHJ1Y3Rvci5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIGV4dGVuZC5qc1xuICogQG1vZHVsZSBleHRlbmRcbiAqL1xuXG4vKipcbiAqIEEgY29tYmluYXRpb24gb2Ygbm9kZSBpbmhlcml0cyBhbmQgYmFiZWwncyBpbmhlcml0cyAoYWZ0ZXIgdHJhbnNwaWxlKS5cbiAqIEJvdGggd29yayB0aGUgc2FtZSBidXQgbm9kZSBhZGRzIGBzdXBlcl9gIHRvIHRoZSBzdWJDbGFzc1xuICogYW5kIEJhYmxlIGFkZHMgdGhlIHN1cGVyQ2xhc3MgYXMgX19wcm90b19fLiBCb3RoIHNlZW0gdXNlZnVsLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWJDbGFzc1xuICogICAgICAgIFRoZSBjbGFzcyB0byBpbmhlcml0IHRvXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN1cGVyQ2xhc3NcbiAqICAgICAgICBUaGUgY2xhc3MgdG8gaW5oZXJpdCBmcm9tXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIF9pbmhlcml0cyA9IGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3VwZXJDbGFzcykpKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcblxuICBpZiAoc3VwZXJDbGFzcykge1xuICAgIC8vIG5vZGVcbiAgICBzdWJDbGFzcy5zdXBlcl8gPSBzdXBlckNsYXNzO1xuICB9XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIGZvciBzdWJjbGFzc2luZyB1c2luZyB0aGUgc2FtZSBpbmhlcml0YW5jZSB0aGF0XG4gKiB2aWRlb2pzIHVzZXMgaW50ZXJuYWxseVxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdXBlckNsYXNzXG4gKiAgICAgICAgVGhlIGNsYXNzIHRvIGluaGVyaXQgZnJvbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3ViQ2xhc3NNZXRob2RzPXt9XVxuICogICAgICAgIFRoZSBjbGFzcyB0byBpbmhlcml0IHRvXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBUaGUgbmV3IG9iamVjdCB3aXRoIHN1YkNsYXNzTWV0aG9kcyB0aGF0IGluaGVyaXRlZCBzdXBlckNsYXNzLlxuICovXG52YXIgZXh0ZW5kRm4gPSBmdW5jdGlvbiBleHRlbmRGbihzdXBlckNsYXNzKSB7XG4gIHZhciBzdWJDbGFzc01ldGhvZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIHZhciBzdWJDbGFzcyA9IGZ1bmN0aW9uIHN1YkNsYXNzKCkge1xuICAgIHN1cGVyQ2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgbWV0aG9kcyA9IHt9O1xuXG4gIGlmICgodHlwZW9mIHN1YkNsYXNzTWV0aG9kcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3ViQ2xhc3NNZXRob2RzKSkgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHN1YkNsYXNzTWV0aG9kcy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgc3ViQ2xhc3MgPSBzdWJDbGFzc01ldGhvZHMuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIG1ldGhvZHMgPSBzdWJDbGFzc01ldGhvZHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN1YkNsYXNzTWV0aG9kcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN1YkNsYXNzID0gc3ViQ2xhc3NNZXRob2RzO1xuICB9XG5cbiAgX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcblxuICAvLyBFeHRlbmQgc3ViT2JqJ3MgcHJvdG90eXBlIHdpdGggZnVuY3Rpb25zIGFuZCBvdGhlciBwcm9wZXJ0aWVzIGZyb20gcHJvcHNcbiAgZm9yICh2YXIgbmFtZSBpbiBtZXRob2RzKSB7XG4gICAgaWYgKG1ldGhvZHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHN1YkNsYXNzLnByb3RvdHlwZVtuYW1lXSA9IG1ldGhvZHNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YkNsYXNzO1xufTtcblxuLyoqXG4gKiBAZmlsZSB2aWRlby5qc1xuICogQG1vZHVsZSB2aWRlb2pzXG4gKi9cbi8vIEluY2x1ZGUgdGhlIGJ1aWx0LWluIHRlY2hzXG4vLyBIVE1MNSBFbGVtZW50IFNoaW0gZm9yIElFOFxuaWYgKHR5cGVvZiBIVE1MVmlkZW9FbGVtZW50ID09PSAndW5kZWZpbmVkJyAmJiBpc1JlYWwoKSkge1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cmFjaycpO1xufVxuXG4vKipcbiAqIERvdWJsZXMgYXMgdGhlIG1haW4gZnVuY3Rpb24gZm9yIHVzZXJzIHRvIGNyZWF0ZSBhIHBsYXllciBpbnN0YW5jZSBhbmQgYWxzb1xuICogdGhlIG1haW4gbGlicmFyeSBvYmplY3QuXG4gKiBUaGUgYHZpZGVvanNgIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGluaXRpYWxpemUgb3IgcmV0cmlldmUgYSBwbGF5ZXIuXG4gICpcbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR9IGlkXG4gKiAgICAgICAgVmlkZW8gZWxlbWVudCBvciB2aWRlbyBlbGVtZW50IElEXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICAgICAgIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IGZvciBjb25maWcvc2V0dGluZ3NcbiAqXG4gKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXG4gKiAgICAgICAgT3B0aW9uYWwgcmVhZHkgY2FsbGJhY2tcbiAqXG4gKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gKiAgICAgICAgIEEgcGxheWVyIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHZpZGVvanMoaWQsIG9wdGlvbnMsIHJlYWR5KSB7XG4gIHZhciB0YWcgPSB2b2lkIDA7XG5cbiAgLy8gQWxsb3cgZm9yIGVsZW1lbnQgb3IgSUQgdG8gYmUgcGFzc2VkIGluXG4gIC8vIFN0cmluZyBJRFxuICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuICAgIHZhciBwbGF5ZXJzID0gdmlkZW9qcy5nZXRQbGF5ZXJzKCk7XG5cbiAgICAvLyBBZGp1c3QgZm9yIGpRdWVyeSBJRCBzeW50YXhcbiAgICBpZiAoaWQuaW5kZXhPZignIycpID09PSAwKSB7XG4gICAgICBpZCA9IGlkLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIC8vIElmIGEgcGxheWVyIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZCBmb3IgdGhpcyBJRCByZXR1cm4gaXQuXG4gICAgaWYgKHBsYXllcnNbaWRdKSB7XG5cbiAgICAgIC8vIElmIG9wdGlvbnMgb3IgcmVhZHkgZnVuY3Rpb24gYXJlIHBhc3NlZCwgd2FyblxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgbG9nJDEud2FybignUGxheWVyIFwiJyArIGlkICsgJ1wiIGlzIGFscmVhZHkgaW5pdGlhbGlzZWQuIE9wdGlvbnMgd2lsbCBub3QgYmUgYXBwbGllZC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlYWR5KSB7XG4gICAgICAgIHBsYXllcnNbaWRdLnJlYWR5KHJlYWR5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBsYXllcnNbaWRdO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSBnZXQgZWxlbWVudCBmb3IgSURcbiAgICB0YWcgPSAkKCcjJyArIGlkKTtcblxuICAgIC8vIElEIGlzIGEgbWVkaWEgZWxlbWVudFxuICB9IGVsc2Uge1xuICAgIHRhZyA9IGlkO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGEgdXNlYWJsZSBlbGVtZW50XG4gIC8vIHJlOiBub2RlTmFtZSwgY291bGQgYmUgYSBib3ggZGl2IGFsc29cbiAgaWYgKCF0YWcgfHwgIXRhZy5ub2RlTmFtZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBlbGVtZW50IG9yIElEIHN1cHBsaWVkIGlzIG5vdCB2YWxpZC4gKHZpZGVvanMpJyk7XG4gIH1cblxuICAvLyBFbGVtZW50IG1heSBoYXZlIGEgcGxheWVyIGF0dHIgcmVmZXJyaW5nIHRvIGFuIGFscmVhZHkgY3JlYXRlZCBwbGF5ZXIgaW5zdGFuY2UuXG4gIC8vIElmIHNvIHJldHVybiB0aGF0IG90aGVyd2lzZSBzZXQgdXAgYSBuZXcgcGxheWVyIGJlbG93XG4gIGlmICh0YWcucGxheWVyIHx8IFBsYXllci5wbGF5ZXJzW3RhZy5wbGF5ZXJJZF0pIHtcbiAgICByZXR1cm4gdGFnLnBsYXllciB8fCBQbGF5ZXIucGxheWVyc1t0YWcucGxheWVySWRdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmlkZW9qcy5ob29rcygnYmVmb3Jlc2V0dXAnKS5mb3JFYWNoKGZ1bmN0aW9uIChob29rRnVuY3Rpb24pIHtcbiAgICB2YXIgb3B0cyA9IGhvb2tGdW5jdGlvbih0YWcsIG1lcmdlT3B0aW9ucyhvcHRpb25zKSk7XG5cbiAgICBpZiAoIWlzT2JqZWN0KG9wdHMpIHx8IEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgIGxvZyQxLmVycm9yKCdwbGVhc2UgcmV0dXJuIGFuIG9iamVjdCBpbiBiZWZvcmVzZXR1cCBob29rcycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0aW9ucywgb3B0cyk7XG4gIH0pO1xuXG4gIHZhciBQbGF5ZXJDb21wb25lbnQgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KCdQbGF5ZXInKTtcbiAgLy8gSWYgbm90LCBzZXQgdXAgYSBuZXcgcGxheWVyXG4gIHZhciBwbGF5ZXIgPSBuZXcgUGxheWVyQ29tcG9uZW50KHRhZywgb3B0aW9ucywgcmVhZHkpO1xuXG4gIHZpZGVvanMuaG9va3MoJ3NldHVwJykuZm9yRWFjaChmdW5jdGlvbiAoaG9va0Z1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGhvb2tGdW5jdGlvbihwbGF5ZXIpO1xuICB9KTtcblxuICByZXR1cm4gcGxheWVyO1xufVxuXG4vKipcbiAqIEFuIE9iamVjdCB0aGF0IGNvbnRhaW5zIGxpZmVjeWNsZSBob29rcyBhcyBrZXlzIHdoaWNoIHBvaW50IHRvIGFuIGFycmF5XG4gKiBvZiBmdW5jdGlvbnMgdGhhdCBhcmUgcnVuIHdoZW4gYSBsaWZlY3ljbGUgaXMgdHJpZ2dlcmVkXG4gKi9cbnZpZGVvanMuaG9va3NfID0ge307XG5cbi8qKlxuICogR2V0IGEgbGlzdCBvZiBob29rcyBmb3IgYSBzcGVjaWZpYyBsaWZlY3ljbGVcbiAqIEBmdW5jdGlvbiB2aWRlb2pzLmhvb2tzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICB0aGUgbGlmZWN5bGUgdG8gZ2V0IGhvb2tzIGZyb21cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiAgICAgICAgT3B0aW9uYWxseSBhZGQgYSBob29rIHRvIHRoZSBsaWZlY3ljbGUgdGhhdCB5b3VyIGFyZSBnZXR0aW5nLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogICAgICAgICBhbiBhcnJheSBvZiBob29rcywgb3IgYW4gZW1wdHkgYXJyYXkgaWYgdGhlcmUgYXJlIG5vbmUuXG4gKi9cbnZpZGVvanMuaG9va3MgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgdmlkZW9qcy5ob29rc19bdHlwZV0gPSB2aWRlb2pzLmhvb2tzX1t0eXBlXSB8fCBbXTtcbiAgaWYgKGZuKSB7XG4gICAgdmlkZW9qcy5ob29rc19bdHlwZV0gPSB2aWRlb2pzLmhvb2tzX1t0eXBlXS5jb25jYXQoZm4pO1xuICB9XG4gIHJldHVybiB2aWRlb2pzLmhvb2tzX1t0eXBlXTtcbn07XG5cbi8qKlxuICogQWRkIGEgZnVuY3Rpb24gaG9vayB0byBhIHNwZWNpZmljIHZpZGVvanMgbGlmZWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiAgICAgICAgdGhlIGxpZmVjeWNsZSB0byBob29rIHRoZSBmdW5jdGlvbiB0by5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEZ1bmN0aW9uW119XG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIG9yIGFycmF5IG9mIGZ1bmN0aW9ucyB0byBhdHRhY2guXG4gKi9cbnZpZGVvanMuaG9vayA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICB2aWRlb2pzLmhvb2tzKHR5cGUsIGZuKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgaG9vayBmcm9tIGEgc3BlY2lmaWMgdmlkZW9qcyBsaWZlY3ljbGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqICAgICAgICB0aGUgbGlmZWN5Y2xlIHRoYXQgdGhlIGZ1bmN0aW9uIGhvb2tlZCB0b1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiAgICAgICAgVGhlIGhvb2tlZCBmdW5jdGlvbiB0byByZW1vdmVcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCB3YXMgcmVtb3ZlZCBvciB1bmRlZlxuICovXG52aWRlb2pzLnJlbW92ZUhvb2sgPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgdmFyIGluZGV4ID0gdmlkZW9qcy5ob29rcyh0eXBlKS5pbmRleE9mKGZuKTtcblxuICBpZiAoaW5kZXggPD0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2aWRlb2pzLmhvb2tzX1t0eXBlXSA9IHZpZGVvanMuaG9va3NfW3R5cGVdLnNsaWNlKCk7XG4gIHZpZGVvanMuaG9va3NfW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBBZGQgZGVmYXVsdCBzdHlsZXNcbmlmICh3aW5kb3cuVklERU9KU19OT19EWU5BTUlDX1NUWUxFICE9PSB0cnVlICYmIGlzUmVhbCgpKSB7XG4gIHZhciBzdHlsZSA9ICQoJy52anMtc3R5bGVzLWRlZmF1bHRzJyk7XG5cbiAgaWYgKCFzdHlsZSkge1xuICAgIHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KCd2anMtc3R5bGVzLWRlZmF1bHRzJyk7XG4gICAgdmFyIGhlYWQgPSAkKCdoZWFkJyk7XG5cbiAgICBpZiAoaGVhZCkge1xuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGUsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHNldFRleHRDb250ZW50KHN0eWxlLCAnXFxuICAgICAgLnZpZGVvLWpzIHtcXG4gICAgICAgIHdpZHRoOiAzMDBweDtcXG4gICAgICAgIGhlaWdodDogMTUwcHg7XFxuICAgICAgfVxcblxcbiAgICAgIC52anMtZmx1aWQge1xcbiAgICAgICAgcGFkZGluZy10b3A6IDU2LjI1JVxcbiAgICAgIH1cXG4gICAgJyk7XG4gIH1cbn1cblxuLy8gUnVuIEF1dG8tbG9hZCBwbGF5ZXJzXG4vLyBZb3UgaGF2ZSB0byB3YWl0IGF0IGxlYXN0IG9uY2UgaW4gY2FzZSB0aGlzIHNjcmlwdCBpcyBsb2FkZWQgYWZ0ZXIgeW91clxuLy8gdmlkZW8gaW4gdGhlIERPTSAod2VpcmQgYmVoYXZpb3Igb25seSB3aXRoIG1pbmlmaWVkIHZlcnNpb24pXG5hdXRvU2V0dXBUaW1lb3V0KDEsIHZpZGVvanMpO1xuXG4vKipcbiAqIEN1cnJlbnQgc29mdHdhcmUgdmVyc2lvbi4gRm9sbG93cyBzZW12ZXIuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmlkZW9qcy5WRVJTSU9OID0gdmVyc2lvbjtcblxuLyoqXG4gKiBUaGUgZ2xvYmFsIG9wdGlvbnMgb2JqZWN0LiBUaGVzZSBhcmUgdGhlIHNldHRpbmdzIHRoYXQgdGFrZSBlZmZlY3RcbiAqIGlmIG5vIG92ZXJyaWRlcyBhcmUgc3BlY2lmaWVkIHdoZW4gdGhlIHBsYXllciBpcyBjcmVhdGVkLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZpZGVvanMub3B0aW9ucyA9IFBsYXllci5wcm90b3R5cGUub3B0aW9uc187XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aXRoIHRoZSBjdXJyZW50bHkgY3JlYXRlZCBwbGF5ZXJzLCBrZXllZCBieSBwbGF5ZXIgSURcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiAgICAgICAgIFRoZSBjcmVhdGVkIHBsYXllcnNcbiAqL1xudmlkZW9qcy5nZXRQbGF5ZXJzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gUGxheWVyLnBsYXllcnM7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBwbGF5ZXJzIG9iamVjdC5cbiAqXG4gKiBAbWVtYmVyT2YgdmlkZW9qc1xuICogQHByb3BlcnR5IHtPYmplY3R9IHBsYXllcnNcbiAqL1xudmlkZW9qcy5wbGF5ZXJzID0gUGxheWVyLnBsYXllcnM7XG5cbi8qKlxuICogR2V0IGEgY29tcG9uZW50IGNsYXNzIG9iamVjdCBieSBuYW1lXG4gKlxuICogQGJvcnJvd3MgQ29tcG9uZW50LmdldENvbXBvbmVudCBhcyB2aWRlb2pzLmdldENvbXBvbmVudFxuICovXG52aWRlb2pzLmdldENvbXBvbmVudCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQ7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBjb21wb25lbnQgc28gaXQgY2FuIHJlZmVycmVkIHRvIGJ5IG5hbWUuIFVzZWQgd2hlbiBhZGRpbmcgdG8gb3RoZXJcbiAqIGNvbXBvbmVudHMsIGVpdGhlciB0aHJvdWdoIGFkZENoaWxkIGBjb21wb25lbnQuYWRkQ2hpbGQoJ215Q29tcG9uZW50JylgIG9yIHRocm91Z2hcbiAqIGRlZmF1bHQgY2hpbGRyZW4gb3B0aW9ucyAgYHsgY2hpbGRyZW46IFsnbXlDb21wb25lbnQnXSB9YC5cbiAqXG4gKiA+IE5PVEU6IFlvdSBjb3VsZCBhbHNvIGp1c3QgaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50IGJlZm9yZSBhZGRpbmcuXG4gKiBgY29tcG9uZW50LmFkZENoaWxkKG5ldyBNeUNvbXBvbmVudCgpKTtgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICBUaGUgY2xhc3MgbmFtZSBvZiB0aGUgY29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtDb21wb25lbnR9IGNvbXBcbiAqICAgICAgICBUaGUgY29tcG9uZW50IGNsYXNzXG4gKlxuICogQHJldHVybiB7Q29tcG9uZW50fVxuICogICAgICAgICBUaGUgbmV3bHkgcmVnaXN0ZXJlZCBjb21wb25lbnRcbiAqL1xudmlkZW9qcy5yZWdpc3RlckNvbXBvbmVudCA9IGZ1bmN0aW9uIChuYW1lJCQxLCBjb21wKSB7XG4gIGlmIChUZWNoLmlzVGVjaChjb21wKSkge1xuICAgIGxvZyQxLndhcm4oJ1RoZSAnICsgbmFtZSQkMSArICcgdGVjaCB3YXMgcmVnaXN0ZXJlZCBhcyBhIGNvbXBvbmVudC4gSXQgc2hvdWxkIGluc3RlYWQgYmUgcmVnaXN0ZXJlZCB1c2luZyB2aWRlb2pzLnJlZ2lzdGVyVGVjaChuYW1lLCB0ZWNoKScpO1xuICB9XG5cbiAgQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50LmNhbGwoQ29tcG9uZW50LCBuYW1lJCQxLCBjb21wKTtcbn07XG5cbi8qKlxuICogR2V0IGEgVGVjaCBjbGFzcyBvYmplY3QgYnkgbmFtZVxuICpcbiAqIEBib3Jyb3dzIFRlY2guZ2V0VGVjaCBhcyB2aWRlb2pzLmdldFRlY2hcbiAqL1xudmlkZW9qcy5nZXRUZWNoID0gVGVjaC5nZXRUZWNoO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgVGVjaCBzbyBpdCBjYW4gcmVmZXJyZWQgdG8gYnkgbmFtZS5cbiAqIFRoaXMgaXMgdXNlZCBpbiB0aGUgdGVjaCBvcmRlciBmb3IgdGhlIHBsYXllci5cbiAqXG4gKiBAYm9ycm93cyBUZWNoLnJlZ2lzdGVyVGVjaCBhcyB2aWRlb2pzLnJlZ2lzdGVyVGVjaFxuICovXG52aWRlb2pzLnJlZ2lzdGVyVGVjaCA9IFRlY2gucmVnaXN0ZXJUZWNoO1xuXG52aWRlb2pzLnVzZSA9IHVzZTtcblxuLyoqXG4gKiBBIHN1aXRlIG9mIGJyb3dzZXIgYW5kIGRldmljZSB0ZXN0cyBmcm9tIHtAbGluayBicm93c2VyfS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmlkZW9qcy5icm93c2VyID0gYnJvd3NlcjtcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciBzdXBwb3J0cyB0b3VjaCBldmVudHMuIEluY2x1ZGVkIGZvciBiYWNrd2FyZFxuICogY29tcGF0aWJpbGl0eSB3aXRoIDQueCwgYnV0IGRlcHJlY2F0ZWQuIFVzZSBgdmlkZW9qcy5icm93c2VyLlRPVUNIX0VOQUJMRURgXG4gKiBpbnN0ZWFkIGdvaW5nIGZvcndhcmQuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA1LjBcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG52aWRlb2pzLlRPVUNIX0VOQUJMRUQgPSBUT1VDSF9FTkFCTEVEO1xuXG4vKipcbiAqIFN1YmNsYXNzIGFuIGV4aXN0aW5nIGNsYXNzXG4gKiBNaW1pY3MgRVM2IHN1YmNsYXNzaW5nIHdpdGggdGhlIGBleHRlbmRgIGtleXdvcmRcbiAqXG4gKiBAYm9ycm93cyBleHRlbmQ6ZXh0ZW5kRm4gYXMgdmlkZW9qcy5leHRlbmRcbiAqL1xudmlkZW9qcy5leHRlbmQgPSBleHRlbmRGbjtcblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9ucyBvYmplY3RzIHJlY3Vyc2l2ZWx5XG4gKiBQZXJmb3JtcyBhIGRlZXAgbWVyZ2UgbGlrZSBsb2Rhc2gubWVyZ2UgYnV0ICoqb25seSBtZXJnZXMgcGxhaW4gb2JqZWN0cyoqXG4gKiAobm90IGFycmF5cywgZWxlbWVudHMsIGFueXRoaW5nIGVsc2UpXG4gKiBPdGhlciB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQgZGlyZWN0bHkgZnJvbSB0aGUgc2Vjb25kIG9iamVjdC5cbiAqXG4gKiBAYm9ycm93cyBtZXJnZS1vcHRpb25zOm1lcmdlT3B0aW9ucyBhcyB2aWRlb2pzLm1lcmdlT3B0aW9uc1xuICovXG52aWRlb2pzLm1lcmdlT3B0aW9ucyA9IG1lcmdlT3B0aW9ucztcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIGNvbnRleHQgKHRoaXMpIG9mIGEgZnVuY3Rpb25cbiAqXG4gKiA+IE5PVEU6IGFzIG9mIHY1LjAgd2UgcmVxdWlyZSBhbiBFUzUgc2hpbSwgc28geW91IHNob3VsZCB1c2UgdGhlIG5hdGl2ZVxuICogYGZ1bmN0aW9uKCkge30uYmluZChuZXdDb250ZXh0KTtgIGluc3RlYWQgb2YgdGhpcy5cbiAqXG4gKiBAYm9ycm93cyBmbjpiaW5kIGFzIHZpZGVvanMuYmluZFxuICovXG52aWRlb2pzLmJpbmQgPSBiaW5kO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgVmlkZW8uanMgcGx1Z2luLlxuICpcbiAqIEBib3Jyb3dzIHBsdWdpbjpyZWdpc3RlclBsdWdpbiBhcyB2aWRlb2pzLnJlZ2lzdGVyUGx1Z2luXG4gKiBAbWV0aG9kIHJlZ2lzdGVyUGx1Z2luXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdG8gYmUgcmVnaXN0ZXJlZC4gTXVzdCBiZSBhIHN0cmluZyBhbmRcbiAqICAgICAgICAgbXVzdCBub3QgbWF0Y2ggYW4gZXhpc3RpbmcgcGx1Z2luIG9yIGEgbWV0aG9kIG9uIHRoZSBgUGxheWVyYFxuICogICAgICAgICBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IHBsdWdpblxuICogICAgICAgICBBIHN1Yi1jbGFzcyBvZiBgUGx1Z2luYCBvciBhIGZ1bmN0aW9uIGZvciBiYXNpYyBwbHVnaW5zLlxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogICAgICAgICBGb3IgYWR2YW5jZWQgcGx1Z2lucywgYSBmYWN0b3J5IGZ1bmN0aW9uIGZvciB0aGF0IHBsdWdpbi4gRm9yXG4gKiAgICAgICAgIGJhc2ljIHBsdWdpbnMsIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IGluaXRpYWxpemVzIHRoZSBwbHVnaW4uXG4gKi9cbnZpZGVvanMucmVnaXN0ZXJQbHVnaW4gPSBQbHVnaW4ucmVnaXN0ZXJQbHVnaW47XG5cbi8qKlxuICogRGVwcmVjYXRlZCBtZXRob2QgdG8gcmVnaXN0ZXIgYSBwbHVnaW4gd2l0aCBWaWRlby5qc1xuICpcbiAqIEBkZXByZWNhdGVkXG4gKiAgICAgICAgdmlkZW9qcy5wbHVnaW4oKSBpcyBkZXByZWNhdGVkOyB1c2UgdmlkZW9qcy5yZWdpc3RlclBsdWdpbigpIGluc3RlYWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogICAgICAgIFRoZSBwbHVnaW4gbmFtZVxuICpcbiAqIEBwYXJhbSB7UGx1Z2lufEZ1bmN0aW9ufSBwbHVnaW5cbiAqICAgICAgICAgVGhlIHBsdWdpbiBzdWItY2xhc3Mgb3IgZnVuY3Rpb25cbiAqL1xudmlkZW9qcy5wbHVnaW4gPSBmdW5jdGlvbiAobmFtZSQkMSwgcGx1Z2luKSB7XG4gIGxvZyQxLndhcm4oJ3ZpZGVvanMucGx1Z2luKCkgaXMgZGVwcmVjYXRlZDsgdXNlIHZpZGVvanMucmVnaXN0ZXJQbHVnaW4oKSBpbnN0ZWFkJyk7XG4gIHJldHVybiBQbHVnaW4ucmVnaXN0ZXJQbHVnaW4obmFtZSQkMSwgcGx1Z2luKTtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBvYmplY3QgY29udGFpbmluZyBtdWx0aXBsZSBWaWRlby5qcyBwbHVnaW5zLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBbbmFtZXNdXG4gKiAgICAgICAgIElmIHByb3ZpZGVkLCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgcGx1Z2luIG5hbWVzLiBEZWZhdWx0cyB0byBfYWxsX1xuICogICAgICAgICBwbHVnaW4gbmFtZXMuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAqICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgcGx1Z2luKHMpIGFzc29jaWF0ZWQgd2l0aCB0aGVpciBuYW1lKHMpIG9yXG4gKiAgICAgICAgIGB1bmRlZmluZWRgIGlmIG5vIG1hdGNoaW5nIHBsdWdpbnMgZXhpc3QpLlxuICovXG52aWRlb2pzLmdldFBsdWdpbnMgPSBQbHVnaW4uZ2V0UGx1Z2lucztcblxuLyoqXG4gKiBHZXRzIGEgcGx1Z2luIGJ5IG5hbWUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICogICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cbiAqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKiAgICAgICAgIFRoZSBwbHVnaW4gKG9yIGB1bmRlZmluZWRgKS5cbiAqL1xudmlkZW9qcy5nZXRQbHVnaW4gPSBQbHVnaW4uZ2V0UGx1Z2luO1xuXG4vKipcbiAqIEdldHMgYSBwbHVnaW4ncyB2ZXJzaW9uLCBpZiBhdmFpbGFibGVcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICogICAgICAgICBUaGUgcGx1Z2luJ3MgdmVyc2lvbiBvciBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbnZpZGVvanMuZ2V0UGx1Z2luVmVyc2lvbiA9IFBsdWdpbi5nZXRQbHVnaW5WZXJzaW9uO1xuXG4vKipcbiAqIEFkZGluZyBsYW5ndWFnZXMgc28gdGhhdCB0aGV5J3JlIGF2YWlsYWJsZSB0byBhbGwgcGxheWVycy5cbiAqIEV4YW1wbGU6IGB2aWRlb2pzLmFkZExhbmd1YWdlKCdlcycsIHsgJ0hlbGxvJzogJ0hvbGEnIH0pO2BcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICogICAgICAgIFRoZSBsYW5ndWFnZSBjb2RlIG9yIGRpY3Rpb25hcnkgcHJvcGVydHlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogICAgICAgIFRoZSBkYXRhIHZhbHVlcyB0byBiZSB0cmFuc2xhdGVkXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAgICAgICBUaGUgcmVzdWx0aW5nIGxhbmd1YWdlIGRpY3Rpb25hcnkgb2JqZWN0XG4gKi9cbnZpZGVvanMuYWRkTGFuZ3VhZ2UgPSBmdW5jdGlvbiAoY29kZSwgZGF0YSkge1xuICB2YXIgX21lcmdlT3B0aW9ucztcblxuICBjb2RlID0gKCcnICsgY29kZSkudG9Mb3dlckNhc2UoKTtcblxuICB2aWRlb2pzLm9wdGlvbnMubGFuZ3VhZ2VzID0gbWVyZ2VPcHRpb25zKHZpZGVvanMub3B0aW9ucy5sYW5ndWFnZXMsIChfbWVyZ2VPcHRpb25zID0ge30sIF9tZXJnZU9wdGlvbnNbY29kZV0gPSBkYXRhLCBfbWVyZ2VPcHRpb25zKSk7XG5cbiAgcmV0dXJuIHZpZGVvanMub3B0aW9ucy5sYW5ndWFnZXNbY29kZV07XG59O1xuXG4vKipcbiAqIExvZyBtZXNzYWdlc1xuICpcbiAqIEBib3Jyb3dzIGxvZzpsb2cgYXMgdmlkZW9qcy5sb2dcbiAqL1xudmlkZW9qcy5sb2cgPSBsb2ckMTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVtdWxhdGVkIFRpbWVSYW5nZSBvYmplY3QuXG4gKlxuICogQGJvcnJvd3MgdGltZS1yYW5nZXM6Y3JlYXRlVGltZVJhbmdlcyBhcyB2aWRlb2pzLmNyZWF0ZVRpbWVSYW5nZVxuICovXG4vKipcbiAqIEBib3Jyb3dzIHRpbWUtcmFuZ2VzOmNyZWF0ZVRpbWVSYW5nZXMgYXMgdmlkZW9qcy5jcmVhdGVUaW1lUmFuZ2VzXG4gKi9cbnZpZGVvanMuY3JlYXRlVGltZVJhbmdlID0gdmlkZW9qcy5jcmVhdGVUaW1lUmFuZ2VzID0gY3JlYXRlVGltZVJhbmdlcztcblxuLyoqXG4gKiBGb3JtYXQgc2Vjb25kcyBhcyBhIHRpbWUgc3RyaW5nLCBIOk1NOlNTIG9yIE06U1NcbiAqIFN1cHBseWluZyBhIGd1aWRlIChpbiBzZWNvbmRzKSB3aWxsIGZvcmNlIGEgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3NcbiAqIHRvIGNvdmVyIHRoZSBsZW5ndGggb2YgdGhlIGd1aWRlXG4gKlxuICogQGJvcnJvd3MgZm9ybWF0LXRpbWU6Zm9ybWF0VGltZSBhcyB2aWRlb2pzLmZvcm1hdFRpbWVcbiAqL1xudmlkZW9qcy5mb3JtYXRUaW1lID0gZm9ybWF0VGltZTtcblxuLyoqXG4gKiBSZXNvbHZlIGFuZCBwYXJzZSB0aGUgZWxlbWVudHMgb2YgYSBVUkxcbiAqXG4gKiBAYm9ycm93cyB1cmw6cGFyc2VVcmwgYXMgdmlkZW9qcy5wYXJzZVVybFxuICovXG52aWRlb2pzLnBhcnNlVXJsID0gcGFyc2VVcmw7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSB1cmwgcGFzc2VkIGlzIGEgY3Jvc3MgZG9tYWluIHJlcXVlc3Qgb3Igbm90LlxuICpcbiAqIEBib3Jyb3dzIHVybDppc0Nyb3NzT3JpZ2luIGFzIHZpZGVvanMuaXNDcm9zc09yaWdpblxuICovXG52aWRlb2pzLmlzQ3Jvc3NPcmlnaW4gPSBpc0Nyb3NzT3JpZ2luO1xuXG4vKipcbiAqIEV2ZW50IHRhcmdldCBjbGFzcy5cbiAqXG4gKiBAYm9ycm93cyBFdmVudFRhcmdldCBhcyB2aWRlb2pzLkV2ZW50VGFyZ2V0XG4gKi9cbnZpZGVvanMuRXZlbnRUYXJnZXQgPSBFdmVudFRhcmdldDtcblxuLyoqXG4gKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gZWxlbWVudFxuICogSXQgc3RvcmVzIHRoZSBoYW5kbGVyIGZ1bmN0aW9uIGluIGEgc2VwYXJhdGUgY2FjaGUgb2JqZWN0XG4gKiBhbmQgYWRkcyBhIGdlbmVyaWMgaGFuZGxlciB0byB0aGUgZWxlbWVudCdzIGV2ZW50LFxuICogYWxvbmcgd2l0aCBhIHVuaXF1ZSBpZCAoZ3VpZCkgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogQGJvcnJvd3MgZXZlbnRzOm9uIGFzIHZpZGVvanMub25cbiAqL1xudmlkZW9qcy5vbiA9IG9uO1xuXG4vKipcbiAqIFRyaWdnZXIgYSBsaXN0ZW5lciBvbmx5IG9uY2UgZm9yIGFuIGV2ZW50XG4gKlxuICogQGJvcnJvd3MgZXZlbnRzOm9uZSBhcyB2aWRlb2pzLm9uZVxuICovXG52aWRlb2pzLm9uZSA9IG9uZTtcblxuLyoqXG4gKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBmcm9tIGFuIGVsZW1lbnRcbiAqXG4gKiBAYm9ycm93cyBldmVudHM6b2ZmIGFzIHZpZGVvanMub2ZmXG4gKi9cbnZpZGVvanMub2ZmID0gb2ZmO1xuXG4vKipcbiAqIFRyaWdnZXIgYW4gZXZlbnQgZm9yIGFuIGVsZW1lbnRcbiAqXG4gKiBAYm9ycm93cyBldmVudHM6dHJpZ2dlciBhcyB2aWRlb2pzLnRyaWdnZXJcbiAqL1xudmlkZW9qcy50cmlnZ2VyID0gdHJpZ2dlcjtcblxuLyoqXG4gKiBBIGNyb3NzLWJyb3dzZXIgWE1MSHR0cFJlcXVlc3Qgd3JhcHBlci4gSGVyZSdzIGEgc2ltcGxlIGV4YW1wbGU6XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICBzZXR0aW5ncyBmb3IgdGhlIHJlcXVlc3QuXG4gKlxuICogQHJldHVybiB7WE1MSHR0cFJlcXVlc3R8WERvbWFpblJlcXVlc3R9XG4gKiAgICAgICAgIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SYXlub3MveGhyXG4gKi9cbnZpZGVvanMueGhyID0geGhyO1xuXG4vKipcbiAqIFRleHRUcmFjayBjbGFzc1xuICpcbiAqIEBib3Jyb3dzIFRleHRUcmFjayBhcyB2aWRlb2pzLlRleHRUcmFja1xuICovXG52aWRlb2pzLlRleHRUcmFjayA9IFRleHRUcmFjaztcblxuLyoqXG4gKiBleHBvcnQgdGhlIEF1ZGlvVHJhY2sgY2xhc3Mgc28gdGhhdCBzb3VyY2UgaGFuZGxlcnMgY2FuIGNyZWF0ZVxuICogQXVkaW9UcmFja3MgYW5kIHRoZW4gYWRkIHRoZW0gdG8gdGhlIHBsYXllcnMgQXVkaW9UcmFja0xpc3RcbiAqXG4gKiBAYm9ycm93cyBBdWRpb1RyYWNrIGFzIHZpZGVvanMuQXVkaW9UcmFja1xuICovXG52aWRlb2pzLkF1ZGlvVHJhY2sgPSBBdWRpb1RyYWNrO1xuXG4vKipcbiAqIGV4cG9ydCB0aGUgVmlkZW9UcmFjayBjbGFzcyBzbyB0aGF0IHNvdXJjZSBoYW5kbGVycyBjYW4gY3JlYXRlXG4gKiBWaWRlb1RyYWNrcyBhbmQgdGhlbiBhZGQgdGhlbSB0byB0aGUgcGxheWVycyBWaWRlb1RyYWNrTGlzdFxuICpcbiAqIEBib3Jyb3dzIFZpZGVvVHJhY2sgYXMgdmlkZW9qcy5WaWRlb1RyYWNrXG4gKi9cbnZpZGVvanMuVmlkZW9UcmFjayA9IFZpZGVvVHJhY2s7XG5cbi8qKlxuICogRGV0ZXJtaW5lcywgdmlhIGR1Y2sgdHlwaW5nLCB3aGV0aGVyIG9yIG5vdCBhIHZhbHVlIGlzIGEgRE9NIGVsZW1lbnQuXG4gKlxuICogQGJvcnJvd3MgZG9tOmlzRWwgYXMgdmlkZW9qcy5pc0VsXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uaXNFbCgpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIERldGVybWluZXMsIHZpYSBkdWNrIHR5cGluZywgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIHRleHQgbm9kZS5cbiAqXG4gKiBAYm9ycm93cyBkb206aXNUZXh0Tm9kZSBhcyB2aWRlb2pzLmlzVGV4dE5vZGVcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5pc1RleHROb2RlKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbGVtZW50IGFuZCBhcHBsaWVzIHByb3BlcnRpZXMuXG4gKlxuICogQGJvcnJvd3MgZG9tOmNyZWF0ZUVsIGFzIHZpZGVvanMuY3JlYXRlRWxcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5jcmVhdGVFbCgpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaGFzIGEgQ1NTIGNsYXNzXG4gKlxuICogQGJvcnJvd3MgZG9tOmhhc0VsQ2xhc3MgYXMgdmlkZW9qcy5oYXNDbGFzc1xuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmhhc0NsYXNzKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogQWRkIGEgQ1NTIGNsYXNzIG5hbWUgdG8gYW4gZWxlbWVudFxuICpcbiAqIEBib3Jyb3dzIGRvbTphZGRFbENsYXNzIGFzIHZpZGVvanMuYWRkQ2xhc3NcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5hZGRDbGFzcygpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIFJlbW92ZSBhIENTUyBjbGFzcyBuYW1lIGZyb20gYW4gZWxlbWVudFxuICpcbiAqIEBib3Jyb3dzIGRvbTpyZW1vdmVFbENsYXNzIGFzIHZpZGVvanMucmVtb3ZlQ2xhc3NcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5yZW1vdmVDbGFzcygpIGluc3RlYWRcbiAqL1xuXG4vKipcbiAqIEFkZHMgb3IgcmVtb3ZlcyBhIENTUyBjbGFzcyBuYW1lIG9uIGFuIGVsZW1lbnQgZGVwZW5kaW5nIG9uIGFuIG9wdGlvbmFsXG4gKiBjb25kaXRpb24gb3IgdGhlIHByZXNlbmNlL2Fic2VuY2Ugb2YgdGhlIGNsYXNzIG5hbWUuXG4gKlxuICogQGJvcnJvd3MgZG9tOnRvZ2dsZUVsQ2xhc3MgYXMgdmlkZW9qcy50b2dnbGVDbGFzc1xuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLnRvZ2dsZUNsYXNzKCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogQXBwbHkgYXR0cmlidXRlcyB0byBhbiBIVE1MIGVsZW1lbnQuXG4gKlxuICogQGJvcnJvd3MgZG9tOnNldEVsQXR0cmlidXRlcyBhcyB2aWRlb2pzLnNldEF0dHJpYnV0ZVxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLnNldEF0dHJpYnV0ZXMoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZSB2YWx1ZXMsIGFzIGRlZmluZWQgb24gdGhlIEhUTUwgdGFnXG4gKiBBdHRyaWJ1dGVzIGFyZSBub3QgdGhlIHNhbWUgYXMgcHJvcGVydGllcy4gVGhleSdyZSBkZWZpbmVkIG9uIHRoZSB0YWdcbiAqIG9yIHdpdGggc2V0QXR0cmlidXRlICh3aGljaCBzaG91bGRuJ3QgYmUgdXNlZCB3aXRoIEhUTUwpXG4gKiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgb3IgZmFsc2UgZm9yIGJvb2xlYW4gYXR0cmlidXRlcy5cbiAqXG4gKiBAYm9ycm93cyBkb206Z2V0RWxBdHRyaWJ1dGVzIGFzIHZpZGVvanMuZ2V0QXR0cmlidXRlc1xuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmdldEF0dHJpYnV0ZXMoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBFbXB0aWVzIHRoZSBjb250ZW50cyBvZiBhbiBlbGVtZW50LlxuICpcbiAqIEBib3Jyb3dzIGRvbTplbXB0eUVsIGFzIHZpZGVvanMuZW1wdHlFbFxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLmVtcHR5RWwoKSBpbnN0ZWFkXG4gKi9cblxuLyoqXG4gKiBOb3JtYWxpemVzIGFuZCBhcHBlbmRzIGNvbnRlbnQgdG8gYW4gZWxlbWVudC5cbiAqXG4gKiBUaGUgY29udGVudCBmb3IgYW4gZWxlbWVudCBjYW4gYmUgcGFzc2VkIGluIG11bHRpcGxlIHR5cGVzIGFuZFxuICogY29tYmluYXRpb25zLCB3aG9zZSBiZWhhdmlvciBpcyBhcyBmb2xsb3dzOlxuICpcbiAqIC0gU3RyaW5nXG4gKiAgIE5vcm1hbGl6ZWQgaW50byBhIHRleHQgbm9kZS5cbiAqXG4gKiAtIEVsZW1lbnQsIFRleHROb2RlXG4gKiAgIFBhc3NlZCB0aHJvdWdoLlxuICpcbiAqIC0gQXJyYXlcbiAqICAgQSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2Ygc3RyaW5ncywgZWxlbWVudHMsIG5vZGVzLCBvciBmdW5jdGlvbnMgKHdoaWNoXG4gKiAgIHJldHVybiBzaW5nbGUgc3RyaW5ncywgZWxlbWVudHMsIG9yIG5vZGVzKS5cbiAqXG4gKiAtIEZ1bmN0aW9uXG4gKiAgIElmIHRoZSBzb2xlIGFyZ3VtZW50LCBpcyBleHBlY3RlZCB0byBwcm9kdWNlIGEgc3RyaW5nLCBlbGVtZW50LFxuICogICBub2RlLCBvciBhcnJheS5cbiAqXG4gKiBAYm9ycm93cyBkb206YXBwZW5kQ29udGVudHMgYXMgdmlkZW9qcy5hcHBlbmRDb250ZXRcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5hcHBlbmRDb250ZW50KCkgaW5zdGVhZFxuICovXG5cbi8qKlxuICogTm9ybWFsaXplcyBhbmQgaW5zZXJ0cyBjb250ZW50IGludG8gYW4gZWxlbWVudDsgdGhpcyBpcyBpZGVudGljYWwgdG9cbiAqIGBhcHBlbmRDb250ZW50KClgLCBleGNlcHQgaXQgZW1wdGllcyB0aGUgZWxlbWVudCBmaXJzdC5cbiAqXG4gKiBUaGUgY29udGVudCBmb3IgYW4gZWxlbWVudCBjYW4gYmUgcGFzc2VkIGluIG11bHRpcGxlIHR5cGVzIGFuZFxuICogY29tYmluYXRpb25zLCB3aG9zZSBiZWhhdmlvciBpcyBhcyBmb2xsb3dzOlxuICpcbiAqIC0gU3RyaW5nXG4gKiAgIE5vcm1hbGl6ZWQgaW50byBhIHRleHQgbm9kZS5cbiAqXG4gKiAtIEVsZW1lbnQsIFRleHROb2RlXG4gKiAgIFBhc3NlZCB0aHJvdWdoLlxuICpcbiAqIC0gQXJyYXlcbiAqICAgQSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2Ygc3RyaW5ncywgZWxlbWVudHMsIG5vZGVzLCBvciBmdW5jdGlvbnMgKHdoaWNoXG4gKiAgIHJldHVybiBzaW5nbGUgc3RyaW5ncywgZWxlbWVudHMsIG9yIG5vZGVzKS5cbiAqXG4gKiAtIEZ1bmN0aW9uXG4gKiAgIElmIHRoZSBzb2xlIGFyZ3VtZW50LCBpcyBleHBlY3RlZCB0byBwcm9kdWNlIGEgc3RyaW5nLCBlbGVtZW50LFxuICogICBub2RlLCBvciBhcnJheS5cbiAqXG4gKiBAYm9ycm93cyBkb206aW5zZXJ0Q29udGVudCBhcyB2aWRlb2pzLmluc2VydENvbnRlbnRcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5pbnNlcnRDb250ZW50KCkgaW5zdGVhZFxuICovXG5bJ2lzRWwnLCAnaXNUZXh0Tm9kZScsICdjcmVhdGVFbCcsICdoYXNDbGFzcycsICdhZGRDbGFzcycsICdyZW1vdmVDbGFzcycsICd0b2dnbGVDbGFzcycsICdzZXRBdHRyaWJ1dGVzJywgJ2dldEF0dHJpYnV0ZXMnLCAnZW1wdHlFbCcsICdhcHBlbmRDb250ZW50JywgJ2luc2VydENvbnRlbnQnXS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gIHZpZGVvanNba10gPSBmdW5jdGlvbiAoKSB7XG4gICAgbG9nJDEud2FybigndmlkZW9qcy4nICsgayArICcoKSBpcyBkZXByZWNhdGVkOyB1c2UgdmlkZW9qcy5kb20uJyArIGsgKyAnKCkgaW5zdGVhZCcpO1xuICAgIHJldHVybiBEb21ba10uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIEEgc2FmZSBnZXRDb21wdXRlZFN0eWxlIHdpdGggYW4gSUU4IGZhbGxiYWNrLlxuICpcbiAqIFRoaXMgaXMgYmVjYXVzZSBpbiBGaXJlZm94LCBpZiB0aGUgcGxheWVyIGlzIGxvYWRlZCBpbiBhbiBpZnJhbWUgd2l0aCBgZGlzcGxheTpub25lYCxcbiAqIHRoZW4gYGdldENvbXB1dGVkU3R5bGVgIHJldHVybnMgYG51bGxgLCBzbywgd2UgZG8gYSBudWxsLWNoZWNrIHRvIG1ha2Ugc3VyZVxuICogdGhhdCB0aGUgcGxheWVyIGRvZXNuJ3QgYnJlYWsgaW4gdGhlc2UgY2FzZXMuXG4gKiBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQGJvcnJvd3MgY29tcHV0ZWQtc3R5bGU6Y29tcHV0ZWRTdHlsZSBhcyB2aWRlb2pzLmNvbXB1dGVkU3R5bGVcbiAqL1xudmlkZW9qcy5jb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcblxuLyoqXG4gKiBFeHBvcnQgdGhlIERvbSB1dGlsaXRpZXMgZm9yIHVzZSBpbiBleHRlcm5hbCBwbHVnaW5zXG4gKiBhbmQgVGVjaCdzXG4gKi9cbnZpZGVvanMuZG9tID0gRG9tO1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgVXJsIHV0aWxpdGllcyBmb3IgdXNlIGluIGV4dGVybmFsIHBsdWdpbnNcbiAqIGFuZCBUZWNoJ3NcbiAqL1xudmlkZW9qcy51cmwgPSBVcmw7XG5cbm1vZHVsZS5leHBvcnRzID0gdmlkZW9qcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gRGVmYXVsdCBleHBvcnRzIGZvciBOb2RlLiBFeHBvcnQgdGhlIGV4dGVuZGVkIHZlcnNpb25zIG9mIFZUVEN1ZSBhbmRcbi8vIFZUVFJlZ2lvbiBpbiBOb2RlIHNpbmNlIHdlIGxpa2VseSB3YW50IHRoZSBjYXBhYmlsaXR5IHRvIGNvbnZlcnQgYmFjayBhbmRcbi8vIGZvcnRoIGJldHdlZW4gSlNPTi4gSWYgd2UgZG9uJ3QgdGhlbiBpdCdzIG5vdCB0aGF0IGJpZyBvZiBhIGRlYWwgc2luY2Ugd2UncmVcbi8vIG9mZiBicm93c2VyLlxuXG52YXIgd2luZG93ID0gcmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpO1xuXG52YXIgdnR0anMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViVlRUOiByZXF1aXJlKFwiLi92dHQuanNcIiksXG4gIFZUVEN1ZTogcmVxdWlyZShcIi4vdnR0Y3VlLmpzXCIpLFxuICBWVFRSZWdpb246IHJlcXVpcmUoXCIuL3Z0dHJlZ2lvbi5qc1wiKVxufTtcblxud2luZG93LnZ0dGpzID0gdnR0anM7XG53aW5kb3cuV2ViVlRUID0gdnR0anMuV2ViVlRUO1xuXG52YXIgY3VlU2hpbSA9IHZ0dGpzLlZUVEN1ZTtcbnZhciByZWdpb25TaGltID0gdnR0anMuVlRUUmVnaW9uO1xudmFyIG5hdGl2ZVZUVEN1ZSA9IHdpbmRvdy5WVFRDdWU7XG52YXIgbmF0aXZlVlRUUmVnaW9uID0gd2luZG93LlZUVFJlZ2lvbjtcblxudnR0anMuc2hpbSA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cuVlRUQ3VlID0gY3VlU2hpbTtcbiAgd2luZG93LlZUVFJlZ2lvbiA9IHJlZ2lvblNoaW07XG59O1xuXG52dHRqcy5yZXN0b3JlID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5WVFRDdWUgPSBuYXRpdmVWVFRDdWU7XG4gIHdpbmRvdy5WVFRSZWdpb24gPSBuYXRpdmVWVFRSZWdpb247XG59O1xuXG5pZiAoIXdpbmRvdy5WVFRDdWUpIHtcbiAgdnR0anMuc2hpbSgpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyB2dHQuanMgQ29udHJpYnV0b3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiAtKi0gTW9kZTogSmF2YTsgdGFiLXdpZHRoOiAyOyBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IGMtYmFzaWMtb2Zmc2V0OiAyIC0qLSAqL1xuLyogdmltOiBzZXQgc2hpZnR3aWR0aD0yIHRhYnN0b3A9MiBhdXRvaW5kZW50IGNpbmRlbnQgZXhwYW5kdGFiOiAqL1xudmFyIF9vYmpDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gRigpIHt9XG4gIHJldHVybiBmdW5jdGlvbihvKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0LmNyZWF0ZSBzaGltIG9ubHkgYWNjZXB0cyBvbmUgcGFyYW1ldGVyLicpO1xuICAgIH1cbiAgICBGLnByb3RvdHlwZSA9IG87XG4gICAgcmV0dXJuIG5ldyBGKCk7XG4gIH07XG59KSgpO1xuXG4vLyBDcmVhdGVzIGEgbmV3IFBhcnNlckVycm9yIG9iamVjdCBmcm9tIGFuIGVycm9yRGF0YSBvYmplY3QuIFRoZSBlcnJvckRhdGFcbi8vIG9iamVjdCBzaG91bGQgaGF2ZSBkZWZhdWx0IGNvZGUgYW5kIG1lc3NhZ2UgcHJvcGVydGllcy4gVGhlIGRlZmF1bHQgbWVzc2FnZVxuLy8gcHJvcGVydHkgY2FuIGJlIG92ZXJyaWRlbiBieSBwYXNzaW5nIGluIGEgbWVzc2FnZSBwYXJhbWV0ZXIuXG4vLyBTZWUgUGFyc2luZ0Vycm9yLkVycm9ycyBiZWxvdyBmb3IgYWNjZXB0YWJsZSBlcnJvcnMuXG5mdW5jdGlvbiBQYXJzaW5nRXJyb3IoZXJyb3JEYXRhLCBtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiUGFyc2luZ0Vycm9yXCI7XG4gIHRoaXMuY29kZSA9IGVycm9yRGF0YS5jb2RlO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IGVycm9yRGF0YS5tZXNzYWdlO1xufVxuUGFyc2luZ0Vycm9yLnByb3RvdHlwZSA9IF9vYmpDcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblBhcnNpbmdFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJzaW5nRXJyb3I7XG5cbi8vIFBhcnNpbmdFcnJvciBtZXRhZGF0YSBmb3IgYWNjZXB0YWJsZSBQYXJzaW5nRXJyb3JzLlxuUGFyc2luZ0Vycm9yLkVycm9ycyA9IHtcbiAgQmFkU2lnbmF0dXJlOiB7XG4gICAgY29kZTogMCxcbiAgICBtZXNzYWdlOiBcIk1hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLlwiXG4gIH0sXG4gIEJhZFRpbWVTdGFtcDoge1xuICAgIGNvZGU6IDEsXG4gICAgbWVzc2FnZTogXCJNYWxmb3JtZWQgdGltZSBzdGFtcC5cIlxuICB9XG59O1xuXG4vLyBUcnkgdG8gcGFyc2UgaW5wdXQgYXMgYSB0aW1lIHN0YW1wLlxuZnVuY3Rpb24gcGFyc2VUaW1lU3RhbXAoaW5wdXQpIHtcblxuICBmdW5jdGlvbiBjb21wdXRlU2Vjb25kcyhoLCBtLCBzLCBmKSB7XG4gICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIChmIHwgMCkgLyAxMDAwO1xuICB9XG5cbiAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihcXGQrKTooXFxkezJ9KSg6XFxkezJ9KT9cXC4oXFxkezN9KS8pO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChtWzNdKSB7XG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCBtWzNdLnJlcGxhY2UoXCI6XCIsIFwiXCIpLCBtWzRdKTtcbiAgfSBlbHNlIGlmIChtWzFdID4gNTkpIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzXTpbbWludXRlc10uW21pbGxpc2Vjb25kc11cbiAgICAvLyBGaXJzdCBwb3NpdGlvbiBpcyBob3VycyBhcyBpdCdzIG92ZXIgNTkuXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIDAsICBtWzRdKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcygwLCBtWzFdLCBtWzJdLCBtWzRdKTtcbiAgfVxufVxuXG4vLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3Rcbi8vIGFzc2lnbm1lbnQgdG8gYSBzcGVjaWZpYyBrZXkuXG5mdW5jdGlvbiBTZXR0aW5ncygpIHtcbiAgdGhpcy52YWx1ZXMgPSBfb2JqQ3JlYXRlKG51bGwpO1xufVxuXG5TZXR0aW5ncy5wcm90b3R5cGUgPSB7XG4gIC8vIE9ubHkgYWNjZXB0IHRoZSBmaXJzdCBhc3NpZ25tZW50IHRvIGFueSBrZXkuXG4gIHNldDogZnVuY3Rpb24oaywgdikge1xuICAgIGlmICghdGhpcy5nZXQoaykgJiYgdiAhPT0gXCJcIikge1xuICAgICAgdGhpcy52YWx1ZXNba10gPSB2O1xuICAgIH1cbiAgfSxcbiAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgYSBrZXksIG9yIGEgZGVmYXVsdCB2YWx1ZS5cbiAgLy8gSWYgJ2RlZmF1bHRLZXknIGlzIHBhc3NlZCB0aGVuICdkZmx0JyBpcyBhc3N1bWVkIHRvIGJlIGFuIG9iamVjdCB3aXRoXG4gIC8vIGEgbnVtYmVyIG9mIHBvc3NpYmxlIGRlZmF1bHQgdmFsdWVzIGFzIHByb3BlcnRpZXMgd2hlcmUgJ2RlZmF1bHRLZXknIGlzXG4gIC8vIHRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBjaG9zZW47IG90aGVyd2lzZSBpdCdzIGFzc3VtZWQgdG8gYmVcbiAgLy8gYSBzaW5nbGUgdmFsdWUuXG4gIGdldDogZnVuY3Rpb24oaywgZGZsdCwgZGVmYXVsdEtleSkge1xuICAgIGlmIChkZWZhdWx0S2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHRbZGVmYXVsdEtleV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdDtcbiAgfSxcbiAgLy8gQ2hlY2sgd2hldGhlciB3ZSBoYXZlIGEgdmFsdWUgZm9yIGEga2V5LlxuICBoYXM6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayBpbiB0aGlzLnZhbHVlcztcbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgb25lIG9mIHRoZSBnaXZlbiBhbHRlcm5hdGl2ZXMuXG4gIGFsdDogZnVuY3Rpb24oaywgdiwgYSkge1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgYS5sZW5ndGg7ICsrbikge1xuICAgICAgaWYgKHYgPT09IGFbbl0pIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCAoc2lnbmVkKSBpbnRlZ2VyLlxuICBpbnRlZ2VyOiBmdW5jdGlvbihrLCB2KSB7XG4gICAgaWYgKC9eLT9cXGQrJC8udGVzdCh2KSkgeyAvLyBpbnRlZ2VyXG4gICAgICB0aGlzLnNldChrLCBwYXJzZUludCh2LCAxMCkpO1xuICAgIH1cbiAgfSxcbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCBwZXJjZW50YWdlLlxuICBwZXJjZW50OiBmdW5jdGlvbihrLCB2KSB7XG4gICAgdmFyIG07XG4gICAgaWYgKChtID0gdi5tYXRjaCgvXihbXFxkXXsxLDN9KShcXC5bXFxkXSopPyUkLykpKSB7XG4gICAgICB2ID0gcGFyc2VGbG9hdCh2KTtcbiAgICAgIGlmICh2ID49IDAgJiYgdiA8PSAxMDApIHtcbiAgICAgICAgdGhpcy5zZXQoaywgdik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBpbnB1dCBpbnRvIGdyb3VwcyBzZXBhcmF0ZWQgYnkgJ2dyb3VwRGVsaW0nLCBhbmRcbi8vIGludGVycHJldGUgZWFjaCBncm91cCBhcyBhIGtleS92YWx1ZSBwYWlyIHNlcGFyYXRlZCBieSAna2V5VmFsdWVEZWxpbScuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMoaW5wdXQsIGNhbGxiYWNrLCBrZXlWYWx1ZURlbGltLCBncm91cERlbGltKSB7XG4gIHZhciBncm91cHMgPSBncm91cERlbGltID8gaW5wdXQuc3BsaXQoZ3JvdXBEZWxpbSkgOiBbaW5wdXRdO1xuICBmb3IgKHZhciBpIGluIGdyb3Vwcykge1xuICAgIGlmICh0eXBlb2YgZ3JvdXBzW2ldICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGt2ID0gZ3JvdXBzW2ldLnNwbGl0KGtleVZhbHVlRGVsaW0pO1xuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgayA9IGt2WzBdO1xuICAgIHZhciB2ID0ga3ZbMV07XG4gICAgY2FsbGJhY2soaywgdik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VDdWUoaW5wdXQsIGN1ZSwgcmVnaW9uTGlzdCkge1xuICAvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgaW5wdXQgaWYgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvci5cbiAgdmFyIG9JbnB1dCA9IGlucHV0O1xuICAvLyA0LjEgV2ViVlRUIHRpbWVzdGFtcFxuICBmdW5jdGlvbiBjb25zdW1lVGltZVN0YW1wKCkge1xuICAgIHZhciB0cyA9IHBhcnNlVGltZVN0YW1wKGlucHV0KTtcbiAgICBpZiAodHMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IoUGFyc2luZ0Vycm9yLkVycm9ycy5CYWRUaW1lU3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNYWxmb3JtZWQgdGltZXN0YW1wOiBcIiArIG9JbnB1dCk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aW1lIHN0YW1wIGZyb20gaW5wdXQuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCBcIlwiKTtcbiAgICByZXR1cm4gdHM7XG4gIH1cblxuICAvLyA0LjQuMiBXZWJWVFQgY3VlIHNldHRpbmdzXG4gIGZ1bmN0aW9uIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKSB7XG4gICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG5cbiAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICBzd2l0Y2ggKGspIHtcbiAgICAgIGNhc2UgXCJyZWdpb25cIjpcbiAgICAgICAgLy8gRmluZCB0aGUgbGFzdCByZWdpb24gd2UgcGFyc2VkIHdpdGggdGhlIHNhbWUgcmVnaW9uIGlkLlxuICAgICAgICBmb3IgKHZhciBpID0gcmVnaW9uTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5zZXQoaywgcmVnaW9uTGlzdFtpXS5yZWdpb24pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICAgIHNldHRpbmdzLmFsdChrLCB2LCBbXCJybFwiLCBcImxyXCJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICB2YXIgdmFscyA9IHYuc3BsaXQoXCIsXCIpLFxuICAgICAgICAgICAgdmFsczAgPSB2YWxzWzBdO1xuICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHZhbHMwKTtcbiAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzMCkgPyBzZXR0aW5ncy5zZXQoXCJzbmFwVG9MaW5lc1wiLCBmYWxzZSkgOiBudWxsO1xuICAgICAgICBzZXR0aW5ncy5hbHQoaywgdmFsczAsIFtcImF1dG9cIl0pO1xuICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoXCJsaW5lQWxpZ25cIiwgdmFsc1sxXSwgW1wic3RhcnRcIiwgXCJtaWRkbGVcIiwgXCJlbmRcIl0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvc2l0aW9uXCI6XG4gICAgICAgIHZhbHMgPSB2LnNwbGl0KFwiLFwiKTtcbiAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzWzBdKTtcbiAgICAgICAgaWYgKHZhbHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgc2V0dGluZ3MuYWx0KFwicG9zaXRpb25BbGlnblwiLCB2YWxzWzFdLCBbXCJzdGFydFwiLCBcIm1pZGRsZVwiLCBcImVuZFwiXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2l6ZVwiOlxuICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHYpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhbGlnblwiOlxuICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgW1wic3RhcnRcIiwgXCJtaWRkbGVcIiwgXCJlbmRcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LCAvOi8sIC9cXHMvKTtcblxuICAgIC8vIEFwcGx5IGRlZmF1bHQgdmFsdWVzIGZvciBhbnkgbWlzc2luZyBmaWVsZHMuXG4gICAgY3VlLnJlZ2lvbiA9IHNldHRpbmdzLmdldChcInJlZ2lvblwiLCBudWxsKTtcbiAgICBjdWUudmVydGljYWwgPSBzZXR0aW5ncy5nZXQoXCJ2ZXJ0aWNhbFwiLCBcIlwiKTtcbiAgICBjdWUubGluZSA9IHNldHRpbmdzLmdldChcImxpbmVcIiwgXCJhdXRvXCIpO1xuICAgIGN1ZS5saW5lQWxpZ24gPSBzZXR0aW5ncy5nZXQoXCJsaW5lQWxpZ25cIiwgXCJzdGFydFwiKTtcbiAgICBjdWUuc25hcFRvTGluZXMgPSBzZXR0aW5ncy5nZXQoXCJzbmFwVG9MaW5lc1wiLCB0cnVlKTtcbiAgICBjdWUuc2l6ZSA9IHNldHRpbmdzLmdldChcInNpemVcIiwgMTAwKTtcbiAgICBjdWUuYWxpZ24gPSBzZXR0aW5ncy5nZXQoXCJhbGlnblwiLCBcIm1pZGRsZVwiKTtcbiAgICBjdWUucG9zaXRpb24gPSBzZXR0aW5ncy5nZXQoXCJwb3NpdGlvblwiLCB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBtaWRkbGU6IDUwLFxuICAgICAgZW5kOiAxMDAsXG4gICAgICByaWdodDogMTAwXG4gICAgfSwgY3VlLmFsaWduKTtcbiAgICBjdWUucG9zaXRpb25BbGlnbiA9IHNldHRpbmdzLmdldChcInBvc2l0aW9uQWxpZ25cIiwge1xuICAgICAgc3RhcnQ6IFwic3RhcnRcIixcbiAgICAgIGxlZnQ6IFwic3RhcnRcIixcbiAgICAgIG1pZGRsZTogXCJtaWRkbGVcIixcbiAgICAgIGVuZDogXCJlbmRcIixcbiAgICAgIHJpZ2h0OiBcImVuZFwiXG4gICAgfSwgY3VlLmFsaWduKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXlxccysvLCBcIlwiKTtcbiAgfVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHRpbWluZ3MuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGN1ZS5zdGFydFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7ICAgLy8gKDEpIGNvbGxlY3QgY3VlIHN0YXJ0IHRpbWVcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgaWYgKGlucHV0LnN1YnN0cigwLCAzKSAhPT0gXCItLT5cIikgeyAgICAgLy8gKDMpIG5leHQgY2hhcmFjdGVycyBtdXN0IG1hdGNoIFwiLS0+XCJcbiAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvci5FcnJvcnMuQmFkVGltZVN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNYWxmb3JtZWQgdGltZSBzdGFtcCAodGltZSBzdGFtcHMgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgJy0tPicpOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvSW5wdXQpO1xuICB9XG4gIGlucHV0ID0gaW5wdXQuc3Vic3RyKDMpO1xuICBza2lwV2hpdGVzcGFjZSgpO1xuICBjdWUuZW5kVGltZSA9IGNvbnN1bWVUaW1lU3RhbXAoKTsgICAgIC8vICg1KSBjb2xsZWN0IGN1ZSBlbmQgdGltZVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHNldHRpbmdzIGxpc3QuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKTtcbn1cblxudmFyIEVTQ0FQRSA9IHtcbiAgXCImYW1wO1wiOiBcIiZcIixcbiAgXCImbHQ7XCI6IFwiPFwiLFxuICBcIiZndDtcIjogXCI+XCIsXG4gIFwiJmxybTtcIjogXCJcXHUyMDBlXCIsXG4gIFwiJnJsbTtcIjogXCJcXHUyMDBmXCIsXG4gIFwiJm5ic3A7XCI6IFwiXFx1MDBhMFwiXG59O1xuXG52YXIgVEFHX05BTUUgPSB7XG4gIGM6IFwic3BhblwiLFxuICBpOiBcImlcIixcbiAgYjogXCJiXCIsXG4gIHU6IFwidVwiLFxuICBydWJ5OiBcInJ1YnlcIixcbiAgcnQ6IFwicnRcIixcbiAgdjogXCJzcGFuXCIsXG4gIGxhbmc6IFwic3BhblwiXG59O1xuXG52YXIgVEFHX0FOTk9UQVRJT04gPSB7XG4gIHY6IFwidGl0bGVcIixcbiAgbGFuZzogXCJsYW5nXCJcbn07XG5cbnZhciBORUVEU19QQVJFTlQgPSB7XG4gIHJ0OiBcInJ1YnlcIlxufTtcblxuLy8gUGFyc2UgY29udGVudCBpbnRvIGEgZG9jdW1lbnQgZnJhZ21lbnQuXG5mdW5jdGlvbiBwYXJzZUNvbnRlbnQod2luZG93LCBpbnB1dCkge1xuICBmdW5jdGlvbiBuZXh0VG9rZW4oKSB7XG4gICAgLy8gQ2hlY2sgZm9yIGVuZC1vZi1zdHJpbmcuXG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ29uc3VtZSAnbicgY2hhcmFjdGVycyBmcm9tIHRoZSBpbnB1dC5cbiAgICBmdW5jdGlvbiBjb25zdW1lKHJlc3VsdCkge1xuICAgICAgaW5wdXQgPSBpbnB1dC5zdWJzdHIocmVzdWx0Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBtID0gaW5wdXQubWF0Y2goL14oW148XSopKDxbXj5dKz4/KT8vKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBzb21lIHRleHQgYmVmb3JlIHRoZSBuZXh0IHRhZywgcmV0dXJuIGl0LCBvdGhlcndpc2UgcmV0dXJuXG4gICAgLy8gdGhlIHRhZy5cbiAgICByZXR1cm4gY29uc3VtZShtWzFdID8gbVsxXSA6IG1bMl0pO1xuICB9XG5cbiAgLy8gVW5lc2NhcGUgYSBzdHJpbmcgJ3MnLlxuICBmdW5jdGlvbiB1bmVzY2FwZTEoZSkge1xuICAgIHJldHVybiBFU0NBUEVbZV07XG4gIH1cbiAgZnVuY3Rpb24gdW5lc2NhcGUocykge1xuICAgIHdoaWxlICgobSA9IHMubWF0Y2goLyYoYW1wfGx0fGd0fGxybXxybG18bmJzcCk7LykpKSB7XG4gICAgICBzID0gcy5yZXBsYWNlKG1bMF0sIHVuZXNjYXBlMSk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkQWRkKGN1cnJlbnQsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIU5FRURTX1BBUkVOVFtlbGVtZW50LmxvY2FsTmFtZV0gfHxcbiAgICAgICAgICAgTkVFRFNfUEFSRU5UW2VsZW1lbnQubG9jYWxOYW1lXSA9PT0gY3VycmVudC5sb2NhbE5hbWU7XG4gIH1cblxuICAvLyBDcmVhdGUgYW4gZWxlbWVudCBmb3IgdGhpcyB0YWcuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgYW5ub3RhdGlvbikge1xuICAgIHZhciB0YWdOYW1lID0gVEFHX05BTUVbdHlwZV07XG4gICAgaWYgKCF0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBlbGVtZW50LmxvY2FsTmFtZSA9IHRhZ05hbWU7XG4gICAgdmFyIG5hbWUgPSBUQUdfQU5OT1RBVElPTlt0eXBlXTtcbiAgICBpZiAobmFtZSAmJiBhbm5vdGF0aW9uKSB7XG4gICAgICBlbGVtZW50W25hbWVdID0gYW5ub3RhdGlvbi50cmltKCk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdmFyIHJvb3REaXYgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgIGN1cnJlbnQgPSByb290RGl2LFxuICAgICAgdCxcbiAgICAgIHRhZ1N0YWNrID0gW107XG5cbiAgd2hpbGUgKCh0ID0gbmV4dFRva2VuKCkpICE9PSBudWxsKSB7XG4gICAgaWYgKHRbMF0gPT09ICc8Jykge1xuICAgICAgaWYgKHRbMV0gPT09IFwiL1wiKSB7XG4gICAgICAgIC8vIElmIHRoZSBjbG9zaW5nIHRhZyBtYXRjaGVzLCBtb3ZlIGJhY2sgdXAgdG8gdGhlIHBhcmVudCBub2RlLlxuICAgICAgICBpZiAodGFnU3RhY2subGVuZ3RoICYmXG4gICAgICAgICAgICB0YWdTdGFja1t0YWdTdGFjay5sZW5ndGggLSAxXSA9PT0gdC5zdWJzdHIoMikucmVwbGFjZShcIj5cIiwgXCJcIikpIHtcbiAgICAgICAgICB0YWdTdGFjay5wb3AoKTtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGlnbm9yZSB0aGUgZW5kIHRhZy5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgdHMgPSBwYXJzZVRpbWVTdGFtcCh0LnN1YnN0cigxLCB0Lmxlbmd0aCAtIDIpKTtcbiAgICAgIHZhciBub2RlO1xuICAgICAgaWYgKHRzKSB7XG4gICAgICAgIC8vIFRpbWVzdGFtcHMgYXJlIGxlYWQgbm9kZXMgYXMgd2VsbC5cbiAgICAgICAgbm9kZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oXCJ0aW1lc3RhbXBcIiwgdHMpO1xuICAgICAgICBjdXJyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtID0gdC5tYXRjaCgvXjwoW14uXFxzLzAtOT5dKykoXFwuW15cXHNcXFxcPl0rKT8oW14+XFxcXF0rKT8oXFxcXD8pPj8kLyk7XG4gICAgICAvLyBJZiB3ZSBjYW4ndCBwYXJzZSB0aGUgdGFnLCBza2lwIHRvIHRoZSBuZXh0IHRhZy5cbiAgICAgIGlmICghbSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRyeSB0byBjb25zdHJ1Y3QgYW4gZWxlbWVudCwgYW5kIGlnbm9yZSB0aGUgdGFnIGlmIHdlIGNvdWxkbid0LlxuICAgICAgbm9kZSA9IGNyZWF0ZUVsZW1lbnQobVsxXSwgbVszXSk7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIHRhZyBzaG91bGQgYmUgYWRkZWQgYmFzZWQgb24gdGhlIGNvbnRleHQgb2Ygd2hlcmUgaXRcbiAgICAgIC8vIGlzIHBsYWNlZCBpbiB0aGUgY3VldGV4dC5cbiAgICAgIGlmICghc2hvdWxkQWRkKGN1cnJlbnQsIG5vZGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gU2V0IHRoZSBjbGFzcyBsaXN0IChhcyBhIGxpc3Qgb2YgY2xhc3Nlcywgc2VwYXJhdGVkIGJ5IHNwYWNlKS5cbiAgICAgIGlmIChtWzJdKSB7XG4gICAgICAgIG5vZGUuY2xhc3NOYW1lID0gbVsyXS5zdWJzdHIoMSkucmVwbGFjZSgnLicsICcgJyk7XG4gICAgICB9XG4gICAgICAvLyBBcHBlbmQgdGhlIG5vZGUgdG8gdGhlIGN1cnJlbnQgbm9kZSwgYW5kIGVudGVyIHRoZSBzY29wZSBvZiB0aGUgbmV3XG4gICAgICAvLyBub2RlLlxuICAgICAgdGFnU3RhY2sucHVzaChtWzFdKTtcbiAgICAgIGN1cnJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBjdXJyZW50ID0gbm9kZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFRleHQgbm9kZXMgYXJlIGxlYWYgbm9kZXMuXG4gICAgY3VycmVudC5hcHBlbmRDaGlsZCh3aW5kb3cuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodW5lc2NhcGUodCkpKTtcbiAgfVxuXG4gIHJldHVybiByb290RGl2O1xufVxuXG4vLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgdGhlIFVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYSBzdHJvbmdcbi8vIHJpZ2h0LXRvLWxlZnQgY2F0ZWdvcnkuIFdoYXQgdGhpcyBtZWFucyBpcyB0aGF0IHRoZXNlIGNoYXJhY3RlcnMgYXJlXG4vLyB3cml0dGVuIHJpZ2h0LXRvLWxlZnQgZm9yIHN1cmUuIEl0IHdhcyBnZW5lcmF0ZWQgYnkgcHVsbGluZyBhbGwgdGhlIHN0cm9uZ1xuLy8gcmlnaHQtdG8tbGVmdCBjaGFyYWN0ZXJzIG91dCBvZiB0aGUgVW5pY29kZSBkYXRhIHRhYmxlLiBUaGF0IHRhYmxlIGNhblxuLy8gZm91bmQgYXQ6IGh0dHA6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VOSURBVEEvVW5pY29kZURhdGEudHh0XG52YXIgc3Ryb25nUlRMUmFuZ2VzID0gW1sweDViZSwgMHg1YmVdLCBbMHg1YzAsIDB4NWMwXSwgWzB4NWMzLCAweDVjM10sIFsweDVjNiwgMHg1YzZdLFxuIFsweDVkMCwgMHg1ZWFdLCBbMHg1ZjAsIDB4NWY0XSwgWzB4NjA4LCAweDYwOF0sIFsweDYwYiwgMHg2MGJdLCBbMHg2MGQsIDB4NjBkXSxcbiBbMHg2MWIsIDB4NjFiXSwgWzB4NjFlLCAweDY0YV0sIFsweDY2ZCwgMHg2NmZdLCBbMHg2NzEsIDB4NmQ1XSwgWzB4NmU1LCAweDZlNl0sXG4gWzB4NmVlLCAweDZlZl0sIFsweDZmYSwgMHg3MGRdLCBbMHg3MGYsIDB4NzEwXSwgWzB4NzEyLCAweDcyZl0sIFsweDc0ZCwgMHg3YTVdLFxuIFsweDdiMSwgMHg3YjFdLCBbMHg3YzAsIDB4N2VhXSwgWzB4N2Y0LCAweDdmNV0sIFsweDdmYSwgMHg3ZmFdLCBbMHg4MDAsIDB4ODE1XSxcbiBbMHg4MWEsIDB4ODFhXSwgWzB4ODI0LCAweDgyNF0sIFsweDgyOCwgMHg4MjhdLCBbMHg4MzAsIDB4ODNlXSwgWzB4ODQwLCAweDg1OF0sXG4gWzB4ODVlLCAweDg1ZV0sIFsweDhhMCwgMHg4YTBdLCBbMHg4YTIsIDB4OGFjXSwgWzB4MjAwZiwgMHgyMDBmXSxcbiBbMHhmYjFkLCAweGZiMWRdLCBbMHhmYjFmLCAweGZiMjhdLCBbMHhmYjJhLCAweGZiMzZdLCBbMHhmYjM4LCAweGZiM2NdLFxuIFsweGZiM2UsIDB4ZmIzZV0sIFsweGZiNDAsIDB4ZmI0MV0sIFsweGZiNDMsIDB4ZmI0NF0sIFsweGZiNDYsIDB4ZmJjMV0sXG4gWzB4ZmJkMywgMHhmZDNkXSwgWzB4ZmQ1MCwgMHhmZDhmXSwgWzB4ZmQ5MiwgMHhmZGM3XSwgWzB4ZmRmMCwgMHhmZGZjXSxcbiBbMHhmZTcwLCAweGZlNzRdLCBbMHhmZTc2LCAweGZlZmNdLCBbMHgxMDgwMCwgMHgxMDgwNV0sIFsweDEwODA4LCAweDEwODA4XSxcbiBbMHgxMDgwYSwgMHgxMDgzNV0sIFsweDEwODM3LCAweDEwODM4XSwgWzB4MTA4M2MsIDB4MTA4M2NdLCBbMHgxMDgzZiwgMHgxMDg1NV0sXG4gWzB4MTA4NTcsIDB4MTA4NWZdLCBbMHgxMDkwMCwgMHgxMDkxYl0sIFsweDEwOTIwLCAweDEwOTM5XSwgWzB4MTA5M2YsIDB4MTA5M2ZdLFxuIFsweDEwOTgwLCAweDEwOWI3XSwgWzB4MTA5YmUsIDB4MTA5YmZdLCBbMHgxMGEwMCwgMHgxMGEwMF0sIFsweDEwYTEwLCAweDEwYTEzXSxcbiBbMHgxMGExNSwgMHgxMGExN10sIFsweDEwYTE5LCAweDEwYTMzXSwgWzB4MTBhNDAsIDB4MTBhNDddLCBbMHgxMGE1MCwgMHgxMGE1OF0sXG4gWzB4MTBhNjAsIDB4MTBhN2ZdLCBbMHgxMGIwMCwgMHgxMGIzNV0sIFsweDEwYjQwLCAweDEwYjU1XSwgWzB4MTBiNTgsIDB4MTBiNzJdLFxuIFsweDEwYjc4LCAweDEwYjdmXSwgWzB4MTBjMDAsIDB4MTBjNDhdLCBbMHgxZWUwMCwgMHgxZWUwM10sIFsweDFlZTA1LCAweDFlZTFmXSxcbiBbMHgxZWUyMSwgMHgxZWUyMl0sIFsweDFlZTI0LCAweDFlZTI0XSwgWzB4MWVlMjcsIDB4MWVlMjddLCBbMHgxZWUyOSwgMHgxZWUzMl0sXG4gWzB4MWVlMzQsIDB4MWVlMzddLCBbMHgxZWUzOSwgMHgxZWUzOV0sIFsweDFlZTNiLCAweDFlZTNiXSwgWzB4MWVlNDIsIDB4MWVlNDJdLFxuIFsweDFlZTQ3LCAweDFlZTQ3XSwgWzB4MWVlNDksIDB4MWVlNDldLCBbMHgxZWU0YiwgMHgxZWU0Yl0sIFsweDFlZTRkLCAweDFlZTRmXSxcbiBbMHgxZWU1MSwgMHgxZWU1Ml0sIFsweDFlZTU0LCAweDFlZTU0XSwgWzB4MWVlNTcsIDB4MWVlNTddLCBbMHgxZWU1OSwgMHgxZWU1OV0sXG4gWzB4MWVlNWIsIDB4MWVlNWJdLCBbMHgxZWU1ZCwgMHgxZWU1ZF0sIFsweDFlZTVmLCAweDFlZTVmXSwgWzB4MWVlNjEsIDB4MWVlNjJdLFxuIFsweDFlZTY0LCAweDFlZTY0XSwgWzB4MWVlNjcsIDB4MWVlNmFdLCBbMHgxZWU2YywgMHgxZWU3Ml0sIFsweDFlZTc0LCAweDFlZTc3XSxcbiBbMHgxZWU3OSwgMHgxZWU3Y10sIFsweDFlZTdlLCAweDFlZTdlXSwgWzB4MWVlODAsIDB4MWVlODldLCBbMHgxZWU4YiwgMHgxZWU5Yl0sXG4gWzB4MWVlYTEsIDB4MWVlYTNdLCBbMHgxZWVhNSwgMHgxZWVhOV0sIFsweDFlZWFiLCAweDFlZWJiXSwgWzB4MTBmZmZkLCAweDEwZmZmZF1dO1xuXG5mdW5jdGlvbiBpc1N0cm9uZ1JUTENoYXIoY2hhckNvZGUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJvbmdSVExSYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3VycmVudFJhbmdlID0gc3Ryb25nUlRMUmFuZ2VzW2ldO1xuICAgIGlmIChjaGFyQ29kZSA+PSBjdXJyZW50UmFuZ2VbMF0gJiYgY2hhckNvZGUgPD0gY3VycmVudFJhbmdlWzFdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZUJpZGkoY3VlRGl2KSB7XG4gIHZhciBub2RlU3RhY2sgPSBbXSxcbiAgICAgIHRleHQgPSBcIlwiLFxuICAgICAgY2hhckNvZGU7XG5cbiAgaWYgKCFjdWVEaXYgfHwgIWN1ZURpdi5jaGlsZE5vZGVzKSB7XG4gICAgcmV0dXJuIFwibHRyXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoTm9kZXMobm9kZVN0YWNrLCBub2RlKSB7XG4gICAgZm9yICh2YXIgaSA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbm9kZVN0YWNrLnB1c2gobm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0VGV4dE5vZGUobm9kZVN0YWNrKSB7XG4gICAgaWYgKCFub2RlU3RhY2sgfHwgIW5vZGVTdGFjay5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbm9kZVN0YWNrLnBvcCgpLFxuICAgICAgICB0ZXh0ID0gbm9kZS50ZXh0Q29udGVudCB8fCBub2RlLmlubmVyVGV4dDtcbiAgICBpZiAodGV4dCkge1xuICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbWF0Y2ggYWxsIHVuaWNvZGUgdHlwZSBCIGNoYXJhY3RlcnMgKHBhcmFncmFwaFxuICAgICAgLy8gc2VwYXJhdG9yIGNoYXJhY3RlcnMpLiBTZWUgaXNzdWUgIzExNS5cbiAgICAgIHZhciBtID0gdGV4dC5tYXRjaCgvXi4qKFxcbnxcXHIpLyk7XG4gICAgICBpZiAobSkge1xuICAgICAgICBub2RlU3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgcmV0dXJuIG1bMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gXCJydWJ5XCIpIHtcbiAgICAgIHJldHVybiBuZXh0VGV4dE5vZGUobm9kZVN0YWNrKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGROb2Rlcykge1xuICAgICAgcHVzaE5vZGVzKG5vZGVTdGFjaywgbm9kZSk7XG4gICAgICByZXR1cm4gbmV4dFRleHROb2RlKG5vZGVTdGFjayk7XG4gICAgfVxuICB9XG5cbiAgcHVzaE5vZGVzKG5vZGVTdGFjaywgY3VlRGl2KTtcbiAgd2hpbGUgKCh0ZXh0ID0gbmV4dFRleHROb2RlKG5vZGVTdGFjaykpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChpc1N0cm9uZ1JUTENoYXIoY2hhckNvZGUpKSB7XG4gICAgICAgIHJldHVybiBcInJ0bFwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gXCJsdHJcIjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUxpbmVQb3MoY3VlKSB7XG4gIGlmICh0eXBlb2YgY3VlLmxpbmUgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgIChjdWUuc25hcFRvTGluZXMgfHwgKGN1ZS5saW5lID49IDAgJiYgY3VlLmxpbmUgPD0gMTAwKSkpIHtcbiAgICByZXR1cm4gY3VlLmxpbmU7XG4gIH1cbiAgaWYgKCFjdWUudHJhY2sgfHwgIWN1ZS50cmFjay50ZXh0VHJhY2tMaXN0IHx8XG4gICAgICAhY3VlLnRyYWNrLnRleHRUcmFja0xpc3QubWVkaWFFbGVtZW50KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciB0cmFjayA9IGN1ZS50cmFjayxcbiAgICAgIHRyYWNrTGlzdCA9IHRyYWNrLnRleHRUcmFja0xpc3QsXG4gICAgICBjb3VudCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMaXN0Lmxlbmd0aCAmJiB0cmFja0xpc3RbaV0gIT09IHRyYWNrOyBpKyspIHtcbiAgICBpZiAodHJhY2tMaXN0W2ldLm1vZGUgPT09IFwic2hvd2luZ1wiKSB7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKytjb3VudCAqIC0xO1xufVxuXG5mdW5jdGlvbiBTdHlsZUJveCgpIHtcbn1cblxuLy8gQXBwbHkgc3R5bGVzIHRvIGEgZGl2LiBJZiB0aGVyZSBpcyBubyBkaXYgcGFzc2VkIHRoZW4gaXQgZGVmYXVsdHMgdG8gdGhlXG4vLyBkaXYgb24gJ3RoaXMnLlxuU3R5bGVCb3gucHJvdG90eXBlLmFwcGx5U3R5bGVzID0gZnVuY3Rpb24oc3R5bGVzLCBkaXYpIHtcbiAgZGl2ID0gZGl2IHx8IHRoaXMuZGl2O1xuICBmb3IgKHZhciBwcm9wIGluIHN0eWxlcykge1xuICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIGRpdi5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXTtcbiAgICB9XG4gIH1cbn07XG5cblN0eWxlQm94LnByb3RvdHlwZS5mb3JtYXRTdHlsZSA9IGZ1bmN0aW9uKHZhbCwgdW5pdCkge1xuICByZXR1cm4gdmFsID09PSAwID8gMCA6IHZhbCArIHVuaXQ7XG59O1xuXG4vLyBDb25zdHJ1Y3RzIHRoZSBjb21wdXRlZCBkaXNwbGF5IHN0YXRlIG9mIHRoZSBjdWUgKGEgZGl2KS4gUGxhY2VzIHRoZSBkaXZcbi8vIGludG8gdGhlIG92ZXJsYXkgd2hpY2ggc2hvdWxkIGJlIGEgYmxvY2sgbGV2ZWwgZWxlbWVudCAodXN1YWxseSBhIGRpdikuXG5mdW5jdGlvbiBDdWVTdHlsZUJveCh3aW5kb3csIGN1ZSwgc3R5bGVPcHRpb25zKSB7XG4gIHZhciBpc0lFOCA9ICgvTVNJRVxcczhcXC4wLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIGNvbG9yID0gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpXCI7XG4gIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBcInJnYmEoMCwgMCwgMCwgMC44KVwiO1xuXG4gIGlmIChpc0lFOCkge1xuICAgIGNvbG9yID0gXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIjtcbiAgICBiYWNrZ3JvdW5kQ29sb3IgPSBcInJnYigwLCAwLCAwKVwiO1xuICB9XG5cbiAgU3R5bGVCb3guY2FsbCh0aGlzKTtcbiAgdGhpcy5jdWUgPSBjdWU7XG5cbiAgLy8gUGFyc2Ugb3VyIGN1ZSdzIHRleHQgaW50byBhIERPTSB0cmVlIHJvb3RlZCBhdCAnY3VlRGl2Jy4gVGhpcyBkaXYgd2lsbFxuICAvLyBoYXZlIGlubGluZSBwb3NpdGlvbmluZyBhbmQgd2lsbCBmdW5jdGlvbiBhcyB0aGUgY3VlIGJhY2tncm91bmQgYm94LlxuICB0aGlzLmN1ZURpdiA9IHBhcnNlQ29udGVudCh3aW5kb3csIGN1ZS50ZXh0KTtcbiAgdmFyIHN0eWxlcyA9IHtcbiAgICBjb2xvcjogY29sb3IsXG4gICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDAsXG4gICAgZGlzcGxheTogXCJpbmxpbmVcIlxuICB9O1xuXG4gIGlmICghaXNJRTgpIHtcbiAgICBzdHlsZXMud3JpdGluZ01vZGUgPSBjdWUudmVydGljYWwgPT09IFwiXCIgPyBcImhvcml6b250YWwtdGJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdWUudmVydGljYWwgPT09IFwibHJcIiA/IFwidmVydGljYWwtbHJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcInZlcnRpY2FsLXJsXCI7XG4gICAgc3R5bGVzLnVuaWNvZGVCaWRpID0gXCJwbGFpbnRleHRcIjtcbiAgfVxuICB0aGlzLmFwcGx5U3R5bGVzKHN0eWxlcywgdGhpcy5jdWVEaXYpO1xuXG4gIC8vIENyZWF0ZSBhbiBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgZGl2IHRoYXQgd2lsbCBiZSB1c2VkIHRvIHBvc2l0aW9uIHRoZSBjdWVcbiAgLy8gZGl2LiBOb3RlLCBhbGwgV2ViVlRUIGN1ZS1zZXR0aW5nIGFsaWdubWVudHMgYXJlIGVxdWl2YWxlbnQgdG8gdGhlIENTU1xuICAvLyBtaXJyb3JzIG9mIHRoZW0gZXhjZXB0IFwibWlkZGxlXCIgd2hpY2ggaXMgXCJjZW50ZXJcIiBpbiBDU1MuXG4gIHRoaXMuZGl2ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHN0eWxlcyA9IHtcbiAgICB0ZXh0QWxpZ246IGN1ZS5hbGlnbiA9PT0gXCJtaWRkbGVcIiA/IFwiY2VudGVyXCIgOiBjdWUuYWxpZ24sXG4gICAgZm9udDogc3R5bGVPcHRpb25zLmZvbnQsXG4gICAgd2hpdGVTcGFjZTogXCJwcmUtbGluZVwiLFxuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgfTtcblxuICBpZiAoIWlzSUU4KSB7XG4gICAgc3R5bGVzLmRpcmVjdGlvbiA9IGRldGVybWluZUJpZGkodGhpcy5jdWVEaXYpO1xuICAgIHN0eWxlcy53cml0aW5nTW9kZSA9IGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIiA/IFwiaG9yaXpvbnRhbC10YlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1ZS52ZXJ0aWNhbCA9PT0gXCJsclwiID8gXCJ2ZXJ0aWNhbC1sclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwidmVydGljYWwtcmxcIi5cbiAgICBzdHlsZXN1bmljb2RlQmlkaSA9ICBcInBsYWludGV4dFwiO1xuICB9XG5cbiAgdGhpcy5hcHBseVN0eWxlcyhzdHlsZXMpO1xuXG4gIHRoaXMuZGl2LmFwcGVuZENoaWxkKHRoaXMuY3VlRGl2KTtcblxuICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHJlZmVyZW5jZSBlZGdlIG9mIHRoZSB2aWV3cG9ydCB0byB0aGUgdGV4dFxuICAvLyBwb3NpdGlvbiBvZiB0aGUgY3VlIGJveC4gVGhlIHJlZmVyZW5jZSBlZGdlIHdpbGwgYmUgcmVzb2x2ZWQgbGF0ZXIgd2hlblxuICAvLyB0aGUgYm94IG9yaWVudGF0aW9uIHN0eWxlcyBhcmUgYXBwbGllZC5cbiAgdmFyIHRleHRQb3MgPSAwO1xuICBzd2l0Y2ggKGN1ZS5wb3NpdGlvbkFsaWduKSB7XG4gIGNhc2UgXCJzdGFydFwiOlxuICAgIHRleHRQb3MgPSBjdWUucG9zaXRpb247XG4gICAgYnJlYWs7XG4gIGNhc2UgXCJtaWRkbGVcIjpcbiAgICB0ZXh0UG9zID0gY3VlLnBvc2l0aW9uIC0gKGN1ZS5zaXplIC8gMik7XG4gICAgYnJlYWs7XG4gIGNhc2UgXCJlbmRcIjpcbiAgICB0ZXh0UG9zID0gY3VlLnBvc2l0aW9uIC0gY3VlLnNpemU7XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBIb3Jpem9udGFsIGJveCBvcmllbnRhdGlvbjsgdGV4dFBvcyBpcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZVxuICAvLyBhcmVhIHRvIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGJveCBhbmQgY3VlLnNpemUgaXMgdGhlIGRpc3RhbmNlIGV4dGVuZGluZyB0b1xuICAvLyB0aGUgcmlnaHQgZnJvbSB0aGVyZS5cbiAgaWYgKGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIikge1xuICAgIHRoaXMuYXBwbHlTdHlsZXMoe1xuICAgICAgbGVmdDogIHRoaXMuZm9ybWF0U3R5bGUodGV4dFBvcywgXCIlXCIpLFxuICAgICAgd2lkdGg6IHRoaXMuZm9ybWF0U3R5bGUoY3VlLnNpemUsIFwiJVwiKVxuICAgIH0pO1xuICAvLyBWZXJ0aWNhbCBib3ggb3JpZW50YXRpb247IHRleHRQb3MgaXMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHRvcCBlZGdlIG9mIHRoZVxuICAvLyBhcmVhIHRvIHRoZSB0b3AgZWRnZSBvZiB0aGUgYm94IGFuZCBjdWUuc2l6ZSBpcyB0aGUgaGVpZ2h0IGV4dGVuZGluZ1xuICAvLyBkb3dud2FyZHMgZnJvbSB0aGVyZS5cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFwcGx5U3R5bGVzKHtcbiAgICAgIHRvcDogdGhpcy5mb3JtYXRTdHlsZSh0ZXh0UG9zLCBcIiVcIiksXG4gICAgICBoZWlnaHQ6IHRoaXMuZm9ybWF0U3R5bGUoY3VlLnNpemUsIFwiJVwiKVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5tb3ZlID0gZnVuY3Rpb24oYm94KSB7XG4gICAgdGhpcy5hcHBseVN0eWxlcyh7XG4gICAgICB0b3A6IHRoaXMuZm9ybWF0U3R5bGUoYm94LnRvcCwgXCJweFwiKSxcbiAgICAgIGJvdHRvbTogdGhpcy5mb3JtYXRTdHlsZShib3guYm90dG9tLCBcInB4XCIpLFxuICAgICAgbGVmdDogdGhpcy5mb3JtYXRTdHlsZShib3gubGVmdCwgXCJweFwiKSxcbiAgICAgIHJpZ2h0OiB0aGlzLmZvcm1hdFN0eWxlKGJveC5yaWdodCwgXCJweFwiKSxcbiAgICAgIGhlaWdodDogdGhpcy5mb3JtYXRTdHlsZShib3guaGVpZ2h0LCBcInB4XCIpLFxuICAgICAgd2lkdGg6IHRoaXMuZm9ybWF0U3R5bGUoYm94LndpZHRoLCBcInB4XCIpXG4gICAgfSk7XG4gIH07XG59XG5DdWVTdHlsZUJveC5wcm90b3R5cGUgPSBfb2JqQ3JlYXRlKFN0eWxlQm94LnByb3RvdHlwZSk7XG5DdWVTdHlsZUJveC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdWVTdHlsZUJveDtcblxuLy8gUmVwcmVzZW50cyB0aGUgY28tb3JkaW5hdGVzIG9mIGFuIEVsZW1lbnQgaW4gYSB3YXkgdGhhdCB3ZSBjYW4gZWFzaWx5XG4vLyBjb21wdXRlIHRoaW5ncyB3aXRoIHN1Y2ggYXMgaWYgaXQgb3ZlcmxhcHMgb3IgaW50ZXJzZWN0cyB3aXRoIGFub3RoZXIgRWxlbWVudC5cbi8vIENhbiBpbml0aWFsaXplIGl0IHdpdGggZWl0aGVyIGEgU3R5bGVCb3ggb3IgYW5vdGhlciBCb3hQb3NpdGlvbi5cbmZ1bmN0aW9uIEJveFBvc2l0aW9uKG9iaikge1xuICB2YXIgaXNJRTggPSAoL01TSUVcXHM4XFwuMC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgLy8gRWl0aGVyIGEgQm94UG9zaXRpb24gd2FzIHBhc3NlZCBpbiBhbmQgd2UgbmVlZCB0byBjb3B5IGl0LCBvciBhIFN0eWxlQm94XG4gIC8vIHdhcyBwYXNzZWQgaW4gYW5kIHdlIG5lZWQgdG8gY29weSB0aGUgcmVzdWx0cyBvZiAnZ2V0Qm91bmRpbmdDbGllbnRSZWN0J1xuICAvLyBhcyB0aGUgb2JqZWN0IHJldHVybmVkIGlzIHJlYWRvbmx5LiBBbGwgY28tb3JkaW5hdGUgdmFsdWVzIGFyZSBpbiByZWZlcmVuY2VcbiAgLy8gdG8gdGhlIHZpZXdwb3J0IG9yaWdpbiAodG9wIGxlZnQpLlxuICB2YXIgbGgsIGhlaWdodCwgd2lkdGgsIHRvcDtcbiAgaWYgKG9iai5kaXYpIHtcbiAgICBoZWlnaHQgPSBvYmouZGl2Lm9mZnNldEhlaWdodDtcbiAgICB3aWR0aCA9IG9iai5kaXYub2Zmc2V0V2lkdGg7XG4gICAgdG9wID0gb2JqLmRpdi5vZmZzZXRUb3A7XG5cbiAgICB2YXIgcmVjdHMgPSAocmVjdHMgPSBvYmouZGl2LmNoaWxkTm9kZXMpICYmIChyZWN0cyA9IHJlY3RzWzBdKSAmJlxuICAgICAgICAgICAgICAgIHJlY3RzLmdldENsaWVudFJlY3RzICYmIHJlY3RzLmdldENsaWVudFJlY3RzKCk7XG4gICAgb2JqID0gb2JqLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvLyBJbiBjZXJ0YWluIGNhc2VzIHRoZSBvdXR0ZXIgZGl2IHdpbGwgYmUgc2xpZ2h0bHkgbGFyZ2VyIHRoZW4gdGhlIHN1bSBvZlxuICAgIC8vIHRoZSBpbm5lciBkaXYncyBsaW5lcy4gVGhpcyBjb3VsZCBiZSBkdWUgdG8gYm9sZCB0ZXh0LCBldGMsIG9uIHNvbWUgcGxhdGZvcm1zLlxuICAgIC8vIEluIHRoaXMgY2FzZSB3ZSBzaG91bGQgZ2V0IHRoZSBhdmVyYWdlIGxpbmUgaGVpZ2h0IGFuZCB1c2UgdGhhdC4gVGhpcyB3aWxsXG4gICAgLy8gcmVzdWx0IGluIHRoZSBkZXNpcmVkIGJlaGF2aW91ci5cbiAgICBsaCA9IHJlY3RzID8gTWF0aC5tYXgoKHJlY3RzWzBdICYmIHJlY3RzWzBdLmhlaWdodCkgfHwgMCwgb2JqLmhlaWdodCAvIHJlY3RzLmxlbmd0aClcbiAgICAgICAgICAgICAgIDogMDtcblxuICB9XG4gIHRoaXMubGVmdCA9IG9iai5sZWZ0O1xuICB0aGlzLnJpZ2h0ID0gb2JqLnJpZ2h0O1xuICB0aGlzLnRvcCA9IG9iai50b3AgfHwgdG9wO1xuICB0aGlzLmhlaWdodCA9IG9iai5oZWlnaHQgfHwgaGVpZ2h0O1xuICB0aGlzLmJvdHRvbSA9IG9iai5ib3R0b20gfHwgKHRvcCArIChvYmouaGVpZ2h0IHx8IGhlaWdodCkpO1xuICB0aGlzLndpZHRoID0gb2JqLndpZHRoIHx8IHdpZHRoO1xuICB0aGlzLmxpbmVIZWlnaHQgPSBsaCAhPT0gdW5kZWZpbmVkID8gbGggOiBvYmoubGluZUhlaWdodDtcblxuICBpZiAoaXNJRTggJiYgIXRoaXMubGluZUhlaWdodCkge1xuICAgIHRoaXMubGluZUhlaWdodCA9IDEzO1xuICB9XG59XG5cbi8vIE1vdmUgdGhlIGJveCBhbG9uZyBhIHBhcnRpY3VsYXIgYXhpcy4gT3B0aW9uYWxseSBwYXNzIGluIGFuIGFtb3VudCB0byBtb3ZlXG4vLyB0aGUgYm94LiBJZiBubyBhbW91bnQgaXMgcGFzc2VkIHRoZW4gdGhlIGRlZmF1bHQgaXMgdGhlIGxpbmUgaGVpZ2h0IG9mIHRoZVxuLy8gYm94LlxuQm94UG9zaXRpb24ucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihheGlzLCB0b01vdmUpIHtcbiAgdG9Nb3ZlID0gdG9Nb3ZlICE9PSB1bmRlZmluZWQgPyB0b01vdmUgOiB0aGlzLmxpbmVIZWlnaHQ7XG4gIHN3aXRjaCAoYXhpcykge1xuICBjYXNlIFwiK3hcIjpcbiAgICB0aGlzLmxlZnQgKz0gdG9Nb3ZlO1xuICAgIHRoaXMucmlnaHQgKz0gdG9Nb3ZlO1xuICAgIGJyZWFrO1xuICBjYXNlIFwiLXhcIjpcbiAgICB0aGlzLmxlZnQgLT0gdG9Nb3ZlO1xuICAgIHRoaXMucmlnaHQgLT0gdG9Nb3ZlO1xuICAgIGJyZWFrO1xuICBjYXNlIFwiK3lcIjpcbiAgICB0aGlzLnRvcCArPSB0b01vdmU7XG4gICAgdGhpcy5ib3R0b20gKz0gdG9Nb3ZlO1xuICAgIGJyZWFrO1xuICBjYXNlIFwiLXlcIjpcbiAgICB0aGlzLnRvcCAtPSB0b01vdmU7XG4gICAgdGhpcy5ib3R0b20gLT0gdG9Nb3ZlO1xuICAgIGJyZWFrO1xuICB9XG59O1xuXG4vLyBDaGVjayBpZiB0aGlzIGJveCBvdmVybGFwcyBhbm90aGVyIGJveCwgYjIuXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUub3ZlcmxhcHMgPSBmdW5jdGlvbihiMikge1xuICByZXR1cm4gdGhpcy5sZWZ0IDwgYjIucmlnaHQgJiZcbiAgICAgICAgIHRoaXMucmlnaHQgPiBiMi5sZWZ0ICYmXG4gICAgICAgICB0aGlzLnRvcCA8IGIyLmJvdHRvbSAmJlxuICAgICAgICAgdGhpcy5ib3R0b20gPiBiMi50b3A7XG59O1xuXG4vLyBDaGVjayBpZiB0aGlzIGJveCBvdmVybGFwcyBhbnkgb3RoZXIgYm94ZXMgaW4gYm94ZXMuXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUub3ZlcmxhcHNBbnkgPSBmdW5jdGlvbihib3hlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMub3ZlcmxhcHMoYm94ZXNbaV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gQ2hlY2sgaWYgdGhpcyBib3ggaXMgd2l0aGluIGFub3RoZXIgYm94LlxuQm94UG9zaXRpb24ucHJvdG90eXBlLndpdGhpbiA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICByZXR1cm4gdGhpcy50b3AgPj0gY29udGFpbmVyLnRvcCAmJlxuICAgICAgICAgdGhpcy5ib3R0b20gPD0gY29udGFpbmVyLmJvdHRvbSAmJlxuICAgICAgICAgdGhpcy5sZWZ0ID49IGNvbnRhaW5lci5sZWZ0ICYmXG4gICAgICAgICB0aGlzLnJpZ2h0IDw9IGNvbnRhaW5lci5yaWdodDtcbn07XG5cbi8vIENoZWNrIGlmIHRoaXMgYm94IGlzIGVudGlyZWx5IHdpdGhpbiB0aGUgY29udGFpbmVyIG9yIGl0IGlzIG92ZXJsYXBwaW5nXG4vLyBvbiB0aGUgZWRnZSBvcHBvc2l0ZSBvZiB0aGUgYXhpcyBkaXJlY3Rpb24gcGFzc2VkLiBGb3IgZXhhbXBsZSwgaWYgXCIreFwiIGlzXG4vLyBwYXNzZWQgYW5kIHRoZSBib3ggaXMgb3ZlcmxhcHBpbmcgb24gdGhlIGxlZnQgZWRnZSBvZiB0aGUgY29udGFpbmVyLCB0aGVuXG4vLyByZXR1cm4gdHJ1ZS5cbkJveFBvc2l0aW9uLnByb3RvdHlwZS5vdmVybGFwc09wcG9zaXRlQXhpcyA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgYXhpcykge1xuICBzd2l0Y2ggKGF4aXMpIHtcbiAgY2FzZSBcIit4XCI6XG4gICAgcmV0dXJuIHRoaXMubGVmdCA8IGNvbnRhaW5lci5sZWZ0O1xuICBjYXNlIFwiLXhcIjpcbiAgICByZXR1cm4gdGhpcy5yaWdodCA+IGNvbnRhaW5lci5yaWdodDtcbiAgY2FzZSBcIit5XCI6XG4gICAgcmV0dXJuIHRoaXMudG9wIDwgY29udGFpbmVyLnRvcDtcbiAgY2FzZSBcIi15XCI6XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tID4gY29udGFpbmVyLmJvdHRvbTtcbiAgfVxufTtcblxuLy8gRmluZCB0aGUgcGVyY2VudGFnZSBvZiB0aGUgYXJlYSB0aGF0IHRoaXMgYm94IGlzIG92ZXJsYXBwaW5nIHdpdGggYW5vdGhlclxuLy8gYm94LlxuQm94UG9zaXRpb24ucHJvdG90eXBlLmludGVyc2VjdFBlcmNlbnRhZ2UgPSBmdW5jdGlvbihiMikge1xuICB2YXIgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMucmlnaHQsIGIyLnJpZ2h0KSAtIE1hdGgubWF4KHRoaXMubGVmdCwgYjIubGVmdCkpLFxuICAgICAgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuYm90dG9tLCBiMi5ib3R0b20pIC0gTWF0aC5tYXgodGhpcy50b3AsIGIyLnRvcCkpLFxuICAgICAgaW50ZXJzZWN0QXJlYSA9IHggKiB5O1xuICByZXR1cm4gaW50ZXJzZWN0QXJlYSAvICh0aGlzLmhlaWdodCAqIHRoaXMud2lkdGgpO1xufTtcblxuLy8gQ29udmVydCB0aGUgcG9zaXRpb25zIGZyb20gdGhpcyBib3ggdG8gQ1NTIGNvbXBhdGlibGUgcG9zaXRpb25zIHVzaW5nXG4vLyB0aGUgcmVmZXJlbmNlIGNvbnRhaW5lcidzIHBvc2l0aW9ucy4gVGhpcyBoYXMgdG8gYmUgZG9uZSBiZWNhdXNlIHRoaXNcbi8vIGJveCdzIHBvc2l0aW9ucyBhcmUgaW4gcmVmZXJlbmNlIHRvIHRoZSB2aWV3cG9ydCBvcmlnaW4sIHdoZXJlYXMsIENTU1xuLy8gdmFsdWVzIGFyZSBpbiByZWZlcmVjbmUgdG8gdGhlaXIgcmVzcGVjdGl2ZSBlZGdlcy5cbkJveFBvc2l0aW9uLnByb3RvdHlwZS50b0NTU0NvbXBhdFZhbHVlcyA9IGZ1bmN0aW9uKHJlZmVyZW5jZSkge1xuICByZXR1cm4ge1xuICAgIHRvcDogdGhpcy50b3AgLSByZWZlcmVuY2UudG9wLFxuICAgIGJvdHRvbTogcmVmZXJlbmNlLmJvdHRvbSAtIHRoaXMuYm90dG9tLFxuICAgIGxlZnQ6IHRoaXMubGVmdCAtIHJlZmVyZW5jZS5sZWZ0LFxuICAgIHJpZ2h0OiByZWZlcmVuY2UucmlnaHQgLSB0aGlzLnJpZ2h0LFxuICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgd2lkdGg6IHRoaXMud2lkdGhcbiAgfTtcbn07XG5cbi8vIEdldCBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBib3gncyBwb3NpdGlvbiB3aXRob3V0IGFueXRoaW5nIGV4dHJhLlxuLy8gQ2FuIHBhc3MgYSBTdHlsZUJveCwgSFRNTEVsZW1lbnQsIG9yIGFub3RoZXIgQm94UG9zaXRvbi5cbkJveFBvc2l0aW9uLmdldFNpbXBsZUJveFBvc2l0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBoZWlnaHQgPSBvYmouZGl2ID8gb2JqLmRpdi5vZmZzZXRIZWlnaHQgOiBvYmoudGFnTmFtZSA/IG9iai5vZmZzZXRIZWlnaHQgOiAwO1xuICB2YXIgd2lkdGggPSBvYmouZGl2ID8gb2JqLmRpdi5vZmZzZXRXaWR0aCA6IG9iai50YWdOYW1lID8gb2JqLm9mZnNldFdpZHRoIDogMDtcbiAgdmFyIHRvcCA9IG9iai5kaXYgPyBvYmouZGl2Lm9mZnNldFRvcCA6IG9iai50YWdOYW1lID8gb2JqLm9mZnNldFRvcCA6IDA7XG5cbiAgb2JqID0gb2JqLmRpdiA/IG9iai5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOlxuICAgICAgICAgICAgICAgIG9iai50YWdOYW1lID8gb2JqLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogb2JqO1xuICB2YXIgcmV0ID0ge1xuICAgIGxlZnQ6IG9iai5sZWZ0LFxuICAgIHJpZ2h0OiBvYmoucmlnaHQsXG4gICAgdG9wOiBvYmoudG9wIHx8IHRvcCxcbiAgICBoZWlnaHQ6IG9iai5oZWlnaHQgfHwgaGVpZ2h0LFxuICAgIGJvdHRvbTogb2JqLmJvdHRvbSB8fCAodG9wICsgKG9iai5oZWlnaHQgfHwgaGVpZ2h0KSksXG4gICAgd2lkdGg6IG9iai53aWR0aCB8fCB3aWR0aFxuICB9O1xuICByZXR1cm4gcmV0O1xufTtcblxuLy8gTW92ZSBhIFN0eWxlQm94IHRvIGl0cyBzcGVjaWZpZWQsIG9yIG5leHQgYmVzdCwgcG9zaXRpb24uIFRoZSBjb250YWluZXJCb3hcbi8vIGlzIHRoZSBib3ggdGhhdCBjb250YWlucyB0aGUgU3R5bGVCb3gsIHN1Y2ggYXMgYSBkaXYuIGJveFBvc2l0aW9ucyBhcmVcbi8vIGEgbGlzdCBvZiBvdGhlciBib3hlcyB0aGF0IHRoZSBzdHlsZUJveCBjYW4ndCBvdmVybGFwIHdpdGguXG5mdW5jdGlvbiBtb3ZlQm94VG9MaW5lUG9zaXRpb24od2luZG93LCBzdHlsZUJveCwgY29udGFpbmVyQm94LCBib3hQb3NpdGlvbnMpIHtcblxuICAvLyBGaW5kIHRoZSBiZXN0IHBvc2l0aW9uIGZvciBhIGN1ZSBib3gsIGIsIG9uIHRoZSB2aWRlby4gVGhlIGF4aXMgcGFyYW1ldGVyXG4gIC8vIGlzIGEgbGlzdCBvZiBheGlzLCB0aGUgb3JkZXIgb2Ygd2hpY2gsIGl0IHdpbGwgbW92ZSB0aGUgYm94IGFsb25nLiBGb3IgZXhhbXBsZTpcbiAgLy8gUGFzc2luZyBbXCIreFwiLCBcIi14XCJdIHdpbGwgbW92ZSB0aGUgYm94IGZpcnN0IGFsb25nIHRoZSB4IGF4aXMgaW4gdGhlIHBvc2l0aXZlXG4gIC8vIGRpcmVjdGlvbi4gSWYgaXQgZG9lc24ndCBmaW5kIGEgZ29vZCBwb3NpdGlvbiBmb3IgaXQgdGhlcmUgaXQgd2lsbCB0aGVuIG1vdmVcbiAgLy8gaXQgYWxvbmcgdGhlIHggYXhpcyBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uLlxuICBmdW5jdGlvbiBmaW5kQmVzdFBvc2l0aW9uKGIsIGF4aXMpIHtcbiAgICB2YXIgYmVzdFBvc2l0aW9uLFxuICAgICAgICBzcGVjaWZpZWRQb3NpdGlvbiA9IG5ldyBCb3hQb3NpdGlvbihiKSxcbiAgICAgICAgcGVyY2VudGFnZSA9IDE7IC8vIEhpZ2hlc3QgcG9zc2libGUgc28gdGhlIGZpcnN0IHRoaW5nIHdlIGdldCBpcyBiZXR0ZXIuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4aXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdoaWxlIChiLm92ZXJsYXBzT3Bwb3NpdGVBeGlzKGNvbnRhaW5lckJveCwgYXhpc1tpXSkgfHxcbiAgICAgICAgICAgICAoYi53aXRoaW4oY29udGFpbmVyQm94KSAmJiBiLm92ZXJsYXBzQW55KGJveFBvc2l0aW9ucykpKSB7XG4gICAgICAgIGIubW92ZShheGlzW2ldKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGZvdW5kIGEgc3BvdCB3aGVyZSB3ZSBhcmVuJ3Qgb3ZlcmxhcHBpbmcgYW55dGhpbmcuIFRoaXMgaXMgb3VyXG4gICAgICAvLyBiZXN0IHBvc2l0aW9uLlxuICAgICAgaWYgKGIud2l0aGluKGNvbnRhaW5lckJveCkpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgICB2YXIgcCA9IGIuaW50ZXJzZWN0UGVyY2VudGFnZShjb250YWluZXJCb3gpO1xuICAgICAgLy8gSWYgd2UncmUgb3V0c2lkZSB0aGUgY29udGFpbmVyIGJveCBsZXNzIHRoZW4gd2Ugd2VyZSBvbiBvdXIgbGFzdCB0cnlcbiAgICAgIC8vIHRoZW4gcmVtZW1iZXIgdGhpcyBwb3NpdGlvbiBhcyB0aGUgYmVzdCBwb3NpdGlvbi5cbiAgICAgIGlmIChwZXJjZW50YWdlID4gcCkge1xuICAgICAgICBiZXN0UG9zaXRpb24gPSBuZXcgQm94UG9zaXRpb24oYik7XG4gICAgICAgIHBlcmNlbnRhZ2UgPSBwO1xuICAgICAgfVxuICAgICAgLy8gUmVzZXQgdGhlIGJveCBwb3NpdGlvbiB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgICAgYiA9IG5ldyBCb3hQb3NpdGlvbihzcGVjaWZpZWRQb3NpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBiZXN0UG9zaXRpb24gfHwgc3BlY2lmaWVkUG9zaXRpb247XG4gIH1cblxuICB2YXIgYm94UG9zaXRpb24gPSBuZXcgQm94UG9zaXRpb24oc3R5bGVCb3gpLFxuICAgICAgY3VlID0gc3R5bGVCb3guY3VlLFxuICAgICAgbGluZVBvcyA9IGNvbXB1dGVMaW5lUG9zKGN1ZSksXG4gICAgICBheGlzID0gW107XG5cbiAgLy8gSWYgd2UgaGF2ZSBhIGxpbmUgbnVtYmVyIHRvIGFsaWduIHRoZSBjdWUgdG8uXG4gIGlmIChjdWUuc25hcFRvTGluZXMpIHtcbiAgICB2YXIgc2l6ZTtcbiAgICBzd2l0Y2ggKGN1ZS52ZXJ0aWNhbCkge1xuICAgIGNhc2UgXCJcIjpcbiAgICAgIGF4aXMgPSBbIFwiK3lcIiwgXCIteVwiIF07XG4gICAgICBzaXplID0gXCJoZWlnaHRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJybFwiOlxuICAgICAgYXhpcyA9IFsgXCIreFwiLCBcIi14XCIgXTtcbiAgICAgIHNpemUgPSBcIndpZHRoXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibHJcIjpcbiAgICAgIGF4aXMgPSBbIFwiLXhcIiwgXCIreFwiIF07XG4gICAgICBzaXplID0gXCJ3aWR0aFwiO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHN0ZXAgPSBib3hQb3NpdGlvbi5saW5lSGVpZ2h0LFxuICAgICAgICBwb3NpdGlvbiA9IHN0ZXAgKiBNYXRoLnJvdW5kKGxpbmVQb3MpLFxuICAgICAgICBtYXhQb3NpdGlvbiA9IGNvbnRhaW5lckJveFtzaXplXSArIHN0ZXAsXG4gICAgICAgIGluaXRpYWxBeGlzID0gYXhpc1swXTtcblxuICAgIC8vIElmIHRoZSBzcGVjaWZpZWQgaW50aWFsIHBvc2l0aW9uIGlzIGdyZWF0ZXIgdGhlbiB0aGUgbWF4IHBvc2l0aW9uIHRoZW5cbiAgICAvLyBjbGFtcCB0aGUgYm94IHRvIHRoZSBhbW91bnQgb2Ygc3RlcHMgaXQgd291bGQgdGFrZSBmb3IgdGhlIGJveCB0b1xuICAgIC8vIHJlYWNoIHRoZSBtYXggcG9zaXRpb24uXG4gICAgaWYgKE1hdGguYWJzKHBvc2l0aW9uKSA+IG1heFBvc2l0aW9uKSB7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIDwgMCA/IC0xIDogMTtcbiAgICAgIHBvc2l0aW9uICo9IE1hdGguY2VpbChtYXhQb3NpdGlvbiAvIHN0ZXApICogc3RlcDtcbiAgICB9XG5cbiAgICAvLyBJZiBjb21wdXRlZCBsaW5lIHBvc2l0aW9uIHJldHVybnMgbmVnYXRpdmUgdGhlbiBsaW5lIG51bWJlcnMgYXJlXG4gICAgLy8gcmVsYXRpdmUgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdmlkZW8gaW5zdGVhZCBvZiB0aGUgdG9wLiBUaGVyZWZvcmUsIHdlXG4gICAgLy8gbmVlZCB0byBpbmNyZWFzZSBvdXIgaW5pdGlhbCBwb3NpdGlvbiBieSB0aGUgbGVuZ3RoIG9yIHdpZHRoIG9mIHRoZVxuICAgIC8vIHZpZGVvLCBkZXBlbmRpbmcgb24gdGhlIHdyaXRpbmcgZGlyZWN0aW9uLCBhbmQgcmV2ZXJzZSBvdXIgYXhpcyBkaXJlY3Rpb25zLlxuICAgIGlmIChsaW5lUG9zIDwgMCkge1xuICAgICAgcG9zaXRpb24gKz0gY3VlLnZlcnRpY2FsID09PSBcIlwiID8gY29udGFpbmVyQm94LmhlaWdodCA6IGNvbnRhaW5lckJveC53aWR0aDtcbiAgICAgIGF4aXMgPSBheGlzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICAvLyBNb3ZlIHRoZSBib3ggdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi4gVGhpcyBtYXkgbm90IGJlIGl0cyBiZXN0XG4gICAgLy8gcG9zaXRpb24uXG4gICAgYm94UG9zaXRpb24ubW92ZShpbml0aWFsQXhpcywgcG9zaXRpb24pO1xuXG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhIHBlcmNlbnRhZ2UgbGluZSB2YWx1ZSBmb3IgdGhlIGN1ZS5cbiAgICB2YXIgY2FsY3VsYXRlZFBlcmNlbnRhZ2UgPSAoYm94UG9zaXRpb24ubGluZUhlaWdodCAvIGNvbnRhaW5lckJveC5oZWlnaHQpICogMTAwO1xuXG4gICAgc3dpdGNoIChjdWUubGluZUFsaWduKSB7XG4gICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgICAgbGluZVBvcyAtPSAoY2FsY3VsYXRlZFBlcmNlbnRhZ2UgLyAyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgIGxpbmVQb3MgLT0gY2FsY3VsYXRlZFBlcmNlbnRhZ2U7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBBcHBseSBpbml0aWFsIGxpbmUgcG9zaXRpb24gdG8gdGhlIGN1ZSBib3guXG4gICAgc3dpdGNoIChjdWUudmVydGljYWwpIHtcbiAgICBjYXNlIFwiXCI6XG4gICAgICBzdHlsZUJveC5hcHBseVN0eWxlcyh7XG4gICAgICAgIHRvcDogc3R5bGVCb3guZm9ybWF0U3R5bGUobGluZVBvcywgXCIlXCIpXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJybFwiOlxuICAgICAgc3R5bGVCb3guYXBwbHlTdHlsZXMoe1xuICAgICAgICBsZWZ0OiBzdHlsZUJveC5mb3JtYXRTdHlsZShsaW5lUG9zLCBcIiVcIilcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImxyXCI6XG4gICAgICBzdHlsZUJveC5hcHBseVN0eWxlcyh7XG4gICAgICAgIHJpZ2h0OiBzdHlsZUJveC5mb3JtYXRTdHlsZShsaW5lUG9zLCBcIiVcIilcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXhpcyA9IFsgXCIreVwiLCBcIi14XCIsIFwiK3hcIiwgXCIteVwiIF07XG5cbiAgICAvLyBHZXQgdGhlIGJveCBwb3NpdGlvbiBhZ2FpbiBhZnRlciB3ZSd2ZSBhcHBsaWVkIHRoZSBzcGVjaWZpZWQgcG9zaXRpb25pbmdcbiAgICAvLyB0byBpdC5cbiAgICBib3hQb3NpdGlvbiA9IG5ldyBCb3hQb3NpdGlvbihzdHlsZUJveCk7XG4gIH1cblxuICB2YXIgYmVzdFBvc2l0aW9uID0gZmluZEJlc3RQb3NpdGlvbihib3hQb3NpdGlvbiwgYXhpcyk7XG4gIHN0eWxlQm94Lm1vdmUoYmVzdFBvc2l0aW9uLnRvQ1NTQ29tcGF0VmFsdWVzKGNvbnRhaW5lckJveCkpO1xufVxuXG5mdW5jdGlvbiBXZWJWVFQoKSB7XG4gIC8vIE5vdGhpbmdcbn1cblxuLy8gSGVscGVyIHRvIGFsbG93IHN0cmluZ3MgdG8gYmUgZGVjb2RlZCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJpbmFyeSB1dGY4IGRhdGEuXG5XZWJWVFQuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIGRlY29kZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIC0gZXhwZWN0ZWQgc3RyaW5nIGRhdGEuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpO1xuICAgIH1cbiAgfTtcbn07XG5cbldlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlID0gZnVuY3Rpb24od2luZG93LCBjdWV0ZXh0KSB7XG4gIGlmICghd2luZG93IHx8ICFjdWV0ZXh0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhcnNlQ29udGVudCh3aW5kb3csIGN1ZXRleHQpO1xufTtcblxudmFyIEZPTlRfU0laRV9QRVJDRU5UID0gMC4wNTtcbnZhciBGT05UX1NUWUxFID0gXCJzYW5zLXNlcmlmXCI7XG52YXIgQ1VFX0JBQ0tHUk9VTkRfUEFERElORyA9IFwiMS41JVwiO1xuXG4vLyBSdW5zIHRoZSBwcm9jZXNzaW5nIG1vZGVsIG92ZXIgdGhlIGN1ZXMgYW5kIHJlZ2lvbnMgcGFzc2VkIHRvIGl0LlxuLy8gQHBhcmFtIG92ZXJsYXkgQSBibG9jayBsZXZlbCBlbGVtZW50ICh1c3VhbGx5IGEgZGl2KSB0aGF0IHRoZSBjb21wdXRlZCBjdWVzXG4vLyAgICAgICAgICAgICAgICBhbmQgcmVnaW9ucyB3aWxsIGJlIHBsYWNlZCBpbnRvLlxuV2ViVlRULnByb2Nlc3NDdWVzID0gZnVuY3Rpb24od2luZG93LCBjdWVzLCBvdmVybGF5KSB7XG4gIGlmICghd2luZG93IHx8ICFjdWVzIHx8ICFvdmVybGF5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIHByZXZpb3VzIGNoaWxkcmVuLlxuICB3aGlsZSAob3ZlcmxheS5maXJzdENoaWxkKSB7XG4gICAgb3ZlcmxheS5yZW1vdmVDaGlsZChvdmVybGF5LmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgdmFyIHBhZGRlZE92ZXJsYXkgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5sZWZ0ID0gXCIwXCI7XG4gIHBhZGRlZE92ZXJsYXkuc3R5bGUucmlnaHQgPSBcIjBcIjtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS50b3AgPSBcIjBcIjtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5ib3R0b20gPSBcIjBcIjtcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5tYXJnaW4gPSBDVUVfQkFDS0dST1VORF9QQURESU5HO1xuICBvdmVybGF5LmFwcGVuZENoaWxkKHBhZGRlZE92ZXJsYXkpO1xuXG4gIC8vIERldGVybWluZSBpZiB3ZSBuZWVkIHRvIGNvbXB1dGUgdGhlIGRpc3BsYXkgc3RhdGVzIG9mIHRoZSBjdWVzLiBUaGlzIGNvdWxkXG4gIC8vIGJlIHRoZSBjYXNlIGlmIGEgY3VlJ3Mgc3RhdGUgaGFzIGJlZW4gY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBjb21wdXRhdGlvbiBvclxuICAvLyBpZiBpdCBoYXMgbm90IGJlZW4gY29tcHV0ZWQgeWV0LlxuICBmdW5jdGlvbiBzaG91bGRDb21wdXRlKGN1ZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjdWVzW2ldLmhhc0JlZW5SZXNldCB8fCAhY3Vlc1tpXS5kaXNwbGF5U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFdlIGRvbid0IG5lZWQgdG8gcmVjb21wdXRlIHRoZSBjdWVzJyBkaXNwbGF5IHN0YXRlcy4gSnVzdCByZXVzZSB0aGVtLlxuICBpZiAoIXNob3VsZENvbXB1dGUoY3VlcykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhZGRlZE92ZXJsYXkuYXBwZW5kQ2hpbGQoY3Vlc1tpXS5kaXNwbGF5U3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYm94UG9zaXRpb25zID0gW10sXG4gICAgICBjb250YWluZXJCb3ggPSBCb3hQb3NpdGlvbi5nZXRTaW1wbGVCb3hQb3NpdGlvbihwYWRkZWRPdmVybGF5KSxcbiAgICAgIGZvbnRTaXplID0gTWF0aC5yb3VuZChjb250YWluZXJCb3guaGVpZ2h0ICogRk9OVF9TSVpFX1BFUkNFTlQgKiAxMDApIC8gMTAwO1xuICB2YXIgc3R5bGVPcHRpb25zID0ge1xuICAgIGZvbnQ6IGZvbnRTaXplICsgXCJweCBcIiArIEZPTlRfU1RZTEVcbiAgfTtcblxuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0eWxlQm94LCBjdWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1ZSA9IGN1ZXNbaV07XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIGludGlhbCBwb3NpdGlvbiBhbmQgc3R5bGVzIG9mIHRoZSBjdWUgZGl2LlxuICAgICAgc3R5bGVCb3ggPSBuZXcgQ3VlU3R5bGVCb3god2luZG93LCBjdWUsIHN0eWxlT3B0aW9ucyk7XG4gICAgICBwYWRkZWRPdmVybGF5LmFwcGVuZENoaWxkKHN0eWxlQm94LmRpdik7XG5cbiAgICAgIC8vIE1vdmUgdGhlIGN1ZSBkaXYgdG8gaXQncyBjb3JyZWN0IGxpbmUgcG9zaXRpb24uXG4gICAgICBtb3ZlQm94VG9MaW5lUG9zaXRpb24od2luZG93LCBzdHlsZUJveCwgY29udGFpbmVyQm94LCBib3hQb3NpdGlvbnMpO1xuXG4gICAgICAvLyBSZW1lbWJlciB0aGUgY29tcHV0ZWQgZGl2IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byByZWNvbXB1dGUgaXQgbGF0ZXJcbiAgICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgdG9vLlxuICAgICAgY3VlLmRpc3BsYXlTdGF0ZSA9IHN0eWxlQm94LmRpdjtcblxuICAgICAgYm94UG9zaXRpb25zLnB1c2goQm94UG9zaXRpb24uZ2V0U2ltcGxlQm94UG9zaXRpb24oc3R5bGVCb3gpKTtcbiAgICB9XG4gIH0pKCk7XG59O1xuXG5XZWJWVFQuUGFyc2VyID0gZnVuY3Rpb24od2luZG93LCB2dHRqcywgZGVjb2Rlcikge1xuICBpZiAoIWRlY29kZXIpIHtcbiAgICBkZWNvZGVyID0gdnR0anM7XG4gICAgdnR0anMgPSB7fTtcbiAgfVxuICBpZiAoIXZ0dGpzKSB7XG4gICAgdnR0anMgPSB7fTtcbiAgfVxuXG4gIHRoaXMud2luZG93ID0gd2luZG93O1xuICB0aGlzLnZ0dGpzID0gdnR0anM7XG4gIHRoaXMuc3RhdGUgPSBcIklOSVRJQUxcIjtcbiAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICB0aGlzLmRlY29kZXIgPSBkZWNvZGVyIHx8IG5ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik7XG4gIHRoaXMucmVnaW9uTGlzdCA9IFtdO1xufTtcblxuV2ViVlRULlBhcnNlci5wcm90b3R5cGUgPSB7XG4gIC8vIElmIHRoZSBlcnJvciBpcyBhIFBhcnNpbmdFcnJvciB0aGVuIHJlcG9ydCBpdCB0byB0aGUgY29uc3VtZXIgaWZcbiAgLy8gcG9zc2libGUuIElmIGl0J3Mgbm90IGEgUGFyc2luZ0Vycm9yIHRoZW4gdGhyb3cgaXQgbGlrZSBub3JtYWwuXG4gIHJlcG9ydE9yVGhyb3dFcnJvcjogZnVuY3Rpb24oZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yKSB7XG4gICAgICB0aGlzLm9ucGFyc2luZ2Vycm9yICYmIHRoaXMub25wYXJzaW5nZXJyb3IoZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBkYXRhIHRoZW4gd2Ugd29uJ3QgZGVjb2RlIGl0LCBidXQgd2lsbCBqdXN0IHRyeSB0byBwYXJzZVxuICAgIC8vIHdoYXRldmVyIGlzIGluIGJ1ZmZlciBhbHJlYWR5LiBUaGlzIG1heSBvY2N1ciBpbiBjaXJjdW1zdGFuY2VzLCBmb3JcbiAgICAvLyBleGFtcGxlIHdoZW4gZmx1c2goKSBpcyBjYWxsZWQuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIGRhdGEgdGhhdCB3ZSByZWNlaXZlZC5cbiAgICAgIHNlbGYuYnVmZmVyICs9IHNlbGYuZGVjb2Rlci5kZWNvZGUoZGF0YSwge3N0cmVhbTogdHJ1ZX0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3ROZXh0TGluZSgpIHtcbiAgICAgIHZhciBidWZmZXIgPSBzZWxmLmJ1ZmZlcjtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgd2hpbGUgKHBvcyA8IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyW3Bvc10gIT09ICdcXHInICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxuJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lID0gYnVmZmVyLnN1YnN0cigwLCBwb3MpO1xuICAgICAgLy8gQWR2YW5jZSB0aGUgYnVmZmVyIGVhcmx5IGluIGNhc2Ugd2UgZmFpbCBiZWxvdy5cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xccicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXG4nKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuICAgICAgc2VsZi5idWZmZXIgPSBidWZmZXIuc3Vic3RyKHBvcyk7XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9XG5cbiAgICAvLyAzLjQgV2ViVlRUIHJlZ2lvbiBhbmQgV2ViVlRUIHJlZ2lvbiBzZXR0aW5ncyBzeW50YXhcbiAgICBmdW5jdGlvbiBwYXJzZVJlZ2lvbihpbnB1dCkge1xuICAgICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG5cbiAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgIHNldHRpbmdzLnNldChrLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImxpbmVzXCI6XG4gICAgICAgICAgc2V0dGluZ3MuaW50ZWdlcihrLCB2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlZ2lvbmFuY2hvclwiOlxuICAgICAgICBjYXNlIFwidmlld3BvcnRhbmNob3JcIjpcbiAgICAgICAgICB2YXIgeHkgPSB2LnNwbGl0KCcsJyk7XG4gICAgICAgICAgaWYgKHh5Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbWFrZSBzdXJlIGJvdGggeCBhbmQgeSBwYXJzZSwgc28gdXNlIGEgdGVtcG9yYXJ5XG4gICAgICAgICAgLy8gc2V0dGluZ3Mgb2JqZWN0IGhlcmUuXG4gICAgICAgICAgdmFyIGFuY2hvciA9IG5ldyBTZXR0aW5ncygpO1xuICAgICAgICAgIGFuY2hvci5wZXJjZW50KFwieFwiLCB4eVswXSk7XG4gICAgICAgICAgYW5jaG9yLnBlcmNlbnQoXCJ5XCIsIHh5WzFdKTtcbiAgICAgICAgICBpZiAoIWFuY2hvci5oYXMoXCJ4XCIpIHx8ICFhbmNob3IuaGFzKFwieVwiKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldHRpbmdzLnNldChrICsgXCJYXCIsIGFuY2hvci5nZXQoXCJ4XCIpKTtcbiAgICAgICAgICBzZXR0aW5ncy5zZXQoayArIFwiWVwiLCBhbmNob3IuZ2V0KFwieVwiKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzY3JvbGxcIjpcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgW1widXBcIl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LCAvPS8sIC9cXHMvKTtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSByZWdpb24sIHVzaW5nIGRlZmF1bHQgdmFsdWVzIGZvciBhbnkgdmFsdWVzIHRoYXQgd2VyZSBub3RcbiAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgIGlmIChzZXR0aW5ncy5oYXMoXCJpZFwiKSkge1xuICAgICAgICB2YXIgcmVnaW9uID0gbmV3IChzZWxmLnZ0dGpzLlZUVFJlZ2lvbiB8fCBzZWxmLndpbmRvdy5WVFRSZWdpb24pKCk7XG4gICAgICAgIHJlZ2lvbi53aWR0aCA9IHNldHRpbmdzLmdldChcIndpZHRoXCIsIDEwMCk7XG4gICAgICAgIHJlZ2lvbi5saW5lcyA9IHNldHRpbmdzLmdldChcImxpbmVzXCIsIDMpO1xuICAgICAgICByZWdpb24ucmVnaW9uQW5jaG9yWCA9IHNldHRpbmdzLmdldChcInJlZ2lvbmFuY2hvclhcIiwgMCk7XG4gICAgICAgIHJlZ2lvbi5yZWdpb25BbmNob3JZID0gc2V0dGluZ3MuZ2V0KFwicmVnaW9uYW5jaG9yWVwiLCAxMDApO1xuICAgICAgICByZWdpb24udmlld3BvcnRBbmNob3JYID0gc2V0dGluZ3MuZ2V0KFwidmlld3BvcnRhbmNob3JYXCIsIDApO1xuICAgICAgICByZWdpb24udmlld3BvcnRBbmNob3JZID0gc2V0dGluZ3MuZ2V0KFwidmlld3BvcnRhbmNob3JZXCIsIDEwMCk7XG4gICAgICAgIHJlZ2lvbi5zY3JvbGwgPSBzZXR0aW5ncy5nZXQoXCJzY3JvbGxcIiwgXCJcIik7XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSByZWdpb24uXG4gICAgICAgIHNlbGYub25yZWdpb24gJiYgc2VsZi5vbnJlZ2lvbihyZWdpb24pO1xuICAgICAgICAvLyBSZW1lbWJlciB0aGUgVlRUUmVnaW9uIGZvciBsYXRlciBpbiBjYXNlIHdlIHBhcnNlIGFueSBWVFRDdWVzIHRoYXRcbiAgICAgICAgLy8gcmVmZXJlbmNlIGl0LlxuICAgICAgICBzZWxmLnJlZ2lvbkxpc3QucHVzaCh7XG4gICAgICAgICAgaWQ6IHNldHRpbmdzLmdldChcImlkXCIpLFxuICAgICAgICAgIHJlZ2lvbjogcmVnaW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRyYWZ0LXBhbnRvcy1odHRwLWxpdmUtc3RyZWFtaW5nLTIwXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXBhbnRvcy1odHRwLWxpdmUtc3RyZWFtaW5nLTIwI3NlY3Rpb24tMy41XG4gICAgLy8gMy41IFdlYlZUVFxuICAgIGZ1bmN0aW9uIHBhcnNlVGltZXN0YW1wTWFwKGlucHV0KSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3MoKTtcblxuICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgIHN3aXRjaChrKSB7XG4gICAgICAgIGNhc2UgXCJNUEVHVFwiOlxuICAgICAgICAgIHNldHRpbmdzLmludGVnZXIoayArICdTJywgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJMT0NBXCI6XG4gICAgICAgICAgc2V0dGluZ3Muc2V0KGsgKyAnTCcsIHBhcnNlVGltZVN0YW1wKHYpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSwgL1teXFxkXTovLCAvLC8pO1xuXG4gICAgICBzZWxmLm9udGltZXN0YW1wbWFwICYmIHNlbGYub250aW1lc3RhbXBtYXAoe1xuICAgICAgICBcIk1QRUdUU1wiOiBzZXR0aW5ncy5nZXQoXCJNUEVHVFNcIiksXG4gICAgICAgIFwiTE9DQUxcIjogc2V0dGluZ3MuZ2V0KFwiTE9DQUxcIilcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIDMuMiBXZWJWVFQgbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQubWF0Y2goL1gtVElNRVNUQU1QLU1BUC8pKSB7XG4gICAgICAgIC8vIFRoaXMgbGluZSBjb250YWlucyBITFMgWC1USU1FU1RBTVAtTUFQIG1ldGFkYXRhXG4gICAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgIHN3aXRjaChrKSB7XG4gICAgICAgICAgY2FzZSBcIlgtVElNRVNUQU1QLU1BUFwiOlxuICAgICAgICAgICAgcGFyc2VUaW1lc3RhbXBNYXAodik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIC89Lyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgICAgY2FzZSBcIlJlZ2lvblwiOlxuICAgICAgICAgICAgLy8gMy4zIFdlYlZUVCByZWdpb24gbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgICAgICAgICAgcGFyc2VSZWdpb24odik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIC86Lyk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyA1LjEgV2ViVlRUIGZpbGUgcGFyc2luZy5cbiAgICB0cnkge1xuICAgICAgdmFyIGxpbmU7XG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gXCJJTklUSUFMXCIpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc3RhcnQgcGFyc2luZyB1bnRpbCB3ZSBoYXZlIHRoZSBmaXJzdCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KHNlbGYuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuXG4gICAgICAgIHZhciBtID0gbGluZS5tYXRjaCgvXldFQlZUVChbIFxcdF0uKik/JC8pO1xuICAgICAgICBpZiAoIW0gfHwgIW1bMF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvci5FcnJvcnMuQmFkU2lnbmF0dXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc3RhdGUgPSBcIkhFQURFUlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChzZWxmLmJ1ZmZlcikge1xuICAgICAgICAvLyBXZSBjYW4ndCBwYXJzZSBhIGxpbmUgdW50aWwgd2UgaGF2ZSB0aGUgZnVsbCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KHNlbGYuYnVmZmVyKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhbHJlYWR5Q29sbGVjdGVkTGluZSkge1xuICAgICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChzZWxmLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgXCJIRUFERVJcIjpcbiAgICAgICAgICAvLyAxMy0xOCAtIEFsbG93IGEgaGVhZGVyIChtZXRhZGF0YSkgdW5kZXIgdGhlIFdFQlZUVCBsaW5lLlxuICAgICAgICAgIGlmICgvOi8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgcGFyc2VIZWFkZXIobGluZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICghbGluZSkge1xuICAgICAgICAgICAgLy8gQW4gZW1wdHkgbGluZSB0ZXJtaW5hdGVzIHRoZSBoZWFkZXIgYW5kIHN0YXJ0cyB0aGUgYm9keSAoY3VlcykuXG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJJRFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSBcIk5PVEVcIjpcbiAgICAgICAgICAvLyBJZ25vcmUgTk9URSBibG9ja3MuXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJJRFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSBcIklEXCI6XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzdGFydCBvZiBOT1RFIGJsb2Nrcy5cbiAgICAgICAgICBpZiAoL15OT1RFKCR8WyBcXHRdKS8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiTk9URVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIDE5LTI5IC0gQWxsb3cgYW55IG51bWJlciBvZiBsaW5lIHRlcm1pbmF0b3JzLCB0aGVuIGluaXRpYWxpemUgbmV3IGN1ZSB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5jdWUgPSBuZXcgKHNlbGYudnR0anMuVlRUQ3VlIHx8IHNlbGYud2luZG93LlZUVEN1ZSkoMCwgMCwgXCJcIik7XG4gICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiQ1VFXCI7XG4gICAgICAgICAgLy8gMzAtMzkgLSBDaGVjayBpZiBzZWxmIGxpbmUgY29udGFpbnMgYW4gb3B0aW9uYWwgaWRlbnRpZmllciBvciB0aW1pbmcgZGF0YS5cbiAgICAgICAgICBpZiAobGluZS5pbmRleE9mKFwiLS0+XCIpID09PSAtMSkge1xuICAgICAgICAgICAgc2VsZi5jdWUuaWQgPSBsaW5lO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFByb2Nlc3MgbGluZSBhcyBzdGFydCBvZiBhIGN1ZS5cbiAgICAgICAgICAvKmZhbGxzIHRocm91Z2gqL1xuICAgICAgICBjYXNlIFwiQ1VFXCI6XG4gICAgICAgICAgLy8gNDAgLSBDb2xsZWN0IGN1ZSB0aW1pbmdzIGFuZCBzZXR0aW5ncy5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VDdWUobGluZSwgc2VsZi5jdWUsIHNlbGYucmVnaW9uTGlzdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgc2VsZi5yZXBvcnRPclRocm93RXJyb3IoZSk7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXG4gICAgICAgICAgICBzZWxmLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJCQURDVUVcIjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLnN0YXRlID0gXCJDVUVURVhUXCI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgXCJDVUVURVhUXCI6XG4gICAgICAgICAgdmFyIGhhc1N1YnN0cmluZyA9IGxpbmUuaW5kZXhPZihcIi0tPlwiKSAhPT0gLTE7XG4gICAgICAgICAgLy8gMzQgLSBJZiB3ZSBoYXZlIGFuIGVtcHR5IGxpbmUgdGhlbiByZXBvcnQgdGhlIGN1ZS5cbiAgICAgICAgICAvLyAzNSAtIElmIHdlIGhhdmUgdGhlIHNwZWNpYWwgc3Vic3RyaW5nICctLT4nIHRoZW4gcmVwb3J0IHRoZSBjdWUsXG4gICAgICAgICAgLy8gYnV0IGRvIG5vdCBjb2xsZWN0IHRoZSBsaW5lIGFzIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGUgY3VycmVudFxuICAgICAgICAgIC8vIG9uZSBhcyBhIG5ldyBjdWUuXG4gICAgICAgICAgaWYgKCFsaW5lIHx8IGhhc1N1YnN0cmluZyAmJiAoYWxyZWFkeUNvbGxlY3RlZExpbmUgPSB0cnVlKSkge1xuICAgICAgICAgICAgLy8gV2UgYXJlIGRvbmUgcGFyc2luZyBzZWxmIGN1ZS5cbiAgICAgICAgICAgIHNlbGYub25jdWUgJiYgc2VsZi5vbmN1ZShzZWxmLmN1ZSk7XG4gICAgICAgICAgICBzZWxmLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJJRFwiO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWxmLmN1ZS50ZXh0KSB7XG4gICAgICAgICAgICBzZWxmLmN1ZS50ZXh0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuY3VlLnRleHQgKz0gbGluZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSBcIkJBRENVRVwiOiAvLyBCQURDVUVcbiAgICAgICAgICAvLyA1NC02MiAtIENvbGxlY3QgYW5kIGRpc2NhcmQgdGhlIHJlbWFpbmluZyBjdWUuXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gXCJJRFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHNlbGYucmVwb3J0T3JUaHJvd0Vycm9yKGUpO1xuXG4gICAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IHBhcnNpbmcgYSBjdWUsIHJlcG9ydCB3aGF0IHdlIGhhdmUuXG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gXCJDVUVURVhUXCIgJiYgc2VsZi5jdWUgJiYgc2VsZi5vbmN1ZSkge1xuICAgICAgICBzZWxmLm9uY3VlKHNlbGYuY3VlKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY3VlID0gbnVsbDtcbiAgICAgIC8vIEVudGVyIEJBRFdFQlZUVCBzdGF0ZSBpZiBoZWFkZXIgd2FzIG5vdCBwYXJzZWQgY29ycmVjdGx5IG90aGVyd2lzZVxuICAgICAgLy8gYW5vdGhlciBleGNlcHRpb24gb2NjdXJyZWQgc28gZW50ZXIgQkFEQ1VFIHN0YXRlLlxuICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuc3RhdGUgPT09IFwiSU5JVElBTFwiID8gXCJCQURXRUJWVFRcIiA6IFwiQkFEQ1VFXCI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBmbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgLy8gRmluaXNoIGRlY29kaW5nIHRoZSBzdHJlYW0uXG4gICAgICBzZWxmLmJ1ZmZlciArPSBzZWxmLmRlY29kZXIuZGVjb2RlKCk7XG4gICAgICAvLyBTeW50aGVzaXplIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgY3VlIG9yIHJlZ2lvbi5cbiAgICAgIGlmIChzZWxmLmN1ZSB8fCBzZWxmLnN0YXRlID09PSBcIkhFQURFUlwiKSB7XG4gICAgICAgIHNlbGYuYnVmZmVyICs9IFwiXFxuXFxuXCI7XG4gICAgICAgIHNlbGYucGFyc2UoKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlJ3ZlIGZsdXNoZWQsIHBhcnNlZCwgYW5kIHdlJ3JlIHN0aWxsIG9uIHRoZSBJTklUSUFMIHN0YXRlIHRoZW5cbiAgICAgIC8vIHRoYXQgbWVhbnMgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggb2YgdGhlIHN0cmVhbSB0byBwYXJzZSB0aGUgZmlyc3RcbiAgICAgIC8vIGxpbmUuXG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gXCJJTklUSUFMXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3IuRXJyb3JzLkJhZFNpZ25hdHVyZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBzZWxmLnJlcG9ydE9yVGhyb3dFcnJvcihlKTtcbiAgICB9XG4gICAgc2VsZi5vbmZsdXNoICYmIHNlbGYub25mbHVzaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlZUVDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIGF1dG9LZXl3b3JkID0gXCJhdXRvXCI7XG52YXIgZGlyZWN0aW9uU2V0dGluZyA9IHtcbiAgXCJcIjogdHJ1ZSxcbiAgXCJsclwiOiB0cnVlLFxuICBcInJsXCI6IHRydWVcbn07XG52YXIgYWxpZ25TZXR0aW5nID0ge1xuICBcInN0YXJ0XCI6IHRydWUsXG4gIFwibWlkZGxlXCI6IHRydWUsXG4gIFwiZW5kXCI6IHRydWUsXG4gIFwibGVmdFwiOiB0cnVlLFxuICBcInJpZ2h0XCI6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGZpbmREaXJlY3Rpb25TZXR0aW5nKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGRpciA9IGRpcmVjdGlvblNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XG4gIHJldHVybiBkaXIgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRBbGlnblNldHRpbmcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgYWxpZ24gPSBhbGlnblNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XG4gIHJldHVybiBhbGlnbiA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuICB2YXIgaSA9IDE7XG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvYmogPSBhcmd1bWVudHNbaV07XG4gICAgZm9yICh2YXIgcCBpbiBjb2JqKSB7XG4gICAgICBvYmpbcF0gPSBjb2JqW3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIFZUVEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgdmFyIGN1ZSA9IHRoaXM7XG4gIHZhciBpc0lFOCA9ICgvTVNJRVxcczhcXC4wLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIGJhc2VPYmogPSB7fTtcblxuICBpZiAoaXNJRTgpIHtcbiAgICBjdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcbiAgfSBlbHNlIHtcbiAgICBiYXNlT2JqLmVudW1lcmFibGUgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoaW0gaW1wbGVtZW50YXRpb24gc3BlY2lmaWMgcHJvcGVydGllcy4gVGhlc2UgcHJvcGVydGllcyBhcmUgbm90IGluXG4gICAqIHRoZSBzcGVjLlxuICAgKi9cblxuICAvLyBMZXRzIHVzIGtub3cgd2hlbiB0aGUgVlRUQ3VlJ3MgZGF0YSBoYXMgY2hhbmdlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgbmVlZFxuICAvLyB0byByZWNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGUuIFRoaXMgbGV0cyB1cyBjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlXG4gIC8vIGxhemlseS5cbiAgY3VlLmhhc0JlZW5SZXNldCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBWVFRDdWUgYW5kIFRleHRUcmFja0N1ZSBwcm9wZXJ0aWVzXG4gICAqIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0Y3VlLWludGVyZmFjZVxuICAgKi9cblxuICB2YXIgX2lkID0gXCJcIjtcbiAgdmFyIF9wYXVzZU9uRXhpdCA9IGZhbHNlO1xuICB2YXIgX3N0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgdmFyIF9lbmRUaW1lID0gZW5kVGltZTtcbiAgdmFyIF90ZXh0ID0gdGV4dDtcbiAgdmFyIF9yZWdpb24gPSBudWxsO1xuICB2YXIgX3ZlcnRpY2FsID0gXCJcIjtcbiAgdmFyIF9zbmFwVG9MaW5lcyA9IHRydWU7XG4gIHZhciBfbGluZSA9IFwiYXV0b1wiO1xuICB2YXIgX2xpbmVBbGlnbiA9IFwic3RhcnRcIjtcbiAgdmFyIF9wb3NpdGlvbiA9IDUwO1xuICB2YXIgX3Bvc2l0aW9uQWxpZ24gPSBcIm1pZGRsZVwiO1xuICB2YXIgX3NpemUgPSA1MDtcbiAgdmFyIF9hbGlnbiA9IFwibWlkZGxlXCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcImlkXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9pZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9pZCA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInBhdXNlT25FeGl0XCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9wYXVzZU9uRXhpdDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9wYXVzZU9uRXhpdCA9ICEhdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJzdGFydFRpbWVcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3N0YXJ0VGltZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3RhcnQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3N0YXJ0VGltZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJlbmRUaW1lXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9lbmRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFbmQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX2VuZFRpbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwidGV4dFwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdGV4dDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF90ZXh0ID0gXCJcIiArIHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJyZWdpb25cIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3JlZ2lvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9yZWdpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwidmVydGljYWxcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGZhbHNlIGJlY2F1c2UgdGhlIHNldHRpbmcgYW4gYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICBpZiAoc2V0dGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF92ZXJ0aWNhbCA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInNuYXBUb0xpbmVzXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwVG9MaW5lcztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF9zbmFwVG9MaW5lcyA9ICEhdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcImxpbmVcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2xpbmU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiICYmIHZhbHVlICE9PSBhdXRvS2V5d29yZCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFuIGludmFsaWQgbnVtYmVyIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9saW5lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcImxpbmVBbGlnblwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfbGluZUFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfbGluZUFsaWduID0gc2V0dGluZztcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxuICAgIFwicG9zaXRpb25cIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3Bvc2l0aW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc2l0aW9uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJwb3NpdGlvbkFsaWduXCIsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbkFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfcG9zaXRpb25BbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcbiAgICBcInNpemVcIiwgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2l6ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfc2l6ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXG4gICAgXCJhbGlnblwiLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfYWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9hbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgLyoqXG4gICAqIE90aGVyIDx0cmFjaz4gc3BlYyBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICovXG5cbiAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLXZpZGVvLWVsZW1lbnQuaHRtbCN0ZXh0LXRyYWNrLWN1ZS1kaXNwbGF5LXN0YXRlXG4gIGN1ZS5kaXNwbGF5U3RhdGUgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzSUU4KSB7XG4gICAgcmV0dXJuIGN1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFZUVEN1ZSBtZXRob2RzXG4gKi9cblxuVlRUQ3VlLnByb3RvdHlwZS5nZXRDdWVBc0hUTUwgPSBmdW5jdGlvbigpIHtcbiAgLy8gQXNzdW1lIFdlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlIGlzIG9uIHRoZSBnbG9iYWwuXG4gIHJldHVybiBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSh3aW5kb3csIHRoaXMudGV4dCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZUVEN1ZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIHNjcm9sbFNldHRpbmcgPSB7XG4gIFwiXCI6IHRydWUsXG4gIFwidXBcIjogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZmluZFNjcm9sbFNldHRpbmcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc2Nyb2xsID0gc2Nyb2xsU2V0dGluZ1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgcmV0dXJuIHNjcm9sbCA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDEwMCk7XG59XG5cbi8vIFZUVFJlZ2lvbiBzaGltIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0cmVnaW9uLWludGVyZmFjZVxuZnVuY3Rpb24gVlRUUmVnaW9uKCkge1xuICB2YXIgX3dpZHRoID0gMTAwO1xuICB2YXIgX2xpbmVzID0gMztcbiAgdmFyIF9yZWdpb25BbmNob3JYID0gMDtcbiAgdmFyIF9yZWdpb25BbmNob3JZID0gMTAwO1xuICB2YXIgX3ZpZXdwb3J0QW5jaG9yWCA9IDA7XG4gIHZhciBfdmlld3BvcnRBbmNob3JZID0gMTAwO1xuICB2YXIgX3Njcm9sbCA9IFwiXCI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIFwid2lkdGhcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfd2lkdGg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzVmFsaWRQZXJjZW50VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2lkdGggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3dpZHRoID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcImxpbmVzXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2xpbmVzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJMaW5lcyBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX2xpbmVzID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInJlZ2lvbkFuY2hvcllcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcmVnaW9uQW5jaG9yWTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWdpb25BbmNob3JYIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9yZWdpb25BbmNob3JZID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInJlZ2lvbkFuY2hvclhcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcmVnaW9uQW5jaG9yWDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmKCFpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZ2lvbkFuY2hvclkgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3JlZ2lvbkFuY2hvclggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwidmlld3BvcnRBbmNob3JZXCI6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3ZpZXdwb3J0QW5jaG9yWTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWaWV3cG9ydEFuY2hvclkgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3ZpZXdwb3J0QW5jaG9yWSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJ2aWV3cG9ydEFuY2hvclhcIjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdmlld3BvcnRBbmNob3JYO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZpZXdwb3J0QW5jaG9yWCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBfdmlld3BvcnRBbmNob3JYID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBcInNjcm9sbFwiOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zY3JvbGw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRTY3JvbGxTZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgLy8gSGF2ZSB0byBjaGVjayBmb3IgZmFsc2UgYXMgYW4gZW1wdHkgc3RyaW5nIGlzIGEgbGVnYWwgdmFsdWUuXG4gICAgICAgIGlmIChzZXR0aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3Njcm9sbCA9IHNldHRpbmc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWVFRSZWdpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB3aW5kb3cgPSByZXF1aXJlKFwiZ2xvYmFsL3dpbmRvd1wiKVxudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKFwiaXMtZnVuY3Rpb25cIilcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKFwicGFyc2UtaGVhZGVyc1wiKVxudmFyIHh0ZW5kID0gcmVxdWlyZShcInh0ZW5kXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlWEhSXG5jcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgbm9vcFxuY3JlYXRlWEhSLlhEb21haW5SZXF1ZXN0ID0gXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiAobmV3IGNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCgpKSA/IGNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCA6IHdpbmRvdy5YRG9tYWluUmVxdWVzdFxuXG5mb3JFYWNoQXJyYXkoW1wiZ2V0XCIsIFwicHV0XCIsIFwicG9zdFwiLCBcInBhdGNoXCIsIFwiaGVhZFwiLCBcImRlbGV0ZVwiXSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgY3JlYXRlWEhSW21ldGhvZCA9PT0gXCJkZWxldGVcIiA/IFwiZGVsXCIgOiBtZXRob2RdID0gZnVuY3Rpb24odXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBvcHRpb25zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgICAgICBvcHRpb25zLm1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgICAgIHJldHVybiBfY3JlYXRlWEhSKG9wdGlvbnMpXG4gICAgfVxufSlcblxuZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0pXG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0VtcHR5KG9iail7XG4gICAgZm9yKHZhciBpIGluIG9iail7XG4gICAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXJhbXMgPSB1cmlcblxuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgICAgICBpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcGFyYW1zID0ge3VyaTp1cml9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMgPSB4dGVuZChvcHRpb25zLCB7dXJpOiB1cml9KVxuICAgIH1cblxuICAgIHBhcmFtcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgcmV0dXJuIHBhcmFtc1xufVxuXG5mdW5jdGlvbiBjcmVhdGVYSFIodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIG9wdGlvbnMgPSBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgcmV0dXJuIF9jcmVhdGVYSFIob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVhIUihvcHRpb25zKSB7XG4gICAgaWYodHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgPT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxsYmFjayBhcmd1bWVudCBtaXNzaW5nXCIpXG4gICAgfVxuXG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2JPbmNlKGVyciwgcmVzcG9uc2UsIGJvZHkpe1xuICAgICAgICBpZighY2FsbGVkKXtcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWVcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soZXJyLCByZXNwb25zZSwgYm9keSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChsb2FkRnVuYywgMClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICAgICAgIC8vIENocm9tZSB3aXRoIHJlcXVlc3RUeXBlPWJsb2IgdGhyb3dzIGVycm9ycyBhcnJvdW5kIHdoZW4gZXZlbiB0ZXN0aW5nIGFjY2VzcyB0byByZXNwb25zZVRleHRcbiAgICAgICAgdmFyIGJvZHkgPSB1bmRlZmluZWRcblxuICAgICAgICBpZiAoeGhyLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlVGV4dCB8fCBnZXRYbWwoeGhyKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSnNvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib2R5XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJyb3JGdW5jKGV2dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKVxuICAgICAgICBpZighKGV2dCBpbnN0YW5jZW9mIEVycm9yKSl7XG4gICAgICAgICAgICBldnQgPSBuZXcgRXJyb3IoXCJcIiArIChldnQgfHwgXCJVbmtub3duIFhNTEh0dHBSZXF1ZXN0IEVycm9yXCIpIClcbiAgICAgICAgfVxuICAgICAgICBldnQuc3RhdHVzQ29kZSA9IDBcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGV2dCwgZmFpbHVyZVJlc3BvbnNlKVxuICAgIH1cblxuICAgIC8vIHdpbGwgbG9hZCB0aGUgZGF0YSAmIHByb2Nlc3MgdGhlIHJlc3BvbnNlIGluIGEgc3BlY2lhbCByZXNwb25zZSBvYmplY3RcbiAgICBmdW5jdGlvbiBsb2FkRnVuYygpIHtcbiAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVyblxuICAgICAgICB2YXIgc3RhdHVzXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpXG4gICAgICAgIGlmKG9wdGlvbnMudXNlWERSICYmIHhoci5zdGF0dXM9PT11bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vSUU4IENPUlMgR0VUIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZG9lc24ndCBoYXZlIGEgc3RhdHVzIGZpZWxkLCBidXQgYm9keSBpcyBmaW5lXG4gICAgICAgICAgICBzdGF0dXMgPSAyMDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICh4aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogeGhyLnN0YXR1cylcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzcG9uc2UgPSBmYWlsdXJlUmVzcG9uc2VcbiAgICAgICAgdmFyIGVyciA9IG51bGxcblxuICAgICAgICBpZiAoc3RhdHVzICE9PSAwKXtcbiAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGdldEJvZHkoKSxcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgdXJsOiB1cmksXG4gICAgICAgICAgICAgICAgcmF3UmVxdWVzdDogeGhyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKXsgLy9yZW1lbWJlciB4aHIgY2FuIGluIGZhY3QgYmUgWERSIGZvciBDT1JTIGluIElFXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoXCJJbnRlcm5hbCBYTUxIdHRwUmVxdWVzdCBFcnJvclwiKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIHJlc3BvbnNlLCByZXNwb25zZS5ib2R5KVxuICAgIH1cblxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociB8fCBudWxsXG5cbiAgICBpZiAoIXhocikge1xuICAgICAgICBpZiAob3B0aW9ucy5jb3JzIHx8IG9wdGlvbnMudXNlWERSKSB7XG4gICAgICAgICAgICB4aHIgPSBuZXcgY3JlYXRlWEhSLlhEb21haW5SZXF1ZXN0KClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB4aHIgPSBuZXcgY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlcbiAgICB2YXIgYWJvcnRlZFxuICAgIHZhciB1cmkgPSB4aHIudXJsID0gb3B0aW9ucy51cmkgfHwgb3B0aW9ucy51cmxcbiAgICB2YXIgbWV0aG9kID0geGhyLm1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCJcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keSB8fCBvcHRpb25zLmRhdGFcbiAgICB2YXIgaGVhZGVycyA9IHhoci5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9XG4gICAgdmFyIHN5bmMgPSAhIW9wdGlvbnMuc3luY1xuICAgIHZhciBpc0pzb24gPSBmYWxzZVxuICAgIHZhciB0aW1lb3V0VGltZXJcbiAgICB2YXIgZmFpbHVyZVJlc3BvbnNlID0ge1xuICAgICAgICBib2R5OiB1bmRlZmluZWQsXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICBzdGF0dXNDb2RlOiAwLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgdXJsOiB1cmksXG4gICAgICAgIHJhd1JlcXVlc3Q6IHhoclxuICAgIH1cblxuICAgIGlmIChcImpzb25cIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuanNvbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgaXNKc29uID0gdHJ1ZVxuICAgICAgICBoZWFkZXJzW1wiYWNjZXB0XCJdIHx8IGhlYWRlcnNbXCJBY2NlcHRcIl0gfHwgKGhlYWRlcnNbXCJBY2NlcHRcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIikgLy9Eb24ndCBvdmVycmlkZSBleGlzdGluZyBhY2NlcHQgaGVhZGVyIGRlY2xhcmVkIGJ5IHVzZXJcbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJHRVRcIiAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gfHwgKGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIikgLy9Eb24ndCBvdmVycmlkZSBleGlzdGluZyBhY2NlcHQgaGVhZGVyIGRlY2xhcmVkIGJ5IHVzZXJcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmpzb24gPT09IHRydWUgPyBib2R5IDogb3B0aW9ucy5qc29uKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHJlYWR5c3RhdGVjaGFuZ2VcbiAgICB4aHIub25sb2FkID0gbG9hZEZ1bmNcbiAgICB4aHIub25lcnJvciA9IGVycm9yRnVuY1xuICAgIC8vIElFOSBtdXN0IGhhdmUgb25wcm9ncmVzcyBiZSBzZXQgdG8gYSB1bmlxdWUgZnVuY3Rpb24uXG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElFIG11c3QgZGllXG4gICAgfVxuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHhoci5vbnRpbWVvdXQgPSBlcnJvckZ1bmNcbiAgICB4aHIub3BlbihtZXRob2QsIHVyaSwgIXN5bmMsIG9wdGlvbnMudXNlcm5hbWUsIG9wdGlvbnMucGFzc3dvcmQpXG4gICAgLy9oYXMgdG8gYmUgYWZ0ZXIgb3BlblxuICAgIGlmKCFzeW5jKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdGlvbnMud2l0aENyZWRlbnRpYWxzXG4gICAgfVxuICAgIC8vIENhbm5vdCBzZXQgdGltZW91dCB3aXRoIHN5bmMgcmVxdWVzdFxuICAgIC8vIG5vdCBzZXR0aW5nIHRpbWVvdXQgb24gdGhlIHhociBvYmplY3QsIGJlY2F1c2Ugb2Ygb2xkIHdlYmtpdHMgZXRjLiBub3QgaGFuZGxpbmcgdGhhdCBjb3JyZWN0bHlcbiAgICAvLyBib3RoIG5wbSdzIHJlcXVlc3QgYW5kIGpxdWVyeSAxLnggdXNlIHRoaXMga2luZCBvZiB0aW1lb3V0LCBzbyB0aGlzIGlzIGJlaW5nIGNvbnNpc3RlbnRcbiAgICBpZiAoIXN5bmMgJiYgb3B0aW9ucy50aW1lb3V0ID4gMCApIHtcbiAgICAgICAgdGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVyblxuICAgICAgICAgICAgYWJvcnRlZCA9IHRydWUvL0lFOSBtYXkgc3RpbGwgY2FsbCByZWFkeXN0YXRlY2hhbmdlXG4gICAgICAgICAgICB4aHIuYWJvcnQoXCJ0aW1lb3V0XCIpXG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBFcnJvcihcIlhNTEh0dHBSZXF1ZXN0IHRpbWVvdXRcIilcbiAgICAgICAgICAgIGUuY29kZSA9IFwiRVRJTUVET1VUXCJcbiAgICAgICAgICAgIGVycm9yRnVuYyhlKVxuICAgICAgICB9LCBvcHRpb25zLnRpbWVvdXQgKVxuICAgIH1cblxuICAgIGlmICh4aHIuc2V0UmVxdWVzdEhlYWRlcikge1xuICAgICAgICBmb3Ioa2V5IGluIGhlYWRlcnMpe1xuICAgICAgICAgICAgaWYoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5oZWFkZXJzICYmICFpc0VtcHR5KG9wdGlvbnMuaGVhZGVycykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIGFuIFhEb21haW5SZXF1ZXN0IG9iamVjdFwiKVxuICAgIH1cblxuICAgIGlmIChcInJlc3BvbnNlVHlwZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlXG4gICAgfVxuXG4gICAgaWYgKFwiYmVmb3JlU2VuZFwiIGluIG9wdGlvbnMgJiZcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuYmVmb3JlU2VuZCA9PT0gXCJmdW5jdGlvblwiXG4gICAgKSB7XG4gICAgICAgIG9wdGlvbnMuYmVmb3JlU2VuZCh4aHIpXG4gICAgfVxuXG4gICAgLy8gTWljcm9zb2Z0IEVkZ2UgYnJvd3NlciBzZW5kcyBcInVuZGVmaW5lZFwiIHdoZW4gc2VuZCBpcyBjYWxsZWQgd2l0aCB1bmRlZmluZWQgdmFsdWUuXG4gICAgLy8gWE1MSHR0cFJlcXVlc3Qgc3BlYyBzYXlzIHRvIHBhc3MgbnVsbCBhcyBib2R5IHRvIGluZGljYXRlIG5vIGJvZHlcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25hdWd0dXIveGhyL2lzc3Vlcy8xMDAuXG4gICAgeGhyLnNlbmQoYm9keSB8fCBudWxsKVxuXG4gICAgcmV0dXJuIHhoclxuXG5cbn1cblxuZnVuY3Rpb24gZ2V0WG1sKHhocikge1xuICAgIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVhNTFxuICAgIH1cbiAgICB2YXIgZmlyZWZveEJ1Z1Rha2VuRWZmZWN0ID0geGhyLnJlc3BvbnNlWE1MICYmIHhoci5yZXNwb25zZVhNTC5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgPT09IFwicGFyc2VyZXJyb3JcIlxuICAgIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSBcIlwiICYmICFmaXJlZm94QnVnVGFrZW5FZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVhNTFxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbicpO1xuXG52YXIgX2Fzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NpZ24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG53aW5kb3cudmlkZW9qcyA9IHJlcXVpcmUoJ3ZpZGVvLmpzJyk7XG52aWRlb2pzID0gdmlkZW9qcy5kZWZhdWx0IHx8IHZpZGVvanM7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICd2aWRlby1wbGF5ZXInLFxuICBwcm9wczoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBzdGFydDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGxheXNpbmxpbmU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgY3VzdG9tRXZlbnROYW1lOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICdzdGF0ZWNoYW5nZWQnO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICBpZiAoIXRoaXMucGxheWVyKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucGxheWVyKSB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuXG4gICAgICAvLyBpbml0XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLnBsYXllciA9IG51bGw7XG5cbiAgICAgIC8vIHZpZGVvanMgb3B0aW9uc1xuICAgICAgdmFyIHZpZGVvT3B0aW9ucyA9ICgwLCBfYXNzaWduMi5kZWZhdWx0KSh7XG4gICAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgICAgY29udHJvbHM6IHRydWUsXG4gICAgICAgIHByZWxvYWQ6ICdhdXRvJyxcbiAgICAgICAgZmx1aWQ6IGZhbHNlLFxuICAgICAgICBtdXRlZDogZmFsc2UsXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgIGhlaWdodDogJzM2MCcsXG4gICAgICAgIGxhbmd1YWdlOiAnZW4nLFxuICAgICAgICBjb250cm9sQmFyOiB7XG4gICAgICAgICAgcmVtYWluaW5nVGltZURpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgIHBsYXlUb2dnbGU6IHt9LFxuICAgICAgICAgIHByb2dyZXNzQ29udHJvbDoge30sXG4gICAgICAgICAgZnVsbHNjcmVlblRvZ2dsZToge30sXG4gICAgICAgICAgdm9sdW1lTWVudUJ1dHRvbjoge1xuICAgICAgICAgICAgaW5saW5lOiBmYWxzZSxcbiAgICAgICAgICAgIHZlcnRpY2FsOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0ZWNoT3JkZXI6IFsnaHRtbDUnXSxcbiAgICAgICAgcGx1Z2luczoge31cbiAgICAgIH0sIHRoaXMub3B0aW9ucyk7XG5cbiAgICAgIC8vIGNoZWNrIHNvdXJjZXNcbiAgICAgIC8qXG4gICAgICBpZiAoIXZpZGVvT3B0aW9ucy5zb3VyY2VzIHx8ICF2aWRlb09wdGlvbnMuc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdNaXNzaW5nIHJlcXVpcmVkIG9wdGlvbjogXCJzb3VyY2VzXCIuJylcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAqL1xuXG4gICAgICAvLyBpb3MgZnVsbHNjcmVlblxuICAgICAgdmFyIHBsYXlzaW5saW5lID0gdGhpcy5wbGF5c2lubGluZTtcbiAgICAgIGlmIChwbGF5c2lubGluZSkge1xuICAgICAgICB0aGlzLiRlbC5jaGlsZHJlblswXS5zZXRBdHRyaWJ1dGUoJ3BsYXlzaW5saW5lJywgcGxheXNpbmxpbmUpO1xuICAgICAgICB0aGlzLiRlbC5jaGlsZHJlblswXS5zZXRBdHRyaWJ1dGUoJ3dlYmtpdC1wbGF5c2lubGluZScsIHBsYXlzaW5saW5lKTtcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCBldmVudFxuICAgICAgdmFyIGVtaXRQbGF5ZXJTdGF0ZSA9IGZ1bmN0aW9uIGVtaXRQbGF5ZXJTdGF0ZShldmVudCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgc2VsZi4kZW1pdChldmVudCwgc2VsZi5wbGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHZhciB2YWx1ZXMgPSB7fTtcbiAgICAgICAgICB2YWx1ZXNbZXZlbnRdID0gdmFsdWU7XG4gICAgICAgICAgc2VsZi4kZW1pdChzZWxmLmN1c3RvbUV2ZW50TmFtZSwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gdmlkZW9PcHRpb25zXG4gICAgICAvLyBjb25zb2xlLmxvZyh2aWRlb09wdGlvbnMpXG5cbiAgICAgIC8vIGF2b2lkIGVycm9yIFwiVklERU9KUzogRVJST1I6IFVuYWJsZSB0byBmaW5kIHBsdWdpbjogX19vYl9fXCJcbiAgICAgIGlmICh2aWRlb09wdGlvbnMucGx1Z2lucykge1xuICAgICAgICBkZWxldGUgdmlkZW9PcHRpb25zLnBsdWdpbnMuX19vYl9fO1xuICAgICAgfVxuICAgICAgdGhpcy5wbGF5ZXIgPSB2aWRlb2pzKHRoaXMuJGVsLmNoaWxkcmVuWzBdLCB2aWRlb09wdGlvbnMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAvLyBwbGF5ZXIgcmVhZGllZFxuICAgICAgICBzZWxmLiRlbWl0KCdyZWFkeScsIHNlbGYucGxheWVyKTtcblxuICAgICAgICAvLyBldmVudHNcbiAgICAgICAgWydsb2FkZWRkYXRhJywgJ2NhbnBsYXknLCAnY2FucGxheXRocm91Z2gnLCAncGxheScsICdwYXVzZScsICd3YWl0aW5nJywgJ3BsYXlpbmcnLCAnZW5kZWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIF90aGlzLm9uKGV2ZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbWl0UGxheWVyU3RhdGUoZXZlbnQsIHRydWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9uKCd0aW1ldXBkYXRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVtaXRQbGF5ZXJTdGF0ZSgndGltZXVwZGF0ZScsIHRoaXMuY3VycmVudFRpbWUoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkaXNwb3NlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgaWYgKHRoaXMucGxheWVyICYmIHZpZGVvanMpIHtcbiAgICAgICAgdGhpcy5wbGF5ZXIucGF1c2UgJiYgdGhpcy5wbGF5ZXIucGF1c2UoKTtcbiAgICAgICAgdmlkZW9qcyh0aGlzLiRlbC5jaGlsZHJlblswXSkuZGlzcG9zZSgpO1xuICAgICAgICBpZiAoIXRoaXMuJGVsLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHZhciB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgdmlkZW8uY2xhc3NOYW1lID0gJ3ZpZGVvLWpzJztcbiAgICAgICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZCh2aWRlbyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wbGF5ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICBkZWVwOiB0cnVlLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihvcHRpb25zLCBvbGRPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNvdXJjZXMgJiYgb3B0aW9ucy5zb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuaWYgKG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMuZGVmYXVsdFxuOyh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIj8gbW9kdWxlLmV4cG9ydHMub3B0aW9uczogbW9kdWxlLmV4cG9ydHMpLnRlbXBsYXRlID0gXCI8ZGl2IGNsYXNzPXZpZGVvLXBsYXllcj48dmlkZW8gY2xhc3M9dmlkZW8tanM+PC92aWRlbz48L2Rpdj5cIlxuIl19
